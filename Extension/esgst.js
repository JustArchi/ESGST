// ==UserScript==
// @name ESGST
// @namespace ESGST
// @description Enhances SteamGifts and SteamTrades by adding some cool features to them.
// @icon https://dl.dropboxusercontent.com/s/lr3t3bxrxfxylqe/esgstIcon.ico?raw=1
// @version 7.22.0
// @author revilheart
// @contributor Royalgamer06
// @downloadURL https://github.com/revilheart/ESGST/raw/master/ESGST.user.js
// @updateURL https://github.com/revilheart/ESGST/raw/master/ESGST.meta.js
// @match https://www.steamgifts.com/*
// @match https://www.steamtrades.com/*
// @connect raw.githubusercontent.com
// @connect api.steampowered.com
// @connect store.steampowered.com
// @connect script.google.com
// @connect script.googleusercontent.com
// @connect sgtools.info
// @connect steamcommunity.com
// @connect steamgifts.com
// @connect steamtrades.com
// @connect isthereanydeal.com
// @connect api.dropboxapi.com
// @connect content.dropboxapi.com
// @connect api.imgur.com
// @connect googleapis.com
// @connect graph.microsoft.com
// @connect userstyles.org
// @grant GM_setValue
// @grant GM_getValue
// @grant GM_deleteValue
// @grant GM_listValues
// @grant GM_xmlhttpRequest
// @grant GM_getResourceURL
// @grant GM.setValue
// @grant GM.getValue
// @grant GM.deleteValue
// @grant GM.listValues
// @grant GM.xmlHttpRequest
// @grant GM.getResourceUrl
// @require https://raw.githubusercontent.com/revilheart/ESGST/master/Extension/js/jquery-3.3.1.min.js
// @require https://raw.githubusercontent.com/revilheart/ESGST/master/Extension/js/jquery-ui-1.12.1.min.js
// @require https://raw.githubusercontent.com/revilheart/ESGST/master/Extension/js/bootstrap-3.3.7.min.js
// @require https://raw.githubusercontent.com/revilheart/ESGST/master/Extension/js/interact-1.3.4.min.js
// @require https://raw.githubusercontent.com/revilheart/ESGST/master/Extension/js/jszip-3.1.5.min.js
// @require https://raw.githubusercontent.com/revilheart/ESGST/master/Extension/js/parsedown-0.0.1.js
// @require https://raw.githubusercontent.com/revilheart/ESGST/master/Extension/js/query-builder-2.5.2.min.js
// @require https://raw.githubusercontent.com/revilheart/ESGST/master/Extension/js/intersection-observer.js
// @require https://raw.githubusercontent.com/revilheart/ESGST/master/Extension/js/encoding.js
// @resource bs https://raw.githubusercontent.com/revilheart/ESGST/master/Extension/css/bootstrap-3.3.7.min.css
// @resource abc https://raw.githubusercontent.com/revilheart/ESGST/master/Extension/css/awesome-bootstrap-checkbox-0.3.7.min.css
// @resource qb https://raw.githubusercontent.com/revilheart/ESGST/master/Extension/css/query-builder-2.5.2.min.css
// @resource sg https://raw.githubusercontent.com/revilheart/ESGST/master/Extension/css/steamgifts-v34.min.css
// @run-at document-start
// @noframes
// ==/UserScript==

(function () {
  `use strict`;
  
  const _MODULES = [];
  let esgst;

  if (!NodeList.prototype[Symbol.iterator]) {
    NodeList.prototype[Symbol.iterator] = Array.prototype[Symbol.iterator];
  }
  if (!HTMLCollection.prototype[Symbol.iterator]) {
    HTMLCollection.prototype[Symbol.iterator] = Array.prototype[Symbol.iterator];
  }

  const theme = getLocalValue(`theme`);
  if (theme) {
    const style = document.createElement(`style`);
    style.id = `esgst-theme`;
    style.innerHTML = theme;
    document.documentElement.appendChild(style);
  }
  const customTheme = getLocalValue(`customTheme`);
  if (customTheme) {
    const style = document.createElement(`style`);
    style.id = `esgst-custom-theme`;
    style.innerHTML = customTheme;
    document.documentElement.appendChild(style);
  }

  let _USER_INFO = {},
    browser = null,
    gm = null;
  if (typeof GM === `undefined` && typeof GM_setValue === `undefined`) {
    [_USER_INFO.extension, browser] = this.chrome && this.chrome.runtime ?
      [this.browser ? `firefox` : `chrome`, this.chrome] : [`edge`, this.browser];
  } else if (typeof GM === `undefined`) {
    // polyfill for userscript managers that do not support the gm-dot api
    gm = {
      deleteValue: GM_deleteValue,
      getValue: GM_getValue,
      listValues: GM_listValues,
      getResourceUrl: GM_getResourceURL,
      setValue: GM_setValue,
      xmlHttpRequest: GM_xmlhttpRequest
    };
    for (const key in gm) {
      const old = gm[key];
      gm[key] = (...args) => {
        return new Promise((resolve, reject) => {
          try {
            resolve(old.apply(this, args));
          } catch (e) {
            reject(e);
          }
        });
      };
    }
  } else {
    gm = GM;
  }
  if (gm) {
    (async () => {
      document.head.insertAdjacentHTML(`beforeEnd`, `
        <link href="${await gm.getResourceUrl(`bs`)}" rel="stylesheet">
        <link href="${await gm.getResourceUrl(`bss`)}" rel="stylesheet">
        <link href="${await gm.getResourceUrl(`abc`)}" rel="stylesheet">
        <link href="${await gm.getResourceUrl(`qb`)}" rel="stylesheet">
      `);
    })();
  }

  class Button {
    constructor(context, position, details) {
      this.callbacks = details.callbacks;
      this.states = this.callbacks.length;
      this.icons = details.icons;
      this.id = details.id;
      this.index = details.index;
      this.titles = details.titles;
      this.button = insertHtml(context, position, `
        <div class="${details.className}"></div>
      `);
      this.change();
      return this;
    }
    async change(mainCallback, index = this.index, event) {
      if (index >= this.states) {
        index = 0;
      }
      this.index = index + 1;
      this.button.title = getFeatureTooltip(this.id, this.titles[index]);
      this.button.innerHTML = `
        <i class="fa ${this.icons[index]}"></i>
      `;
      if (mainCallback) {
        if (await mainCallback(event)) {
          this.change();
        } else {
          this.button.innerHTML = `
            <i class="fa fa-times esgst-red" title="Unable to perform action"></i>
          `;
        }
      } else if (this.callbacks[index]) {
        this.button.firstElementChild.addEventListener(`click`, this.change.bind(this, this.callbacks[index], undefined));
      }
    }
  }

  class ButtonSet {
    constructor(color1, color2, icon1, icon2, title1, title2, callback1, callback2) {
      this.busy = false;
      this.dependencies = [];
      const classes = {
        green: `form__submit-button`,
        grey: `form__saving-button`,
        red: `sidebar__error`,
        yellow: `sidebar__entry-delete`
      };
      this.set = document.createElement(`div`);
      this.set.className = `esgst-button-set`;
      this.set.innerHTML = `
        <div class="${classes[color1]} btn_action ${color1}">
          <i class="fa ${icon1}"></i>
          <span>${title1}</span>
        </div>
        <div class="${classes[color2]} btn_action ${color2} is-disabled is_disabled esgst-hidden">
          <i class="fa ${icon2}"></i>
          <span>${title2}</span>
        </div>
      `;
      this.button1 = this.set.firstElementChild;
      this.button2 = this.set.lastElementChild;
      this.callback1 = callback1;
      this.callback2 = callback2;
      this.button1.addEventListener(`click`, () => this.toggle(this.callback1));
      if (this.callback2) {
        this.button2.classList.remove(`is-disabled`, `is_disabled`);
        this.button2.addEventListener(`click`, () => this.toggle(this.callback2));
      }
    }
    toggle(callback) {
      this.dependencies.forEach(dependency => dependency.classList.toggle(`esgst-hidden`));
      this.busy = !this.busy;
      this.button1.classList.toggle(`esgst-hidden`);
      this.button2.classList.toggle(`esgst-hidden`);
      if (callback) {
        callback(this.toggle.bind(this));
      }
    }
    trigger() {
      this.toggle(this.callback1);
    }
  }

  class ButtonSet_v2 {
    constructor(details) {
      this.busy = false;
      this.dependencies = [];
      let classes = {
        green: `form__submit-button`,
        grey: `form__saving-button`,
        red: `sidebar__error`,
        yellow: `sidebar__entry-delete`
      };
      if (details.set) {
        this.set = details.set;
      } else {
        this.set = document.createElement(`div`);
        this.set.className = `esgst-button-set`;
      }
      this.set.innerHTML = `
        <div class="${classes[details.color1]} btn_action ${details.color1}">
          <i class="fa ${details.icon1}"></i>
          <span>${details.title1}</span>
        </div>
        <div class="${classes[details.color2]} btn_action ${details.color2} is-disabled is_disabled esgst-hidden">
          <i class="fa ${details.icon2}"></i>
          <span>${details.title2}</span>
        </div>
      `;
      this.button1 = this.set.firstElementChild;
      this.button2 = this.set.lastElementChild;
      this.callback1 = details.callback1;
      this.callback2 = details.callback2;
      if (this.callback1) {
        this.button1.addEventListener(`click`, async () => {
          this.isCanceled = false;
          this.toggle();
          await this.callback1();
          if (!this.isCanceled) {
            this.toggle();
          }
        });
      }
      if (this.callback2) {
        this.button2.classList.remove(`is-disabled`, `is_disabled`);
        this.button2.addEventListener(`click`, async () => {
          this.isCanceled = true;
          this.toggle();
          await this.callback2();
        });
      }
      if (details.input) {
        details.input.addEventListener(`keydown`, event => {
          if (event.key === `Enter`) {
            this.trigger();
          }
        });
      }
    }
    toggle() {
      this.dependencies.forEach(dependency => dependency.classList.toggle(`esgst-hidden`));
      this.busy = !this.busy;
      this.button1.classList.toggle(`esgst-hidden`);
      this.button2.classList.toggle(`esgst-hidden`);
    }
    trigger() {
      this.button1.dispatchEvent(new Event(`click`));
    }
    changeButton(i) {
      return {
        setIcon: this.setIcon.bind(this, this[`button${i}`]),
        setTitle: this.setTitle.bind(this, this[`button${i}`])
      };
    }
    setIcon(button, icon) {
      button.firstElementChild.className = `fa ${icon}`;
    }
    setTitle(button, title) {
      button.lastElementChild.textContent = title;
    }
  }

  class Checkbox {
    constructor (context, defaultValue, threeState, messages = {}) {
      this.value = defaultValue;
      this.isThreeState = threeState;
      this.checkbox = insertHtml(context, `afterBegin`, `
        <span class="esgst-checkbox">
          <input class="esgst-hidden" type="checkbox">
          <i class="fa fa-square-o"></i>
          <i class="fa fa-square" title="${messages.select || ``}"></i>
          <i class="fa fa-check-square" title="${messages.unselect || ``}"></i>
        </span>
      `);
      this.input = this.checkbox.firstElementChild;
      this.disabled = this.input.nextElementSibling;
      this.none = this.disabled.nextElementSibling;
      this.enabled = this.none.nextElementSibling;
      if (this.isThreeState) {
        if (this.value === `disabled`) {
          this.none.classList.add(`esgst-hidden`);
          this.enabled.classList.add(`esgst-hidden`);
        } else if (this.value === `none`) {
          this.disabled.classList.add(`esgst-hidden`);
          this.enabled.classList.add(`esgst-hidden`);
        } else {
          this.disabled.classList.add(`esgst-hidden`);
          this.none.classList.add(`esgst-hidden`);
        }
        this.checkbox.addEventListener(`click`, event => this.change(false, null, null, event));
      } else {
        this.input.checked = this.value;
        if (this.value) {
          this.disabled.classList.add(`esgst-hidden`);
          this.none.classList.add(`esgst-hidden`);
        } else {
          this.none.classList.add(`esgst-hidden`);
          this.disabled.classList.add(`esgst-hidden`);
        }
        this.checkbox.addEventListener(`click`, event => this.change(true, null, null, event));
        this.checkbox.addEventListener(`mouseenter`, () => this.showNone());
        this.checkbox.addEventListener(`mouseleave`, () => this.hideNone());
        this.change();
      }
    }
    change(toggle, value, callback, event) {
      if (this.isThreeState) {
        if ((this.value === `disabled` && !value) || (value === `none`)) {
          this.enabled.classList.add(`esgst-hidden`);
          this.disabled.classList.add(`esgst-hidden`);
          this.none.classList.remove(`esgst-hidden`);
          this.value = `none`;
        } else if ((this.value === `none` && !value) || (value === `enabled`)) {
          this.none.classList.add(`esgst-hidden`);
          this.disabled.classList.add(`esgst-hidden`);
          this.enabled.classList.remove(`esgst-hidden`);
          this.value = `enabled`;
        } else if (!value || value === `disabled`) {
          this.enabled.classList.add(`esgst-hidden`);
          this.none.classList.add(`esgst-hidden`);
          this.disabled.classList.remove(`esgst-hidden`);
          this.value = `disabled`;
        }
      } else {
        if (toggle) {
          this.preValue = this.input.checked = !this.input.checked;
        }
        if (this.preValue) {
          if (this.onPreEnabled && !this.isBlocked) {
            this.onPreEnabled(event);
          }
          this.value = this.preValue;
          this.disabled.classList.add(`esgst-hidden`);
          this.none.classList.add(`esgst-hidden`);
          this.enabled.classList.remove(`esgst-hidden`);
          if (this.onEnabled && !this.isBlocked) {
            this.onEnabled(event);
          }
        } else {
          if (this.onPreDisabled && !this.isBlocked) {
            this.onPreDisabled(event);
          }
          this.value = this.preValue;
          this.enabled.classList.add(`esgst-hidden`);
          this.none.classList.add(`esgst-hidden`);
          this.disabled.classList.remove(`esgst-hidden`);
          if (this.onDisabled && !this.isBlocked) {
            this.onDisabled(event);
          }
        }
      }
      if (event && this.onChange) {
        this.onChange();
      }
    }
    showNone() {
      if (!this.value) {
        this.disabled.classList.add(`esgst-hidden`);
        this.none.classList.remove(`esgst-hidden`);
      }
    }
    hideNone() {
      if (!this.value) {
        this.disabled.classList.remove(`esgst-hidden`);
        this.none.classList.add(`esgst-hidden`);
      }
    }
    check(callback) {
      this.preValue = this.input.checked = true;
      this.change(false, null, callback);
    }
    uncheck(callback) {
      this.preValue = this.input.checked = false;
      this.change(false, null, callback);
    }
    toggle(callback) {
      this.change(true, null, callback);
    }
  }

  class CompletionCheck {
    constructor(total, callback, onCheck) {
      this.callback = callback;
      this.onCheck = onCheck;
      this.counter = {
        count: 0,
        total: total
      };
      setTimeout(() => this.check(), 500);
      return this.counter;
    }
    check() {
      if (this.onCheck) {
        this.onCheck();
      }
      if (this.counter.count < this.counter.total) {
        setTimeout(() => this.check(), 500);
      } else {
        this.callback();
      }
    }
  }

  class Popout {
    constructor(className = ``, context = null, hoverSpeed = 1000, onClick = false, popout = null, onOpen = null) {
      this.onOpen = onOpen;
      this.context = context;
      this.popout = popout || insertHtml(document.body, `beforeEnd`, `<div class="${className}"></div>`);
      this.popout.classList.add(`esgst-popout`, `esgst-hidden`);
      this.popup = this.popout.closest(`.esgst-popup`);
      this.hoverSpeed = hoverSpeed;
      if (!onClick) {
        if (this.context) {
          let timeout = null;
          this.context.addEventListener(`mouseenter`, () => {
            timeout = setTimeout(() => {
              this.open();
            }, this.hoverSpeed);
          });
          this.context.addEventListener(`mouseleave`, event => {
            if (timeout) {
              clearTimeout(timeout);
              timeout = null;
            }
            if (!this.popout.contains(event.relatedTarget)) {
              this.close();
            }
          });
        }
        let timeout = null;
        this.popout.addEventListener(`mouseenter`, () => {
          if (timeout) {
            clearTimeout(timeout);
            timeout = null;
          }
        });
        this.popout.addEventListener(`mouseleave`, event => {
          timeout = setTimeout(() => {
            if (event.relatedTarget && !this.context.contains(event.relatedTarget) && (className !== `esgst-qiv-popout` || !event.relatedTarget.closest(`.esgst-popout`))) {
              this.context.classList.remove(`esgst-qgs-container-expanded`);
              this.close();
            }
          }, this.hoverSpeed);
        });
        document.addEventListener(`click`, event => {
          if (this.context && !this.context.contains(event.target) && !this.popout.contains(event.target) && (className !== `esgst-qiv-popout` || !event.target.closest(`.esgst-popout`))) {
            this.close();
          }
        }, true);
      } else {
        if (this.context) {
          this.context.addEventListener(`click`, () => {
            if (this.isOpen) {
              this.close();
            } else {
              this.open();
            }
          });
        }
        document.addEventListener(`click`, event => {
          if (this.context && !this.context.contains(event.target) && !this.popout.contains(event.target)) {
            this.close();
          }
        });
      }
      this.isOpen = false;
    }
    open(context = null, isFixed = false) {
      this.context = context || this.context;
      this.isFixed = isFixed;
      this.popout.classList.remove(`esgst-hidden`);
      let n = 9999 + document.querySelectorAll(`.esgst-popup:not(.esgst-hidden), .esgst-popout:not(.esgst-hidden)`).length;
      if (esgst.openPopups > 0) {
        const highestN = parseInt(esgst.popups[esgst.openPopups - 1].popup.style.zIndex || 0);
        if (n <= highestN) {
          n = highestN + 1;
        }
      }
      this.popout.style.zIndex = n;
      if (this.isFixed) {
        this.popout.classList.add(`esgst-fixed`);
      }
      this.reposition();
      this.isOpen = true;
      if (this.onOpen) {
        this.onOpen(this.popout);
      }
    }
    close() {
      this.popout.classList.add(`esgst-hidden`);
      if (this.isOpen && this.onClose) {
        this.onClose();
      }
      this.isOpen = false;
    }
    reposition(context = null) {
      let contextLeft, contextRect, contextTop, popoutHeight, popoutWidth, popupRect;
      this.popout.style.height = ``;
      this.popout.style.left = `0`;
      this.popout.style.top = `0`;
      this.context = context || this.context;
      contextRect = this.context.getBoundingClientRect();
      contextLeft = contextRect.left;
      contextTop = contextRect.top;
      if (contextTop > (innerHeight - (contextTop + contextRect.height))) {
        this.popout.style.maxHeight = `${contextTop}px`;
      } else {
        this.popout.style.maxHeight = `${innerHeight - (contextTop + contextRect.height)}px`;
      }
      const oldHeight = parseFloat(getComputedStyle(this.popout).getPropertyValue(`height`));
      const oldRealHeight = this.popout.offsetHeight;
      const difference = (oldRealHeight - oldHeight) + 10;
      const newHeight = Math.max(
        Math.min(oldHeight, document.documentElement.clientHeight - (contextTop + contextRect.height + difference)),
        Math.min(oldHeight, contextTop - difference)
      );
      this.popout.style.height = `${newHeight}px`;
      if (esgst.qiv && esgst.qiv.popout === this && esgst.qiv.comments) {
        esgst.qiv.comments.style.maxHeight = `${newHeight - esgst.qiv.comments.offsetTop}px`;
      }
      popoutHeight = this.popout.offsetHeight;
      popoutWidth = this.popout.offsetWidth;
      popupRect = this.popup && this.popup.getBoundingClientRect();
      if (contextLeft + popoutWidth > document.documentElement.clientWidth) {
        this.popout.style.left = `${(contextLeft - popoutWidth + contextRect.width) - (this.popup ? popupRect.left : 0) + scrollX}px`;
      } else {
        this.popout.style.left = `${contextLeft - (this.popup ? popupRect.left : 0) + scrollX}px`;
      }
      if (contextTop + contextRect.height + popoutHeight > document.documentElement.clientHeight) {
        this.popout.style.top = `${(contextTop - popoutHeight + (this.isFixed || this.popup ? 0 :  scrollY)) - (this.popup ? popupRect.top : 0)}px`;
      } else {
        this.popout.style.top = `${(contextTop + contextRect.height + (this.isFixed || this.popup ? 0 :  scrollY)) - (this.popup ? popupRect.top : 0)}px`;
      }
    }
  }

  class Popup {
    constructor(icon, title, temp, settings, popup = null) {
      this.isCreated = popup ? false : true;
      this.temp = temp;
      this.popup = popup || insertHtml(document.body, `beforeEnd`, `
        <div class="esgst-hidden esgst-popup">
          <div class="esgst-popup-heading">
            <i class="fa ${icon} esgst-popup-icon${icon ? `` : ` esgst-hidden`}"></i>
            <div class="esgst-popup-title${title ? `` : ` esgst-hidden`}">${title}</div>
          </div>
          <div class="esgst-popup-description">
            <div class="esgst-popup-scrollable"></div>
          </div>
          <div class="esgst-popup-actions">
            <span class="esgst-hidden">Settings</span>
            <span class="esgst-popup-close">Close</span>
          </div>
        </div>
      `);
      if (this.isCreated) {
        this.icon = this.popup.firstElementChild.firstElementChild;
        this.title = this.icon.nextElementSibling;
        this.description = this.popup.firstElementChild.nextElementSibling;
        this.scrollable = this.description.firstElementChild;
        this.actions = this.description.nextElementSibling;
        if (!settings) {
          settings = this.actions.firstElementChild;
          settings.classList.remove(`esgst-hidden`);
          settings.addEventListener(`mousedown`, event => {
            if (event.button === 2) return;
            event.preventDefault();
            if (esgst.openSettingsInTab || event.button === 1) {
              open(`/esgst/settings`);
            } else {
              loadMenu();
            }
          });
        }
        this.description.nextElementSibling.lastElementChild.addEventListener(`click`, () => this.close());
      } else {
        this.popup.classList.add(`esgst-popup`);
        let closeButton = this.popup.getElementsByClassName(`b-close`)[0];
        if (closeButton) {
          closeButton.addEventListener(`click`, () => this.close());
        }
      }
    }
    open(callback) {
      this.isOpen = true;
      let n = 9999 + document.querySelectorAll(`.esgst-popup:not(.esgst-hidden), .esgst-popout:not(.esgst-hidden)`).length;
      if (esgst.openPopups > 0) {
        const highestN = parseInt(esgst.popups[esgst.openPopups - 1].popup.style.zIndex || 0);
        if (n <= highestN) {
          n = highestN + 1;
        }
      }
      esgst.openPopups += 1;
      esgst.popups.push(this);
      this.modal = insertHtml(document.body, `beforeEnd`, `
        <div class="esgst-popup-modal"></div>
      `);
      if (this.isCreated) {
        this.popup.classList.remove(`esgst-hidden`);
      } else {
        this.popup.style.display = `block`;
      }
      this.modal.style.zIndex = n;
      this.popup.style.zIndex = n + 1;
      this.modal.addEventListener(`click`, () => this.close());
      this.reposition();
      if (!esgst.isRepositioning && !esgst.staticPopups) {
        setTimeout(() => repositionPopups(), 2000);
      }
      if (callback) {
        callback();
      }
    }
    close() {
      this.modal.remove();
      if (this.isCreated) {
        if (this.temp) {
          this.popup.remove();
        } else {
          this.popup.classList.add(`esgst-hidden`);
          if (esgst.minimizePanel) {
            minimizePanel_addItem(this);
          }
        }
      } else {
        this.popup.style = ``;
      }
      if (this.onClose) {
        this.onClose();
      }
      esgst.openPopups -= 1;
      esgst.popups.pop();
      this.isOpen = false;
    }
    reposition() {
      if (this.isCreated) {
        if (esgst.staticPopups) {
          this.scrollable.style.maxHeight = `${ innerHeight - (this.popup.offsetHeight - this.scrollable.offsetHeight) - 100}px`;
        } else {
          this.scrollable.style.maxHeight = `${ innerHeight * 0.9 - (this.popup.offsetHeight - this.scrollable.offsetHeight)}px`;
        }
      }
      if (!esgst.staticPopups) {
        let newLeft, newTop;
        newLeft = (innerWidth - this.popup.offsetWidth) / 2;
        newTop = (innerHeight - this.popup.offsetHeight) / 2;
        if (Math.abs(newLeft - this.popup.offsetLeft) > 5 || Math.abs(newTop - this.popup.offsetTop) > 5) {
          this.popup.style.left = `${newLeft}px`;
          this.popup.style.top = `${newTop}px`;
        }
      }
    }
    setTitle(title) {
      this.title.innerHTML = title;
      if (this.minimizeLink) {
        this.minimizeLink.textContent = title;
      }
    }
    setDone(temp) {
      this.temp = temp;
      if (esgst.minimizePanel && !this.isOpen) {
        minimizePanel_alert(this);
      }
    }
  }

  class Popup_v2 {
    constructor(details) {
      this.isCreated = details.popup ? false : true;
      this.temp = details.isTemp;
      this.popup = details.popup || insertHtml(document.body, `beforeEnd`, `
        <div class="esgst-hidden esgst-popup">
          <div class="esgst-popup-heading">
            <i class="fa ${details.icon} esgst-popup-icon${details.icon ? `` : ` esgst-hidden`}"></i>
            <div class="esgst-popup-title${details.title ? `` : ` esgst-hidden`}">${details.title}</div>
          </div>
          <div class="esgst-popup-description"></div>
          <div class="esgst-popup-actions">
            <span class="esgst-hidden">Settings</span>
            <span class="esgst-popup-close">Close</span>
          </div>
        </div>
      `);
      this.onClose = details.onClose;
      if (this.isCreated) {
        this.icon = this.popup.firstElementChild.firstElementChild;
        this.title = this.icon.nextElementSibling;
        this.description = this.popup.firstElementChild.nextElementSibling;
        this.actions = this.description.nextElementSibling;
        if (!details.settings) {
          let settings = this.actions.firstElementChild;
          settings.classList.remove(`esgst-hidden`);
          settings.addEventListener(`mousedown`, event => {
            if (event.button === 2) return;
            event.preventDefault();
            if (esgst.openSettingsInTab || event.button === 1) {
              open(`/esgst/settings`);
            } else {
              loadMenu();
            }
          });
        }
        this.description.nextElementSibling.lastElementChild.addEventListener(`click`, () => this.close());
      } else {
        this.popup.classList.add(`esgst-popup`);
        let closeButton = this.popup.getElementsByClassName(`b-close`)[0];
        if (closeButton) {
          closeButton.addEventListener(`click`, () => this.close());
        }
      }
      if (details.textInputs) {
        this.textInputs = [];
        details.textInputs.forEach(textInput => {
          let input = insertHtml(this.description, `beforeEnd`, `
            ${textInput.title || ``}<input placeholder="${textInput.placeholder || ``}" type="text">
          `);
          input.addEventListener(`keydown`, this.triggerButton.bind(this, 0));
          this.textInputs.push(input);
        });
      }
      if (details.options) {
        this.description.appendChild(createOptions(details.options));
        let inputs = this.description.lastElementChild.getElementsByTagName(`input`);
        for (let input of inputs) {
          switch (input.getAttribute(`type`)) {
            case `number`:
              observeNumChange(input, input.getAttribute(`name`));
              break;
            case `text`:
              observeChange(input, input.getAttribute(`name`));
              break;
            default:
              break;
          }
        }
      }
      if (details.buttons) {
        this.buttons = [];
        details.buttons.forEach(button => {
          let set = new ButtonSet_v2(button);
          this.buttons.push(set);
          this.description.appendChild(set.set);
        });
      }
      if (details.addProgress) {
        this.progress = insertHtml(this.description, `beforeEnd`, `<div></div>`);
        this.overallProgress = insertHtml(this.description, `beforeEnd`, `<div></div>`);
      }
      if (details.addScrollable) {
        this.scrollable = insertHtml(this.description, `beforeEnd`, `<div class="esgst-popup-scrollable"></div>`);
        if (details.addScrollable === `left`) {
          this.scrollable.classList.add(`esgst-text-left`);
        }
      }
    }
    open(callback) {
      this.isOpen = true;
      let n = 9999 + document.querySelectorAll(`.esgst-popup:not(.esgst-hidden), .esgst-popout:not(.esgst-hidden)`).length;
      if (esgst.openPopups > 0) {
        const highestN = parseInt(esgst.popups[esgst.openPopups - 1].popup.style.zIndex || 0);
        if (n <= highestN) {
          n = highestN + 1;
        }
      }
      esgst.openPopups += 1;
      esgst.popups.push(this);
      this.modal = insertHtml(document.body, `beforeEnd`, `
        <div class="esgst-popup-modal"></div>
      `);
      if (this.isCreated) {
        this.popup.classList.remove(`esgst-hidden`);
      } else {
        this.popup.style.display = `block`;
      }
      this.modal.style.zIndex = n;
      this.popup.style.zIndex = n + 1;
      this.modal.addEventListener(`click`, () => this.close());
      this.reposition();
      if (!esgst.isRepositioning && !esgst.staticPopups) {
        setTimeout(() => repositionPopups(), 2000);
      }
      if (this.textInputs) {
        this.textInputs[0].focus();
      }
      if (callback) {
        callback();
      }
    }
    close() {
      this.modal.remove();
      if (this.isCreated) {
        if (this.temp) {
          this.popup.remove();
        } else {
          this.popup.classList.add(`esgst-hidden`);
          if (esgst.minimizePanel) {
            minimizePanel_addItem(this);
          }
        }
      } else {
        this.popup.style = ``;
      }
      if (this.onClose) {
        this.onClose();
      }
      esgst.openPopups -= 1;
      esgst.popups.pop();
      this.isOpen = false;
    }
    reposition() {
      if (this.isCreated && this.scrollable) {
        if (esgst.staticPopups) {
          this.scrollable.style.maxHeight = `${ innerHeight - (this.popup.offsetHeight - this.scrollable.offsetHeight) - 100}px`;
        } else {
          this.scrollable.style.maxHeight = `${ innerHeight * 0.9 - (this.popup.offsetHeight - this.scrollable.offsetHeight)}px`;
        }
      }
      if (!esgst.staticPopups) {
        let newLeft, newTop;
        newLeft = (innerWidth - this.popup.offsetWidth) / 2;
        newTop = (innerHeight - this.popup.offsetHeight) / 2;
        if (Math.abs(newLeft - this.popup.offsetLeft) > 5 || Math.abs(newTop - this.popup.offsetTop) > 5) {
          this.popup.style.left = `${newLeft}px`;
          this.popup.style.top = `${newTop}px`;
        }
      }
    }
    getTextInputValue(index) {
      return this.textInputs[index].value;
    }
    triggerButton(index, event) {
      if (event && (event.key !== `Enter` || this.buttons[index].busy)) return;
      this.buttons[index].trigger();
    }
    isButtonBusy(index) {
      return (!this.buttons[index] || this.buttons[index].busy);
    }
    removeButton(index) {
      let button = this.buttons.splice(index, 1)[0];
      button.set.remove();
    }
    setScrollable(html) {
      insertHtml(this.scrollable, `beforeEnd`, `<div>${html}</div>`);
    }
    getScrollable(html = ``) {
      return insertHtml(this.scrollable, `beforeEnd`, `<div>${html}</div>`);
    }
    setError(message) {
      this.progress.innerHTML = `
        <i class="fa fa-times-circle"></i>
        <span>${message}</span>
      `;
    }
    setProgress(message) {
      if (this.progressMessage) {
        this.progressMessage.textContent = message;
      } else {
        this.progress.innerHTML = `
          <i class="fa fa-circle-o-notch fa-spin"></i>
          <span>${message}</span>
        `;
        this.progressMessage = this.progress.lastElementChild;
      }
    }
    clearProgress() {
      this.progress.innerHTML = ``;
      this.progressMessage = null;
    }
    setOverallProgress(message) {
      this.overallProgress.textContent = message;
    }
    clear() {
      this.progress.innerHTML = ``;
      this.progressMessage = null;
      this.overallProgress.textContent = ``;
      this.scrollable.innerHTML = ``;
    }
    setDone(temp) {
      this.temp = temp;
      if (esgst.minimizePanel && !this.isOpen) {
        minimizePanel_alert(this);
      }
    }
  }

  class Process {
    constructor(details) {
      this.mainPopup = details.mainPopup;
      this.popupDetails = details.popup;
      this.contextHtml = details.contextHtml;
      this.init = details.init;
      this.requests = details.requests;
      this.urls = details.urls;
      if (!details.mainPopup) {
        if (details.button) {
          this.button = details.button;
        } else {
          this.button = createHeadingButton(details.headingButton);
        }
        this.button.addEventListener(`click`, this.openPopup.bind(this));
      }
    }
    async openPopup() {
      if (this.popup) {
        this.popup.open();
        return;
      }
      this.popupDetails.buttons = [
        {
          color1: `green`,
          color2: `red`,
          icon1: `fa-arrow-circle-right`,
          icon2: `fa-times-circle`,
          title1: `Start`,
          title2: `Stop`,
          callback1: this.start.bind(this),
          callback2: this.stop.bind(this)
        }
      ];
      this.popup = new Popup_v2(this.popupDetails);
      this.popup.open();
      if (this.urls) {
        this.index = 0;
        this.perLoad = this.urls.perLoad;
        this.items = [];
        await this.urls.init(this, ...this.urls.arguments || []);
        this.total = this.items.length;
        if (!this.urls.doNotTrigger) {
          this.popup.triggerButton(0);
        }
        if (esgst[`es_${this.urls.id}`]) {
          this.popup.scrollable.addEventListener(`scroll`, () => {
            if (this.popup.scrollable.scrollTop + this.popup.scrollable.offsetHeight >= this.popup.scrollable.scrollHeight && !this.popup.isButtonBusy(0)) {
              this.popup.triggerButton(0);
            }
          });
        }
      }
    }
    async start() {
      if (this.button) {
        this.button.classList.add(`esgst-busy`);
      }
      this.isCanceled = false;

      if (this.popup && (!this.urls || this.urls.doNotTrigger)) {
        this.popup.clear();
      }

      if (this.init && (await this.init(this))) {
        if (this.button) {
          this.button.classList.remove(`esgst-busy`);
        }
        return;
      }

      if (this.urls) {
        await this.requestNextUrl(this.urls.request);
      } else {
        for (let i = 0; !this.isCanceled && i < this.requests.length; i++) {
          const request = this.requests[i];
          if (typeof request === `object`) {
            await this.request(request);
            if (request.onDone) {
              await request.onDone(this, request);
            }
          } else {
            await request(this);
          }
        }
      }

      if (this.button) {
        this.button.classList.remove(`esgst-busy`);
      }
      if (this.popup) {
        this.popup.clearProgress();
      }
    }
    stop() {
      this.isCanceled = true;
    }
    async requestNextUrl(details) {
      if (!this.urls.doNotTrigger && this.index >= this.total) {
        this.popup.removeButton(0);
        return;
      }
      this.popup.setProgress(`Loading more...`);
      this.popup.setOverallProgress(`${this.index} of ${this.total} loaded.`);
      this.context = this.mainContext ? insertHtml(this.mainContext, `beforeEnd`, this.contextHtml) : this.popup.getScrollable(this.contextHtml);
      let i = 0;
      while (!this.isCanceled && (i < this.perLoad || (esgst[`es_${this.urls.id}`] && this.popup.scrollable.scrollHeight <= this.popup.scrollable.offsetHeight))) {
        let url = this.items[this.index];
        if (!url) break;
        url = url.url || url;
        let response = await request({method: `GET`, queue: details.queue, url: url});
        let responseHtml = parseHtml(response.responseText);
        await details.request(this, details, response, responseHtml);
        i += 1;
        this.index += 1;
        this.popup.setOverallProgress(`${this.index} of ${this.total} loaded.`);
      }
      if (!this.urls.doNotTrigger && this.index >= this.total) {
        this.popup.removeButton(0);
      }
      if (this.urls.restart) {
        this.index = 0;
      }
      await endless_load(this.context);
    }
    async request(details) {
      if (!details.nextPage) {
        details.nextPage = 1;
      }
      let backup = details.nextPage;
      details.lastPage = ``;
      let pagination = null;
      let stop = false;
      do {
        let response = await request({method: `GET`, queue: details.queue, url: `${details.url}${details.nextPage}`});
        let responseHtml = parseHtml(response.responseText);
        if (details.source && details.nextPage === backup) {
          details.lastPage = lpl_getLastPage(responseHtml, false, details.source);
          details.lastPage = details.lastPage === 999999999 ? `` : ` of ${details.lastPage}`;
        }
        stop = await details.request(this, details, response, responseHtml);
        details.nextPage += 1;
        pagination = responseHtml.getElementsByClassName(`pagination__navigation`)[0];
      } while (!stop && !this.isCanceled && (!details.maxPage || details.nextPage <= details.maxPage) && pagination && !pagination.lastElementChild.classList.contains(esgst.selectedClass));
      details.nextPage = backup;
    }
  }

  class Table {
    /**
     * @param {Array[]} [values] A matrix containing the values of the table.
     */
    constructor(values) {
      this.table = document.createElement(`div`);
      this.table.className = `table esgst-ugd-table`;
      this.table.innerHTML = `
        <div class="table__heading"></div>
        <div class="table__rows"></div>
      `;
      this.heading = this.table.firstElementChild;
      this.rows = this.heading.nextElementSibling;
      this.hiddenColumns = [];
      this.numRows = 0;
      this.numColumns = 0;

      if (!values) {
        return this;
      }

      for (const column of values[0]) {
        this.addColumn(column);
      }
      const n = values.length;
      for (let i = 1; i < n; i++) {
        this.addRow(values[i]);
      }
    }
    addRow(columns) {
      const row = insertHtml(this.rows, `beforeEnd`, `
        <div class="table__row-outer-wrap">
          <div class="table__row-inner-wrap"></div>
        </div>
      `).firstElementChild;
      let isBold = false;
      for (let i = 0; i < this.numColumns; i++) {
        let cell = columns ? columns[i] : ``;
        let additionalClasses = [];
        let alignment = `center`;
        let attributes = [];
        let size = `small`;
        if (cell && typeof cell === `object`) {
          additionalClasses = additionalClasses.concat(cell.additionalClasses);
          alignment = cell.alignment || alignment;
          attributes = attributes.concat(cell.attributes);
          size = cell.size || size;
          cell = cell.value;
        }
        if (this.hiddenColumns.indexOf(i) > -1) {
          additionalClasses.push(`esgst-hidden`);
        }
        if (i === 0 && cell && cell === `Total`) {
          isBold = true;
        }
        if (!cell || cell === `0 (0%)`) {
          additionalClasses.push(`is-faded`);
        }
        if (isBold) {
          additionalClasses.push(`esgst-bold`);
        }
        row.insertAdjacentHTML(`beforeEnd`, `
          <div class="table__column--width-${size} text-${alignment} ${additionalClasses.join(` `)}" ${attributes.join(` `)}>
            ${cell}
          </div>
        `);
      }
      this.numRows += 1;
    }
    addColumn(column) {
      let cell = typeof column === `string` ? column : column.value;
      let additionalClasses = [].concat(column.additionalClasses);
      let alignment = column.alignment || `center`;
      let attributes = [].concat(column.attributes);
      let size = column.size || `small`;
      this.heading.insertAdjacentHTML(`beforeEnd`, `
        <div class="table__column--width-${size} text-${alignment} ${additionalClasses.join(` `)}" ${attributes.join(` `)}>${cell}</div>
      `);
      for (let i = 0; i < this.numRows; i++) {
        const row = this.rows.children[i];
        row.insertAdjacentHTML(`beforeEnd`, `
          <div class="table__column--width-${size} text-${alignment} ${cell === `Total` ? `esgst-bold` : ``}${additionalClasses.join(` `)}" ${attributes.join(` `)}></div>
        `);
      }
      this.numColumns += 1;
    }
    hideColumns() {
      for (const column of arguments) {
        this.hiddenColumns.push(column - 1);
        this.heading.children[column - 1].classList.add(`esgst-hidden`);
        for (let i = this.numRows.length - 1; i > -1; i--) {
          this.rows.children[i].firstElementChild.chilren[column - 1].classList.add(`esgst-hidden`);
        }
      }
    }
  }

  class ToggleSwitch {
    constructor(context, id, inline, name, sg, st, tooltip, value) {
      this.dependencies = [];
      this.exclusions = [];
      this.id = id;
      this.sg = sg;
      this.st = st;
      this.value = value;
      this.container = insertHtml(context, `beforeEnd`, `
        <div class="esgst-toggle-switch-container ${inline ? `inline` : ``}">
          <label class="esgst-toggle-switch">
            <input type="checkbox">
            <div class="esgst-toggle-switch-slider"></div>
          </label>
          <span>${name}</span>
          ${tooltip ? `<i class="fa fa-question-circle" title="${tooltip}"></i>` : ``}
        </div>
      `);
      this.switch = this.container.firstElementChild;
      this.input = this.switch.firstElementChild;
      this.name = this.switch.nextElementSibling;
      this.input.checked = this.value;
      this.input.addEventListener(`change`, () => this.change());
    }
    async change(settings) {
      this.value = this.input.checked;
      if (this.id) {
        let key = this.id;
        if (this.sg) {
          key += `_sg`;
        } else if (this.st) {
          key += `_st`;
        }
        let setting = esgst.settings[key];
        if (typeof setting === `undefined` || !setting.include) {
          setting = this.value;
        } else {
          setting.enabled = this.value ? 1 : 0;
        }
        esgst.settings[key] = setting;
        esgst[this.id] = this.value;
        if (!settings) {
          let message = insertHtml(this.container, `beforeEnd`, `
            <div class="esgst-description esgst-bold">
              <i class="fa fa-circle-o-notch fa-spin" title="Saving..."></i>
            </div>
          `);
          await setSetting(key, setting);
          message.classList.add(`esgst-green`);
          message.innerHTML = `<i class="fa fa-check" title="Saved!"></i>`;
          setTimeout(() => message.remove(), 2500);
        }
      }
      if (this.value) {
        this.dependencies.forEach(dependency => dependency.classList.remove(`esgst-hidden`));
        this.exclusions.forEach(exclusion => exclusion.classList.add(`esgst-hidden`));
        if (this.onEnabled) {
          this.onEnabled();
        }
      } else {
        this.dependencies.forEach(dependency => dependency.classList.add(`esgst-hidden`));
        this.exclusions.forEach(exclusion => exclusion.classList.remove(`esgst-hidden`));
        if (this.onDisabled) {
          this.onDisabled();
        }
      }
    }
    enable(settings) {
      this.input.checked = true;
      this.change(settings);
    }
    disable(settings) {
      this.input.checked = false;
      this.change(settings);
    }
    toggle(settings) {
      this.input.checked = !this.input.checked;
      this.change(settings);
    }
  }

  async function init() {
    if (document.getElementById(`esgst`)) {
      // esgst is already running
      return;
    }

    // initialize the global variable
    esgst = {
      parameters: getParameters(),
      defaultValues: {
        ct_o_sg: true,
        ct_o_st: true,
        ct_f_sg: true,
        ct_f_st: true,
        gf_m_b_sg: false,
        gf_m_a_sg: false,
        df_m_b_sg: false,
        df_m_a_sg: false,
        cf_m_b_sg: false,
        cf_m_a_sg: false,
        gf_presets: [],
        df_presets: [],
        cf_presets: [],
        chfl_key: `ctrlKey + e`,
        getSyncGameNames_sg: false,
        getSyncGameNames_st: false,
        sgDarkGrey_startTime: `00:00`,
        sgDarkGrey_endTime: `23:59`,
        sgv2Dark_startTime: `00:00`,
        sgv2Dark_endTime: `23:59`,
        steamGiftiesBlack_startTime: `00:00`,
        steamGiftiesBlack_endTime: `23:59`,
        steamGiftiesBlue_startTime: `00:00`,
        steamGiftiesBlue_endTime: `23:59`,
        steamTradiesBlackBlue_startTime: `00:00`,
        steamTradiesBlackBlue_endTime: `23:59`,
        customTheme_startTime: `00:00`,
        customTheme_endTime: `23:59`,
        mm_useRegExp: false,
        mm_enableGiveaways: false,
        mm_enableDiscussions: false,
        mm_enableUsers: false,
        mm_enableGames: false,
        cs_limitPages: false,
        cs_minPage: ``,
        cs_maxPage: ``,
        ge_sgt_limit: 1,
        filter_os: 0,
        filter_giveaways_exist_in_account: 0,
        filter_giveaways_missing_base_game: 0,
        filter_giveaways_level: 0,
        filter_giveaways_additional_games: 0,
        dismissedOptions: [],
        hr_g_format: `🏆`,
        hr_w_format: `(#❤)`,
        hr_p_format: `(#P)`,
        ef_filters: ``,
        gwc_h_width: `3px`,
        gwr_h_width: `3px`,
        chfl_giveaways_sg: [
          `new`,
          `wishlist`,
          `created`,
          `entered`,
          `won`,
          {color: `grey`, description: `View your hidden games.`, icon: `fa-eye`, id: `filters`, name: `Hidden Games`, url: `/account/settings/giveaways/filters`},
          {color: `grey`, description: `Check if a game receives reduced CV.`, icon: `fa-calendar-minus-o`, id: `bundle-games`, name: `Reduced CV Games`, url: `/bundle-games`},
          {id: `type=wishlist`, name: `Browse Wishlist Giveaways`, url: `/giveaways/search?type=wishlist`},
          {id: `type=recommended`, name: `Browse Recommended Giveaways`, url: `/giveaways/search?type=recommended`},
          {id: `type=group`, name: `Browse Group Giveaways`, url: `/giveaways/search?type=group`},
          {id: `type=new`, name: `Browse New Giveaways`, url: `/giveaways/search?type=new`}
        ],
        chfl_discussions_sg: [
          `new`,
          `created`,
          `dh`,
          {color: `grey`, description: `Help the community.`, icon: `fa-question-circle `, id: `categorize-discussions`, name: `Categorize Discussions`, url: `/tools/categorize-discussions`},
          {id: `announcements`, name: `Browse Announcements`, url: `/discussions/announcements`},
          {id: `bugs-suggestions`, name: `Browse Bugs / Suggestions`, url: `/discussions/bugs-suggestions`},
          {id: `deals`, name: `Browse Deals`, url: `/discussions/deals`},
          {id: `general`, name: `Browse General`, url: `/discussions/general`},
          {id: `group-recruitment`, name: `Browse Group Recruitment`, url: `/discussions/group-recruitment`},
          {id: `lets-play-together`, name: `Browse Let's Play Together`, url: `/discussions/lets-play-together`},
          {id: `off-topic`, name: `Browse Off-Topic`, url: `/discussions/off-topic`},
          {id: `puzzles`, name: `Browse Puzzles`, url: `/discussions/puzzles`},
          {id: `uncategorized`, name: `Browse Uncategorized`, url: `/discussions/uncategorized`}
        ],
        chfl_support_sg: [
          `new`,
          {color: `grey`, description: `Check a user's real CV.`, icon: `fa-dollar`, id: `real-cv`, name: `Real CV`, url: `https://www.sgtools.info/real-cv`},
          {color: `red`, description: `Check if a user has not activated wins.`, icon: `fa-exchange`, id: `activation`, name: `Not Activated Wins`, url: `https://www.sgtools.info/activation`},
          {color: `red`, description: `Check if a user has multiple wins.`, icon: `fa-clone`, id: `multiple-wins`, name: `Multiple Wins`, url: `https://www.sgtools.info/multiple-wins`},
          {color: `grey`, description: `Check the last bundled games.`, icon: `fa-percent`, id: `lastbundled`, name: `Last Bundled`, url: `https://www.sgtools.info/lastbundled`}
        ],
        chfl_help_sg: [
          `comment-formatting`,
          `faq`,
          `guidelines`,
          {color: `grey`, description: `View SteamGifts' change log.`, icon: `fa-file-text-o`, id: `e9zDo`, name: `Change Log`, url: `/discussion/e9zDo/`}
        ],
        chfl_account_sg: [
          `profile`,
          `stats`,
          `et`,
          `ch`,
          {color: `blue`, icon: `fa-heart`, id: `whitelist`, name: `Whitelist`, url: `/account/manage/whitelist`},
          {color: `red`, icon: `fa-ban`, id: `blacklist`, name: `Blacklist`, url: `/account/manage/blacklist`},
          {color: `grey`, icon: `fa-folder`, id: `games`, name: `Games`, url: `/account/steam/games`},
          {color: `grey`, icon: `fa-user`, id: `groups`, name: `Groups`, url: `/account/steam/groups`},
          {color: `grey`, icon: `fa-star`, id: `wishlist`, name: `Wishlist`, url: `/account/steam/wishlist`},
        ],
        chfl_footer_sg: [
          `archive`,
          `stats`,
          `roles`,
          `users`,
          `steamgifts`,
          `103582791432125620`,
          `privacy-policy`,
          `terms-of-service`
        ],
        chfl_trades_st: [
          `new`,
          `user=[steamId]`
        ],
        chfl_account_st: [
          `user=[steamId]`
        ],
        chfl_footer_st: [
          `guidelines`,
          `comment-formatting`,
          `privacy-policy`,
          `terms-of-service`
        ],
        cdr_days: 7,
        addNoCvGames_sg: false,
        lockGiveawayColumns_sg: false,
        staticPopups_width: `900px`,
        hgr_removeOwned: true,
        giveawayColumns: [`ged`, `endTime`, `winners`, `startTime`, `touhou`, `inviteOnly`, `whitelist`, `group`, `regionRestricted`, `level`],
        giveawayPanel: [`ttec`, `gwc`, `gwr`, `gp`, `elgb`, `sgTools`],
        giveawayColumns_gv: [`sgTools`, `ged`, `time`, `touhou`, `inviteOnly`, `whitelist`, `group`, `regionRestricted`, `level`],
        giveawayPanel_gv: [`ttec`, `gwc`, `gwr`, `gp`, `elgb`],
        enableByDefault_sg: false,
        enableByDefault_st: false,
        cf_m_sg: true,
        checkVersion_sg: true,
        checkVersionMain_sg: true,
        collapseSections_sg: false,
        collapseSections_st: false,
        df_m_sg: true,
        elgb_d_sg: true,
        gb_ue_sg: true,
        gc_g_s_sg: false,
        ge_o_sg: false,
        gf_m_sg: true,
        gwc_a_b_sg: false,
        gwr_a_b_sg: false,
        hpg_sg: false,
        pm_a: false,
        radb_sg: true,
        showChangelog_sg: true,
        showChangelog_st: true,
        staticPopups_sg: false,
        staticPopups_st: false,
        vai_i_sg: false,
        avatar: ``,
        steamId: ``,
        steamApiKey: ``,
        username: ``,
        adots_index: 0,
        ags_type: ``,
        ags_maxDate: ``,
        ags_minDate: ``,
        ags_maxScore: ``,
        ags_minScore: ``,
        ags_maxLevel: ``,
        ags_minLevel: ``,
        ags_maxEntries: ``,
        ags_minEntries: ``,
        ags_maxCopies: ``,
        ags_minCopies: ``,
        ags_maxPoints: ``,
        ags_minPoints: ``,
        ags_regionRestricted: false,
        ags_dlc: false,
        ags_app: false,
        ags_sub: false,
        ap_index: 0,
        as_searchAppId: false,
        autoBackup_days: 1,
        autoBackup_index: 0,
        autoSyncGroups: 0,
        autoSyncWhitelist: 0,
        autoSyncBlacklist: 0,
        autoSyncHiddenGames: 0,
        autoSyncGames: 0,
        autoSyncWonGames: 0,
        autoSyncReducedCvGames: 0,
        autoSyncNoCvGames: 0,
        autoSyncGiveaways: 0,
        calculateDelete: true,
        calculateExport: true,
        calculateImport: true,
        cf_enable: true,
        cf_preset: null,
        cfh_pasteFormatting: true,
        cfh_img_choice: 1,
        cfh_img_remember: false,
        cleanDiscussions: true,
        cleanEntries: true,
        cleanGiveaways: true,
        cleanSgCommentHistory: true,
        cleanStCommentHistory: true,
        cleanTickets: true,
        cleanTrades: true,
        cleanDuplicates: true,
        cleanDiscussions_days: 30,
        cleanEntries_days: 30,
        cleanGiveaways_days: 30,
        cleanSgCommentHistory_days: 30,
        cleanStCommentHistory_days: 30,
        cleanTickets_days: 30,
        cleanTrades_days: 30,
        df_enable: true,
        df_enableCreated: false,
        df_preset: null,
        df_presetCreated: null,
        ds_auto: false,
        ds_option: `sortIndex_asc`,
        elgb_filters: `.|(bestof|(g(ood)?)?)(l(uck)?)?(h(ave)?)?(f(un)?)?|enjoy|(h(umble)?)?(b(undle)?)?(g(ift)?)?(l(ink)?)?`,
        exportBackup: true,
        exportBackupIndex: 0,
        gas_auto: false,
        gas_option: `sortIndex_asc`,
        gas_autoWishlist: false,
        gas_optionWishlist: `sortIndex_asc`,
        gas_autoRecommended: false,
        gas_optionRecommended: `sortIndex_asc`,
        gas_autoGroup: false,
        gas_optionGroup: `sortIndex_asc`,
        gas_autoNew: false,
        gas_optionNew: `sortIndex_asc`,
        gas_autoEntered: false,
        gas_optionEntered: `sortIndex_asc`,
        gas_autoUser: false,
        gas_optionUser: `sortIndex_asc`,
        gas_autoGroups: false,
        gas_optionGroups: `sortIndex_asc`,
        gas_autoPopup: false,
        gas_optionPopup: `sortIndex_asc`,
        gb_hours: 1,
        gc_categories: [`gc_gi`, `gc_r`, `gc_fcv`, `gc_rcv`, `gc_ncv`, `gc_h`, `gc_i`, `gc_o`, `gc_w`, `gc_pw`, `gc_a`, `gc_mp`, `gc_sc`, `gc_tc`, `gc_l`, `gc_m`, `gc_ea`, `gc_rm`, `gc_dlc`, `gc_p`, `gc_rd`, `gc_g`],
        gc_indexes: {},
        gc_categories_gv: [`gc_gi`, `gc_r`, `gc_fcv`, `gc_rcv`, `gc_ncv`, `gc_h`, `gc_i`, `gc_o`, `gc_w`, `gc_pw`, `gc_a`, `gc_mp`, `gc_sc`, `gc_tc`, `gc_l`, `gc_m`, `gc_ea`, `gc_rm`, `gc_dlc`, `gc_p`, `gc_rd`, `gc_g`],
        gc_indexes_gv: {},
        gc_o_altAccounts: [],
        gc_g_colors: [],
        gc_g_filters: ``,
        gc_r_colors: [
          {bgColor: `#a34c25`, color: `#ffffff`, icon: `thumbs-down`, lower: 0, upper: 39},
          {bgColor: `#b9a074`, color: `#ffffff`, icon: `minus-circle`, lower: 40, upper: 69},
          {bgColor: `#66c0f4`, color: `#ffffff`, icon: `thumbs-up`, lower: 70, upper: 100}
        ],
        gc_fcvIcon: `calendar`,
        gc_rcvIcon: `calendar-minus-o`,
        gc_ncvIcon: `calendar-times-o`,
        gc_hIcon: `eye-slash`,
        gc_iIcon: `ban`,
        gc_oIcon: `folder`,
        gc_wIcon: `heart`,
        gc_pwIcon: `gift`,
        gc_aIcon: `trophy`,
        gc_mpIcon: `users`,
        gc_scIcon: `cloud`,
        gc_tcIcon: `clone`,
        gc_lIcon: `linux`,
        gc_mIcon: `apple`,
        gc_eaIcon: `unlock`,
        gc_rmIcon: `trash`,
        gc_dlcIcon: `download`,
        gc_pIcon: `suitcase`,
        gc_rdIcon: `clock-o`,
        gc_fcvLabel: `Full CV`,
        gc_rcvLabel: `Reduced CV`,
        gc_ncvLabel: `No CV`,
        gc_hLabel: `Hidden`,
        gc_iLabel: `Ignored`,
        gc_oLabel: `Owned`,
        gc_wLabel: `Wishlisted`,
        gc_pwLabel: `Previously Won`,
        gc_aLabel: `Achievements`,
        gc_mpLabel: `Multiplayer`,
        gc_scLabel: `Steam Cloud`,
        gc_tcLabel: `Trading Cards`,
        gc_lLabel: `Linux`,
        gc_mLabel: `Mac`,
        gc_eaLabel: `Early Access`,
        gc_rmLabel: `Removed`,
        gc_dlcLabel: `DLC`,
        gc_pLabel: `Package`,
        gc_rdLabel: `Mon DD, YYYY`,
        gc_h_color: `#ffffff`,
        gc_gi_color: `#ffffff`,
        gc_fcv_color: `#ffffff`,
        gc_rcv_color: `#ffffff`,
        gc_ncv_color: `#ffffff`,
        gc_w_color: `#ffffff`,
        gc_o_color: `#ffffff`,
        gc_pw_color: `#ffffff`,
        gc_i_color: `#ffffff`,
        gc_rm_color: `#ffffff`,
        gc_ea_color: `#ffffff`,
        gc_tc_color: `#ffffff`,
        gc_a_color: `#ffffff`,
        gc_mp_color: `#ffffff`,
        gc_sc_color: `#ffffff`,
        gc_l_color: `#ffffff`,
        gc_m_color: `#ffffff`,
        gc_dlc_color: `#ffffff`,
        gc_p_color: `#ffffff`,
        gc_rd_color: `#ffffff`,
        gc_g_color: `#ffffff`,
        gc_h_bgColor: `#e74c3c`,
        gc_gi_bgColor: `#555555`,
        gc_fcv_bgColor: `#641e16`,
        gc_rcv_bgColor: `#641e16`,
        gc_ncv_bgColor: `#641e16`,
        gc_o_bgColor: `#16a085`,
        gc_w_bgColor: `#3498db`,
        gc_pw_bgColor: `#16a085`,
        gc_i_bgColor: `#e74c3c`,
        gc_rm_bgColor: `#e74c3c`,
        gc_ea_bgColor: `#3498db`,
        gc_tc_bgColor: `#2ecc71`,
        gc_a_bgColor: `#145a32`,
        gc_mp_bgColor: `#0e6251`,
        gc_sc_bgColor: `#154360`,
        gc_l_bgColor: `#f39c12`,
        gc_m_bgColor: `#d35400`,
        gc_dlc_bgColor: `#8e44ad`,
        gc_p_bgColor: `#8e44ad`,
        gc_rd_bgColor: `#7f8c8d`,
        gc_g_bgColor: `#7f8c8d`,
        gcl_index: 0,
        ge_b_bgColor: `#ddcccc`,
        ge_g_bgColor: `#ccddcc`,
        ge_p_bgColor: `#ccccdd`,
        ged: true,
        gf_enable: true,
        gf_enableWishlist: true,
        gf_enableRecommended: true,
        gf_enableNew: true,
        gf_enableGroup: true,
        gf_enableCreated: true,
        gf_enableEntered: true,
        gf_enableWon: true,
        gf_enableGroups: true,
        gf_enableUser: true,
        gf_enableGb: true,
        gf_enableGe: true,
        gf_enableGed: true,
        gf_preset: null,
        gf_presetWishlist: null,
        gf_presetRecommended: null,
        gf_presetNew: null,
        gf_presetGroup: null,
        gf_presetCreated: null,
        gf_presetEntered: null,
        gf_presetWon: null,
        gf_presetGroups: null,
        gf_presetUser: null,
        gf_presetGb: null,
        gf_presetGe: null,
        gf_presetGed: null,
        ggl_index: 0,
        gt_colors: {},
        gts_preciseStart: false,
        gts_preciseEnd: false,
        gts_preciseStartDate: false,
        gts_preciseEndDate: false,
        gv_spacing: 0,
        gch_colors: [],
        gwc_colors: [],
        gwr_colors: [],
        geth_colors: [],
        hr_minutes: 1,
        hr_w_hours: 24,
        lastBackup: 0,
        lastSyncGroups: 0,
        lastSyncWhitelist: 0,
        lastSyncBlacklist: 0,
        lastSyncHiddenGames: 0,
        lastSyncGames: 0,
        lastSyncWonGames: 0,
        lastSyncReducedCvGames: 0,
        lastSyncNoCvGames: 0,
        lastSyncGiveaways: 0,
        leftButtonIds: [`wbsDesc`, `wbsAsc`, `wbc`, `ugs`, `tb`, `sks`, `rbp`, `namwc`, `mpp`, `mm`, `hgr`, `gv`, `gts`, `gf`, `ge`, `gas`, `ds`, `df`, `ctUnread`, `ctRead`, `ctGo`, `cs`, `cf`, `as`, `aic`],
        mgc_createTrain: true,
        mgc_bumpLast: true,
        mgc_groupKeys: false,
        mgc_groupAllKeys: false,
        mgc_reversePosition: false,
        mgc_removeLinks: true,
        namwc_checkNotActivated: false,
        namwc_checkMultiple: false,
        npth_previousKey: `ArrowLeft`,
        npth_nextKey: `ArrowRight`,
        nrf_searchMultiple: false,
        rightButtonIds: [`esResume`, `esPause`, `esRefresh`, `esRefreshAll`, `stbb`, `sttb`],
        sal_index: 2,
        sk_closePopups: `escape`,
        sk_searchBox: `ctrlKey + q`,
        sk_firstPage: `ctrlKey + arrowup`,
        sk_previousPage: `ctrlKey + arrowleft`,
        sk_nextPage: `ctrlKey + arrowright`,
        sk_lastPage: `ctrlKey + arrowdown`,
        sk_toggleFilters: `altKey + q`,
        sk_hideGame: `altKey + g`,
        sk_hideGiveaway: `altKey + h`,
        sk_giveawayEntry: `ctrlKey + enter`,
        sk_creator: `altKey + c`,
        sk_replyBox: `ctrlKey +  `,
        sk_replyUser: `altKey + u`,
        sk_submitReply: `ctrlKey + enter`,
        sks_exportKeys: false,
        sks_searchCurrent: false,
        sks_limitDate: false,
        sks_limitPages: false,
        sks_minDate: ``,
        sks_maxDate: ``,
        sks_minPage: ``,
        sks_maxPage: ``,
        stbb_index: 0,
        sttb_index: 0,
        syncGroups: true,
        syncWhitelist: true,
        syncBlacklist: true,
        syncHiddenGames: true,
        syncGames: true,
        syncWonGames: true,
        syncReducedCvGames: true,
        syncNoCvGames: true,
        syncGiveaways: true,
        ugd_getPlaytime: true,
        ugd_getAchievements: false,
        ugd_clearCache: false,
        ugs_checkRules: false,
        ugs_checkWhitelist: false,
        ugs_checkBlacklist: false,
        ugs_checkMember: false,
        ugs_checkDifference: false,
        ugs_difference: 0,
        ut_colors: {},
        wbc_hb_sg: false,
        wbc_checkSingle: false,
        wbc_checkBlacklist: false,
        wbc_checkAll: false,
        wbc_checkPages: false,
        wbc_minPage: ``,
        wbc_maxPage: ``,
        wbc_returnWhitelists: false,
        wbc_returnBlacklists: false,
        wbc_checkSelected: false,
        wbc_pages: 0,
        wbc_skipUsers: false,
        wbm_clearTags: false,
        wbm_useCache: false,
        wbm_tags: [],
        wbc_checkNew: false,
        wbc_clearCache: false,
        wbh_w_color: `#ffffff`,
        wbh_w_bgColor: `#228b22`,
        wbh_b_color: `#ffffff`,
        wbh_b_bgColor: `#ff4500`
      },
      oldValues: {
        mm_useRegExp: `gm_useRegExp`,
        mm_enableGiveaways: `gm_enable`,
        mm_enableDiscussions: `gm_enable`,
        mm_enableUsers: `gm_enable`,
        mm_enableGames: `gm_enable`,
        pl_sg: `wbl_sg`,
        pl_w_sg: `wbl_sg`,
        pl_b_sg: `wbl_sg`,
        gdttt_vg_sg: `gdttt_v_sg`,
        gdttt_vd_sg: `gdttt_v_sg`,
        gdttt_vt_sg: `gdttt_v_sg`,
        gdttt_vts_st: `gdttt_v_st`,
        wbc_hb_sg: `wbc_b_sg`,
        wbc_checkBlacklist: `wbc_checkWhitelist`
      },
      domParser: new DOMParser(),
      markdownParser: new Parsedown(),
      sg: location.hostname.match(/www.steamgifts.com/),
      st: location.hostname.match(/www.steamtrades.com/),
      currentVersion: `7.22.0`,
      devVersion: `7.22.1 (Dev.35)`,
      icon: `data:image/x-icon;base64,AAABAAEAEBAAAAEAIABoBAAAFgAAACgAAAAQAAAAIAAAAAEAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAqv8DCbP/Hgeq+CQIrf8iCK3/Igit/yIIrf8iB6//Iwit9x8Aqv8DAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKr0GAa2/c0DvfzfA7f83QO3/N0Dt/zdA7f83QO+/d4Gs/3OAKP1GQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACm/xQFs/n2Bcf//wW///8FwP//BcD//wW///8Fx///BbP69gC2/xUAAAAAAAAAAAAAAAAA/1UDFptOFxSZMxkLpJktAq720QW1+ugEsfvjA7b92wO2/dsEsfvjBbX66Aau/dEoiO4tUlLWGU5k3hdVVf8DEJxKHxWqT8cVrU7uE6VN0guqny0Apv8XAJfQGwBAVywAQFcsAJfQGwCx/xcogugtS2Lk0lBl6u5Qae7ISmPeHxagSSMVr07jF7lV/xOiSu0brgATAAAAAAAAAA8AAAC/AAAAwAAAABAAAAAAYznjEkth4OxWb/3/T2jv40lf4iMXnksiEq1O3RayUv8UpEnkEo0+HQAAABkAAABBAAAA8QAAAPEAAABBAAAAGUBSvxxOYeDjU2v0/05m7d1LYuEiF55LIhKtTt0Ws1L/FahN2gU1FTAAAADAAAAA7AAAAP0AAAD9AAAA7AAAAMAVG0owUGPm2lNr9P9OZu3dS2LhIheeSyISrU7dFrNS/xWoTdoFNRswAAAAvwAAAOsAAAD9AAAA/QAAAOsAAADAFRtKMFBj6NpTa/T/Tmbt3Uti4SIXnksiEq1O3RayUv8UpEnkEo0+HQAAABgAAABAAAAA8QAAAPEAAABBAAAAGT5PuR1OYeDjU2v0/05m7d1LYuEiFqBJIxWuT+QXuVX/E6JL7QC8XhMAAAAAAAAADwAAAL8AAAC/AAAAEAAAAAAOR/8SSWLh7FZv/f9PaO/jSV/iIxCUSh8Vrk7HFqxN7ROlS9JskzMt1XULGK12EhxGLgYsRy8GK612EhzVgAsYgmxxLU1i39JNZ+vtT2fwx0pj1h8AqlUDF65GFgqZUhlsiC0txH0T0s5/EujJgBPkz4QR28+EEdvJgBPkzn8Q6Md+E9KLdHosM1LWGUZo6BZVVf8DAAAAAAAAAAAAAAAA/2YAFMl9EvbgjRb/14gV/9eIFf/XiBX/14gV/9+NFv/KgBD254YAFQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAL91FRjKgRHN1IgU3s+EEt3PhBLdz4QS3c+EEt3UiBTezYMRzcJ6FBkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACqqgADxIARHr18FiO8eA8ivHgPIrx4DyK8eA8ivXwPI8SAER7/VQADAAAAAAAAAAAAAAAA78cAAPA3AAD4FwAABCAAADGOAAAE+AAAkBEAAJ55AACYOQAAlgEAAER4AAAXaAAATnoAAPgXAAD0JwAA69cAAA==`,
      sgIcon: `data:image/x-icon;base64,AAABAAEAEBAAAAEAIABoBAAAFgAAACgAAAAQAAAAIAAAAAEAIAAAAAAAQAQAABMLAAATCwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIUAAAD5AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAPoAAACFAAAAAAAAAAAAAAD8AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA+QAAAAAAAAAAAAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAAAAAAAAAAAAP8AAAD/AAAA/wAAABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcAAAA/wAAAP8AAAD/AAAAAAAAAAAAAAD/AAAA/wAAAP8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP8AAAD/AAAA/wAAAAAAAAAAAAAA/wAAAP8AAAD/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/AAAA/wAAAP8AAAAAAAAAAAAAAP8AAAD/AAAA/wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/wAAAP8AAAD/AAAAAAAAAAAAAAD/AAAA/wAAAP8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP8AAAD/AAAA/wAAAAAAAAAAAAAA/wAAAP8AAAD/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/AAAA/wAAAP8AAAAAAAAAAAAAAP8AAAD/AAAA/wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/wAAAP8AAAD/AAAAAAAAAAAAAAD/AAAA/wAAAP8AAAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAAAP8AAAD/AAAA/wAAAAAAAAAAAAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAAAAAAAAAAAAPwAAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD5AAAAAAAAAAAAAACFAAAA+QAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD5AAAAhQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//8AAP//AADAAwAAwAMAAMfjAADP8wAAz/MAAM/zAADP8wAAz/MAAM/zAADH4wAAwAMAAMADAAD//wAA//8AAA==`,
      stIcon: `data:image/x-icon;base64,AAABAAEAEBAAAAEAIABoBAAAFgAAACgAAAAQAAAAIAAAAAEAIAAAAAAAQAQAABMLAAATCwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABbD6SgWw+ucFsPrkBbD6SgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAWw+uYFsPr/BbD6/wWw+ucAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFsPrmBbD6/wWw+v8FsPrmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABbD6SQWw+uYFsPrmBbD6SQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFKRLShSkS+cUpEvkFKRLSgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAExi4EpMYuDnTGLg5Exi4EoAAAAAAAAAABSkS+YUpEv/FKRL/xSkS+cAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABMYuDmTGLg/0xi4P9MYuDnAAAAAAAAAAAUpEvmFKRL/xSkS/8UpEvmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAATGLg5kxi4P9MYuD/TGLg5gAAAAAAAAAAFKRLSRSkS+YUpEvmFKRLSQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAExi4ElMYuDmTGLg5kxi4EkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMZ9E0rGfRPnxn0T5MZ9E0oAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADGfRPmxn0T/8Z9E//GfRPnAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAxn0T5sZ9E//GfRP/xn0T5gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMZ9E0nGfRPmxn0T5sZ9E0kAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//8AAPw/AAD8PwAA/D8AAPw/AAD//wAAh+EAAIfhAACH4QAAh+EAAP//AAD8PwAA/D8AAPw/AAD8PwAA//8AAA==`,
      attachedImages: [],
      mainComments: [],
      popupComments: [],
      popups: [],
      openPopups: 0,
      ustCheckboxes: {},
      ustTickets: {},
      numUstTickets: 0,
      elgbCache: JSON.parse(getLocalValue(`elgbCache`, `{"descriptions": {}, "timestamp": ${Date.now()}}`)),
      menuPath: location.pathname.match(/^\/esgst\//),
      settingsPath: location.pathname.match(/^\/esgst\/settings/),
      importMenuPath: location.pathname.match(/^\/esgst\/(import|restore)/),
      exportMenuPath: location.pathname.match(/^\/esgst\/(backup|export)/),
      deleteMenuPath: location.pathname.match(/^\/esgst\/delete/),
      gbPath: location.pathname.match(/^\/esgst\/bookmarked-giveaways/),
      gedPath: location.pathname.match(/^\/esgst\/decrypted-giveaways/),
      gePath: location.pathname.match(/^\/esgst\/extracted-giveaways/),
      glwcPath: location.pathname.match(/^\/esgst\/glwc/),
      userPath: location.pathname.match(/^\/user\//),
      groupPath: location.pathname.match(/^\/group\//),
      regionsPath: location.pathname.match(/^\/regions\//),
      groupWishlistPath: location.pathname.match(/^\/group\/(.*?)\/wishlist/),
      mainPath: location.pathname.match(/^\/$/),
      winnersPath: location.pathname.match(/^\/giveaway\/.+\/winners/),
      giveawaysPath: location.href.match(/steamgifts.com($|\/$|\/giveaways(?!.*\/(new|wishlist|created|entered|won)))/),
      giveawayCommentsPath: location.pathname.match(/^\/giveaway\/(?!.+\/(entries|winners|groups))/),
      discussionsTicketsPath: location.pathname.match(/^\/(discussions|support\/tickets)/),
      ticketsPath: location.pathname.match(/^\/support\/tickets/),
      tradesPath: location.href.match(/steamtrades.com($|\/$|\/trades)/),
      discussionsTicketsTradesPath: location.href.match(/steamtrades.com($|\/$)/) || location.pathname.match(/^\/(discussions|support\/tickets|trades)/),
      originalHash: location.hash,
      discussionTicketTradeCommentsPath: location.pathname.match(/^\/(discussion|support\/ticket|trade)\//),
      archivePath: location.pathname.match(/^\/archive/),
      profilePath: location.pathname.match(/^\/account\/settings\/profile/),
      giveawayPath: location.pathname.match(/^\/giveaway\//),
      discussionPath: location.pathname.match(/^\/discussion\//),
      ticketPath: location.pathname.match(/^\/support\/ticket\//),
      tradePath: location.pathname.match(/^\/trade\//),
      discussionsPath: location.pathname.match(/^\/discussions(?!\/(new|edit))/),
      newDiscussionPath: location.pathname.match(/^\/discussions\/new/),
      editDiscussionPath: location.pathname.match(/^\/discussions\/edit/),
      createdDiscussionsPath: location.pathname.match(/^\/discussions\/created/),
      newGiveawayPath: location.pathname.match(/^\/giveaways\/new/),
      newTicketPath: location.pathname.match(/^\/support\/tickets\/new/),
      wishlistPath: location.pathname.match(/^\/giveaways\/wishlist/),
      createdPath: location.pathname.match(/^\/giveaways\/created/),
      wonPath: location.pathname.match(/^\/giveaways\/won/),
      enteredPath: location.pathname.match(/^\/giveaways\/entered/),
      commentsPath: location.pathname.match(/^\/(giveaway\/(?!.*\/(entries|winners|groups))|discussion\/|support\/ticket\/|trade\/)/),
      accountPath: location.pathname.match(/^\/account/),
      aboutPath: location.pathname.match(/^\/(about|legal)/),
      whitelistPath: location.pathname.match(/^\/account\/manage\/whitelist/),
      blacklistPath: location.pathname.match(/^\/account\/manage\/blacklist/),
      inboxPath: location.pathname.match(/^\/messages/),
      groupsPath: location.pathname.match(/^\/account\/steam\/groups/),
      pageTop: 0,
      commentsTop: 0,
      apPopouts: {},
      tsTables: [],
      currentUsers: {},
      mainGiveaways: [],
      mainDiscussions: [],
      mainUsers: [],
      mainGames: [],
      popupGiveaways: [],
      popupDiscussions: [],
      popupUsers: [],
      popupGames: [],
      mmWbcUsers: [],
      giveawayFeatures: [],
      discussionFeatures: [],
      profileFeatures: [],
      endlessFeatures: [],
      edited: {}
    };
    if (document.body && document.body.getAttribute(`data-esgst-action`)) {
      esgst.menuPath = true;
      esgst.settingsPath = true;
      esgst.sg = true;
    }
    esgst.markdownParser.setBreaksEnabled(true);
    esgst.markdownParser.setMarkupEscaped(true);
    esgst.name = esgst.sg ? `sg` : `st`;

    if (_USER_INFO.extension) {
      // esgst is running as an extension
      setValue = (key, value) => {
        return setValues({[key]: value});
      };
      setValues = values => {
        let key;
        return new Promise(resolve => {
          browser.runtime.sendMessage({
            action: `setValues`,
            values: JSON.stringify(values)
          }, () => {
            for (key in values) {
              esgst.storage[key] = values[key];
            }
            resolve();
          });
        });
      };
      getValue = async (key, value) => {
        return isSet(esgst.storage[key]) ? esgst.storage[key] : value;
      };
      getValues = values => {
        return new Promise(resolve => {
          let output = {};
          for (let key in values) {
            output[key] = isSet(esgst.storage[key]) ? esgst.storage[key] : values[key];
          }
          resolve(output);
        });
      };
      delValue = key => {
        return delValues([key]);
      };
      delValues = keys => {
        return new Promise(resolve => {
          browser.runtime.sendMessage({
            action: `delValues`,
            keys: JSON.stringify(keys)
          }, () => {
            keys.forEach(key => {
              delete esgst.storage[key];
            });
            resolve();
          });
        });
      };
      getStorage = () => {
        return new Promise(resolve => {
          browser.runtime.sendMessage({
            action: `getStorage`
          }, storage => {
            resolve(JSON.parse(storage));
          });
        });
      };
      notifyNewVersion = version => {
        let message;
        if (esgst.isNotifying) return;
        esgst.isNotifying = true;
        if (esgst.discussionPath) {
          message = `You are not using the latest ESGST version. Please update before reporting bugs and make sure the bugs still exist in the latest version.`;
        } else {
          message = `A new ESGST version is available.`;
        }
        let details = {
          icon: `fa-exclamation`,
          title: message,
          isTemp: true,
          onClose: () => {
            esgst.isNotifying = false;
            setValue(`dismissedVersion`, version);
          }
        };
        if (_USER_INFO.extension !== `firefox`) {
          details.buttons = [
            {color1: `green`, color2: `` , icon1: `fa-download`, icon2: ``, title1: `Download .zip`, title2: ``, callback1: open.bind(null, `https://github.com/revilheart/ESGST/releases/download/${version}/extension.zip`)},
            {color1: `green`, color2: `` , icon1: `fa-refresh`, icon2: ``, title1: `Reload Extension`, title2: ``, callback1: browser.runtime.sendMessage.bind(browser.runtime, {action: `reload`}, location.reload.bind(location))}
          ];
        }
        new Popup_v2(details).open();
      };
      continueRequest = details => {
        return new Promise(async resolve => {
          let isLocal = details.url.match(/^\//) || details.url.match(new RegExp(location.hostname));
          details.url = details.url.replace(/^\//, `https://${location.hostname}/`).replace(/^https?:/, location.href.match(/^http:/) ? `http:` : `https:`);
          if (isLocal) {
            let response = await fetch(details.url, {
              body: details.data,
              credentials: details.anon ? `omit` : `include`,
              headers: new Headers(details.headers),
              method: details.method,
              redirect: `follow`
            });
            let responseText = await response.text();
            response = {
              finalUrl: response.url,
              redirected: response.redirected,
              responseText: responseText
            };
            resolve(response);
            if (response.finalUrl.match(/www.steamgifts.com/)) {
              lookForPopups(response);
            }
          } else {
            browser.runtime.sendMessage({
              action: `fetch`,
              blob: details.blob,
              fileName: details.fileName,
              manipulateCookies: _USER_INFO.extension === `firefox` && esgst.manipulateCookies,
              parameters: JSON.stringify({
                body: details.data,
                credentials: details.anon ? `omit` : `include`,
                headers: details.headers,
                method: details.method,
                redirect: `follow`
              }),
              url: details.url
            }, response => {
              response = JSON.parse(response);
              resolve(response);
              if (response.finalUrl.match(/www.steamgifts.com/)) {
                lookForPopups(response);
              }
            });
          }
        });
      };
      addHeaderMenu = () => {
        let arrow, button, className, context, dropdown, menu, position;
        if (esgst.sg) {
          className = `nav__left-container`;
          position = `beforeEnd`;
        } else {
          className = `nav_logo`;
          position = `afterEnd`;
        }
        context = document.getElementsByClassName(className)[0];
        menu = insertHtml(context, position, `
          <div class="esgst-header-menu" id="esgst" title="${getFeatureTooltip()}">
            <div class="esgst-header-menu-relative-dropdown esgst-hidden">
              <div class="esgst-header-menu-absolute-dropdown">
                <a class="esgst-header-menu-row" href="https://github.com/revilheart/ESGST">
                  <i class="fa fa-fw fa-github grey"></i>
                  <div>
                    <p class="esgst-header-menu-name">GitHub</p>
                    <p class="esgst-header-menu-description">Visit the GitHub page.</p>
                  </div>
                </a>
                <a class="esgst-header-menu-row" href="https://github.com/revilheart/ESGST/issues">
                  <i class="fa fa-fw fa-bug red"></i>
                  <div>
                    <p class="esgst-header-menu-name">Bugs/Suggestions</p>
                    <p class="esgst-header-menu-description">Report bugs and/or make suggestions.</p>
                  </div>
                </a>
                <a class="esgst-header-menu-row" href="https://github.com/revilheart/ESGST/milestones">
                  <i class="fa fa-fw fa-map-signs blue"></i>
                  <div>
                    <p class="esgst-header-menu-name">Milestones</p>
                    <p class="esgst-header-menu-description">Check out what's coming in the next version.</p>
                  </div>
                </a>
                <a class="esgst-header-menu-row" href="https://www.steamgifts.com/discussion/TDyzv/">
                  <i class="fa fa-fw fa-commenting green"></i>
                  <div>
                    <p class="esgst-header-menu-name">Discussion</p>
                    <p class="esgst-header-menu-description">Visit the discussion page.</p>
                  </div>
                </a>
                <a class="esgst-header-menu-row" href="http://steamcommunity.com/groups/esgst">
                  <i class="fa fa-fw fa-steam green"></i>
                  <div>
                    <p class="esgst-header-menu-name">Steam Group</p>
                    <p class="esgst-header-menu-description">Visit/join the Steam group.</p>
                  </div>
                </a>
                <div class="esgst-header-menu-row">
                  <i class="fa fa-fw fa-file-text-o yellow"></i>
                  <div>
                    <p class="esgst-header-menu-name">Changelog</p>
                    <p class="esgst-header-menu-description">Check out the changelog.</p>
                  </div>
                </div>
                <a class="esgst-header-menu-row" href="https://www.patreon.com/revilheart">
                  <i class="fa fa-fw fa-dollar grey"></i>
                  <div>
                    <p class="esgst-header-menu-name">Patreon</p>
                    <p class="esgst-header-menu-description">Become a patron to support ESGST!</p>
                  </div>
                </a>
                <div class="esgst-header-menu-row esgst-version-row">
                  <i class="fa fa-fw fa-paypal grey"></i>
                  <div>
                    <p class="esgst-header-menu-name">Paypal (rafaelxgs@gmail.com)</p>
                    <p class="esgst-header-menu-description">Donate to support ESGST. Thank you!</p>
                  </div>
                </div>
                <div class="esgst-header-menu-row esgst-version-row">
                  <div>
                    <p class="esgst-header-menu-description">Current Version: ${esgst.devVersion}</p>
                  </div>
                </div>
              </div>
            </div>
            <div class="esgst-header-menu-button">
              <i class="fa">
                <img src="${esgst.icon}"/>
              </i>
              <span>ESGST</span>
            </div>
            <div class="esgst-header-menu-button arrow">
              <i class="fa fa-angle-down"></i>
            </div>
          </div>
        `);
        dropdown = menu.firstElementChild;
        button = dropdown.nextElementSibling;
        arrow = button.nextElementSibling;
        button.addEventListener(`mousedown`, event => {
          if (event.button === 2) return;
          event.preventDefault();
          if (esgst.openSettingsInTab || event.button === 1) {
            open(`/esgst/settings`);
          } else {
            loadMenu();
          }
        });
        arrow.addEventListener(`click`, toggleHeaderMenu.bind(null, arrow, dropdown));
        document.addEventListener(`click`, closeHeaderMenu.bind(null, arrow, dropdown, menu), true);
        dropdown.firstElementChild.lastElementChild.previousElementSibling.previousElementSibling.addEventListener(`click`, loadChangelog);
      };
      browser.runtime.onMessage.addListener(message => {
        let key;
        message = JSON.parse(message);
        switch (message.action) {
          case `delValues`:
            message.values.forEach(value => {
              delete esgst.storage[value];
            });
            break;
          case `setValues`:
            for (key in message.values) {
              esgst.storage[key] = message.values[key];
            }
            break;
        }
      });
    } else {
      // esgst is running as a script
      setValue = gm.setValue;
      setValues = async values => {
        let promises = [];
        for (let key in values) {
          promises.push(gm.setValue(key, values[key]));
        }
        await Promise.all(promises);
      };
      getValue = gm.getValue;
      getValues = async values => {
        let output = {};
        let promises = [];
        for (let key in values) {
          let promise = gm.getValue(key, values[key]);
          promise.then(value => {
            output[key] = value;
          });
          promises.push(promise);
        }
        await Promise.all(promises);
        return output;
      };
      delValue = gm.deleteValue;
      delValues = async keys => {
        let promises = [];
        for (let i = keys.length - 1; i > -1; i--) {
          promises.push(gm.deleteValue(keys[i]));
        }
        await Promise.all(promises);
      };
      getStorage = async () => {
        let keys = await gm.listValues();
        let promises = [];
        let storage = {};
        for (let i = keys.length - 1; i > -1; i--) {
          let promise = gm.getValue(keys[i]);
          promise.then(value => {
            storage[keys[i]] = value;
          });
          promises.push(promise);
        }
        await Promise.all(promises);
        return storage;
      };
      notifyNewVersion = version => {
        let message, popup;
        if (esgst.isNotifying) return;
        esgst.isNotifying = true;
        if (esgst.discussionPath) {
          message = `You are not using the latest ESGST version. Please update before reporting bugs and make sure the bugs still exist in the latest version.`;
        } else {
          message = `A new ESGST version is available.`;
        }
        popup = new Popup(`fa-exclamation`, message, true);
        insertHtml(popup.actions, `afterBegin`, `<span>Update</span>`).addEventListener(`click`, checkUpdate);
        popup.onClose = () => {
          esgst.isNotifying = false;
          setValue(`dismissedVersion`, version);
        };
        popup.open();
      };
      continueRequest = details => {
        return new Promise(async resolve => {
          let isLocal = details.url.match(/^\//) || details.url.match(new RegExp(location.hostname));
          details.url = details.url.replace(/^\//, `https://${location.hostname}/`).replace(/^https?:/, location.href.match(/^http:/) ? `http:` : `https:`);
          if (isLocal) {
            let response = await fetch(details.url, {
              body: details.data,
              credentials: details.anon ? `omit` : `include`,
              headers: details.headers,
              method: details.method,
              redirect: `follow`
            });
            let responseText = await response.text();
            response = {
              finalUrl: response.url,
              redirected: response.redirected,
              responseText: responseText
            };
            resolve(response);
            if (response.finalUrl.match(/www.steamgifts.com/)) {
              lookForPopups(response);
            }
          } else {
            gm.xmlHttpRequest({
              binary: details.fileName ? true : false,
              data: details.fileName
                ? await getZip(details.data, details.fileName, `binarystring`)
                : details.data,
              headers: details.headers,
              method: details.method,
              overrideMimeType: details.blob ? `text/plain; charset=x-user-defined` : ``,
              url: details.url,
              onload: async response => {
                if (details.blob) {
                  response.responseText = (await readZip(response.responseText))[0].value;
                }
                resolve(response);
                if (response.finalUrl.match(/www.steamgifts.com/)) {
                  lookForPopups(response);
                }
              }
            });
          }
        });
      };
      addHeaderMenu = () => {
        let arrow, button, className, context, dropdown, menu, position;
        if (esgst.sg) {
          className = `nav__left-container`;
          position = `beforeEnd`;
        } else {
          className = `nav_logo`;
          position = `afterEnd`;
        }
        context = document.getElementsByClassName(className)[0];
        menu = insertHtml(context, position, `
          <div class="esgst-header-menu" id="esgst" title="${getFeatureTooltip()}">
            <div class="esgst-header-menu-relative-dropdown esgst-hidden">
              <div class="esgst-header-menu-absolute-dropdown">
                <div class="esgst-header-menu-row">
                  <i class="fa fa-fw fa-refresh blue"></i>
                  <div>
                    <p class="esgst-header-menu-name">Update</p>
                    <p class="esgst-header-menu-description">Check for updates.</p>
                  </div>
                </div>
                <a class="esgst-header-menu-row" href="https://github.com/revilheart/ESGST">
                  <i class="fa fa-fw fa-github grey"></i>
                  <div>
                    <p class="esgst-header-menu-name">GitHub</p>
                    <p class="esgst-header-menu-description">Visit the GitHub page.</p>
                  </div>
                </a>
                <a class="esgst-header-menu-row" href="https://github.com/revilheart/ESGST/issues">
                  <i class="fa fa-fw fa-bug red"></i>
                  <div>
                    <p class="esgst-header-menu-name">Bugs/Suggestions</p>
                    <p class="esgst-header-menu-description">Report bugs and/or make suggestions.</p>
                  </div>
                </a>
                <a class="esgst-header-menu-row" href="https://github.com/revilheart/ESGST/milestones">
                  <i class="fa fa-fw fa-map-signs blue"></i>
                  <div>
                    <p class="esgst-header-menu-name">Milestones</p>
                    <p class="esgst-header-menu-description">Check out what's coming in the next version.</p>
                  </div>
                </a>
                <a class="esgst-header-menu-row" href="https://www.steamgifts.com/discussion/TDyzv/">
                  <i class="fa fa-fw fa-commenting green"></i>
                  <div>
                    <p class="esgst-header-menu-name">Discussion</p>
                    <p class="esgst-header-menu-description">Visit the discussion page.</p>
                  </div>
                </a>
                <a class="esgst-header-menu-row" href="http://steamcommunity.com/groups/esgst">
                  <i class="fa fa-fw fa-steam green"></i>
                  <div>
                    <p class="esgst-header-menu-name">Steam Group</p>
                    <p class="esgst-header-menu-description">Visit/join the Steam group.</p>
                  </div>
                </a>
                <div class="esgst-header-menu-row">
                  <i class="fa fa-fw fa-file-text-o yellow"></i>
                  <div>
                    <p class="esgst-header-menu-name">Changelog</p>
                    <p class="esgst-header-menu-description">Check out the changelog.</p>
                  </div>
                </div>
                <a class="esgst-header-menu-row" href="https://www.patreon.com/revilheart">
                  <i class="fa fa-fw fa-dollar grey"></i>
                  <div>
                    <p class="esgst-header-menu-name">Patreon</p>
                    <p class="esgst-header-menu-description">Become a patron to support ESGST!</p>
                  </div>
                </a>
                <div class="esgst-header-menu-row esgst-version-row">
                  <i class="fa fa-fw fa-paypal grey"></i>
                  <div>
                    <p class="esgst-header-menu-name">Paypal (rafaelxgs@gmail.com)</p>
                    <p class="esgst-header-menu-description">Donate to support ESGST. Thank you!</p>
                  </div>
                </div>
                <div class="esgst-header-menu-row esgst-version-row">
                  <div>
                    <p class="esgst-header-menu-description">Current Version: ${esgst.devVersion}</p>
                  </div>
                </div>
              </div>
            </div>
            <div class="esgst-header-menu-button">
              <i class="fa">
                <img src="${esgst.icon}"/>
              </i>
              <span>ESGST</span>
            </div>
            <div class="esgst-header-menu-button arrow">
              <i class="fa fa-angle-down"></i>
            </div>
          </div>
        `);
        dropdown = menu.firstElementChild;
        button = dropdown.nextElementSibling;
        arrow = button.nextElementSibling;
        button.addEventListener(`mousedown`, event => {
          if (event.button === 2) return;
          event.preventDefault();
          if (esgst.openSettingsInTab || event.button === 1) {
            open(`/esgst/settings`);
          } else {
            loadMenu();
          }
        });
        arrow.addEventListener(`click`, toggleHeaderMenu.bind(null, arrow, dropdown));
        document.addEventListener(`click`, closeHeaderMenu.bind(null, arrow, dropdown, menu), true);
        dropdown.firstElementChild.firstElementChild.addEventListener(`click`, checkUpdate);
        dropdown.firstElementChild.lastElementChild.previousElementSibling.previousElementSibling.addEventListener(`click`, loadChangelog);
      };
    }

    let toDelete, toSet;

    // set default values or correct values
    esgst.storage = await getStorage();
    toDelete = [];
    toSet = {};
    if (isSet(esgst.storage.users)) {
      esgst.users = JSON.parse(esgst.storage.users);
      let changed = false;
      for (let key in esgst.users.users) {
        let wbc = esgst.users.users[key].wbc;
        if (wbc && wbc.result && wbc.result !== `whitelisted` && wbc.result !== `blacklisted`) {
          delete esgst.users.users[key].wbc;
          changed = true;
        }
      }
      if (changed) {
        toSet.users = JSON.stringify(esgst.users);
      }
    } else {
      esgst.users = {
        steamIds: {},
        users: {}
      };
      toSet.users = JSON.stringify(esgst.users);
    }
    if (!isSet(esgst.storage[`${esgst.name}RfiCache`])) {
      toSet[`${esgst.name}RfiCache`] = getLocalValue(`replies`, `{}`);
      delLocalValue(`replies`);
    }
    if (isSet(esgst.storage.emojis)) {
      const fixed = fixEmojis(esgst.storage.emojis);
      if (esgst.storage.emojis !== fixed) {
        toSet.emojis = fixed;
      } else if (!esgst.storage.emojis) {
        toSet.emojis = `[]`;
      }
    } else {
      toSet.emojis = isSet(esgst.storage.Emojis) ? fixEmojis(esgst.storage.Emojis) : `[]`;
      toDelete.push(`Emojis`);
    }
    if (esgst.sg) {
      if (!isSet(esgst.storage.templates)) {
        toSet.templates = getLocalValue(`templates`, `[]`);
        delLocalValue(`templates`);
      }
      if (!isSet(esgst.storage.stickiedCountries)) {
        toSet.stickiedCountries = getLocalValue(`stickiedCountries`, `[]`);
        delLocalValue(`stickiedCountries`);
      }
      if (isSet(esgst.storage.giveaways)) {
        esgst.giveaways = JSON.parse(esgst.storage.giveaways);
      } else {
        toSet.giveaways = getLocalValue(`giveaways`, `{}`);
        esgst.giveaways = JSON.parse(toSet.giveaways);
        delLocalValue(`giveaways`);
      }
      if (isSet(esgst.storage.decryptedGiveaways)) {
        esgst.decryptedGiveaways = esgst.storage.decryptedGiveaways;
        if (typeof esgst.decryptedGiveaways === `string`) {
          esgst.decryptedGiveaways = JSON.parse(esgst.decryptedGiveaways);
        } else {
          toSet.decryptedGiveaways = JSON.stringify(esgst.decryptedGiveaways);
        }
      } else {
        toSet.decryptedGiveaways = `{}`;
        esgst.decryptedGiveaways = {};
      }
      if (isSet(esgst.storage.discussions)) {
        esgst.discussions = JSON.parse(esgst.storage.discussions);
      } else {
        toSet.discussions = getLocalValue(`discussions`, `{}`);
        esgst.discussions = JSON.parse(toSet.discussions);
        delLocalValue(`discussions`);
      }
      if (isSet(esgst.storage.tickets)) {
        esgst.tickets = JSON.parse(esgst.storage.tickets);
      } else {
        toSet.tickets = getLocalValue(`tickets`, `{}`);
        esgst.tickets = JSON.parse(toSet.tickets);
        delLocalValue(`tickets`);
      }
      delLocalValue(`gFix`);
      delLocalValue(`dFix`);
      delLocalValue(`tFix`);
      if (isSet(esgst.storage.groups)) {
        esgst.groups = JSON.parse(esgst.storage.groups);
      } else {
        toSet.groups = getLocalValue(`groups`, `[]`);
        esgst.groups = JSON.parse(toSet.groups);
        delLocalValue(`groups`);
      }
      if (!isSet(esgst.storage.entries)) {
        toSet.entries = getLocalValue(`entries`, `[]`);
        delLocalValue(`entries`);
      }
      if (isSet(esgst.storage.rerolls)) {
        esgst.rerolls = JSON.parse(esgst.storage.rerolls);
      } else {
        toSet.rerolls = getLocalValue(`rerolls`, `[]`);
        esgst.rerolls = JSON.parse(toSet.rerolls);
        delLocalValue(`rerolls`);
      }
      if (isSet(esgst.storage.winners)) {
        esgst.winners = JSON.parse(esgst.storage.winners);
      } else {
        toSet.winners = getLocalValue(`winners`, `{}`);
        esgst.winners = JSON.parse(toSet.winners);
        delLocalValue(`winners`);
      }
    } else {
      if (isSet(esgst.storage.trades)) {
        esgst.trades = JSON.parse(esgst.storage.trades);
      } else {
        toSet.trades = getLocalValue(`trades`, `{}`);
        esgst.trades = JSON.parse(toSet.trades);
        delLocalValue(`trades`);
      }
      delLocalValue(`tFix`);
    }
    let cache = JSON.parse(getLocalValue(`gdtttCache`, `{"giveaways":[],"discussions":[],"tickets":[],"trades":[]}`));
    for (let type in cache) {
      let doSet = false;
      cache[type].forEach(code => {
        if (!esgst[type][code]) {
          esgst[type][code] = {
            readComments: {}
          };
        }
        if (!esgst[type][code].visited) {
          doSet = true;
          esgst[type][code].visited = true;
        }
      });
      if (doSet) {
        toSet[type] = JSON.stringify(esgst[type]);
      }
    }
    setLocalValue(`gdtttCache`, `{"giveaways":[],"discussions":[],"tickets":[],"trades":[]}`);
    if (isSet(esgst.storage.games)) {
      esgst.games = JSON.parse(esgst.storage.games);
    } else {
      esgst.games = {
        apps: {},
        subs: {}
      };
      toSet.games = JSON.stringify(esgst.games);
    }
    if (isSet(esgst.storage.settings)) {
      esgst.settings = JSON.parse(esgst.storage.settings);
    } else {
      esgst.settings = {};
    }
    esgst.version = esgst.storage.version;
    for (let key in esgst.settings) {
      let match = key.match(new RegExp(`(.+?)_${esgst.name}$`));
      if (match) {
        esgst[match[1]] = esgst.settings[key];
      }
    }
    for (let key in esgst.oldValues) {
      let localKey = key.replace(new RegExp(`(.+?)_${esgst.name}$`), `$1`);
      if (typeof esgst[localKey] === `undefined`) {
        esgst[localKey] = getSetting(key, key.match(/^(wbc_checkBlacklist|wbc_hb_sg)$/));
      }
    }
    for (let key in esgst.defaultValues) {
      let localKey = key.replace(new RegExp(`(.+?)_${esgst.name}$`), `$1`);
      if (typeof esgst[localKey] === `undefined`) {
        esgst[localKey] = getSetting(key, key.match(/^(wbc_checkBlacklist|wbc_hb_sg)$/));
      }
    }
    if (isSet(esgst.storage.filterPresets)) {
      esgst.gf_presets = esgst.gf_presets.concat(
        filters_convert(JSON.parse(esgst.storage.filterPresets))
      );
      esgst.settings.gf_presets = esgst.gf_presets;
      esgst.settingsChanged = true;
      toSet.old_gf_presets = esgst.storage.filterPresets;
      toDelete.push(`filterPresets`);
    }
    if (isSet(esgst.storage.dfPresets)) {
      esgst.df_presets = esgst.df_presets.concat(
        filters_convert(JSON.parse(esgst.storage.dfPresets))
      );
      esgst.settings.df_presets = esgst.df_presets;
      esgst.settingsChanged = true;
      toSet.old_df_presets = esgst.storage.dfPresets;
      toDelete.push(`dfPresets`);
    }

    esgst.features = getFeatures();
    for (let type in esgst.features) {
      for (let id in esgst.features[type].features) {
        getFeatureSetting(esgst.features[type].features[id], id);
      }
    }

    [
      {id: `cec`, side: `left`},
      {id: `esContinuous`, side: `right`},
      {id: `esNext`, side: `right`},
      {id: `glwc`, side: `left`},
      {id: `mm`, side: `right`},
      {id: `stbb`, side: `right`},
      {id: `sttb`, side: `right`},
      {id: `ust`, side: `left`},
      {id: `wbm`, side: `left`}
    ].forEach(item => {
      if (esgst.leftButtonIds.indexOf(item.id) < 0 && esgst.rightButtonIds.indexOf(item.id) < 0) {
        esgst[`${item.side}ButtonIds`].push(item.id);
        esgst.settings.leftButtonIds = esgst.leftButtonIds;
        esgst.settings.rightButtonIds = esgst.rightButtonIds;
        esgst.settingsChanged = true;
      }
    });
    if (esgst.settings.users) {
      delete esgst.settings.users;
      esgst.settingsChanged = true;
    }
    if (esgst.settings.comments) {
      delete esgst.settings.comments;
      esgst.settingsChanged = true;
    }
    if (esgst.settings.giveaways) {
      delete esgst.settings.giveaways;
      esgst.settingsChanged = true;
    }
    if (esgst.settings.groups) {
      delete esgst.settings.groups;
      esgst.settingsChanged = true;
    }
    if (esgst.gc_categories.indexOf(`gc_rd`) < 0) {
      esgst.gc_categories.push(`gc_rd`);
      esgst.settings.gc_categories = esgst.gc_categories;
      esgst.settingsChanged = true;
    }
    if (esgst.gc_categories.indexOf(`gc_pw`) < 0) {
      esgst.gc_categories.push(`gc_pw`);
      esgst.settings.gc_categories = esgst.gc_categories;
      esgst.settingsChanged = true;
    }
    if (esgst.gc_categories_gv.indexOf(`gc_pw`) < 0) {
      esgst.gc_categories_gv.push(`gc_pw`);
      esgst.settings.gc_categories_gv = esgst.gc_categories_gv;
      esgst.settingsChanged = true;
    }
    [`gc_categories`, `gc_categories_gv`].forEach(key => {
      let bkpLength = esgst[key].length;
      esgst[key] = Array.from(new Set(esgst[key]));
      if (bkpLength !== esgst[key].length) {
        esgst.settings[key] = esgst[key];
        esgst.settingsChanged = true;
      }
    });
    [``, `_gv`].forEach(key => {
      if (esgst[`giveawayColumns${key}`].indexOf(`sgTools`) < 0 && esgst[`giveawayPanel${key}`].indexOf(`sgTools`) < 0) {
        if (key === ``) {
          esgst[`giveawayPanel${key}`].push(`sgTools`);
          esgst.settings[`giveawayPanel${key}`] = esgst[`giveawayPanel${key}`];
        } else {
          esgst[`giveawayColumns${key}`].unshift(`sgTools`);
          esgst.settings[`giveawayColumns${key}`] = esgst[`giveawayColumns${key}`];
        }
        esgst.settingsChanged = true;
      }
      if (esgst[`giveawayColumns${key}`].indexOf(`ged`) < 0 && esgst[`giveawayPanel${key}`].indexOf(`ged`) < 0) {
        esgst[`giveawayColumns${key}`].unshift(`ged`);
        esgst.settings[`giveawayColumns${key}`] = esgst[`giveawayColumns${key}`];
        esgst.settingsChanged = true;
      }
      if (esgst[`giveawayColumns${key}`].indexOf(`touhou`) < 0 && esgst[`giveawayPanel${key}`].indexOf(`touhou`) < 0) {
        esgst[`giveawayColumns${key}`].push(`touhou`);
        esgst.settings[`giveawayColumns${key}`] = esgst[`giveawayColumns${key}`];
        esgst.settingsChanged = true;
      }
      for (let i = esgst[`giveawayColumns${key}`].length - 1; i > -1; i--) {
        let id = esgst[`giveawayColumns${key}`][i];
        if (esgst[`giveawayPanel${key}`].indexOf(id) > -1) {
          esgst[`giveawayColumns${key}`].splice(i, 1);
          esgst.settings[`giveawayColumns${key}`] = esgst[`giveawayColumns${key}`];
          esgst.settingsChanged = true;
        }
      }
      for (let i = esgst[`giveawayPanel${key}`].length - 1; i > -1; i--) {
        let id = esgst[`giveawayPanel${key}`][i];
        if (esgst[`giveawayColumns${key}`].indexOf(id) > -1) {
          esgst[`giveawayPanel${key}`].splice(i, 1);
          esgst.settings[`giveawayPanel${key}`] = esgst[`giveawayPanel${key}`];
          esgst.settingsChanged = true;
        }
      }
    });
    if (document.readyState === `loading`) {
      document.addEventListener(`DOMContentLoaded`, load.bind(null, toDelete, toSet));
    } else {
      load(toDelete, toSet);
    }
  }

  async function load(toDelete, toSet) {
    if (esgst.menuPath) {
      document.head.insertAdjacentHTML(`beforeEnd`, `
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
        <link rel="stylesheet" type="text/css" href="${_USER_INFO.extension ? browser.runtime.getURL(`css/steamgifts-v34.min.css`) : (await gm.getResourceUrl(`sg`))}">
      `);
      const element = document.querySelector(`[href*="https://cdn.steamgifts.com/css/static.css"]`);
      if (element) {
        element.remove();
      }
      document.body.innerHTML = ``;
    }
    addStyle();
    if (esgst.sg) {
      try {
        let avatar = document.getElementsByClassName(`nav__avatar-inner-wrap`)[0].style.backgroundImage.match(/\("(.+)"\)/)[1];
        if (esgst.settings.avatar !== avatar) {
          esgst.avatar = esgst.settings.avatar = avatar;
          esgst.settingsChanged = true;
        }
        let username = document.getElementsByClassName(`nav__avatar-outer-wrap`)[0].href.match(/\/user\/(.+)/)[1];
        if (esgst.settings.username_sg !== username) {
          esgst.username = esgst.settings.username_sg = username;
          esgst.settingsChanged = true;
        }
        if (!esgst.settings.registrationDate_sg || !esgst.settings.steamId) {
          let responseHtml = parseHtml((await request({method: `GET`, url: `https://www.steamgifts.com/user/${esgst.settings.username_sg}`})).responseText);
          let elements = responseHtml.getElementsByClassName(`featured__table__row__left`);
          for (let i = 0, n = elements.length; i < n; i++) {
            let element = elements[i];
            if (element.textContent === `Registered`) {
              esgst.registrationDate = esgst.settings.registrationDate_sg = parseInt(element.nextElementSibling.firstElementChild.getAttribute(`data-timestamp`));
              break;
            }
          }
          esgst.steamId = esgst.settings.steamId = responseHtml.querySelector(`a[href*="/profiles/"]`).getAttribute(`href`).match(/\d+/)[0];
          esgst.settingsChanged = true;
        }
      } catch (e) { /**/ }
    } else {
      try {
        let avatar = document.getElementsByClassName(`nav_avatar`)[0].style.backgroundImage.match(/\("(.+)"\)/)[1];
        if (esgst.settings.avatar !== avatar) {
          esgst.avatar = esgst.settings.avatar = avatar;
          esgst.settingsChanged = true;
        }
        let username = document.querySelector(`.author_name[href*="/user/${esgst.settings.steamId}"], .underline[href*="/user/${esgst.settings.steamId}"]`).textContent;
        if (esgst.settings.username_st !== username) {
          esgst.username = esgst.settings.username_st = username;
          esgst.settingsChanged = true;
        }
      } catch (e) { /**/ }
    }
    if (esgst.settingsChanged) {
      toSet.settings = JSON.stringify(esgst.settings);
    }
    if (Object.keys(toSet).length) {
      await setValues(toSet);
    }
    if (Object.keys(toDelete).length) {
      await delValues(toDelete);
    }

    // now that all values are set esgst can begin to load

    /* [URLR] URL Redirector */
    if (esgst.urlr && location.pathname.match(/^\/(giveaway|discussion|support\/ticket|trade)\/.{5}$/)) {
      location.href = `${location.href}/`;
    }

    if (location.pathname.match(/esgst-settings/)) {
      location.href = `/esgst/settings`;
    } else if (location.pathname.match(/esgst-sync/)) {
      location.href = `/esgst/sync`;
    } else if (location.pathname.match(/^\/esgst\/dropbox/)) {
      await setValue(`dropboxToken`, location.hash.match(/access_token=(.+?)&/)[1]);
      close();
    } else if (location.pathname.match(/^\/esgst\/google-drive/)) {
      await setValue(`googleDriveToken`, location.hash.match(/access_token=(.+?)&/)[1]);
      close();
    } else if (location.pathname.match(/^\/esgst\/onedrive/)) {
      await setValue(`oneDriveToken`, location.hash.match(/access_token=(.+?)&/)[1]);
      close();
    } else if (location.pathname.match(/^\/esgst\/imgur/)) {
      await setValue(`imgurToken`, location.hash.match(/access_token=(.+?)&/)[1]);
      close();
    } else {
      esgst.logoutButton = document.querySelector(`.js__logout, .js_logout`);
      if (!esgst.logoutButton && !esgst.menuPath) {
        // user is not logged in
        return;
      }
      if (esgst.st && !esgst.settings.esgst_st) {
        // esgst is not enabled for steamtrades
        return;
      }
      esgst.lastPage = lpl_getLastPage(document, true);
      await getElements();
      if (esgst.sg && !esgst.menuPath) {
        checkSync();
      }
      if (esgst.autoBackup) {
        checkBackup();
      }
      if (esgst.profilePath && esgst.autoSync) {
        document.getElementsByClassName(`form__sync-default`)[0].addEventListener(`click`, setSync.bind(null, true, null, null));
      }
      if (esgst.menuPath) {
        esgst.favicon.href = esgst.icon;
        let response = await request({method: `GET`, url: `/`});
        let responseHtml = parseHtml(response.responseText);
        document.body.innerHTML = `
          ${responseHtml.getElementsByTagName(`header`)[0].outerHTML}
          <div class="page__outer-wrap">
            <div class="page__inner-wrap"></div>
          </div>
          ${responseHtml.getElementsByClassName(`footer__outer-wrap`)[0].outerHTML}
        `;
        esgst.header = document.body.firstElementChild;
        esgst.footer = document.body.lastElementChild;
        esgst.headerNavigationLeft = document.getElementsByClassName(`nav__left-container`)[0];
        esgst.pageOuterWrap = esgst.header.nextElementSibling;
        esgst.mainContext = esgst.pageOuterWrap.lastElementChild;
        esgst.logoutButton = responseHtml.getElementsByClassName(esgst.sg ? `js__logout` : `js_logout`)[0];
        if (esgst.logoutButton) {
          esgst.xsrfToken = esgst.logoutButton.getAttribute(`data-form`).match(/xsrf_token=(.+)/)[1];
        }
        await hr_refreshHeaderElements(document);
        
        if (esgst.settingsPath) {
          document.title = `ESGST - Settings`;
          loadMenu(true);
        } else if (esgst.importMenuPath) {
          document.title = `ESGST - Restore`;
          loadDataManagement(true, `import`);
        } else if (esgst.exportMenuPath) {
          document.title = `ESGST - Backup`;
          loadDataManagement(true, `export`);
        } else if (esgst.deleteMenuPath) {
          document.title = `ESGST - Delete`;
          loadDataManagement(true, `delete`);
        } else if (esgst.gbPath) {
          document.title = `ESGST - Giveaway Bookmarks`;
          esgst.originalTitle = `ESGST - Giveaway Bookmarks`;
        } else if (esgst.gedPath) {
          document.title = `ESGST - Decrypted Giveaways`;
          esgst.originalTitle = `ESGST - Decrypted Giveaways`;
        } else if (esgst.gePath) {
          document.title = `ESGST - Extracted Giveaways`;
          esgst.originalTitle = `ESGST - Extracted Giveaways`;
        } else if (esgst.glwcPath) {
          document.title = `ESGST - Group Library/Wishlist Checker`;
          esgst.originalTitle = `ESGST - Group Library/Wishlist Checker`;
        } else  if (location.pathname.match(/esgst\/sync/)) {
          await setSync();
        }

        // make the header dropdown menus work
        let elements = document.querySelectorAll(`nav .nav__button--is-dropdown-arrow`);
        for (let element of elements) {
          element.addEventListener(`click`, event => {
            let isSelected = element.classList.contains(`is-selected`);
            let buttons = document.querySelectorAll(`nav .nav__button`);
            for (let button of buttons) {
              button.classList.remove(`is-selected`);
            }
            let dropdowns = document.querySelectorAll(`nav .nav__relative-dropdown`);
            for (let dropdown of dropdowns) {
              dropdown.classList.add(`is-hidden`);
            }
            if (!isSelected) {
              element.classList.add(`is-selected`);
              (element.previousElementSibling.previousElementSibling || element.nextElementSibling).classList.remove(`is-hidden`);
            }
            event.stopPropagation();
          });
        }
        document.addEventListener(`click`, () => {
          let buttons = document.querySelectorAll(`nav .nav__button, .page__heading__button--is-dropdown`);
          for (let button of buttons) {
            button.classList.remove(`is-selected`);
          }
          let dropdowns = document.querySelectorAll(`nav .nav__relative-dropdown`);
          for (let dropdown of dropdowns) {
            dropdown.classList.add(`is-hidden`);
          }
        });
      }

      addHeaderMenu();
      showPatreonNotice();
      checkNewVersion();
      loadFeatures();
    }
  }

  function minimizePanel_add() {
    if (!esgst.pageOuterWrap) {
      return;
    }

    esgst.minimizePanel = insertHtml(esgst.pageOuterWrap, `beforeEnd`, `
      <div class="esgst-minimize-panel">
        <div class="esgst-minimize-container markdown">
          <h3>Minimized Popups:</h3>
          <hr></hr>
          <ul class="esgst-minimize-list"></ul>
        </div>
      </div>
    `);
    esgst.minimizeList = esgst.minimizePanel.firstElementChild.lastElementChild;
  }

  function minimizePanel_addItem(popup) {
    if (!esgst.minimizeList) {
      return;
    }

    popup.minimizeItem = insertHtml(esgst.minimizeList, `beforeEnd`, `
      <li class="esgst-minimize-item">
        <a href="javascript:void(0);">${popup.title.textContent.replace(/:$/, ``)}</a>
      </li>
    `);
    popup.minimizeLink = popup.minimizeItem.firstElementChild;
    popup.minimizeItem.addEventListener(`click`, minimizePanel_openItem.bind(null, popup));
  }

  function minimizePanel_openItem(popup) {
    popup.open();
    popup.minimizeItem.remove();
    popup.minimizeItem = null;
    if (!esgst.minimizePanel.getElementsByClassName(`alert`).length) {
      esgst.minimizePanel.classList.remove(`alert`);
    }
  }

  function minimizePanel_alert(popup) {
    if (popup.minimizeItem) {
      popup.minimizeItem.classList.add(`alert`);
    }
    if (esgst.minimizePanel) {
      esgst.minimizePanel.classList.add(`alert`);
    }
  }

  async function loadFeatures() {
    if (esgst.minimizePanel) {
      minimizePanel_add();
    }

    let hiddenButtonsBefore, hiddenButtonsAfter;
    if (esgst.hideButtons) {
      hiddenButtonsBefore = document.createElement(`div`);
      hiddenButtonsBefore.className = `esgst-heading-button`;
      hiddenButtonsBefore.title = getFeatureTooltip(`hideButtons`);
      hiddenButtonsBefore.innerHTML = `
        <i class="fa fa-ellipsis-v"></i>
      `;
      esgst.leftButtons = insertHtml(new Popout(`esgst-hidden-buttons`, hiddenButtonsBefore, 0, true).popout, `beforeEnd`, `
        <div class="esgst-page-heading"></div>
      `);
      hiddenButtonsAfter = document.createElement(`div`);
      hiddenButtonsAfter.className = `esgst-heading-button`;
      hiddenButtonsAfter.title = getFeatureTooltip(`hideButtons`);
      hiddenButtonsAfter.innerHTML = `
        <i class="fa fa-ellipsis-v"></i>
      `;
      esgst.rightButtons = insertHtml(new Popout(`esgst-hidden-buttons`, hiddenButtonsAfter, 0, true).popout, `beforeEnd`, `
        <div class="esgst-page-heading"></div>
      `);
    }

    for (const modd of _MODULES) {
      if ((!modd.endless && !esgst[modd.id]) || !modd.load) {
        continue;
      }
      try {
        await modd.load();
      } catch (e) {
        console.log(e);
      }
    }

    if (esgst.updateHiddenGames) {
      const hideButton = document.getElementsByClassName(`js__submit-hide-games`)[0];
      if (hideButton) {
        hideButton.addEventListener(`click`, () => updateHiddenGames(esgst.hidingGame.id, esgst.hidingGame.type, false));
      }
    }
  
    observeStickyChanges(document.body);

    if (esgst.newGiveawayPath) {
      // when the user searches for a game in the new giveaway page, wait until the results appear and load the game features for them
      let rows = document.getElementsByClassName(`form__rows`)[0];
      if (rows) {
        setTimeout(() => checkNewGiveawayInput(document.getElementsByClassName(`js__autocomplete-data`)[0]), 1000);
      }
    }

    if (esgst.hideButtons && esgst.mainPageHeading) {
      if (!esgst.leftButtons.querySelector(`.esgst-heading-button:not(.esgst-hidden)`)) {
        hiddenButtonsBefore.classList.add(`esgst-hidden`);
      }
      if (!esgst.rightButtons.querySelector(`.esgst-heading-button:not(.esgst-hidden)`)) {
        hiddenButtonsAfter.classList.add(`esgst-hidden`);
      }
      esgst.mainPageHeading.insertBefore(hiddenButtonsBefore, esgst.mainPageHeading.firstElementChild);
      esgst.mainPageHeading.appendChild(hiddenButtonsAfter);
    }
    reorderButtons(hiddenButtonsBefore, esgst.leftButtons, hiddenButtonsAfter, esgst.rightButtons);
    if (document.readyState === `complete`) {
      goToComment(esgst.originalHash);
    } else {
      document.addEventListener(`readystatechange`, goToComment.bind(null, esgst.originalHash, null, false));
    }
    addEventListener(`beforeunload`, checkBusy);
    addEventListener(`hashchange`, goToComment.bind(null, null, null, false));
    if (!esgst.staticPopups) {
      setTimeout(() => repositionPopups(), 2000);
    }
  }

  async function getElements() {
    if (esgst.sg) {
      esgst.pageOuterWrapClass = `page__outer-wrap`;
      esgst.pageHeadingClass = `page__heading`;
      esgst.pageHeadingBreadcrumbsClass = `page__heading__breadcrumbs`;
      esgst.footer = document.getElementsByClassName(`footer__outer-wrap`)[0];
      esgst.replyBox = document.getElementsByClassName(`comment--submit`)[0];
      esgst.cancelButtonClass = `comment__cancel-button`;
      esgst.paginationNavigationClass = `pagination__navigation`;
      esgst.hiddenClass = `is-hidden`;
      esgst.selectedClass = `is-selected`;
    } else {
      esgst.pageOuterWrapClass = `page_outer_wrap`;
      esgst.pageHeadingClass = `page_heading`;
      esgst.pageHeadingBreadcrumbsClass = `page_heading_breadcrumbs`;
      esgst.footer = document.getElementsByTagName(`footer`)[0];
      esgst.replyBox = document.getElementsByClassName(`reply_form`)[0];
      esgst.cancelButtonClass = `btn_cancel`;
      esgst.paginationNavigationClass = `pagination_navigation`;
      esgst.hiddenClass = `is_hidden`;
      esgst.selectedClass = `is_selected`;
    }
    esgst.currentPage = location.href.match(/page=(\d+)/);
    if (esgst.currentPage) {
      esgst.currentPage = parseInt(esgst.currentPage[1]);
    } else {
      esgst.currentPage = 1;
    }
    let url = location.href.replace(location.search, ``).replace(location.hash, ``).replace(`/search`, ``);
    esgst.originalUrl = url;
    esgst.favicon = document.querySelector(`[rel="shortcut icon"]`);
    esgst.originalTitle = document.title;
    if (esgst.mainPath) {
      url += esgst.sg ? `giveaways` : `trades`;
    }
    url += `/search?`;
    let parameters = location.search.replace(/^\?/, ``).split(/&/);
    for (let i = 0, n = parameters.length; i < n; ++i) {
      if (parameters[i] && !parameters[i].match(/page/)) {
        url += parameters[i] + `&`;
      }
    }
    if (location.search) {
      esgst.originalUrl = url.replace(/&$/, ``);
      if (esgst.currentPage > 1) {
        esgst.originalUrl += `&page=${esgst.currentPage}`;
      }
    }
    url += `page=`;
    esgst.searchUrl = url;
    if (!esgst.menuPath) {
      await hr_refreshHeaderElements(document);
    }
    esgst.header = document.getElementsByTagName(`header`)[0];
    esgst.headerNavigationLeft = document.getElementsByClassName(`nav__left-container`)[0];
    esgst.pagination = document.getElementsByClassName(`pagination`)[0];
    esgst.featuredContainer = document.getElementsByClassName(`featured__container`)[0];
    esgst.pageOuterWrap = document.getElementsByClassName(esgst.pageOuterWrapClass)[0];
    esgst.paginationNavigation = document.getElementsByClassName(esgst.paginationNavigationClass)[0];
    esgst.sidebar = document.getElementsByClassName(`sidebar`)[0];
    if (esgst.sidebar) {
      esgst.enterGiveawayButton = esgst.sidebar.getElementsByClassName(`sidebar__entry-insert`)[0];
      esgst.leaveGiveawayButton = esgst.sidebar.getElementsByClassName(`sidebar__entry-delete`)[0];
    }
    esgst.activeDiscussions = document.querySelector(`.widget-container--margin-top:last-of-type`);
    esgst.pinnedGiveaways = document.getElementsByClassName(`pinned-giveaways__outer-wrap`)[0];
    let mainPageHeadingIndex;
    if (esgst.commentsPath) {
      mainPageHeadingIndex = 1;
    } else {
      mainPageHeadingIndex = 0;
    }
    esgst.mainPageHeading = document.getElementsByClassName(esgst.pageHeadingClass)[mainPageHeadingIndex];
    if (!esgst.mainPageHeading && mainPageHeadingIndex === 1) {
      esgst.mainPageHeading = document.getElementsByClassName(esgst.pageHeadingClass)[0];
    }
    if (esgst.logoutButton) {
      esgst.xsrfToken = esgst.logoutButton.getAttribute(`data-form`).match(/xsrf_token=(.+)/)[1];
    }
  }

  /**
   * Modules
   * 
   * Order here is important. The modules must be listed in the order
   * that they are supposed to run.
   */
  
  // [BGL]

  _MODULES.push({
    description: `
      <ul>
        <li>If you cannot access a giveaway for blacklist reasons (either because you have blacklisted the creator or the creator has blacklisted you), this feature requests the giveaway in anonymous mode (as if you were not logged in) and loads it to you.</li>
      </ul>
    `,
    id: `bgl`,
    load: bgl,
    name: `Blacklist Giveaway Loader`,
    sg: true,
    type: `giveaways`
  });

  async function bgl() {
    if (!esgst.giveawayPath) return;

    let backup = esgst.pageOuterWrap.innerHTML;
    let summary = document.getElementsByClassName(`table--summary`)[0];
    summary = summary && summary.lastElementChild.firstElementChild.lastElementChild;
    if (!summary) return;
    let match = summary.textContent.match(/you\s(have\s(been\s)?|previously\s)blacklisted/);
    if (!match) return;
    esgst.pageOuterWrap.innerHTML = `
      <i class="fa fa-circle-o-notch fa-spin"></i>
      <span>Loading giveaway...</span>
    `;
    let responseHtml = parseHtml((await request({anon: true, method: `GET`, url: location.pathname})).responseText);
    if (responseHtml.getElementsByClassName(`table--summary`)[0]) {
      esgst.pageOuterWrap.innerHTML = backup;
      esgst.pageOuterWrap.getElementsByClassName(`table--summary`)[0].lastElementChild.firstElementChild.lastElementChild.insertAdjacentHTML(`beforeEnd`, `<br><br><span class="esgst-red">This is a group/whitelist giveaway and therefore cannot be loaded by Blacklist Giveaway Loader.</span>`);
    } else {
      esgst.featuredContainer = insertHtml(esgst.pageOuterWrap, `beforeBegin`, `<div class="featured__container"></div>`);
      esgst.featuredContainer.innerHTML = responseHtml.getElementsByClassName(`featured__container`)[0].innerHTML;
      esgst.pageOuterWrap.innerHTML = responseHtml.getElementsByClassName(`page__outer-wrap`)[0].innerHTML;
      await getElements();
      esgst.sidebar.insertAdjacentHTML(`afterBegin`, `
        <div class="sidebar__error is-disabled">
          <i class="fa fa-exclamation-circle"></i> ${match[1] ? (match[1] === `previously ` ? `Off Your Blacklist<br>(${summary.firstElementChild.outerHTML})` : (match[1] === `have been ` ? `You Are Blacklisted` : `On Your Blacklist`)) : `On Your Blacklist`}
        </div>
      `);
    }
  }

  // [NS]

  _MODULES.push({
    description: `
      <ul>
        <li>Keeps the sidebar narrowed in all pages.</li>
      </ul>
    `,
    id: `ns`,
    load: ns,
    name: `Narrow Sidebar`,
    sg: true,
    type: `general`
  });

  function ns() {
    if (!esgst.sidebar) return;
    esgst.sidebar.classList.remove(`sidebar--wide`);
    esgst.sidebar.classList.add(`esgst-ns`);
  }

  // [HCP]

  _MODULES.push({
    description: `
      <ul>
        <li>Hides the community poll (if there is one) of the main page.</li>
      </ul>
    `,
    features: {
      hcp_v: {
        name: `Only hide the poll if you already voted in it.`,
        sg: true
      }
    },
    id: `hcp`,
    load: hcp,
    name: `Hidden Community Poll`,
    sg: true,
    type: `general`
  });

  function hcp() {
    if (!esgst.giveawaysPath || !esgst.activeDiscussions) return;
    let poll = esgst.activeDiscussions.previousElementSibling;
    if (poll && poll.classList.contains(`widget-container`)) {
      if (!esgst.hcp_v || poll.querySelector(`.table__row-outer-wrap.is-selected`)) {
        poll.classList.add(`esgst-hidden`);
      }
    }
  }

  // [OADD]

  _MODULES.push({
    description: `
      <ul>
        <li>Brings back the SteamGifts' old active discussions design, while keeping the new "Deals" section.</li>
        <li>Only one section ("Discussions" or "Deals") can be shown at a time. There is a button (<i class="fa fa-retweet"></i>) in the page heading of the active discussions that allows you to switch sections.</li>
      </ul>
    `,
    features: {
      oadd_d: {
        description: `
          <ul>
            <li>With this option enabled, the deals are included in the "Discussions" section instead of being exclusive to the "Deals" section.</li>
          </ul>
        `,
        name: `Show deals in the "Discussions" section.`,
        sg: true
      }
    },
    id: `oadd`,
    load: oadd,
    name: `Old Active Discussions Design`,
    sg: true,
    type: `discussions`
  });

  async function oadd() {
    if (!esgst.giveawaysPath || !esgst.activeDiscussions) return;
    await oadd_load();
  }

  async function oadd_load(refresh, callback) {
    let deals, dealsRows, dealsSwitch, discussions, discussionsRows, discussionsSwitch, i, j, response1Html, response2Html, revisedElements, savedDiscussions;
    response1Html = parseHtml((await request({method: `GET`, url: `/discussions`})).responseText);
    response2Html = parseHtml((await request({method: `GET`, url: `/discussions/deals`})).responseText);
    esgst.activeDiscussions.classList.add(`esgst-oadd`);
    esgst.activeDiscussions.innerHTML = `
      <div>
        <div class="page__heading">
          <div class="esgst-heading-button" title="Switch to Deals">
            <i class="fa fa-retweet"></i>
          </div>
          <div class="page__heading__breadcrumbs">
            <a href="/discussions">Active Discussions</a>
          </div>
          <a class="page__heading__button page__heading__button--green" href="/discussions">
            More<i class="fa fa-angle-right"></i>
          </a>
        </div>
        <div class="table">
          <div class="table__heading">
            <div class="table__column--width-fill">Summary</div>
            <div class="table__column--width-small text-center">Comments</div>
            <div class="table__column--width-medium text-right">Last Post</div>
          </div>
          <div class="table__rows"></div>
        </div>
      </div>
      <div class="esgst-hidden">
        <div class="page__heading">
          <div class="esgst-heading-button" title="Switch to Discussions">
            <i class="fa fa-retweet"></i>
          </div>
          <div class="page__heading__breadcrumbs">
            <a href="/discussions/deals">Active Deals</a>
          </div>
          <a class="page__heading__button page__heading__button--green" href="/discussions/deals">
            More<i class="fa fa-angle-right"></i>
          </a>
        </div>
        <div class="table">
          <div class="table__heading">
            <div class="table__column--width-fill">Summary</div>
            <div class="table__column--width-small text-center">Comments</div>
            <div class="table__column--width-medium text-right">Last Post</div>
          </div>
          <div class="table__rows"></div>
        </div>
      </div>
    `;
    discussions = esgst.activeDiscussions.firstElementChild;
    deals = discussions.nextElementSibling;
    discussionsSwitch = discussions.firstElementChild.firstElementChild;
    discussionsRows = discussions.lastElementChild.lastElementChild;
    dealsSwitch = deals.firstElementChild.firstElementChild;
    dealsRows = deals.lastElementChild.lastElementChild;
    let preset = null;
    if (esgst.df && esgst.df_m && esgst.df_enable) {
      let name = esgst.df_preset;
      if (name) {
        let i;
        for (i = esgst.df_presets.length - 1; i > -1 && esgst.df_presets[i].name !== name; i--);
        if (i > -1) {
          preset = esgst.df_presets[i];
        }
      }
    }
    savedDiscussions = JSON.parse(await getValue(`discussions`, `{}`));
    let elements = await discussions_get(response1Html, true);
    if (!esgst.oadd_d) {
      revisedElements = [];
      elements.forEach(element => {
        if (element.category !== `Deals`) {
          revisedElements.push(element);
        }
      });
      elements = revisedElements;
    }
    const filters = df_getFilters();
    for (i = 0, j = elements.length - 1; i < 5 && j > -1; j--) {
      if (!preset || filters_filterItem(`df`, filters, elements[j], preset.rules)) {
        discussionsRows.appendChild(elements[j].outerWrap);
        i += 1;
      }
    }
    elements = await discussions_get(response2Html, true);
    for (i = 0, j = elements.length - 1; i < 5 && j > -1; j--) {
      if (!preset || filters_filterItem(`df`, filters, elements[j], preset.rules)) {
        dealsRows.appendChild(elements[j].outerWrap);
        i += 1;
      }
    }
    discussionsSwitch.addEventListener(`click`, () => {
      discussions.classList.add(`esgst-hidden`);
      deals.classList.remove(`esgst-hidden`);
    });
    dealsSwitch.addEventListener(`click`, () => {
      discussions.classList.remove(`esgst-hidden`);
      deals.classList.add(`esgst-hidden`);
    });
    if (esgst.adots) {
      adots_load(refresh);
    } else if (esgst.radb) {
      radb_addButtons();
    }
    if (refresh) {
      await endless_load(esgst.activeDiscussions);
      if (callback) {
        callback();
      }
    } else if (callback) {
      callback();
    }
  }

  // [ADOTS]
  
  _MODULES.push({
    description: `
      <ul>
        <li>Moves the active discussions (in the main page) to the top/sidebar of the page (you can decide where).</li>
        <li>If you move it to the sidebar, some things will be changed to save some space:</li>
        <ul>
          <li>The username and avatar of the user who last posted to the discussion will be removed (the button to go to the last comment will remain).</li>
          <li>If you have [id=ags] enabled, it will be hidden and only visible when hovering hover the search field.</li>
          <li>If you have [id=at] enabled, it will not run inside of the active discussions.</li>
          <li>If you have [id=ut] enabled, any user tags will be hidden inside of the active discussions (they will still be visible if you click on the tag button to edit them).</li>
        </ul>
      </ul>
    `,
    id: `adots`,
    load: adots,
    name: `Active Discussions On Top/Sidebar`,
    options: {
      title: `Move to:`,
      values: [`Top`, `Sidebar`]
    },
    sg: true,
    type: `discussions`
  });

  async function adots() {
    if (!esgst.giveawaysPath || !esgst.activeDiscussions || esgst.oadd) return;
    await checkMissingDiscussions();
  }

  function adots_load(refresh) {
    let parent, panel, size, tabHeading1, tabHeading2, activeDiscussions, discussions, deals, element, elements, i, icon, n, comments, rows;
    if (esgst.activeDiscussions) {
      if (!refresh) {
        esgst.activeDiscussions.classList.remove(`widget-container--margin-top`);
        esgst.activeDiscussions.classList.add(`esgst-adots`);
      }
      if (esgst.adots_index === 0) {
        if (!refresh) {
          parent = esgst.activeDiscussions.parentElement;
          parent.insertBefore(esgst.activeDiscussions, parent.firstElementChild);
          if (esgst.radb) {
            radb_addButtons();
          }
        } else if (esgst.oadd && esgst.radb) {
          radb_addButtons();
        }
      } else {
        if (!refresh) {
          if (esgst.ib) {
            size = 45;
          } else {
            size = 35;
          }
          esgst.style.insertAdjacentText(`beforeEnd`, `
            .esgst-adots .table__row-inner-wrap >:first-child {
              float: left;
              width: ${size}px;
              height: ${size}px;
            }
            .esgst-adots .table__row-inner-wrap >:first-child >* {
              width: ${size}px;
              height: ${size}px;
            }
            .esgst-adots .table__row-inner-wrap >:last-child {
              margin-left: ${size + 5}px;
              text-align: left;
              width: auto;
            }
            .esgst-adots .table__column--width-fill {
              margin-left: 5px;
              vertical-align: top;
              width: calc(100% - ${size + 15}px);
            }
          `);
          panel = insertHtml(esgst.sidebar, `beforeEnd`, `
            <h3 class="sidebar__heading">
              <span class="esgst-adots-tab-heading esgst-selected">Discussions</span>
              <span class="esgst-adots-tab-heading">Deals</span>
              <a class="esgst-float-right sidebar__navigation__item__name" href="/discussions">More</a>
            </h3>
          `);
          tabHeading1 = panel.firstElementChild;
          tabHeading2 = tabHeading1.nextElementSibling;
          if (esgst.radb) {
            insertHtml(tabHeading2.nextElementSibling, `beforeBegin`, `
              <div class="esgst-radb-button" title="${getFeatureTooltip(`radb`, `Refresh active discussions/deals`)}">
                <i class="fa fa-refresh"></i>
              </div>
            `).addEventListener(`click`, event => {
              let icon = event.currentTarget.firstElementChild;
              icon.classList.add(`fa-spin`);
              if (esgst.oadd) {
                oadd_load(true, icon.classList.remove.bind(icon, `fa-spin`));
              } else {
                checkMissingDiscussions(true, () => icon.classList.remove(`fa-spin`));
              }
            });
          }
        }
        if (esgst.oadd) {
          discussions = esgst.activeDiscussions.firstElementChild;
          deals = esgst.activeDiscussions.lastElementChild;
          discussions.firstElementChild.remove();
          discussions.firstElementChild.firstElementChild.remove();
          deals.firstElementChild.remove();
          deals.firstElementChild.firstElementChild.remove();
          elements = esgst.activeDiscussions.getElementsByClassName(`table__column--last-comment`);
          for (i = 0, n = elements.length; i < n; ++i) {
            icon = elements[0].getElementsByClassName(`table__last-comment-icon`)[0];
            if (icon) {
              icon.classList.add(`esgst-float-right`);
              elements[0].previousElementSibling.appendChild(icon);
            }
            elements[0].remove();
          }
          if (!refresh) {
            discussions = discussions.firstElementChild.firstElementChild;
            deals = deals.firstElementChild.firstElementChild;
          }
        } else {
          if (refresh) {
            rows = document.getElementsByClassName(`table`);
            discussions = rows[0];
            deals = rows[1];
          } else {
            discussions = esgst.activeDiscussions.firstElementChild.firstElementChild.lastElementChild;
            deals = esgst.activeDiscussions.lastElementChild.firstElementChild.lastElementChild;
          }
          elements = discussions.getElementsByClassName(`table__row-outer-wrap`);
          for (i = 0, n = elements.length; i < n; ++i) {
            element = elements[i];
            comments = element.getElementsByClassName(`table__column__secondary-link`)[0];
            parent = comments.parentElement;
            panel = insertHtml(parent, `afterEnd`, `<p></p><div style="clear: both;"></div>`);
            panel.appendChild(comments);
            if (parent.lastElementChild.classList.contains(`table__last-comment-icon`)) {
              parent.lastElementChild.classList.add(`esgst-float-right`);
              panel.appendChild(parent.lastElementChild);
            }
            parent.remove();
          }
          elements = deals.getElementsByClassName(`table__row-outer-wrap`);
          for (i = 0, n = elements.length; i < n; ++i) {
            element = elements[i];
            comments = element.getElementsByClassName(`table__column__secondary-link`)[0];
            parent = comments.parentElement;
            panel = insertHtml(parent, `afterEnd`, `<p></p><div style="clear: both;"></div>`);
            panel.appendChild(comments);
            if (parent.lastElementChild.classList.contains(`table__last-comment-icon`)) {
              parent.lastElementChild.classList.add(`esgst-float-right`);
              panel.appendChild(parent.lastElementChild);
            }
            parent.remove();
          }
        }
        if (!tabHeading1) {
          tabHeading1 = discussions.parentElement.previousElementSibling.firstElementChild;
          tabHeading2 = tabHeading1.nextElementSibling;
        }
        if (tabHeading1.classList.contains(`esgst-selected`)) {
          deals.classList.add(`esgst-hidden`, `esgst-adots`);
          discussions.classList.add(`esgst-adots`);
          discussions.classList.remove(`esgst-hidden`);
        } else {
          discussions.classList.add(`esgst-hidden`, `esgst-adots`);
          deals.classList.add(`esgst-adots`);
          deals.classList.remove(`esgst-hidden`);
        }
        if (!refresh) {
          activeDiscussions = insertHtml(esgst.sidebar, `beforeEnd`, `<div></div>`);
          activeDiscussions.appendChild(discussions);
          activeDiscussions.appendChild(deals);
          tabHeading1.addEventListener(`click`, adots_changeTab.bind(null, tabHeading1, tabHeading2));
          tabHeading2.addEventListener(`click`, adots_changeTab.bind(null, tabHeading1, tabHeading2));
          esgst.activeDiscussions.remove();
          esgst.activeDiscussions = activeDiscussions;
        }
      }
    }
  }

  function adots_changeTab(button1, button2, event) {
    if ((button1.classList.contains(`esgst-selected`) && event.currentTarget === button2) || (button2.classList.contains(`esgst-selected`) && event.currentTarget === button1)) {
      button1.classList.toggle(`esgst-selected`);
      button2.classList.toggle(`esgst-selected`);
      button1.parentElement.nextElementSibling.firstElementChild.classList.toggle(`esgst-hidden`);
      button1.parentElement.nextElementSibling.lastElementChild.classList.toggle(`esgst-hidden`);
    }
  }
  
  // [EF]

  _MODULES.push({
    description: `
      <ul>
        <li>Allows you to hide elements in any page using CSS selectors.</li>
        <li>If you do not know how to use CSS selectors or you are having trouble hiding an element, leave a comment in the ESGST thread with a description/image of the element that you want to hide and I will give you the selector that you have to use.</li>
        <li>Here are some quick examples:</li>
        <ul>
          <li>To hide the "Redeem" button in your <a href="https://www.steamgifts.com/giveaways/won">won</a> page, use: <code>.table__column__key__redeem</code></li>
          <li>To hide the featured giveaway container (the big giveaway) in the main page, use: <code>[esgst.giveawaysPath].featured__container</code></li>
          <li>To hide the pinned giveaways (the multiple copy giveaways) in the main page, use: <code>[esgst.giveawaysPath].pinned-giveaways__outer-wrap</code></li>
        </ul>
      </ul>
    `,
    inputItems: [
      {
        id: `ef_filters`,
        prefix: `Filters: `,
        tooltip: `Separate each selector by a comma followed by a space, for example: .class_1, .class_2, #id`
      }
    ],
    id: `ef`,
    load: ef,
    name: `Element Filters`,
    sg: true,
    st: true,
    type: `general`
  });

  function ef() {
    ef_hideElements(document);
    esgst.endlessFeatures.push(ef_hideElements);
    if (esgst.sal || !esgst.wonPath) return;
    esgst.endlessFeatures.push(sal_addObservers);
  }

  function ef_hideElements(context, main, source, endless) {
    if (context === document && main) return;
    esgst.ef_filters.split(`, `).forEach(filter => {
      if (!filter) return;
      try {
        const property = filter.match(/\[esgst\.(.+)\]/);
        if (property) {
          if (!esgst[property[1]]) return;
          filter = filter.replace(/\[esgst\..+\]/, ``);
        }
        const elements = context.querySelectorAll(`${endless ? `.esgst-es-page-${endless} ${filter}, .esgst-es-page-${endless}${filter}` : `${filter}`}`);
        for (let i = elements.length - 1; i > -1; i--) {
          elements[i].classList.add(`esgst-hidden`);
        }
      } catch (e) { /**/ }
    });
  }

  // Add giveaways to storage.

  _MODULES.push({
    endless: true,
    id: `giveaways_addToStorage`,
    load: giveaways_addToStorage
  });
  
  function giveaways_addToStorage() {
    if ((esgst.lpv || esgst.cewgd || (esgst.gc && esgst.gc_gi)) && esgst.giveawayPath && document.referrer === `https://www.steamgifts.com/giveaways/new`) {
      addGiveawayToStorage();
    }
  }

  // [AIC]

  _MODULES.push({
    description: `
      <ul>
        <li>Adds a button (<i class="fa fa-image"></i>) to the main page heading of any page that allows you to navigate through a carousel containing all of the attached images in the page.</li>
        <li>The carousel can also be opened by clicking on any attached image in the page.</li>
      </ul>
    `,
    features: {
      aic_b: {
        name: `Only trigger the carousel when clicking on the button in the main page heading.`,
        sg: true,
        st: true
      }
    },
    id: `aic`,
    load: aic,
    name: `Attached Image Carousel`,
    sg: true,
    st: true,
    type: `general`
  });

  function aic() {
    esgst.endlessFeatures.push(aic_getImages);
    document.addEventListener(`keydown`, aic_move);
    if (!esgst.mainPageHeading) return;
    esgst.aicButton = createHeadingButton({id: `aic`, icons: [`fa-image`], title: `View attached images`});
    esgst.aicButton.classList.add(`esgst-hidden`);
    esgst.aicButton.addEventListener(`click`, aic_openCarousel.bind(null, 0, null));
  }

  function aic_move(event) {
    if (event.key === `ArrowLeft` && esgst.aicPrevious) {
      esgst.aicPrevious.click();
    }
    if (event.key === `ArrowRight` && esgst.aicNext) {
      esgst.aicNext.click();
    }
  }

  function aic_getImages(context, main, source, endless) {
    let buttons = context.querySelectorAll(`${endless ? `.esgst-es-page-${endless} .comment__toggle-attached, .esgst-es-page-${endless}.comment__toggle-attached` : `.comment__toggle-attached`}, ${endless ? `.esgst-es-page-${endless} .view_attached, .esgst-es-page-${endless}.view_attached` : `.view_attached`}`);
    let found = false;
    for (let i = 0, n = buttons.length; i < n; i++) {
      let button = buttons[i];
      let image = button.nextElementSibling.firstElementChild;
      let url = image.getAttribute(`src`);
      let index = esgst.attachedImages.length;
      if (!esgst.aic_b) {
        image.addEventListener(`click`, aic_openCarousel.bind(null, index));
      }
      let comment = button.closest(`.comment`);
      esgst.attachedImages.push({
        button: button,
        image: image,
        outerWrap: button,
        qiv: context.getAttribute && context.getAttribute(`data-esgst-qiv`),
        source: comment && comment.querySelector(`.comment__summary`).id,
        url: url
      });
      found = true;
    }
    if (!found || !esgst.aicButton) {
      return;
    }
    esgst.aicButton.classList.remove(`esgst-hidden`);
  }

  function aic_openCarousel(i, event) {
    if (event) {
      event.preventDefault();
      event.stopPropagation();
    }
    let carousel = insertHtml(document.body, `beforeEnd`, `<div class="esgst-popup-modal esgst-aic-carousel"></div>`);
    carousel.style.zIndex = 9999 + document.querySelectorAll(`.esgst-popup:not(.esgst-hidden), .esgst-popout:not(.esgst-hidden)`).length;
    carousel.addEventListener(`click`, aic_removeCarousel);
    aic_showImage(carousel, i);
  }

  function aic_removeCarousel(event) {
    if (event.target.closest(`.esgst-aic-panel`) || event.target.closest(`img`)) return;

    event.currentTarget.remove();
  }

  function aic_showImage(carousel, i) {
    let attachedImage, height, image, n, panel;
    n = esgst.attachedImages.length;
    attachedImage = esgst.attachedImages[i];
    if (esgst.ail) {
      attachedImage.image.setAttribute(`src`, attachedImage.url);
    }
    carousel.innerHTML = `
      <div class="esgst-aic-panel">
        <div class="esgst-aic-left-button">
          <i class="fa fa-chevron-left"></i>
        </div>
        <div class="esgst-aic-right-button">
          <i class="fa fa-chevron-right"></i>
        </div>
        <div>
          ${i + 1}/${n}
        </div>
        ${attachedImage.source ? `
          <div class="esgst-aic-source">
            <a href="#${attachedImage.source}">Source</a>
          </div>
        ` : ``}
      </div>
      <a href="${attachedImage.url}" rel="nofollow noreferrer" target="_blank">
        ${attachedImage.image.outerHTML.replace(/is_hidden|is-hidden/, ``)}
      </a>
    `;
    panel = carousel.firstElementChild;
    image = panel.nextElementSibling;
    height = panel.offsetHeight + 25;
    image.style.maxHeight = `calc(90% - ${height}px)`;
    image.style.marginTop = `${height}px`;
    image.firstElementChild.onload = aic_resizeImage.bind(null, image);
    esgst.aicPrevious = panel.firstElementChild;
    esgst.aicNext = esgst.aicPrevious.nextElementSibling;
    if (i > 0) {
      esgst.aicPrevious.addEventListener(`click`, aic_showImage.bind(null, carousel, i - 1));
    } else {
      esgst.aicPrevious.classList.add(`esgst-disabled`);
    }
    if (i < n - 1) {
      esgst.aicNext.addEventListener(`click`, aic_showImage.bind(null, carousel, i + 1));
    } else {
      esgst.aicNext.classList.add(`esgst-disabled`);
    }
    if (attachedImage.source) {
      panel.lastElementChild.addEventListener(`click`, () => {
        carousel.remove();
        if (attachedImage.qiv && esgst.qiv.popout) {
          esgst.qiv.popout.open();
        }
      });
    }
  }

  function aic_resizeImage(image) {
    image.firstElementChild.style.maxHeight = `${image.offsetHeight - 10}px`;
    image.firstElementChild.style.maxWidth = `${image.offsetWidth - 10}px`;
  }

  // [AS]
  
  _MODULES.push({
    description: `
      <ul>
        <li>Adds a button (<i class="fa fa-folder"></i> <i class="fa fa-search"></i>) to the main page heading of any <a href="https://www.steamgifts.com/archive">archive</a> page that allows you to search the archive by exact title/app id.</li>
      </ul>
    `,
    id: `as`,
    load: as_load,
    name: `Archive Searcher`,
    sg: true,
    type: `giveaways`
  });

  function as_load() {
    if (!esgst.archivePath) return;

    let category = location.pathname.match(/^\/archive\/(coming-soon|open|closed|deleted)/);
    new Process({
      headingButton: {
        id: `as`,
        icons: [`fa-folder`, `fa-search`],
        title: `Search archive`
      },
      popup: {
        icon: `fa-folder`,
        title: `Search archive${category ? ` for ${category[1]} giveaways` : ``}:`,
        options: [
          {
            check: true,
            description: `Search by AppID.`,
            id: `as_searchAppId`,
            tooltip: `If unchecked, a search by exact title will be performed.`
          }
        ],
        textInputs: [
          {
            placeholder: `Title/app id`
          }
        ],
        addProgress: true,
        addScrollable: `left`
      },
      init: as_init,
      requests: [
        {
          request: as_request
        }
      ]
    });
  }

  async function as_init(obj) {
    obj.query = obj.popup.getTextInputValue(0);
    if (!obj.query) {
      obj.popup.setError(`Please enter a title/app id.`);
      return true;
    }

    // retrieve the game title from Steam
    if (esgst.as_searchAppId) {
      obj.popup.setProgress(`Retrieving game title...`);
      let title = parseHtml((await request({method: `GET`, url: `https://steamcommunity.com/app/${obj.query}`})).responseText).getElementsByClassName(`apphub_AppName`)[0];
      if (title) {
        obj.query = title.textContent;
      } else {
        obj.button.classList.remove(`esgst-busy`);
        obj.popup.setError(`Game title not found. Make sure you are entering a valid AppID. For example, 229580 is the AppID for Dream (http://steamcommunity.com/app/229580).`);
        return true;
      }
    }
    obj.query = ((obj.query.length >= 50) ? obj.query.slice(0, 50) : obj.query).toLowerCase();
    obj.total = 0;
    obj.requests[0].url = `${location.href.match(/(.+?)(\/search.+?)?$/)[1]}/search?q=${encodeURIComponent(obj.query)}&page=`;
  }

  async function as_request(obj, details, response, responseHtml) {
    obj.popup.setProgress(`Loading page ${details.nextPage}...`);
    obj.popup.setOverallProgress(`${obj.total} giveaways found...`);
    let context = obj.popup.getScrollable();
    let elements = responseHtml.getElementsByClassName(`table__row-outer-wrap`);
    for (let i = 0, n = elements.length; i < n; i++) {
      let element = elements[i];
      if (element.getElementsByClassName(`table__column__heading`)[0].textContent.match(/(.+?)( \(.+ Copies\))?$/)[1].toLowerCase() === obj.query) {
        context.appendChild(element.cloneNode(true));
        obj.total += 1;
      }
    }
    obj.popup.setOverallProgress(`${obj.total} giveaways found...`);
    await endless_load(context);
  }

  // [CDR]

  _MODULES.push({
    description: `
      <ul>
        <li>Shows a popup reminding you of your cake day on SteamGifts.</li>
        <li>You can set it to remind you a specified number of days before your cake day.</li>
      </ul>
    `,
    features: {
      cdr_b: {
        inputItems: [
          {
            id: `cdr_days`,
            prefix: `Days: `
          }
        ],
        name: `Remind you a specified number of days before your cake day.`,
        sg: true
      },
      cdr_d: {
        description: `
          <ul>
            <li>With this option enabled, the feature also reminds you if some days have already passed since your cake day and you had not logged in during that time.</li>
          </ul>
        `,
        name: `Remind you on your cake day.`,
        sg: true
      }
    },
    id: `cdr`,
    load: cdr,
    name: `Cake Day Reminder`,
    sg: true,
    type: `general`
  });

  function cdr() {
    let currentDate = new Date();
    let year = currentDate.getFullYear();
    let time = currentDate.getTime();
    let registrationDate = new Date(esgst.registrationDate * 1e3);
    registrationDate.setFullYear(year);
    registrationDate = registrationDate.getTime();
    if (esgst.cdr_b && parseInt(getLocalValue(`cdr_bYear`, 0)) !== year && time < registrationDate && time + (esgst.cdr_days * 86400000) >= registrationDate) {
      setLocalValue(`cdr_bYear`, year);
      new Popup(`fa-birthday-cake`, `ESGST reminder: your cake day is in ${Math.floor((registrationDate - time) / 86400000)} days.`, true).open();
    } else if (esgst.cdr_d && parseInt(getLocalValue(`cdr_dYear`, 0)) !== year && time >= registrationDate) {
      setLocalValue(`cdr_dYear`, year);
      if (time >= registrationDate + 86400000) {
        new Popup(`fa-birthday-cake`, `ESGST reminder: your cake day was ${Math.floor((time - registrationDate) / 86400000)} days ago.`, true).open();
      } else {
        new Popup(`fa-birthday-cake`, `ESGST reminder: your cake day is today. Happy cake day!`, true).open();
      }
    }
  }

  // [CEC]

  _MODULES.push({
    description: `
      <ul>
        <li>Adds a button (<i class="fa fa-comments"></i> <i class="fa fa-ticket"></i> <i class="fa fa-question-circle"></i>) to the main page heading of any <a href="https://www.steamgifts.com/giveaway/aeqw7/">giveaway</a> page that allows you to view the list (including the number and percentage) of users that commented without entering, users that entered without commenting and users that commented & entered.</li>
        <li>If the giveaway has a link to a discussion, the feature will also check for comments in the discussion.</li>
      </ul>
    `,
    id: `cec`,
    load: cec,
    name: `Comment/Entry Checker`,
    sg: true,
    type: `giveaways`
  });

  function cec() {
    if (!esgst.giveawayPath || !esgst.mainPageHeading) return;

    let obj = {
      button: createHeadingButton({id: `cec`, icons: [`fa-comments`, `fa-ticket`, `fa-question-circle`], title: `Check comments/entries`})
    };
    obj.button.addEventListener(`click`, cec_openPopup.bind(null, obj));
  }

  function cec_openPopup(obj) {
    if (obj.popup) {
      obj.popup.open();
      return;
    }
    obj.popup = new Popup_v2({
      icon: `fa-question`,
      title: `Check Comments/Entries`,
      buttons: [
        {
          color1: `green`,
          color2: `grey`,
          icon1: `fa-arrow-right`,
          icon2: `fa-times`,
          title1: `Check`,
          title2: `Cancel`,
          callback1: cec_start.bind(null, obj),
          callback2: cec_stop.bind(null, obj)
        }
      ],
      addProgress: true,
      addScrollable: true
    });
    obj.popup.open();
    obj.popup.triggerButton(0);
  }

  async function cec_start(obj) {
    obj.isCanceled = false;
    obj.button.classList.add(`esgst-busy`);

    // get comments
    let comments = [];
    let urls = [location.pathname.match(/\/giveaway\/.+?\//)[0]];
    for (let i = 0; !obj.isCanceled && i < urls.length; i++) {
      let nextPage = 1;
      let pagination = null;
      let url = urls[i];
      do {
        obj.popup.setProgress(`Retrieving ${i > 0 ? `bumps ` : `comments `} (page ${nextPage})...</span>`);
        let response = await request({method: `GET`, queue: true, url: `${url}${nextPage}`});
        let responseHtml = parseHtml(response.responseText);
        let elements = responseHtml.querySelectorAll(`.comment:not(.comment--submit) .comment__username:not(.comment__username--op):not(.comment__username--deleted)`);
        for (let j = elements.length - 1; j > -1; j--) {
          comments.push(elements[j].textContent.trim());
        }
        if (nextPage === 1) {
          url = urls[i] = `${response.finalUrl}/search?page=`;
        }
        nextPage += 1;
        pagination = responseHtml.getElementsByClassName(`pagination__navigation`)[0];

        if (i === 0) {
          // get discussion links to check for bump comments
          let elements = responseHtml.querySelectorAll(`.page__description [href*="/discussion/"]`);
          for (let j = elements.length - 1; j > -1; j--) {
            urls.push(elements[j].getAttribute(`href`).match(/\/discussion\/.+?\//)[0]);
          }
        }
      } while (!obj.isCanceled && pagination && !pagination.lastElementChild.classList.contains(`is-selected`));
    }

    if (obj.isCanceled) return;

    // get entries
    let entries = [];
    let nextPage = 1;
    let pagination = null;
    let url = urls[0].replace(/search\?page=/, `entries/search?page=`);
    do {
      obj.popup.setProgress(`Retrieving entries (page ${nextPage})...`);
      let responseHtml = parseHtml((await request({method: `GET`, queue: true, url: `${url}${nextPage}`})).responseText);
      let elements = responseHtml.getElementsByClassName(`table__column__heading`);
      for (let i = elements.length - 1; i > -1; i--) {
        entries.push(elements[i].textContent.trim());
      }
      nextPage += 1;
      pagination = responseHtml.getElementsByClassName(`pagination__navigation`)[0];
    } while (!obj.isCanceled && pagination && !pagination.lastElementChild.classList.contains(`is-selected`));

    if (obj.isCanceled) return;

    obj.popup.removeButton(0);
    obj.button.classList.remove(`esgst-busy`);
    obj.popup.clearProgress();

    // calculate data
    comments = sortArray(Array.from(new Set(comments)));
    entries = sortArray(Array.from(new Set(entries)));
    let both = [];
    let commented = [];
    for (const user of comments) {
      if (entries.indexOf(user) > -1) {
        // user commented and entered
        both.push(`<a href="/user/${user}">${user}</a>`);
      } else {
        // user commented but did not enter
        commented.push(`<a href="/user/${user}">${user}</a>`);
      }
    }
    let entered = [];
    let total = comments.length;
    for (const user of entries) {
      if (comments.indexOf(user) < 0) {
        // user entered but did not comment
        entered.push(`<a href="/user/${user}">${user}</a>`);
        total += 1;
      }
    }
    obj.popup.setScrollable(`
      ${both.length > 0 ? `
        <div>
          <span class="esgst-bold">${both.length} user${both.length > 1 ? `s` : ``} commented and entered (${Math.round(both.length / total * 10000) / 100}%):</span> ${both.join(`, `)}
        </div>
      ` : ``}
      ${commented.length > 0 ? `
        <div>
          <span class="esgst-bold">${commented.length} user${commented.length > 1 ? `s` : ``} commented but did not enter (${Math.round(commented.length / total * 10000) / 100}%):</span> ${commented.join(`, `)}
        </div>
      ` : ``}
      ${entered.length > 0 ? `
        <div>
          <span class="esgst-bold">${entered.length} user${entered.length > 1 ? `s` : ``} entered but did not comment (${Math.round(entered.length / total * 10000) / 100}%):</span> ${entered.join(`, `)}
        </div>
      ` : ``}
    `);
  }

  function cec_stop(obj) {
    obj.button.classList.remove(`esgst-busy`);
    obj.popup.clearProgress();
    obj.isCanceled = true;
  }

  // [CODB]
  
  _MODULES.push({
    description: `
      <ul>
        <li>Adds a button (<i class="fa fa-lock"></i> if the discussion is open and <i class="fa fa-lock esgst-red"></i> if it is closed) next to the title of a discussion created by yourself (in any <a href="https://www.steamgifts.com/discussions">discussions</a> page) that allows you to close/open the discussion without having to access it.</li>
      </ul>
    `,
    id: `codb`,
    name: `Close/Open Discussion Button`,
    sg: true,
    type: `discussions`
  });

  async function codb_close(discussion) {
    let response = await request({data: `xsrf_token=${esgst.xsrfToken}&do=close_discussion`, method: `POST`, url: discussion.url});
    if (parseHtml(response.responseText).getElementsByClassName(`page__heading__button--red`)[0]) {
      discussion.closed = true;
      discussion.innerWrap.classList.add(`is-faded`);
      return true;
    }
    return false;
  }

  async function codb_open(discussion) {
    let response = await request({data: `xsrf_token=${esgst.xsrfToken}&do=reopen_discussion`, method: `POST`, url: discussion.url});
    if (!parseHtml(response.responseText).getElementsByClassName(`page__heading__button--red`)[0]) {
      discussion.closed = false;
      discussion.innerWrap.classList.remove(`is-faded`);
      return true;
    }
    return false;
  }

  // [CR]

  _MODULES.push({
    description: `
      <ul>
        <li>Reverses the comments of any <a href="https://www.steamgifts.com/discussion/e9zDo/">discussion</a> page so that they are ordered from newest to oldest.</li>
      </ul>
    `,
    id: `cr`,
    load: cr,
    name: `Comment Reverser`,
    sg: true,
    st: true,
    type: `comments`
  });

  function cr() {
    if (!esgst.discussionPath || !esgst.pagination) return;
    reverseComments(esgst.pagination.previousElementSibling);
  }

  // [CS]

  _MODULES.push({
    description: `
      <ul>
        <li>Adds a button (<i class="fa fa-comments"></i> <i class="fa fa-search"></i>) to the main page heading of any page that allows you to search for comments made by specific users in the page.</li>
      </ul>
    `,
    id: `cs`,
    name: `Comment Searcher`,
    sg: true,
    st: true,
    type: `comments`
  });

  function cs() {
    if (!esgst.commentsPath || (esgst.giveawayPath && document.getElementsByClassName(`table--summary`)[0])) return;
    new Process({
      headingButton: {
        id: `cs`,
        icons: [`fa-comments`, `fa-search`],
        title: `Search comments from specific users`
      },
      popup: {
        icon: `fa-comments`,
        title: `Search comments from specific users:`,
        textInputs: [
          {
            placeholder: `username1, username2, ...`
          }
        ],
        options: [
          {
            check: true,
            description: `Limit search by pages, from <input class="esgst-switch-input" type="number" min="1" name="cs_minPage" value="${esgst.cs_minPage}"> to <input class="esgst-switch-input" name="cs_maxPage" min="1" type="number" value="${esgst.cs_maxPage}">.`,
            id: `cs_limitPages`,
            tooltip: `If unchecked, all pages will be searched.`
          }
        ],
        addProgress: true,
        addScrollable: `left`
      },
      init: cs_init,
      requests: [
        {
          source: esgst.discussionPath,
          url: esgst.searchUrl,
          request: cs_request
        }
      ]
    });
  }

  function cs_init(obj) {
    obj.usernames = obj.popup.getTextInputValue(0)
      .toLowerCase()
      .replace(/(,\s*)+/g, cs_format)
      .split(`, `);
    let match = location.pathname.match(/^\/(giveaway|discussion|support\/ticket|trade)\/(.+?)\//);
    obj.code = match[2];
    obj.type = match[1];
    obj.title = esgst.originalTitle.replace(/\s-\sPage\s\d+/, ``);
    obj.results = 0;
    if (esgst.cs_limitPages) {
      obj.requests[0].nextPage = esgst.cs_minPage;
      obj.requests[0].maxPage = esgst.cs_maxPage;
    }
  }

  function cs_format(match, p1, offset, string) {
    return (((offset === 0) || (offset === (string.length - match.length))) ? `` : `, `);
  }

  async function cs_request(obj, details, response, responseHtml) {
    obj.popup.setProgress(`Searching comments (page ${details.nextPage}${details.maxPage ? ` of ${details.maxPage}` : details.lastPage})..`);
    obj.popup.setOverallProgress(`${obj.results} results found.`);
    let comments = responseHtml.getElementsByClassName(`comments`);
    let elements = (comments[1] || comments[0]).querySelectorAll(`.comment:not(.comment--submit), .comment_outer`);
    let context = obj.popup.getScrollable();
    for (let i = 0, n = elements.length; i < n; i++) {
      let element = elements[i];
      if (esgst.sg) {
        element.firstElementChild.classList.remove(`comment__parent`);
        element.firstElementChild.classList.add(`comment__child`);
      }
      let parent = element.parentElement.closest(`.comment, .comment_outer`);
      element = element.cloneNode(true);
      element.lastElementChild.innerHTML = ``;
      let html = `
        <div class="comment comments comment_outer">
      `;
      if (parent) {
        parent = parent.cloneNode(true);
        parent.lastElementChild.remove();
        parent.insertAdjacentHTML(`beforeEnd`, `
          <div class="comment__children comment_children">${element.outerHTML}</div>
        `);
        html += parent.outerHTML;
      } else {
        if (esgst.st) {
          element.getElementsByClassName(`action_list`)[0].firstElementChild.insertAdjacentHTML(`afterEnd`, `
            <a href="/${obj.type}/${obj.code}/">${obj.title} - Page ${details.nextPage}</a>
          `);
        }
        html += esgst.sg ? `
          <div class="comments__entity">
            <p class="comments__entity__name">
              <a href="/${obj.type}/${obj.code}/">${obj.title} - Page ${details.nextPage}</a>
            </p>
          </div>` : ``;
        html += `
          <div class="comment__children comment_children">${element.outerHTML}</div>
        `;
      }
      html += `
        </div>
      `;
      if (obj.usernames.indexOf(element.querySelector(`.comment__username, .author_name`).textContent.trim().toLowerCase()) > -1) {
        context.insertAdjacentHTML(`beforeEnd`, html);
        obj.results += 1;
      }
    }
    obj.popup.setOverallProgress(`${obj.results} results found.`);
    await endless_load(context);
  }

  // [CT]

  _MODULES.push({
    description: `
      <ul>
        <li>Keeps track of any comments (in any page) and fades out comments that you have marked as read so that you can easily see which comments you have read/unread in the page.</li>
        <li>Comments made by yourself are automatically marked as read.</li>
        <li>The comments are tracked by saving the date when they were made. If a comment is edited then the date when it was last edited is saved instead, so if you had previously marked a comment as read and that comment was edited, it will now appear as unread.</li>
        <li>Adds a panel to the "Comments" column of any <a href="https://www.steamgifts.com/discussions">discussions</a>/<a href="https://www.steamgifts.com/support/tickets">tickets</a>/<a href="https://www.steamtrades.com/trades">trades</a> pages and to the main page heading of any page containing:</li>
        <ul>
          <li>A red number in parenthesis indicating how many unread comments there are in the thread.</li>
          <li>A button (<i class="fa fa-comments"></i>) that allows you to go to the first unread comment of the thread/page.</li>
          <li>A button (<i class="fa fa-eye"></i>) that allows you to mark every comment in the thread/page as read.</li>
          <li>A button (<i class="fa fa-eye-slash"></i>) that allows you to mark every comment in the thread/page as unread.</li>
        </ul>
        <li>Adds a panel next a comment's "Permalink" (in any page) containing:</li>
        <ul>
          <li>A button (<i class="fa fa-eye"></i>) that allows you to mark the comment as read.</li>
          <li>A button (<i class="fa fa-eye-slash"></i>) that allows you to mark the comment as unread.</li>
          <li>A button (<i class="fa fa-eye"></i> <i class="fa fa-angle-double-right"></i>) that allows you to mark the comment as read and go to the next unread comment.</li>
          <li>A button (<i class="fa fa-eye"></i> <i class="fa fa-angle-up"></i>) that allows you to mark every comment from the comment upward as read.</li>
          <li>A button (<i class="fa fa-eye-slash"></i> <i class="fa fa-angle-up"></i>) that allows you to mark every comment from the comment upward as unread.</li>
        </ul>
      </ul>
    `,
    features: {
      ct_a: {
        name: `Automatically mark comments as read in the inbox page when clicking on the "Mark as Read" button.`,
        sg: true,
        st: true
      },
      ct_o: {
        name: `Automatically mark your own comments as read.`,
        sg: true,
        st: true
      },
      ct_c: {
        name: `Enable tracking controls for your own comments.`,
        sg: true,
        st: true
      },
      ct_s: {
        description: `
          <ul>
            <li>The simplified version of the tracker does not have the concept of read/unread comments, but simply shows the red number of comments that were made since you last visited a thread, so the comments are not tracked by date (they are tracked by quantity) and there are no buttons to go to the first unread comment of a thread/page or mark comments as read/unread.</li>
            <li>If you mark a thread as visited with [id=gdttt], all of the comments in the thread will be considered as "read", and if you mark it as unvisited, they will be considered as "unread".</li>
          </ul>
        `,
        features: {
          ct_s_h: {
            description: `
              <ul>
                <li>Only shows the red number for a thread after you have visited it.</li>
              </ul>
            `,
            name: `Hide the counter if you have not visited the thread yet.`,
            sg: true,
            st: true
          }
        },
        name: `Enable the simplified version.`,
        sg: true,
        st: true
      },
      ct_f: {
        name: `Fade out read comments.`,
        sg: true,
        st: true
      },
      ct_r: {
        description: `
          <ul>
            <li>Searches pages for an unread comment from the bottom to the top if [id=cr] is disabled or from the top to the bottom if it is enabled.</li>
          </ul>
        `,
        name: `Search for the first unread comment in reverse order.`,
        sg: true,
        st: true
      }
    },
    id: `ct`,
    load: ct,
    name: `Comment Tracker`,
    sg: true,
    st: true,
    type: `comments`
  });

  async function ct() {
    if (((esgst.commentsPath && (!esgst.giveawayPath || !document.getElementsByClassName(`table--summary`)[0])) || esgst.inboxPath) && !esgst.ct_s) {
      if (!esgst.ct_s) {
        let button3 = createHeadingButton({featureId: `ct`, id: `ctUnread`, icons: [`fa-eye-slash`], title: `Mark all comments in this page as unread`});
        let button2 = createHeadingButton({featureId: `ct`, id: `ctRead`, icons: [`fa-eye`], title: `Mark all comments in this page as read`});
        let button1 = createHeadingButton({featureId: `ct`, id: `ctGo`, icons: [`fa-comments-o`], title: `Go to the first unread comment of this page`});
        ct_addCommentPanel(button1, button2, button3);
      }
      let match = location.pathname.match(/\/(giveaway|discussion|ticket|trade)\/(.+?)\//);
      if (match) {
        let code, count, diff, comments, element, type;
        element = esgst.mainPageHeading.querySelector(`.page__heading__breadcrumbs, .page_heading_breadcrumbs`).firstElementChild;
        type = `${match[1]}s`;
        code = match[2];
        comments = JSON.parse(await getValue(type));
        count = parseInt(element.textContent.replace(/,/g, ``).match(/\d+/)[0]);
        if (comments[code]) {
          let id, read;
          if (esgst.ct_s) {
            read = comments[code].count || (esgst.ct_s_h ? count : 0);
          } else {
            read = 0;
            for (id in comments[code].readComments) {
              if (!id.match(/^(Count|undefined|)$/) && comments[code].readComments[id]) {
                ++read;
              }
            }
          }
          diff = count === read ? 0 : count - read;
        } else if (esgst.ct_s && esgst.ct_s_h) {
          diff = 0;
        } else {
          diff = count;
        }
        element.insertAdjacentHTML(`beforeEnd`, ` <span class="esgst-ct-count" title="${getFeatureTooltip(`ct`, `Unread comments`)}">(+${diff})</span>`);
      }
    }
  }

  async function ct_addDiscussionPanels(context, main, source, endless, dh) {
    let code, comments, count, countLink, diff, heading, i, id, j, match, matches, n, read, url, key;
    matches = context.querySelectorAll(`${endless ? `.esgst-es-page-${endless} .table__row-outer-wrap, .esgst-es-page-${endless}.table__row-outer-wrap` : `.table__row-outer-wrap`}, ${endless ? `.esgst-es-page-${endless} .row_outer_wrap, .esgst-es-page-${endless}.row_outer_wrap` : `.row_outer_wrap`}`);
    if (!matches.length) return;
    if (esgst.discussionsPath || dh) {
      key = `discussions`;
    } else if (esgst.ticketsPath) {
      key = `tickets`;
    } else if (esgst.tradesPath) {
      key = `trades`;
    } else {
      key = `discussions`;
    }
    comments = JSON.parse(await getValue(key, `{}`));
    for (i = 0, n = matches.length; i < n; ++i) {
      match = matches[i];
      countLink = match.querySelector(`.table__column__secondary-link[href*="/discussion/"], .table__column--width-small.text-center, .column_small.text_center`);
      if (countLink) {
        count = parseInt(countLink.textContent.replace(/,/g, ``));
        heading = match.querySelector(`.homepage_table_column_heading, .table__column__heading, .column_flex h3 a`);
        url = heading.getAttribute(`href`);
        if (url) {
          code = url.match(new RegExp(`/${key.slice(0, -1)}/(.+?)(/.*)?$`));
          if (code) {
            code = code[1];
            if (esgst.ust && key === `tickets` && (!comments[code] || !comments[code].sent) && match.getElementsByClassName(`table__column__secondary-link`)[0].textContent.trim().match(/Request\sNew\sWinner|User\sReport/)) {
              ust_addCheckbox(code, match);
            }
            if (esgst.gdttt || esgst.ct) {
              if (comments[code]) {
                if (esgst.ct_s) {
                  read = comments[code].count || (esgst.ct_s_h ? count : 0);
                } else {
                  read = 0;
                  for (id in comments[code].readComments) {
                    if (!id.match(/^(Count|undefined|)$/) && comments[code].readComments[id]) {
                      ++read;
                    }
                  }
                }
                diff = count === read ? 0 : count - read;
              } else if (esgst.ct_s && esgst.ct_s_h) {
                diff = 0;
              } else {
                diff = count;
              }
              let discussion = null;
              for (j = esgst.mainDiscussions.length - 1; j > -1 && esgst.mainDiscussions[j].code !== code; --j);
                if (j > -1) {
                discussion = esgst.mainDiscussions[j];
                }
              if (key === `discussions` && diff > 0 && discussion) {
                discussion.unread = true;
              }
              ct_addDiscussionPanel(code, comments, match, countLink, count, diff, url, key, dh, discussion);
            }
          }
        }
      }
    }
    if (esgst.df && esgst.df.filteredCount && esgst[`df_enable${esgst.df.type}`]) {
      filters_filter(esgst.df, false, endless);
    }
    if (esgst.ustButton) {
      if (esgst.numUstTickets > 0) {
        esgst.ustButton.classList.remove(`esgst-hidden`);
      } else {
        esgst.ustButton.classList.add(`esgst-hidden`);
      }
    }
  }

  async function ct_getComments(count, comments, index, goToUnread, markRead, markUnread, endless) {
    let found = false;
    if (goToUnread) {
      found = await ct_checkComments(count, comments, index, true, false, false, endless);
    } else {
      let deleteLock;
      if (!endless) {
        deleteLock = await createLock(`commentLock`, 300);
      }
      found = await ct_checkComments(count, comments, index, false, markRead, markUnread, endless);
      if (deleteLock) {
        deleteLock();
      }
    }
    return found;
  }

  async function ct_checkComments(count, comments, index, goToUnread, markRead, markUnread, endless) {
    let code, comment, found, i, n, saved, source, type, unread;
    esgst.ctGoToUnread = false;
    let values;
    if (endless) {
      if (esgst.sg) {
        saved = {
          giveaways: esgst.giveaways,
          discussions: esgst.discussions,
          tickets: esgst.tickets
        };
      } else {
        saved = {
          trades: esgst.trades
        };
      }
    } else {
      values = await getValues({
        giveaways: `{}`,
        discussions: `{}`,
        tickets: `{}`,
        trades: `{}`
      });
      if (esgst.sg) {
        saved = {
          giveaways: JSON.parse(values.giveaways),
          discussions: JSON.parse(values.discussions),
          tickets: JSON.parse(values.tickets)
        };
      } else {
        saved = {
          trades: JSON.parse(values.trades)
        };
      }
    }
    n = comments.length;
    found = false;
    if (n > 0) {
      for (i = index || 0; i < n; ++i) {
        comment = comments[i];
        if (comment.id || comment.id.match(/^$/)) {
          if (!saved[comment.type][comment.code]) {
            saved[comment.type][comment.code] = {
              readComments: {}
            };
          } else if (!saved[comment.type][comment.code].readComments) {
            saved[comment.type][comment.code].readComments = {};
          }
          if (count > 0) {
            saved[comment.type][comment.code].count = count;
          }
          if (esgst.gdttt && esgst[`gdttt_v${{
            giveaways: `g`,
            discussions: `d`,
            tickets: `t`,
            trades: `ts`
          }[comment.type]}`]) {
            saved[comment.type][comment.code].visited = true;
            let cache = JSON.parse(getLocalValue(`gdtttCache`, `{"giveaways":[],"discussions":[],"tickets":[],"trades":[]}`));
            if (cache[comment.type].indexOf(comment.code) < 0) {
              cache[comment.type].push(comment.code);
              setLocalValue(`gdtttCache`, JSON.stringify(cache));
            }
          }
          saved[comment.type][comment.code].lastUsed = Date.now();
          esgst.edited[comment.type] = true;
          if (!esgst.ct_s) {
            let buttons = comment.comment.getElementsByClassName(`esgst-ct-comment-button`);
            if (comment.author === esgst.username) {
              if (esgst.ct_c) {
                if (!saved[comment.type][comment.code].readComments[comment.id] || comment.timestamp !== saved[comment.type][comment.code].readComments[comment.id]) {
                  if (markRead) {
                    ct_markCommentRead(comment, saved);
                    ct_addUnreadCommentButton(buttons[0], comment);
                  } else {
                    ct_markCommentUnread(comment, saved);
                    ct_addReadCommentButton(buttons[0], comment);
                  }
                } else {
                  if (markUnread) {
                    ct_markCommentUnread(comment, saved);
                    ct_addReadCommentButton(buttons[0], comment);
                  } else {
                    ct_markCommentRead(comment, saved);
                    ct_addUnreadCommentButton(buttons[0], comment);
                  }
                }
                ct_addReadUntilHereButton(buttons[1], comment);
                ct_addUnreadUntilHereButton(buttons[2], comment);
              }
              if (esgst.ct_o) {
                ct_markCommentRead(comment, saved);
                if (esgst.ct_c) {
                  ct_addUnreadCommentButton(buttons[0], comment);
                }
              }
            } else if (!saved[comment.type][comment.code].readComments[comment.id] || comment.timestamp !== saved[comment.type][comment.code].readComments[comment.id]) {
              if (goToUnread && (!esgst.ctGoToUnread || ((((esgst.ct_r && !esgst.cr) || (!esgst.ct_r && esgst.cr)) && comment.comment.offsetTop <  scrollY + esgst.commentsTop) || (((!esgst.ct_r && !esgst.cr) || (esgst.ct_r && esgst.cr)) && comment.comment.offsetTop >  scrollY + esgst.commentsTop)))) {
                esgst.ctGoToUnread = true;
                if ((esgst.discussionPath && ((!esgst.ct_r && !esgst.cr) || (esgst.ct_r && esgst.cr))) || (!esgst.discussionPath && !esgst.ct_r)) {
                  unread = comment;
                  found = true;
                } else {
                  if (esgst.discussionsPath) {
                    esgst.ctUnreadFound = true;
                    if (!esgst.ctNewTab && esgst.sto) {
                      if (comment.id) {
                        location.href = `/go/comment/${comment.id}`;
                      } else {
                        location.href = `/discussion/${comment.code}/`;
                      }
                    } else {
                      if (comment.id) {
                        open(`/go/comment/${comment.id}`);
                      } else {
                        open(`/discussion/${comment.code}/`);
                      }
                    }
                  } else {
                    goToComment(comment.id, comment.comment);
                  }
                  found = true;
                  break;
                }
              } else {
                if (markRead) {
                  ct_markCommentRead(comment, saved);
                  ct_addUnreadCommentButton(buttons[0], comment);
                } else {
                  ct_markCommentUnread(comment, saved);
                  ct_addReadCommentButton(buttons[0], comment);
                }
                ct_addReadUntilHereButton(buttons[1], comment);
                ct_addUnreadUntilHereButton(buttons[2], comment);
              }
            } else {
              if (markUnread) {
                ct_markCommentUnread(comment, saved);
                ct_addReadCommentButton(buttons[0], comment);
              } else {
                ct_markCommentRead(comment, saved);
                ct_addUnreadCommentButton(buttons[0], comment);
              }
              ct_addReadUntilHereButton(buttons[1], comment);
              ct_addUnreadUntilHereButton(buttons[2], comment);
            }
          }
        }
      }
      if (!esgst.ct_s && goToUnread) {
        if (unread) {
          if (esgst.discussionsPath) {
            esgst.ctUnreadFound = true;
            if (!esgst.ctNewTab && esgst.sto) {
              if (unread.id) {
                location.href = `/go/comment/${unread.id}`;
              } else {
                location.href = `/discussion/${unread.code}/`;
              }
            } else {
              if (unread.id) {
                open(`/go/comment/${unread.id}`);
              } else {
                open(`/discussion/${unread.code}/`);
              }
            }
          } else {
            goToComment(unread.id, unread.comment);
          }
        }
      } else if (!endless) {
        if (esgst.sg) {
          await setValues({
            giveaways: JSON.stringify(saved.giveaways),
            discussions: JSON.stringify(saved.discussions),
            tickets: JSON.stringify(saved.tickets)
          });
        } else {
          await setValue(`trades`, JSON.stringify(saved.trades));
        }
      }
    } else {
      source = location.pathname.match(/(giveaway|discussion|trade|ticket)\/(.+?)(\/.*)?$/);
      if (source) {
        type = `${source[1]}s`;
        code = source[2];
        if (!saved[type][code]) {
          saved[type][code] = {
            readComments: {},
            visited: true
          };
        }
        if (count > 0) {
          saved[type][code].count = count;
        }
        saved[type][code].lastUsed = Date.now();
        esgst.edited[type] = true;
        if (!endless) {
          if (esgst.sg) {
            await setValues({
              giveaways: JSON.stringify(saved.giveaways),
              discussions: JSON.stringify(saved.discussions),
              tickets: JSON.stringify(saved.tickets)
            });
          } else {
            await setValue(`trades`, JSON.stringify(saved.trades));
          }
        }
      }
    }
    return found;
  }

  async function ct_markCommentRead(comment, comments, save) {
    let count;
    if (save) {
      let deleteLock = await createLock(`commentLock`, 300);
      comments = JSON.parse(await getValue(comment.type));
      if (comment.id && !comments[comment.code].readComments[comment.id] && esgst.commentsPath) {
        count = document.getElementsByClassName(`esgst-ct-count`)[0];
        count.textContent = ` (+${parseInt(count.textContent.match(/\d+/)[0]) - 1})`;
      }
      comments[comment.code].readComments[comment.id] = comment.timestamp;
      await setValue(comment.type, JSON.stringify(comments));
      deleteLock();
      if (esgst.ct_f) {
        comment.comment.classList.add(`esgst-ct-comment-read`);
        comment.comment.style.opacity = `0.5`;
        setHoverOpacity(comment.comment, `1`, `0.5`);
      }
    } else {
      if (comments) {
        if (comment.id && !comments[comment.type][comment.code].readComments[comment.id] && esgst.commentsPath) {
          count = document.getElementsByClassName(`esgst-ct-count`)[0];
          count.textContent = ` (+${parseInt(count.textContent.match(/\d+/)[0]) - 1})`;
        }
        comments[comment.type][comment.code].readComments[comment.id] = comment.timestamp;
      }
      if (esgst.ct_f) {
        comment.comment.classList.add(`esgst-ct-comment-read`);
        comment.comment.style.opacity = `0.5`;
        setHoverOpacity(comment.comment, `1`, `0.5`);
      }
    }
  }

  async function ct_markCommentUnread(comment, comments, save) {
    let count;
    if (save) {
      let deleteLock = await createLock(`commentLock`, 300);
      comments = JSON.parse(await getValue(comment.type));
      if (comments[comment.code].readComments[comment.id]) {
        delete comments[comment.code].readComments[comment.id];
        if (comment.id && esgst.commentsPath) {
          count = document.getElementsByClassName(`esgst-ct-count`)[0];
          count.textContent = ` (+${parseInt(count.textContent.match(/\d+/)[0]) + 1})`;
        }
      }
      await setValue(comment.type, JSON.stringify(comments));
      deleteLock();
      if (esgst.ct_f) {
        comment.comment.classList.remove(`esgst-ct-comment-read`);
        comment.comment.style.opacity = `1`;
        setHoverOpacity(comment.comment, `1`, `1`);
      }
    } else {
      if (comments && comments[comment.type][comment.code].readComments[comment.id]) {
        if (comment.id && esgst.commentsPath) {
          count = document.getElementsByClassName(`esgst-ct-count`)[0];
          count.textContent = ` (+${parseInt(count.textContent.match(/\d+/)[0]) + 1})`;
        }
        delete comments[comment.type][comment.code].readComments[comment.id];
      }
      if (esgst.ct_f) {
        comment.comment.classList.remove(`esgst-ct-comment-read`);
        comment.comment.style.opacity = `1`;
        setHoverOpacity(comment.comment, `1`, `1`);
      }
    }
  }

  function ct_addReadUntilHereButton(button, comment) {
    if (!button) {
      button = insertHtml(comment.actions, `beforeEnd`, `<div class="esgst-ct-comment-button" title="${getFeatureTooltip(`ct`, `Mark all comments from this comment upwards as read`)}"></div>`);
    }
    button.innerHTML = `
      <span>
        <i class="fa fa-eye"></i>
        <i class="fa fa-angle-up"></i>
      </span>
    `;
    button.firstElementChild.addEventListener(`click`, ct_readUntilHere.bind(null, button, comment));
  }

  async function ct_readUntilHere(button, comment) {
    button.innerHTML = `<i class="fa fa-circle-o-notch fa-spin"></i>`;
    await ct_getComments(0, esgst.mainComments, comment.index, false, true, false);
    ct_addReadUntilHereButton(button, comment);
  }

  function ct_addUnreadUntilHereButton(button, comment) {
    if (!button) {
      button = insertHtml(comment.actions, `beforeEnd`, `<div class="esgst-ct-comment-button" title="${getFeatureTooltip(`ct`, `Mark all comments from this comment upwards as unread`)}"></div>`);
    }
    button.innerHTML = `
      <span>
        <i class="fa fa-eye-slash"></i>
        <i class="fa fa-angle-up"></i>
      </span>
    `;
    button.firstElementChild.addEventListener(`click`, ct_unreadUntilHere.bind(null, button, comment));
  }

  async function ct_unreadUntilHere(button, comment) {
    button.innerHTML = `<i class="fa fa-circle-o-notch fa-spin"></i>`;
    await ct_getComments(0, esgst.mainComments, comment.index, false, false, true);
    ct_addUnreadUntilHereButton(button, comment);
  }

  function ct_addReadCommentButton(button, comment) {
    if (!button) {
      button = insertHtml(comment.actions, `beforeEnd`, `<div class="esgst-ct-comment-button"></div>`);
    }
    button.innerHTML = `
      <i class="fa fa-eye" title="${getFeatureTooltip(`ct`, `Mark this comment as read`)}"></i>
      <span title="${getFeatureTooltip(`ct`, `Mark this comment as read and go to the next unread comment`)}">
        <i class="fa fa-eye"></i>
        <i class="fa fa-angle-double-right"></i>
      </span>
    `;
    button.firstElementChild.addEventListener(`click`, ct_readComment.bind(null, button, comment));
    button.lastElementChild.addEventListener(`click`, ct_readCommentAndGo.bind(null, button, comment));
  }

  async function ct_readComment(button, comment) {
    button.innerHTML = `<i class="fa fa-circle-o-notch fa-spin"></i>`;
    await ct_markCommentRead(comment, null, true);
    button.innerHTML = ``;
    ct_addUnreadCommentButton(button, comment);
  }

  async function ct_readCommentAndGo(button, comment) {
    button.innerHTML = `<i class="fa fa-circle-o-notch fa-spin"></i>`;
    await ct_markCommentRead(comment, null, true);
    button.innerHTML = ``;
    ct_addUnreadCommentButton(button, comment);
    ct_getComments(0, esgst.mainComments, null, true);
  }

  function ct_addUnreadCommentButton(button, comment) {
    if (!button) {
      button = insertHtml(comment.actions, `beforeEnd`, `<div class="esgst-ct-comment-button"></div>`);
    }
    button.innerHTML = `<i class="fa fa-eye-slash" title="${getFeatureTooltip(`ct`, `Mark comment as unread`)}">`;
    button.firstElementChild.addEventListener(`click`, ct_unreadComment.bind(null, button, comment));
  }

  async function ct_unreadComment(button, comment) {
    button.innerHTML = `<i class="fa fa-circle-o-notch fa-spin"></i>`;
    await ct_markCommentUnread(comment, null, true);
    button.innerHTML = ``;
    ct_addReadCommentButton(button, comment);
  }

  function ct_addCommentPanel(goToUnread, markRead, markUnread) {
    let button, key, newButton, url;
    goToUnread.addEventListener(`click`, ct_goToUnread.bind(null, goToUnread));
    markRead.addEventListener(`click`, ct_markCommentsRead.bind(null, markRead));
    markUnread.addEventListener(`click`, ct_markCommentsUnread.bind(null, markUnread));
    if (esgst.ct_a && esgst.inboxPath) {
      button = document.querySelector(`.js__submit-form, .js_mark_as_read`);
      if (button) {
        if (esgst.sg) {
          newButton = insertHtml(button, `afterEnd`, `
            <div class="sidebar__action-button">
              <i class="fa fa-check-circle"></i> Mark as Read
            </div>
          `);
          key = `read_messages`;
          url = `/messages`;
        } else {
          newButton = insertHtml(button, `afterEnd`, `
            <a class="page_heading_btn green">
              <i class="fa fa-check-square-o"></i>
              <span>Mark as Read</span>
            </a>
          `);
          key = `mark_as_read`;
          url = `/ajax.php`;
        }
        button.remove();
        newButton.addEventListener(`click`, ct_markMessagesRead.bind(null, key, markRead, url));
      }
    }
  }

  async function ct_markMessagesRead(key, markRead, url, event) {
    await request({data: `xsrf_token=${esgst.xsrfToken}&do=${key}`, method: `POST`, url});
    await ct_markCommentsRead(markRead);
    ct_completeInboxRead(event.currentTarget);
  }

  function ct_completeInboxRead(newButton) {
    let elements, i, n;
    elements = document.querySelectorAll(`.comment__envelope, .comment_unread`);
    for (i = 0, n = elements.length; i < n; ++i) {
      elements[i].remove();
    }
    newButton.remove();
  }

  async function ct_goToUnread(goToUnread) {
    goToUnread.innerHTML = `
      <i class="fa fa-circle-o-notch fa-spin"></i>
    `;
    const found = await ct_getComments(0, esgst.mainComments, null, true, false, false);
    goToUnread.innerHTML = `
      <i class="fa fa-comments-o"></i>
    `;
    if (!found) {
      createAlert(`No unread comments were found.`);
    }
  }

  async function ct_markCommentsRead(markRead) {
    markRead.innerHTML = `
      <i class="fa fa-circle-o-notch fa-spin"></i>
    `;
    await ct_getComments(0, esgst.mainComments, null, false, true, false);
    markRead.innerHTML = `
      <i class="fa fa-eye"></i>
    `;
  }

  async function ct_markCommentsUnread(markUnread) {
    markUnread.innerHTML = `
      <i class="fa fa-circle-o-notch fa-spin"></i>
    `;
    await ct_getComments(0, esgst.mainComments, null, false, false, true);
    markUnread.innerHTML = `
      <i class="fa fa-eye-slash"></i>
    `;
  }

  function ct_addDiscussionPanel(code, comments, container, context, count, diff, url, type, dh, discussion) {
    const obj = {
      code,
      count,
      diff,
      panel: insertHtml(context, esgst.giveawaysPath && !esgst.oadd ? `afterEnd` : `beforeEnd`, `
        <span>
          <span class="esgst-ct-count esgst-hidden" title="${getFeatureTooltip(`ct`)}">(+${diff})</span>
          <div class="esgst-heading-button esgst-hidden" title="${getFeatureTooltip(`ct`, `Go to first unread comment of this discussion`)}">
            <i class="fa fa-comments-o"></i>
          </div>
          <div class="esgst-heading-button esgst-hidden" title="${getFeatureTooltip(`ct`, `Mark all comments in this discussion as read`)}">
            <i class="fa fa-eye"></i>
          </div>
          <div class="esgst-heading-button esgst-hidden" title="${getFeatureTooltip(`ct`, `Mark all comments in this discussion as unread`)}">
            <i class="fa fa-eye-slash"></i>
          </div>
          <div class="esgst-heading-button esgst-hidden" title="${getFeatureTooltip(`ct`, `Clean discussion (remove deleted comments from the database)`)}">
            <i class="fa fa-paint-brush"></i>
          </div>
          <i class="fa fa-circle-o-notch fa-spin esgst-hidden"></i>
        </span>
      `),
      url
    };
    obj.diffContainer = obj.panel.firstElementChild;
    obj.goToUnread = obj.diffContainer.nextElementSibling;
    obj.markRead = obj.goToUnread.nextElementSibling;
    obj.markUnread = obj.markRead.nextElementSibling;
    obj.clean = obj.markUnread.nextElementSibling;
    obj.loadingIcon = obj.clean.nextElementSibling;
    if (esgst.gdttt) {
      const button = new Button(obj.panel, `beforeEnd`, {
        callbacks: [gdttt_markVisited.bind(null, code, container, count, obj.diffContainer, type), null, gdttt_markUnvisited.bind(null, code, container, count, obj.diffContainer, type), null],
        className: `esgst-gdttt-button`,
        icons: [`fa-check esgst-clickable`, `fa-circle-o-notch fa-spin`, `fa-times esgst-clickable`, `fa-circle-o-notch fa-spin`],
        id: `gdttt`,
        index: !comments[code] || !comments[code].visited ? 0 : 2,
        titles: [`Mark discussion as visited`, `Marking...`, `Mark discussion as unvisited`, `Marking...`]
      });
      if (discussion) {
        discussion.gdtttButton = button;
        discussion.count = count;
      }
    }
    if (esgst.ct && (esgst.giveawaysPath || esgst.discussionsPath || dh)) {
      if (esgst.ct_s) {
        if (diff > 0) {
          obj.diffContainer.classList.remove(`esgst-hidden`);
        }
      } else {
        if (diff > 0) {
          obj.diffContainer.classList.remove(`esgst-hidden`);
          obj.goToUnread.classList.remove(`esgst-hidden`);
          obj.markRead.classList.remove(`esgst-hidden`);
          if (diff !== count) {
            obj.markUnread.classList.remove(`esgst-hidden`);
          }
        } else {
          obj.markUnread.classList.remove(`esgst-hidden`);
        }
        obj.clean.classList.remove(`esgst-hidden`);
      }
    }
    obj.goToUnread.addEventListener(`mousedown`, ct_goToUnreadPanel.bind(null, obj));
    obj.markRead.addEventListener(`click`, ct_markReadPanel.bind(null, obj));
    obj.markUnread.addEventListener(`click`, ct_markUnreadPanel.bind(null, obj));
    obj.clean.addEventListener(`click`, ct_clean.bind(null, obj));
  }

  async function ct_clean(obj, event) {
    obj.clean.classList.add(`esgst-hidden`);
    obj.goToUnread.classList.add(`esgst-hidden`);
    obj.markRead.classList.add(`esgst-hidden`);
    obj.markUnread.classList.add(`esgst-hidden`);
    obj.loadingIcon.classList.remove(`esgst-hidden`);
    await ct_markCommentsReadUnread(false, false, false, obj.code, `${obj.url}/search?page=`);
    obj.loadingIcon.classList.add(`esgst-hidden`);
    obj.goToUnread.classList.remove(`esgst-hidden`);
    obj.markRead.classList.remove(`esgst-hidden`);
    obj.clean.classList.remove(`esgst-hidden`);
    if (obj.diff !== obj.count) {
      obj.markUnread.classList.remove(`esgst-hidden`);
    }
  }

  async function ct_goToUnreadPanel(obj, event) {
    esgst.ctNewTab = false;
    if (event.button === 1) {
      event.preventDefault();
      esgst.ctNewTab = true;
    } else if (event.button === 2) {
      return;
    }
    obj.clean.classList.add(`esgst-hidden`);
    obj.goToUnread.classList.add(`esgst-hidden`);
    obj.markRead.classList.add(`esgst-hidden`);
    obj.markUnread.classList.add(`esgst-hidden`);
    obj.loadingIcon.classList.remove(`esgst-hidden`);
    esgst.ctUnreadFound = false;
    await ct_markCommentsReadUnread(true, false, false, null, `${obj.url}/search?page=`);
    obj.loadingIcon.classList.add(`esgst-hidden`);
    obj.goToUnread.classList.remove(`esgst-hidden`);
    obj.markRead.classList.remove(`esgst-hidden`);
    obj.clean.classList.remove(`esgst-hidden`);
    if (obj.diff !== obj.count) {
      obj.markUnread.classList.remove(`esgst-hidden`);
    }
  }

  async function ct_markReadPanel(obj) {
    obj.clean.classList.add(`esgst-hidden`);
    obj.goToUnread.classList.add(`esgst-hidden`);
    obj.markRead.classList.add(`esgst-hidden`);
    obj.markUnread.classList.add(`esgst-hidden`);
    obj.loadingIcon.classList.remove(`esgst-hidden`);
    await ct_markCommentsReadUnread(false, true, false, null, `${obj.url}/search?page=`);
    obj.loadingIcon.classList.add(`esgst-hidden`);
    obj.diffContainer.classList.add(`esgst-hidden`);
    obj.markUnread.classList.remove(`esgst-hidden`);
    obj.clean.classList.remove(`esgst-hidden`);
  }

  async function ct_markUnreadPanel(obj) {
    obj.clean.classList.add(`esgst-hidden`);
    obj.goToUnread.classList.add(`esgst-hidden`);
    obj.markRead.classList.add(`esgst-hidden`);
    obj.markUnread.classList.add(`esgst-hidden`);
    obj.loadingIcon.classList.remove(`esgst-hidden`);
    const deleteLock = await createLock(`commentLock`, 300);
    const comments = JSON.parse(await getValue(`discussions`));
    for (const key in comments[obj.code].readComments) {
      delete comments[obj.code].readComments[key];
    }
    comments[obj.code].lastUsed = Date.now();
    await setValue(`discussions`, JSON.stringify(comments));
    deleteLock();
    obj.loadingIcon.classList.add(`esgst-hidden`);
    obj.diffContainer.classList.remove(`esgst-hidden`);
    obj.diffContainer.textContent = `(+${obj.count})`;
    obj.goToUnread.classList.remove(`esgst-hidden`);
    obj.markRead.classList.remove(`esgst-hidden`);
    obj.clean.classList.remove(`esgst-hidden`);
  }

  async function ct_markCommentsReadUnread(goToUnread, markRead, markUnread, code, url) {
    let firstRun = true;
    let lastPageMissing = false;
    let nextPage = 1;
    let comments = [];
    let discussion = null;
    if (code) {
      discussion = JSON.parse(await getValue(`discussions`))[code];
      if (!discussion || !discussion.readComments) {
        return;
      }
    }
    while (true) {
      const context = parseHtml((await request({
        method: `GET`,
        queue: true,
        url: `${url}${nextPage}`
      })).responseText);
      if (code) {
        const elements = context.querySelectorAll(`[href*="/go/comment/"]`);
        for (const element of elements) {
          comments.push(element.getAttribute(`href`).match(/\/go\/comment\/(.+)/)[1]);
        }
      } else {
        await ct_getComments(0, await comments_get(context, context, true), null, goToUnread, markRead, markUnread);
      }

      if (goToUnread && esgst.ctUnreadFound) break;

      nextPage += 1;
      const pagination = context.getElementsByClassName(`pagination__navigation`)[0];

      if (!pagination || ((!goToUnread || ((!esgst.ct_r || nextPage <= 1) && (esgst.ct_r || pagination.lastElementChild.classList.contains(`is-selected`)))) && (goToUnread || pagination.lastElementChild.classList.contains(`is-selected`)))) break;

      if (!goToUnread || !esgst.ct_r) continue;

      if (firstRun) {
        firstRun = !firstRun;
        const lastLink = pagination.lastElementChild;
        if (lastLink.textContent.match(/Last/)) {
          nextPage = parseInt(lastLink.getAttribute(`data-page-number`));
        } else {
          nextPage = 999999999;
          lastPageMissing = true;
        }
      } else {
        if (lastPageMissing) {
          nextPage = parseInt(pagination.lastElementChild.getAttribute(`data-page-number`)) - 1;
        } else {
          nextPage -= 2;
        }
      }

      if (nextPage <= 1) break;
    }
    if (code) {
      for (const id in discussion.readComments) {
        if (id && comments.indexOf(id) < 0) {
          delete discussion.readComments[id];
        }
      }
      await lockAndSaveDiscussions({[code]: discussion});
    }
  }
  
  // [CWSL]

  _MODULES.push({
    description: `
      <ul>
        <li>Turns the numbers in the "Giveaways" column of any <a href="https://www.steamgifts.com/giveaways/wishlist">community wishlist</a> page into links that allow you to search for all of the active giveaways for the game (that are visible to you).</li>
      </ul>
    `,
    id: `cwsl`,
    name:  `Community Wishlist Search Link`,
    sg: true,
    type: `giveaways`
  });

  // [DED]

  _MODULES.push({
    description: `
      <ul>
        <li>Replaces SteamGifts' native comment box (in any page) with a comment box that ensures that any comment you submit is actually submitted.</li>
        <li>This fixes a (unfortunately) very well-known bug on SteamGifts that does not submit a comment to a discussion if during the timeframe between the moment when you started to write it and the moment when you submitted it the title of the discussion title was edited.</li>
      </ul>
    `,
    id: `ded`,
    load: ded,
    name: `Discussion Edit Detector`,
    sg: true,
    st: true,
    type: `discussions`
  });

  function ded() {
    if (esgst.replyBox && !esgst.userPath) {
      ded_addButton(esgst.replyBox);
    }
  }

  function ded_addButton(context, commentUrl, callback) {
    const obj = {
      callback,
      checked: false,
      commentUrl,
      context: context.parentElement,
      description: context.querySelector(`[name="description"]`),
      parentId: context.querySelector(`[name="parent_id"]`),
      tradeCode: (context.querySelector(`[name="trade_code"]`) || {value: ``}).value,
      url: esgst.sg ? location.href.match(/(.+?)(#.+?)?$/)[1] : `/ajax.php`
    };
    const container = context.getElementsByClassName(esgst.sg
      ? `align-button-container`
      : `btn_actions`
    )[0];
    container.firstElementChild.remove();
    obj.button = insertHtml(container, `afterBegin`, `
      <div class="esgst-ded-button"></div>
    `);
    obj.status = insertHtml(container, `beforeEnd`, `
      <div class="comment__actions action_list esgst-ded-status"></div>
    `);
    obj.set = new ButtonSet_v2({
      color1: `grey`,
      color2: `grey`,
      icon1: `fa-send`,
      icon2: `fa-circle-o-notch fa-spin`,
      title1: `Submit`,
      title2: `Saving...`,
      callback1: ded_submitComment.bind(null, obj)
    });
    obj.button.appendChild(obj.set.set);
  }

  async function ded_submitComment(obj) {
    obj.status.innerHTML = ``;

    if (!obj.commentUrl) {
      saveComment(
        obj.tradeCode,
        obj.parentId.value,
        obj.description.value,
        obj.url,
        obj.status,
        null,
        obj.callback
      );
      return;
    }

    const response = await request({
          method: `GET`,
          url: obj.commentUrl
        }),
        responseHtml = parseHtml(response.responseText),
        comment = responseHtml.getElementById(obj.commentUrl.match(/\/comment\/(.+)/)[1]);
    obj.parentId = esgst.sg
      ? comment.closest(`.comment`).getAttribute(`data-comment-id`)
      : comment.getAttribute(`data-id`);
    obj.tradeCode = esgst.sg
      ? ``
      : response.finalUrl.match(/\/trade\/(.+?)\//)[1];
    obj.url = esgst.sg
      ? response.finalUrl.match(/(.+?)(#.+?)?$/)[1]
      : `/ajax.php`;

    if (obj.checked || !esgst.rfi_c) {
      saveComment(
        obj.tradeCode,
        obj.parentId,
        obj.description.value,
        obj.url,
        obj.status,
        null,
        obj.callback
      );
      return;
    }

    const comments = esgst.sg
      ? comment.closest(`.comment`).getElementsByClassName(`comment__children`)[0]
      : comment.getElementsByClassName(`comment_children`)[0];
    for (let i = comments.children.length - 1; i > -1; i--) {
      const comment = comments.children[i],
          id = comment.querySelector(`[href*="/go/comment/"]`)
              .getAttribute(`href`)
              .match(/\/go\/comment\/(.+)/)[1];
      if (obj.context.querySelector(`[href*="/go/comment/${id}"`)) {
        comment.remove();
      }
    }
    if (comments.children.length) {
      obj.context.appendChild(comments);
      await endless_load(comments);
      for (let i = comments.children.length - 1; i > -1; i--) {
        obj.context.appendChild(comments.children[i]);
      }
      comments.remove();
      obj.set.changeButton(1).setTitle(`Confirm`);
      obj.status.innerHTML = `
        <span class="esgst-bold esgst-warning">
          Somebody beat you to it!
          <br>
          There are other replies to this comment.
          <br>
          You can review them below before confirming your reply.
        </span>
      `;
      obj.checked = true;
    } else {
      saveComment(
        obj.tradeCode,
        obj.parentId,
        obj.description.value,
        obj.url,
        obj.status,
        null,
        obj.callback
      );
    }
  }

  // [DH]
  
  _MODULES.push({
    description: `
      <ul>
        <li>Adds a button (<i class="fa fa-star"></i> if the discussion is highlighted and <i class="fa fa-star-o"></i> if it is not) next to a discussion's title (in any page) that allows you to highlight the discussion.</li>
        <li>Highlighted discussions have a green background.</li>
        <li>Adds a button (<i class="fa fa-star esgst-yellow"></i> View Highlighted) to the dropdown menu accessible by clicking on the arrow in the "Discussions" box at the header of any page that allows you to view all of the discussions that have been highlighted.</li>
      </ul>
    `,
    features: {
      dh_t: {
        name: `Pin any highlighted discussions in the page.`,
        sg: true
      }
    },
    id: `dh`,
    load: dh,
    name: `Discussion Highlighter`,
    sg: true,
    type: `discussions`
  });

  function dh() {
    new Process({
      button: insertHtml(document.getElementsByClassName(`nav__absolute-dropdown`)[1], `beforeEnd`, generateHeaderMenuItem({description: `View your highlighted discussions.`, icon: `fa-star yellow`, id: `dh`, name: `View Highlighted`, title: getFeatureTooltip(`dh`)})),
      popup: {
        icon: `fa-star`,
        title: `Highlited Discussions`,
        addProgress: true,
        addScrollable: `left`
      },
      urls: {
        id: `dh`,
        init: dh_initUrls,
        perLoad: 5,
        request: {
          request: dh_requestUrl
        }
      }
    });
  }

  async function dh_initUrls(obj) {
    let discussions = JSON.parse(await getValue(`discussions`));
    obj.keys = [];
    for (let key in discussions) {
      let discussion = discussions[key];
      if (!discussion.highlighted) continue;
      obj.keys.push(key);
      obj.items.push(`/discussion/${key}/`);
    }
    obj.mainContext = obj.popup.getScrollable(`
      <div class="table esgst-text-left">
        <div class="table__heading">
          <div class="table__column--width-fill">Summary</div>
          <div class="table__column--width-small text-center">Comments</div>
        </div>
      </div>
    `).lastElementChild;
    obj.contextHtml = `
      <div class="table__rows"></div>
    `;
  }

  function dh_requestUrl(obj, details, response, responseHtml) {
    let key = obj.keys[obj.index];
    let breadcrumbs = responseHtml.getElementsByClassName(`page__heading__breadcrumbs`);
    let categoryLink = breadcrumbs[0].firstElementChild.nextElementSibling.nextElementSibling;
    let usernameLink = responseHtml.getElementsByClassName(`comment__username`)[0].firstElementChild;
    obj.context.insertAdjacentHTML(`beforeEnd`, `
      <div>
        <div class="table__row-outer-wrap">
          <div class="table__row-inner-wrap">
            <div>
              ${responseHtml.getElementsByClassName(`global__image-outer-wrap`)[0].outerHTML}
            </div>
            <div class="table__column--width-fill">
              <h3>
                <a class="table__column__heading" href="/discussion/${key}/">${categoryLink.nextElementSibling.nextElementSibling.firstElementChild.textContent}</a>
              </h3>
              <p>
                <a class="table__column__secondary-link" href="${categoryLink.getAttribute(`href`)}">${categoryLink.textContent}</a> -
                ${responseHtml.querySelector(`.comment [data-timestamp]`).outerHTML} ago by
                <a class="table__column__secondary-link" href="${usernameLink.getAttribute(`href`)}">${usernameLink.textContent}</a>
              </p>
            </div>
            <div class="table__column--width-small text-center">
              <a class="table__column__secondary-link" href="/discussion/${key}/">${breadcrumbs[1].textContent.match(/(.+) Comments?/)[1]}</a>
            </div>
          </div>
        </div>
      </div>
    `);
  }

  async function dh_highlightDiscussion(code, context, save) {
    if (save) {
      let deleteLock = await createLock(`commentLock`, 300);
      const comments = JSON.parse(await getValue(`discussions`));
      if (!comments[code]) {
        comments[code] = {
          readComments: {}
        };
      }
      comments[code].highlighted = true;
      comments[code].lastUsed = Date.now();
      await setValue(`discussions`, JSON.stringify(comments));
      context.classList.add(`esgst-dh-highlighted`);
      deleteLock();
    } else {
      context.classList.add(`esgst-dh-highlighted`);
    }
    return true;
  }

  async function dh_unhighlightDiscussion(code, context, save) {
    if (save) {
      let deleteLock = await createLock(`commentLock`, 300);
      const comments = JSON.parse(await getValue(`discussions`));
      delete comments[code].highlighted;
      comments[code].lastUsed = Date.now();
      await setValue(`discussions`, JSON.stringify(comments));
      context.classList.remove(`esgst-dh-highlighted`);
      deleteLock();
    } else {
      context.classList.remove(`esgst-dh-highlighted`);
    }
    return true;
  }

  // [DS]

  _MODULES.push({
    description: `
      <ul>
        <li>Adds a button (<i class="fa fa-sort"></i>) to the main page heading of any <a href="https://www.steamgifts.com/discussions">discussions</a> page that allows you to sort the discussions in the page by title, category, created time, author and number of comments.</li>
        <li>There is also an option to automatically sort the discussions so that every time you open the page the discussions are already sorted by whatever option you prefer.</li>
      </ul>
    `,
    id: `ds`,
    load: ds,
    name: `Discussions Sorter`,
    sg: true,
    type: `discussions`
  });

  function ds() {
    if (!esgst.discussionsPath) return;

    let object = {
      button: createHeadingButton({id: `ds`, icons: [`fa-sort`], title: `Sort discussions`})
    };
    object.button.addEventListener(`click`, ds_openPopout.bind(null, object));
  }

  function ds_openPopout(obj) {
    if (obj.popout) return;
    obj.popout = new Popout(`esgst-ds-popout`, obj.button, 0, true);
    new ToggleSwitch(obj.popout.popout, `ds_auto`, false, `Auto Sort`, false, false, `Automatically sorts the discussions by the selected option when loading the page.`, esgst.ds_auto);
    let options = insertHtml(obj.popout.popout, `beforeEnd`, `
      <select>
        <option value="sortIndex_asc">Default</option>
        <option value="title_asc">Title - Ascending</option>
        <option value="title_desc">Title - Descending</option>
        <option value="category_asc">Category - Ascending</option>
        <option value="category_desc">Category - Descending</option>
        <option value="createdTimestamp_asc">Created Time - Ascending</option>
        <option value="createdTimestamp_desc">Created Time - Descending</option>
        <option value="author_asc">Author - Ascending</option>
        <option value="author_desc">Author - Descending</option>
        <option value="comments_asc">Comments - Ascending</option>
        <option value="comments_desc">Comments - Descending</option>
      </select>
    `);
    options.value = esgst.ds_option;
    let callback = saveAndSortContent.bind(null, `ds_option`, `mainDiscussions`, options, null);
    options.addEventListener(`change`, callback);
    obj.popout.popout.appendChild(new ButtonSet_v2({color1: `green`, color2: ``, icon1: `fa-arrow-circle-right`, icon2: ``, title1: `Sort`, title2: ``, callback1: callback}).set);
    obj.popout.open();
  }

  // [EGH]

  _MODULES.push({
    description: `
      <ul>
        <li>Adds an icon (<i class="fa fa-star"></i>) next to a game's name (in any page) to indicate that you have entered giveaways for the game in the past. Clicking on the icon unhighlights the game.</li>
        <li>A game is only highlighted if you entered a giveaway for it after this feature was enabled.</li>
      </ul>
    `,
    id: `egh`,
    name: `Entered Game Highlighter`,
    sg: true,
    type: `games`
  });

  async function egh_saveGame(id, type) {
    let games;
    if (id && type) {
      games = JSON.parse(await getValue(`games`));
      if (!games[type][id] || !games[type][id].entered) {
        let deleteLock = await createLock(`gameLock`, 300);
        games = JSON.parse(await getValue(`games`));
        if (!games[type][id]) {
          games[type][id] = {};
        }
        games[type][id].entered = true;
        await setValue(`games`, JSON.stringify(games));
        deleteLock();
      }
    }
  }

  async function egh_unhighlightGame(id, type, event) {
    let icon = event.currentTarget;
    if (icon.classList.contains(`fa-spin`)) return;
    icon.innerHTML = `<i class="fa fa-circle-o-notch fa-spin"></i>`;
    let deleteLock = await createLock(`gameLock`, 300);
    let games = JSON.parse(await getValue(`games`));
    delete games[type][id].entered;
    await setValue(`games`, JSON.stringify(games));
    icon.remove();
    deleteLock();
  }

  // [ET]

  _MODULES.push({
    description: `
      <ul>
        <li>Adds a button (<i class="fa fa-ticket esgst-red"></i> My Entry History) to the dropdown menu accessible by clicking on the arrow next to your avatar at the header of any page that allows you to view your giveaway entry history (the detailed log, including the name, link and date of every giveaway you have entered/left) and some other details (the average number of giveaways that you enter per day, the date when you entered the least number of giveaways, the date when you entered the most number of giveaways and a table containing how many giveaways you have entered/left per day).</li>
        <li>An entry only appears in the history if you entered/left the giveaway after this feature was enabled.</li>
      </ul>
    `,
    id: `et`,
    load: et,
    name: `Entry Tracker`,
    sg: true,
    type: `giveaways`
  });

  function et() {
    if (esgst.enteredPath) {
      esgst.endlessFeatures.push(et_getEntries);
    }
    if (!esgst.sg) return;
    insertHtml(esgst.sg ? esgst.mainButton.parentElement.getElementsByClassName(`nav__absolute-dropdown`)[0].lastElementChild : esgst.mainButton.parentElement.getElementsByClassName(`dropdown`)[0].firstElementChild.lastElementChild, `beforeBegin`, `
      <div class="esgst-header-menu-row" data-link-id="et" data-link-key="account" title="${getFeatureTooltip(`et`)}">
        <i class="fa fa-fw fa-ticket red"></i>
        <div>
          <p class="esgst-header-menu-name">My Entry History</p>
          <p class="esgst-header-menu-description">View your entry history.</p>
        </div>
      </div>
    `).addEventListener(`click`, et_menu);
    if (esgst.giveawayPath && !document.getElementsByClassName(`table--summary`)[0] && esgst.enterGiveawayButton) {
      let code, name;
      code = location.pathname.match(/^\/giveaway\/(.+?)\//)[1];
      name = document.getElementsByClassName(`featured__heading__medium`)[0].textContent;
      esgst.enterGiveawayButton.addEventListener(`click`, et_setEntry.bind(null, code, true, name));
      esgst.leaveGiveawayButton.addEventListener(`click`, et_setEntry.bind(null, code, false, name));
    }
  }

  async function et_menu() {
    let dates = {};
    let entries = JSON.parse(await getValue(`entries`, `[]`));
    let historyHtml = ``;
    for (let i = entries.length - 1; i > -1; i--) {
      let entry = entries[i];
      historyHtml += `
        <li>
          ${entry.entry ? `Entered` : `Left`} <a href="/giveaway/${entry.code}/">${entry.name}</a> on ${getTimestamp(entry.timestamp, esgst.at_24, esgst.at_s)}
        </li>
      `;
      let date = getDate(`[MMM] [D], [YYYY]`, entry.timestamp);
      let key = new Date(date).getTime();
      if (!dates[key]) {
        dates[key] = {
          date: date,
          entered: 0,
          left: 0
        };
      }
      if (entry.entry) {
        dates[key].entered += 1;
      } else {
        dates[key].left += 1;
      }
    }
    let popup = new Popup(`fa-history`, `Entry Tracker`, true);
    let rows = insertHtml(popup.scrollable, `beforeEnd`, `
      <div class="esgst-text-left esgst-float-right table" style="width: auto;">
        <div class="table__heading">
          <div class="table__column--width-small">Delete</div>
          <div class="table__column--width-small">Date</div>
          <div class="table__column--width-small">Entered</div>
          <div class="table__column--width-small">Left</div>
        </div>
        <div class="table__rows"></div>
      </div>
    `).lastElementChild;
    let keys = Object.keys(dates);
    keys.sort();
    let lowest = {
      count: 999999999,
      date: null
    };
    let highest = {
      count: 0,
      date: null
    };
    let total = 0;
    for (let i = keys.length - 1; i > -1; i--) {
      let key = keys[i];
      let button = insertHtml(rows, `beforeEnd`, `
        <div class="table__row-outer-wrap">
          <div class="table__row-inner-wrap">
            <div class="table__column--width-small esgst-text-center">
              <i class="fa fa-times esgst-clickable" title="Delete"></i>
            </div>
            <div class="table__column--width-small">${dates[key].date}</div>
            <div class="table__column--width-small">${dates[key].entered}</div>
            <div class="table__column--width-small">${dates[key].left}</div>
          </div>
        </div>
      `).firstElementChild.firstElementChild;
      button.firstElementChild.addEventListener(`click`, et_deleteEntry.bind(null, button, dates[key].date, popup));
      if (dates[key].entered < lowest.count) {
        lowest.count = dates[key].entered;
        lowest.date = dates[key].date;
      }
      if (dates[key].entered > highest.count) {
        highest.count = dates[key].entered;
        highest.date = dates[key].date;
      }
      total += dates[key].entered;
    }
    let average = Math.round(total / keys.length * 100) / 100;
    popup.description.insertAdjacentHTML(`afterBegin`, `
      <div>
        You enter on average <span class="esgst-bold">${average}</span> giveaways per day.
      </div>
      <div>
        Your highest entry count was on <span class="esgst-italic">${highest.date}</span> with <span class="esgst-bold">${highest.count}</span> entries.
      </div>
      <div>
        Your lowest entry count was on <span class="esgst-italic">${lowest.date}</span> with <span class="esgst-bold">${lowest.count}</span> entries.
      </div>
    `);
    popup.scrollable.insertAdjacentHTML(`beforeEnd`, `
      <div class="esgst-text-left esgst-float-left markdown" style="border-right: 1px solid #ccc;">
        <ul>${historyHtml}</ul>
      </div>
    `);
    popup.scrollable.insertAdjacentHTML(`beforeEnd`, `<div class="esgst-clear"></div>`);
    popup.open();
  }

  async function et_deleteEntry(button, date, popup) {
    if (! confirm(`Are you sure you want to delete entries for ${date}? Your entire history for that day will be deleted.`)) return;
    button.innerHTML = `
      <i class="fa fa-circle-o-notch fa-spin"></i>
    `;
    let entries = JSON.parse(await getValue(`entries`, `[]`));
    for (let i = entries.length - 1; i > -1; i--) {
      let entry = entries[i];
      if (date !== getDate(`[MMM] [D], [YYYY]`, entry.timestamp)) continue;
      entries.splice(i, 1);
    }
    await setValue(`entries`, JSON.stringify(entries));
    popup.close();
    et_menu();
  }

  function et_getEntries(context, main, source, endless) {
    const elements = context.querySelectorAll(`${endless ? `.esgst-es-page-${endless} .table__remove-default:not(.is-hidden), .esgst-es-page-${endless}.table__remove-default:not(.is-hidden)` : `.table__remove-default:not(.is-hidden)`}`);
    for (let i = 0, n = elements.length; i < n; ++i) {
      et_setObserver(elements[i]);
    }
  }

  function et_setObserver(element) {
    let code, container, heading, name;
    container = element.closest(`.table__row-inner-wrap`);
    heading = container.getElementsByClassName(`table__column__heading`)[0];
    code = heading.getAttribute(`href`).match(/\/giveaway\/(.+?)\//)[1];
    name = heading.firstChild.textContent.trim().match(/(.+?)(\s\(.+\sCopies\))?$/)[1];
    element.addEventListener(`click`, et_setEntry.bind(null, code, false, name));
  }

  async function et_setEntry(code, entry, name) {
    let entries = JSON.parse(await getValue(`entries`, `[]`));
    entries.push({
      code: code,
      entry: entry,
      name: name,
      timestamp: Date.now()
    });
    setValue(`entries`, JSON.stringify(entries));
  }

  // [CH]

  _MODULES.push({
    description: `
      <ul>
        <li>Adds a button (<i class="fa fa-comments esgst-yellow"></i> My Comment History) to the dropdown menu accessible by clicking on the arrow next to your avatar at the header of any page that allows you to view your comment history.</li>
        <li>A comment only appears in the history if it was submitted through the comment box of any of the following features: [id=ded], [id=mr], [id=rrbp], [id=rbp] and [id=rfi]. If you submit the comment through SteamGifts' native comment box it will not be added to the history.</li>
      </ul>
    `,
    id: `ch`,
    load: ch,
    name: `Comment History`,
    sg: true,
    type: `comments`
  });

  function ch() {
    new Process({
      button: insertHtml(esgst.mainButton.parentElement.getElementsByClassName(`nav__absolute-dropdown`)[0].lastElementChild, `beforeBegin`, `
        <div class="esgst-header-menu-row" data-link-id="ch" data-link-key="account" title="${getFeatureTooltip(`ch`)}">
          <i class="fa fa-fw fa-comments yellow"></i>
          <div>
            <p class="esgst-header-menu-name">My Comment History</p>
            <p class="esgst-header-menu-description">View your comment history.</p>
          </div>
        </div>
      `),
      popup: {
        icon: `fa-comments`,
        title: `Comment History`,
        addProgress: true,
        addScrollable: `left`
      },
      urls: {
        id: `ch`,
        init: ch_initUrls,
        perLoad: 5,
        request: {
          request: ch_requestUrl
        }
      }
    });
  }

  async function ch_initUrls(obj) {
    obj.ids = [];
    let comments = JSON.parse(await getValue(`${esgst.name}CommentHistory`, `[]`));
    for (let i = 0, n = comments.length; i < n; i++) {
      obj.ids.push(comments[i].id);
      obj.items.push(`https://${location.hostname}/go/comment/${comments[i].id}`);
    }
  }

  function ch_requestUrl(obj, details, response, responseHtml) {
    let comment = responseHtml.getElementById(obj.ids[obj.index]);
    if (esgst.sg) {
      comment = comment.closest(`.comment`);
      comment.firstElementChild.classList.remove(`comment__parent`);
      comment.firstElementChild.classList.add(`comment__child`);
    }
    comment.lastElementChild.remove();
    let parent = comment.parentElement.closest(`.comment, .comment_outer`);
    let html = ``;
    if (parent) {
      parent.lastElementChild.remove();
      parent.insertAdjacentHTML(`beforeEnd`, `
        <div class="comment__children comment_children">${comment.outerHTML}</div>
      `);
      html += parent.outerHTML;
    } else {
      if (esgst.st) {
        comment.getElementsByClassName(`action_list`)[0].firstElementChild.insertAdjacentHTML(`afterEnd`, `
          <a href="${response.finalUrl}">${responseHtml.title}</a>
        `);
      }
      html += esgst.sg ? `
        <div class="comments__entity">
          <p class="comments__entity__name">
            <a href="${response.finalUrl}">${responseHtml.title}</a>
          </p>
        </div>` : ``;
      html += `
        <div class="comment__children comment_children">${comment.outerHTML}</div>
      `;
    }
    obj.context.insertAdjacentHTML(`beforeEnd`, `
      <div class="comment comments comment_outer">${html}</div>
    `);
  }

  async function ch_saveComment(id, timestamp) {
    let deleteLock = await createLock(`${esgst.name}CommentHistoryLock`, 300);
    let key = `${esgst.name}CommentHistory`;
    let comments = JSON.parse(await getValue(key, `[]`));
    comments.unshift({
      id: id,
      timestamp: timestamp
    });
    await setValue(key, JSON.stringify(comments));
    deleteLock();
  }

  // [CHFL]

  _MODULES.push({
    description: `
      <ul>
        <li>Allows you to add custom links to the header dropdowns/footer of any page.</li>
        <li>Already comes with some predefined links:</li>
        <ul>
          <li>Giveaways: Hidden Games, Reduced CV Games, Browse Wishlist, Browse Recommended, Browse Group, Browse New</li>
          <li>Discussions: Categorize Discussions, Browse Announcements, Browse Bugs / Suggestions, Browse Deals, Browse General, Browse Group Recruitment, Browse Let's Play Together, Browse Off-Topic, Browse Puzzles, Browse Uncategorized</li>
          <li>Support: Real CV, Not Activated Wins, Multiple Wins</li>
          <li>Help: Change Log</li>
          <li>Account: Whitelist, Blacklist, Games, Groups, Wishlist</li>
        </ul>
        <li>If you press the Ctrl key with a dropdown open, the feature adds two buttons ("<i class="fa fa-plus-circle"></i> Add Custom Link" and "<i class="fa fa-undo"></i> Reset Links") to the end of the dropdown that allow you to add/reset the custom links. It also adds two other buttons (<i class="fa fa-edit"></i> to edit and <i class="fa fa-trash"></i> to remove) to each custom link in the dropdown that allow you to edit/remove the custom link.</li>
        <li>If you press the Ctrl key with no dropdown open, those same buttons will be added to the footer of the page.</li>
        <li>You can move the custom links by dragging and dropping them.</li>
      </ul>
    `,
    inputItems: `chfl_key`,
    id: `chfl`,
    load: chfl,
    name: `Custom Header/Footer Links`,
    sg: true,
    st: true,
    type: `general`
  });

  function chfl() {
    let chfl = null;
    if (esgst.sg) {
      let elements = document.getElementsByClassName(`nav__relative-dropdown`);
      chfl = {
        sources: {
          giveaways: {
            container: elements[0],
            context: elements[0].firstElementChild,
            elements: {}
          },
          discussions: {
            container: elements[1],
            context: elements[1].firstElementChild,
            elements: {}
          },
          support: {
            container: elements[2],
            context: elements[2].firstElementChild,
            elements: {}
          },
          help: {
            container: elements[3],
            context: elements[3].firstElementChild,
            elements: {}
          },
          account: {
            container: elements[4],
            context: elements[4].firstElementChild,
            elements: {}
          },
          footer: {
            container: esgst.footer,
            context: esgst.footer.firstElementChild.lastElementChild,
            elements: {}
          }
        }
      };
    } else {
      let elements = document.getElementsByClassName(`dropdown`);
      chfl = {
        sources: {
          trades: {
            container: elements[0],
            context: elements[0].firstElementChild,
            elements: {}
          },
          account: {
            container: elements[1],
            context: elements[1].firstElementChild,
            elements: {}
          },
          footer: {
            container: esgst.footer,
            context: esgst.footer.firstElementChild.lastElementChild,
            elements: {}
          }
        }
      };
    }
    for (let key in chfl.sources) {
      let source = chfl.sources[key];
      for (let i = source.context.children.length - 1; i > -1; i--) {
        let element = source.context.children[i];
        let id = element.getAttribute(`data-link-id`);
        if (id) {
          if (!source.elements[id]) {
            source.elements[id] = element;
          }
          continue;
        }
        if ((!element.getAttribute(`href`) || element.getAttribute(`href`).match(/^javascript/)) && (key !== `footer` || !element.lastElementChild.getAttribute(`href`))) continue;
        id = (key === `footer` ? element.lastElementChild : element).getAttribute(`href`).match(/.*(\/|\?)(.+)$/)[2];
        id = id.replace(/\[steamId\]/, esgst.steamId);
        element.setAttribute(`data-link-id`, id);
        element.setAttribute(`data-link-key`, key);
        source.elements[id] = element;
      }
      chfl_reorder(chfl, key, true);
    }
    document.addEventListener(`keydown`, chfl_checkKey.bind(null, chfl));
  }

  function chfl_checkKey(chfl, event) {
    event.stopPropagation();
    let value = ``;
    if (event.ctrlKey) {
      value += `ctrlKey + `;
    } else if (event.shiftKey) {
      value += `shiftKey + `;
    } else if (event.altKey) {
      value += `altKey + `;
    }
    value += event.key.toLowerCase();

    if (value !== esgst.chfl_key) return;

    const removedKey = chfl_removeButton(chfl);
    chfl_addButton(chfl, removedKey);
  }

  function chfl_reorder(chfl, key, firstRun) {
    let source = chfl.sources[key];
    let ids = [];
    for (let i = esgst[`chfl_${key}`].length - 1; i > -1; i--) {
      let item = esgst[`chfl_${key}`][i];
      if (item.id) {
        let element = source.elements[item.id];
        if (element && !firstRun) {
          source.context.insertBefore(element, source.context.firstElementChild);
        } else {
          if (element) {
            element.remove();
          }
          if (key === `footer`) {
            source.elements[item.id] = insertHtml(source.context, `afterBegin`, `
              <${esgst.sg ? `div` : `li`} data-link-id="${item.id}" data-link-key="footer" title="${getFeatureTooltip(`chfl`)}">
                <i class="fa ${item.icon}"></i>
                <a href="${item.url}">${item.name}</a>
              </${esgst.sg ? `div` : `li`}>
            `);
          } else {
            source.elements[item.id] = insertHtml(source.context, `afterBegin`, generateHeaderMenuItem(item, key));
            source.elements[item.id].title = getFeatureTooltip(`chfl`);
            if (!item.description) {
              source.elements[item.id].classList.add(`esgst-chfl-small`);
            }
            if (item.compact) {
              source.elements[item.id].classList.add(`esgst-chfl-compact`);
            }
          }
        }
        chfl_makeDraggable(chfl, source.elements[item.id]);
        ids.push(item.id);
      } else {
        let element = source.elements[item];
        if (element) {
          source.context.insertBefore(element, source.context.firstElementChild);
          chfl_makeDraggable(chfl, element);
        }
        ids.push(item);
      }
    }
    for (let key in source.elements) {
      if (ids.indexOf(key) > -1) continue;
      source.elements[key].remove();
      delete source.elements[key];
    }
    if (!firstRun) {
      chfl_removeButton(chfl, key);
      chfl_addButton(chfl, null, key);
    }
  }

  function chfl_makeDraggable(chfl, element) {
    element.setAttribute(`draggable`, true);
    element.addEventListener(`dragstart`, chfl_startDrag.bind(null, chfl));
    element.addEventListener(`dragenter`, chfl_enterDrag.bind(null, chfl));
    element.addEventListener(`dragend`, chfl_saveOrder.bind(null, chfl));
  }

  function chfl_startDrag(chfl, event) {
    event.dataTransfer.setData(`text/plain`, ``);
    chfl.source = event.currentTarget;
  }

  function chfl_enterDrag(chfl, event) {
    let current = chfl.source;
    let element = event.currentTarget;
    if (current.getAttribute(`data-link-key`) !== element.getAttribute(`data-link-key`)) return;
    do {
      current = current.previousElementSibling;
      if (current && current === element) {
        element.parentElement.insertBefore(chfl.source, element);
        return;
      }
    } while (current);
    element.parentElement.insertBefore(chfl.source, element.nextElementSibling);
  }

  function chfl_saveOrder(chfl) {
    for (let key in chfl.sources) {
      let elements = {};
      for (const item of esgst.settings[`chfl_${key}_${esgst.name}`]) {
        if (item.id) {
          elements[item.id] = item;
        }
      }
      esgst.settings[`chfl_${key}_${esgst.name}`] = [];
      let source = chfl.sources[key];
      for (let i = 0, n = source.context.children.length; i < n; i++) {
        let element = source.context.children[i];
        let id = element.getAttribute(`data-link-id`);
        if (!id) continue;
        esgst.settings[`chfl_${key}_${esgst.name}`].push(elements[id] || id);
      }
      esgst[`chfl_${key}`] = esgst.settings[`chfl_${key}_${esgst.name}`];
    }
    setValue(`settings`, JSON.stringify(esgst.settings));
  }

  function chfl_addButton(chfl, removedKey, forceKey) {
    for (const key in chfl.sources) {
      if (key === removedKey) return;

      const source = chfl.sources[key];
      if (key !== forceKey && (source.container.classList.contains(`is-hidden`) || source.container.classList.contains(`is_hidden`))) continue;

      const button = insertHtml(source.context, `beforeEnd`, key === `footer` ? `
        <${esgst.sg ? `div` : `li`} class="esgst-chfl-button">
          <i class="fa fa-plus"></i>
          <a href="#">Add Custom Link</a>
        </${esgst.sg ? `div` : `li`}>
      ` : generateHeaderMenuItem({className: ` esgst-chfl-button`, color: `grey`, icon: `fa-plus-circle`, name: `Add Custom Link`, description: `Click here to add a custom link.`}));
      button.addEventListener(`click`, chfl_openPopup.bind(null, chfl, null, key));
      const resetButton = insertHtml(source.context, `beforeEnd`, key === `footer` ? `
        <${esgst.sg ? `div` : `li`} class="esgst-chfl-button">
          <i class="fa fa-undo"></i>
          <a href="#">Reset Links</a>
        </${esgst.sg ? `div` : `li`}>
      ` : generateHeaderMenuItem({className: ` esgst-chfl-button`, color: `grey`, icon: `fa-undo`, name: `Reset Links`, description: `Click here to reset the custom links.`}));
      resetButton.addEventListener(`click`, createConfirmation.bind(null, `Are you sure you want to reset the links? Any custom links you added will be deleted.`, chfl_resetLinks.bind(null, chfl, key), null));
      for (const subKey in source.elements) {
        const element = source.elements[subKey],
            panel = insertHtml(element, `beforeEnd`, `
              <div class="esgst-chfl-panel">
                <i class="esgst-chfl-edit-button fa fa-edit icon-grey"></i>
                <i class="esgst-chfl-remove-button fa fa-trash icon-grey"></i>
              </div>
            `);
        panel.firstElementChild.addEventListener(`click`, chfl_openPopup.bind(null, chfl, subKey, key));
        panel.lastElementChild.addEventListener(`click`, chfl_removeLink.bind(null, chfl, subKey, key));
      }
      return;
    }
  }

  function chfl_openPopup(chfl, editId, key, event) {
    event.preventDefault();
    let popup = new Popup(editId ? `fa-edit` : `fa-plus`, `${editId ? `Edit` : `Add`} Custom Link`, true);
    let description = insertHtml(popup.description, `beforeEnd`, `
      <div>
        <span>URL:</span>
        <i class="fa fa-question-circle" title="Instead of entering 'https://www.steamgifts.com/url', you can simply enter '/url'."></i>
        <input class="esgst-switch-input esgst-switch-input-large" type="text">
      </div>
      <div>
        <span>Color:</span>
        <select class="esgst-switch-input esgst-switch-input-large">
          <option value="grey">Grey (Default)</option>
          <option value="blue">Blue</option>
          <option value="green">Green</option>
          <option value="red">Red</option>
          <option value="yellow">Yellow</option>
        </select>
      </div>
      <div>
        <span>Icon:</span>
        <a href="https://fontawesome.com/v4.7.0/icons/">
          <i class="fa fa-question-circle" title="You must use an icon from FontAwesome (click on this icon to go to the FontAwesome page). The icon must be in the format 'fa-icon', without the quotes."></i>
        </a>
        <input class="esgst-switch-input esgst-switch-input-large" type="text">
      </div>
      <div>
        <span>Name:</span>
        <input class="esgst-switch-input esgst-switch-input-large" type="text">
      </div>
      <div>
        <span>Description:</span>
        <input class="esgst-switch-input esgst-switch-input-large" type="text">
      </div>
    `);
    let name = description.previousElementSibling;
    let icon = name.previousElementSibling;
    let color = icon.previousElementSibling;
    let url = color.previousElementSibling.lastElementChild;
    let compactSwitch = new ToggleSwitch(popup.description, null, null, `Use compact size.`, false, false, `The bottom/top padding of the link will be reduced to 8px.`);
    description = description.lastElementChild;
    name = name.lastElementChild;
    icon = icon.lastElementChild;
    color = color.lastElementChild;
    if (key === `footer`) {
      color.parentElement.classList.add(`esgst-hidden`);
      description.parentElement.classList.add(`esgst-hidden`);
      compactSwitch.switch.classList.add(`esgst-hidden`);
    }
    if (esgst.st) {
      description.parentElement.classList.add(`esgst-hidden`);
    }
    if (editId) {
      for (let i = esgst[`chfl_${key}`].length - 1; i > -1; i--) {
        let item = esgst[`chfl_${key}`][i];
        if (item !== editId && (!item.id || item.id !== editId)) continue;
        if (item.id) {
          description.value = item.description || ``;
          name.value = item.name || ``;
          icon.value = item.icon || ``;
          color.value = item.color || ``;
          url.value = item.url || ``;
          if (item.compact) {
            compactSwitch.enable();
          }
        } else {
          let element = chfl.sources[key].elements[item];
          let context = element.firstElementChild;
          if (esgst.sg) {
            if (key === `footer`) {
              name.value = context.nextElementSibling.textContent.trim();
              icon.value = context.className.match(/.+(fa-.+)$/)[1];
              url.value = context.nextElementSibling.getAttribute(`href`);
            } else {
              description.value = context.nextElementSibling.lastElementChild.textContent.trim();
              name.value = context.nextElementSibling.firstElementChild.textContent.trim();
              icon.value = context.className.match(/.+(fa-.+)$/)[1];
              color.value = context.className.match(/icon-(.+?)\s/)[1];
              url.value = element.getAttribute(`href`);
            }
          } else {
            if (key === `footer`) {
              name.value = context.nextElementSibling.textContent.trim();
              icon.value = context.className.match(/.+(fa-.+)$/)[1];
              url.value = context.nextElementSibling.getAttribute(`href`);
            } else {
              name.value = context.nextElementSibling.textContent.trim();
              icon.value = context.className.match(/.+(fa-.+)$/)[1];
              color.value = context.className.match(/^(.+?)\s/)[1];
              url.value = element.getAttribute(`href`);
            }
          }
        }
        break;
      }
    }
    popup.description.appendChild(new ButtonSet_v2({color1: `green`, color2: `grey`, icon1: editId ? `fa-edit` : `fa-plus-circle`, icon2: `fa-circle-o-notch fa-spin`, title1: editId ? `Edit` : `Add`, title2: editId ? `Editing...` : `Adding...`, callback1: chfl_addLink.bind(null, chfl, color, compactSwitch, description, editId, icon, key, name, popup, url)}).set);
    popup.open();
  }

  async function chfl_addLink(chfl, color, compactSwitch, description, editId, icon, key, name, popup, url) {
    let match = url.value.match(/\/(giveaway|discussion|support\/ticket|trade)\/(.+?)\//) || url.value.match(/.*(\/|\?)(.+)$/);
    let item = {
      color: color.value,
      compact: compactSwitch.value ? 1 : 0,
      description: description.value,
      icon: icon.value,
      id: match[2],
      name: name.value,
      url: url.value
    };
    if (editId) {
      chfl.sources[key].elements[editId].remove();
      delete chfl.sources[key].elements[editId];
      for (let i = esgst.settings[`chfl_${key}_${esgst.name}`].length - 1; i > -1; i--) {
        let subItem = esgst.settings[`chfl_${key}_${esgst.name}`][i];
        if (subItem.id) {
          if (subItem.id !== editId) continue;
          esgst.settings[`chfl_${key}_${esgst.name}`][i] = item;
          break;
        } else {
          if (subItem !== editId) continue;
          esgst.settings[`chfl_${key}_${esgst.name}`][i] = item;
          break;
        }
      }
    } else {
      esgst.settings[`chfl_${key}_${esgst.name}`].push(item);
    }
    esgst[`chfl_${key}`] = esgst.settings[`chfl_${key}_${esgst.name}`];
    await setValue(`settings`, JSON.stringify(esgst.settings));
    chfl.sources[key].elements[item.id] = insertHtml(chfl.sources[key].context, `beforeEnd`, key === `footer` ? `
      <${esgst.sg ? `div` : `li`} data-link-id="${item.id}" data-link-key="footer">
        <i class="fa ${item.icon}"></i>
        <a href="${item.url}">${item.name}</a>
      </${esgst.sg ? `div` : `li`}>
    ` : generateHeaderMenuItem(item, key));
    if (!item.description) {
      chfl.sources[key].elements[item.id].classList.add(`esgst-chfl-small`);
    }
    if (item.compact) {
      chfl.sources[key].elements[item.id].classList.add(`esgst-chfl-compact`);
    }
    chfl_makeDraggable(chfl, chfl.sources[key].elements[item.id]);
    chfl_reorder(chfl, key);
    popup.close();
  }

  function chfl_resetLinks(chfl, key, event) {
    event.preventDefault();
    event.stopPropagation();
    for (const item of esgst.settings[`chfl_${key}_${esgst.name}`]) {
      if (!item.id) continue;
      let element = chfl.sources[key].elements[item.id];
      if (!element) continue;
      element.remove();
      delete chfl.sources[key].elements[item.id];
    }
    esgst.settings[`chfl_${key}_${esgst.name}`] = esgst.defaultValues[`chfl_${key}_${esgst.name}`];
    esgst[`chfl_${key}`] = esgst.settings[`chfl_${key}_${esgst.name}`];
    chfl_reorder(chfl, key);
    setValue(`settings`, JSON.stringify(esgst.settings));
  }

  function chfl_removeLink(chfl, id, key, event) {
    event.preventDefault();
    event.stopPropagation();
    chfl.sources[key].elements[id].remove();
    delete chfl.sources[key].elements[id];
    chfl_saveOrder(chfl);
  }

  function chfl_removeButton(chfl, forceKey) {
    for (const key in chfl.sources) {
      const source = chfl.sources[key];
      if (key !== forceKey && (source.container.classList.contains(`is-hidden`) || source.container.classList.contains(`is_hidden`))) continue;

      const buttons = source.context.getElementsByClassName(`esgst-chfl-button`);
      let found = false;
      for (let i = buttons.length - 1; i > -1; i--) {
        found = true;
        buttons[i].remove();
      }
      for (const subKey in source.elements) {
        const element = source.elements[subKey],
            elements = element.getElementsByClassName(`esgst-chfl-panel`);
        for (let i = elements.length - 1; i > -1; i--) {
          elements[i].remove();
        }
      }
      return (found ? key : null);
    }
  }

  // [FF]

  _MODULES.push({
    description: `
      <ul>
        <li>Keeps the footer of any page at the bottom of the window while you scroll down the page.</li>
      </ul>
    `,
    id: `ff`,
    load: ff,
    name: `Fixed Footer`,
    sg: true,
    st: true,
    type: `general`
  });

  function ff() {
    if (!esgst.footer) {
      return;
    }

    esgst.footer.classList.add(`esgst-ff`);
  }

  // [FH]

  _MODULES.push({
    description: `
      <ul>
        <li>Keeps the header of any page at the top of the window while you scroll down the page.</li>
      </ul>
    `,
    id: `fh`,
    load: fh,
    name: `Fixed Header`,
    sg: true,
    st: true,
    type: `general`
  });

  function fh() {
    if (!esgst.header) {
      return;
    }

    esgst.header.classList.add(`esgst-fh`);
    const height = esgst.header.offsetHeight;
    esgst.pageTop += height;
    esgst.commentsTop += height;
  }

  // [FMPH]

  _MODULES.push({
    description: `
      <ul>
        <li>Keeps the main page heading (usually the first heading of the page, for example, the heading that says "Giveaways" in the main page) of any page at the top of the window while you scroll down the page.</li>
      </ul>
    `,
    id: `fmph`,
    load: fmph,
    name: `Fixed Main Page Heading`,
    sg: true,
    st: true,
    type: `general`
  });

  function fmph() {
    if (!esgst.mainPageHeading) {
      return;
    }

    esgst.style.insertAdjacentText(`beforeEnd`, `
      .esgst-fmph {
        top: ${esgst.pageTop}px;
      }
    `);

    esgst.mainPageHeading.classList.add(`esgst-fmph`);
    const height = esgst.mainPageHeading.offsetHeight;
    esgst.commentsTop += height;
  }

  // [CERB]

  _MODULES.push({
    description: `
      <ul>
        <li>Adds a button (<i class="fa fa-plus-square"></i> if all of the replies in the page are collapsed and <i class="fa fa-minus-square"></i> if they are expanded) above the comments (in any page) that allows you to collapse/expand all of the replies (comments nested 2 or more levels deep) in the page.</li>
        <li>Also adds the same button in front of each comment nested 1 level deep in the page, which allows you to collapse/expand the replies of the comment individually.</li>
      </ul>
    `,
    features: {
      cerb_a: {
        name: `Automatically collapse all replies when visiting a page.`,
        sg: true,
        st: true
      }
    },
    id: `cerb`,
    load: cerb,
    name: `Collapse/Expand Reply Button`,
    sg: true,
    st: true,
    type: `comments`
  });

  function cerb() {
    if (!esgst.commentsPath) return;
    let button, collapse, comments, expand;
    comments = document.getElementsByClassName(`comments`)[0];
    if (comments && comments.children.length) {
      esgst.cerbButtons = [];
      button = insertHtml(esgst.mainPageHeading, `afterEnd`, `
        <div class="esgst-cerb-button esgst-clickable">
          <span>
            <i class="fa fa-minus-square"></i> Collapse all replies
          </span>
          <span class="esgst-hidden">
            <i class="fa fa-plus-square"></i> Expand all replies
          </span>
        </div>
      `);
      collapse = button.firstElementChild;
      expand = collapse.nextElementSibling;
      collapse.addEventListener(`click`, cerb_collapseAllReplies.bind(null, collapse, expand));
      expand.addEventListener(`click`, cerb_expandAllReplies.bind(null, collapse, expand));
      esgst.endlessFeatures.push(cerb_getReplies.bind(null, collapse, expand));
    }
  }

  function cerb_getReplies(collapse, expand, context, main, source, endless) {
    let id = context === document && main ? location.hash.replace(/#/, ``) : null,
      permalink = id ? document.getElementById(id) : null,
      elements = context.querySelectorAll(`${endless ? `.esgst-es-page-${endless} :not(.esgst-popup) .comments > .comment, .esgst-es-page-${endless}:not(.esgst-popup) .comments > .comment` : `:not(.esgst-popup) .comments > .comment`}, ${endless ? `.esgst-es-page-${endless} :not(.esgst-popup) .comments > .comment_outer, .esgst-es-page-${endless}:not(.esgst-popup) .comments > .comment_outer` : `:not(.esgst-popup) .comments > .comment_outer`}`);
    if (!elements.length) return;
    for (let reply of elements) {
      let replies = reply.querySelector(`.comment__children, .comment_children`);
      if (replies && replies.children.length) {
        cerb_setButton(insertHtml(reply.firstElementChild, `afterBegin`, `
          <div class="esgst-cerb-reply-button esgst-clickable">
            <span title="${getFeatureTooltip(`cerb`, `Collapse all replies`)}">
              <i class="fa fa-minus-square"></i>
            </span>
            <span class="esgst-hidden" title="${getFeatureTooltip(`cerb`, `Expand all replies`)}">
              <i class="fa fa-plus-square"></i>
            </span>
          </div>
        `), permalink && reply.contains(permalink), reply, replies.children);
      }
    }
    if (esgst.cerb_a) {
      cerb_collapseAllReplies(collapse, expand);
    }
  }

  function cerb_setButton(button, permalink,  reply, replies) {
    let collapse, expand;
    collapse = button.firstElementChild;
    expand = collapse.nextElementSibling;
    esgst.cerbButtons.push({
      collapse: cerb_collapseReplies.bind(null, collapse, expand, replies),
      expand: cerb_expandReplies.bind(null, collapse, expand, replies),
      permalink: permalink
    });
    collapse.addEventListener(`click`, cerb_collapseReplies.bind(null, collapse, expand, replies));
    expand.addEventListener(`click`, cerb_expandReplies.bind(null, collapse, expand, replies));
    if (esgst.cerb_a && !permalink) {
      collapse.classList.toggle(`esgst-hidden`);
      expand.classList.toggle(`esgst-hidden`);
    }
  }

  function cerb_collapseReplies(collapse, expand, replies) {
    let i, n;
    for (i = 0, n = replies.length; i < n; ++i) {
      replies[i].classList.add(`esgst-hidden`);
    }
    collapse.classList.add(`esgst-hidden`);
    expand.classList.remove(`esgst-hidden`);
  }

  function cerb_expandReplies(collapse, expand, replies) {
    let i, n;
    for (i = 0, n = replies.length; i < n; ++i) {
      replies[i].classList.remove(`esgst-hidden`);
    }
    collapse.classList.remove(`esgst-hidden`);
    expand.classList.add(`esgst-hidden`);
  }

  function cerb_collapseAllReplies(collapse, expand) {
    let i, n;
    for (i = 0, n = esgst.cerbButtons.length; i < n; ++i) {
      if (!esgst.cerbButtons[i].permalink) {
        esgst.cerbButtons[i].collapse();
      }
    }
    collapse.classList.add(`esgst-hidden`);
    expand.classList.remove(`esgst-hidden`);
  }

  function cerb_expandAllReplies(collapse, expand) {
    let i, n;
    for (i = 0, n = esgst.cerbButtons.length; i < n; ++i) {
      esgst.cerbButtons[i].expand();
    }
    collapse.classList.remove(`esgst-hidden`);
    expand.classList.add(`esgst-hidden`);
  }

  // [RBOT]

  _MODULES.push({
    description: `
      <ul>
        <li>Moves the reply box over the comments (in any page) so that you do not need to scroll down to the bottom of the page to add a comment.</li>
      </ul>
    `,
    id: `rbot`,
    load: rbot,
    name: `Reply Box On Top`,
    sg: true,
    st: true,
    type: `comments`
  });

  function rbot() {
    let element = esgst.mainPageHeading;
    if (!esgst.replyBox) {
      if (esgst.st && esgst.userPath) {
        let review = document.getElementsByClassName(`notification yellow`)[0];
        if (!review) return;
        element.parentElement.insertBefore(review, element.nextElementSibling);
      }
      return;
    }
    let box = insertHtml(element, `afterEnd`, `
      <div class="esgst-rbot"></div>
    `);
    box.appendChild(esgst.replyBox);
    let button = box.getElementsByClassName(esgst.cancelButtonClass)[0];
    if (!button) return;
    button.addEventListener(`click`, setTimeout.bind(null, box.appendChild.bind(box, esgst.replyBox), 0));
  }

  // [FS]

  _MODULES.push({
    description: `
      <ul>
        <li>Keeps the sidebar of any page at the left side of the window while you scroll down the page.</li>
      </ul>
    `,
    id: `fs`,
    load: fs,
    name: `Fixed Sidebar`,
    sg: true,
    type: `general`
  });

  function fs() {
    if (!esgst.sidebar) {
      return;
    }

    const top = esgst.pageTop + 25;
    esgst.style.insertAdjacentText(`beforeEnd`, `
      .esgst-fs {
        max-height: calc(100vh - ${top + 30 + (esgst.ff ? 39 : 0)}px);
        top: ${top}px;
      }

      .esgst-fs.stuck {
        height: calc(100vh - ${top + 30 + (esgst.ff ? 39 : 0)}px);
      }

      .sticky_sentinel--top {
        top: ${esgst.sidebar.offsetTop - top - 1}px;
      }
    `);

    esgst.sidebar.classList.add(`esgst-fs`, `sticky`);
  }

  // [GAS]

  _MODULES.push({
    description: `
      <ul>
        <li>Adds a button (<i class="fa fa-sort"></i>) to the main page heading of any <a href="https://www.steamgifts.com/giveaways">giveaways</a>/<a href="https://www.steamgifts.com/entered">entered</a>/<a href="https://www.steamgifts.com/group/SJ7Bu/">group</a>/<a href="https://www.steamgifts.com/user/cg">user</a> page that allows you to sort the giveaways in the page by game name, points, rating (if [id=gc_r] is enabled), end time, start time, creator, comments, entries, chance/chance per point (if [id=gwc] is enabled) and ratio (if [id=gwr] is enabled).</li>
        <li>There is also an option to automatically sort the giveaways so that every time you open the page the giveaways are already sorted by whatever option you prefer.</li>
      </ul>
    `,
    id: `gas`,
    load: gas,
    name: `Giveaways Sorter`,
    sg: true,
    type: `giveaways`
  });

  function gas(popup) {
    if (!popup && !esgst.giveawaysPath && !esgst.enteredPath && !esgst.groupPath && !esgst.userPath) return;

    let type = location.search.match(/type=(wishlist|recommended|group|new)/);
    if (type) {
      type = capitalizeFirstLetter(type[1]);
    } else if (esgst.enteredPath) {
      type = `Entered`;
    } else if (esgst.userPath) {
      type = `User`;
    } else if (esgst.groupPath) {
      type = `Groups`;
    } else if (popup) {
      type = `Popup`
    } else {
      type = ``;
    }
    esgst.gas = {
      autoKey: `gas_auto${type}`,
      mainKey: popup ? `popupGiveaways` : `mainGiveaways`,
      optionKey: `gas_option${type}`
    };

    let object = {
      button: createHeadingButton({context: popup, id: `gas`, icons: [`fa-sort`], title: `Sort giveaways`})
    };
    object.button.addEventListener(`click`, gas_openPopout.bind(null, object));
  }

  function gas_openPopout(obj) {
    if (obj.popout) return;

    obj.popout = new Popout(`esgst-gas-popout`, obj.button, 0, true);
    new ToggleSwitch(obj.popout.popout, esgst.gas.autoKey, false, `Auto Sort`, false, false, `Automatically sorts the giveaways by the selected option when loading the page.`, esgst[esgst.gas.autoKey]);
    let options = insertHtml(obj.popout.popout, `beforeEnd`, `
      <select>
        <option value="sortIndex_asc">Default</option>
        <option value="name_asc">Game Name - Ascending</option>
        <option value="name_desc">Game Name - Descending</option>
      ${!esgst.enteredPath ? `
        <option value="points_asc">Points - Ascending</option>
        <option value="points_desc">Points - Descending</option>
      ` : ``}
      ${esgst.gc && esgst.gc_r && !esgst.enteredPath ? `
        <option value="rating_asc">Rating - Ascending</option>
        <option value="rating_desc">Rating - Descending</option>
      ` : ``}
        <option value="endTime_asc">End Time - Ascending</option>
        <option value="endTime_desc">End Time - Descending</option>
      ${!esgst.enteredPath ? `
        <option value="startTime_asc">Start Time - Ascending</option>
        <option value="startTime_desc">Start Time - Descending</option>
        <option value="creator_asc">Creator - Ascending</option>
        <option value="creator_desc">Creator - Descending</option>
        <option value="comments_asc">Comments - Ascending</option>
        <option value="comments_desc">Comments - Descending</option>
      ` : ``}
        <option value="entries_asc">Entries - Ascending</option>
        <option value="entries_desc">Entries - Descending</option>
      ${esgst.gwc ? `
        <option value="chance_asc">Chance - Ascending</option>
        <option value="chance_desc">Chance - Descending</option>
        <option value="chancePerPoint_asc">Chance Per Point - Ascending</option>
        <option value="chancePerPoint_desc">Chance Per Point - Descending</option>
      ` : ``}
      ${esgst.gwr ? `
        <option value="ratio_asc">Ratio - Ascending</option>
        <option value="ratio_desc">Ratio - Descending</option>
      ` : ``}
      </select>
    `);
    options.value = esgst[esgst.gas.optionKey];
    let callback = saveAndSortContent.bind(null, esgst.gas.optionKey, esgst.gas.mainKey, options, null);
    options.addEventListener(`change`, callback);
    obj.popout.popout.appendChild(new ButtonSet_v2({color1: `green`, color2: ``, icon1: `fa-arrow-circle-right`, icon2: ``, title1: `Sort`, title2: ``, callback1: callback}).set);
    obj.popout.open();
  }

  // [GB]

  _MODULES.push({
    description: `
      <ul>
        <li>Adds a button (<i class="fa fa-bookmark"></i> if the giveaway is bookmarked and <i class="fa fa-bookmark-o"></i> if it is not) next to a giveaway's game name (in any page) that allows you to bookmark the giveaway so that you can enter it later.</li>
        <li>Adds a button (<i class="fa fa-bookmark"></i>) next to the ESGST button at the header of any page that allows you to view all of the giveaways that have been bookmarked.</li>
      </ul>
    `,
    features: {
      gb_u: {
        name: `Automatically unbookmark ended giveaways.`,
        sg: true
      },
      gb_ue: {
        name: `Automatically unbookmark entered giveaways.`,
        sg: true
      },
      gb_h: {
        description: `
          <ul>
            <li>Giveaways that have not started yet will not appear in the list of bookmarked giveaways. Instead, they will stay in a sort of hidden state until they start. When they start, the button will turn green, indicating that you must open the list of bookmarked giveaways so that the started giveaways can be updated with their end times.</li>
            <li>When giveaways are about to end (based on the number of hours specified below), the button will turn red.</li>
            <li>If there are both started and ending giveaways, the button will be colored with a brown-ish color, as a mixture of the green and red colors.</li>
            <li>If you hover over the button, it shows more details about how many giveaways have started and/or are ending.</li>
          </ul>
        `,
        inputItems: [
          {
            id: `gb_hours`,
            prefix: `Time range to trigger highlight: `,
            suffix: ` hours`
          }
        ],
        name: `Highlight the header button when giveaways have started and/or are about to end.`,
        sg: true
      },
      gb_t: {
        name: `Open the list of bookmarked giveaways in a new tab.`,
        sg: true
      },
      gb_se: {
        name: `Show the button for entered giveaways.`,
        sg: true
      }
    },
    id: `gb`,
    load: gb,
    name: `Giveaway Bookmarks`,
    sg: true,
    type: `giveaways`
  });

  function gb() {
    esgst.giveawayFeatures.push(gb_getGiveaways);
    let button = null;
    if (!esgst.gbPath) {
      button = insertHtml(document.getElementsByClassName(`nav__left-container`)[0], `beforeEnd`, `
        <div class="nav__button-container esgst-hidden" title="${getFeatureTooltip(`gb`, `View your bookmarked giveaways`)}">
          <div class="nav__button">
            <i class="fa fa-bookmark"></i>
          </div>
        </div>
      `);
    }
    gb_addButton(button);
    if (esgst.gb_ue && esgst.enterGiveawayButton) {
      esgst.enterGiveawayButton.onclick = () => {
        let giveaway = esgst.mainGiveaways[0];
        if (giveaway && giveaway.gbButton) {
          if (giveaway.gbButton.index === 3) {
            giveaway.gbButton.change(giveaway.gbButton.callbacks[2]);
          }
          if (!esgst.gb_se) {
            giveaway.gbButton.button.classList.add(`esgst-hidden`);
          }
        }
      };
    }
    if (esgst.leaveGiveawayButton) {
      esgst.leaveGiveawayButton.onclick = () => {
        let giveaway = esgst.mainGiveaways[0];
        if (giveaway && giveaway.gbButton) {
          giveaway.gbButton.button.classList.remove(`esgst-hidden`);
        }
      };
    }
  }

  async function gb_addButton(button) {
    let i, n;
    let bookmarked = [], endingSoon = 1, started = 0, ending = 0;
    if (esgst.gb_h && button) {
      button.classList.add(`esgst-gb-highlighted`);
    }
    for (let key in esgst.giveaways) {
      const giveaway = esgst.giveaways[key];
      if (giveaway.bookmarked) {
        if (typeof giveaway.started === `undefined`) {
          giveaway.started = true;
          esgst.edited.giveaways = true;
        }
        if (Date.now() >= giveaway.endTime || !giveaway.endTime) {
          if (giveaway.started) {
            if (esgst.gb_u) {
              delete giveaway.bookmarked;
              esgst.edited.giveaways = true;
            } else {
              bookmarked.push(giveaway);
            }
          } else {
            bookmarked.push(giveaway);
            ++started;
            if (esgst.gb_h && button) {
              button.classList.add(`started`);
            }
          }
        } else {
          if (giveaway.started) {
            bookmarked.push(giveaway);
            endingSoon = giveaway.endTime - Date.now() - (esgst.gb_hours * 3600000);
            if (endingSoon <= 0) {
              ++ending;
            }
          }
        }
      }
    }
    let title;
    if (started || ending) {
      if (started) {
        if (ending) {
          title = `(${started} started - click to update them, ${ending} ending)`;
        } else {
          title = `(${started} started - click to update them)`;
        }
      } else {
        title = `(${ending} ending)`;
      }
    } else {
      title = ``;
    }
    if (button) {
      button.title = getFeatureTooltip(`gb`, `View your bookmarked giveaways ${title}`);
    }
    if (bookmarked.length) {
      bookmarked.sort((a, b) => {
        if (a.endTime > b.endTime) {
          return 1;
        } else if (a.endTime < b.endTime) {
          return -1;
        } else {
          return 0;
        }
      });
      for (i = 0, n = bookmarked.length; i < n; ++i) {
        if (Date.now() > bookmarked[i].endTime) {
          bookmarked.push(bookmarked.splice(i, 1)[0]);
          i -= 1;
          n -= 1;
        }
      }
      if (button) {
        button.classList.remove(`esgst-hidden`);
        if (esgst.gb_h && ending > 0) {
          button.classList.add(`ending`);
        }
      }
    }
    if (esgst.gbPath) {
      gb_loadGibs(bookmarked, esgst.mainContext, insertHtml(esgst.mainContext, `beforeEnd`, `<div></div>`));
    }
    if (!esgst.gbPath && button) {
      button.addEventListener(`mousedown`, event => {
        if (event.button === 2) return;
        event.preventDefault();
        if (esgst.gb_t || event.button === 1) {
          open(`/esgst/bookmarked-giveaways`);
        } else {
          let popup = new Popup(`fa-bookmark`, `Bookmarked Giveaways`, true);
          gb_loadGibs(bookmarked, popup.description, popup.scrollable, popup);
        }
      });
    }
  }

  function gb_loadGibs(bookmarked, container, context, popup) {
    let info;
    let i = 0;
    let n = bookmarked.length;
    let gbGiveaways = insertHtml(context, `beforeEnd`, `<div class="esgst-text-left"></div>`);
    let set = new ButtonSet(`green`, `grey`, `fa-plus`, `fa-circle-o-notch fa-spin`, `Load more...`, `Loading more...`, callback => {
      gb_loadGiveaways(i, i + 5, bookmarked, gbGiveaways, info, popup, value => {
        i = value;
        if (i > n) {
          set.set.remove();
        } else if (esgst.es_gb && context.scrollHeight <= context.offsetHeight) {
          set.trigger();
        }
        callback();
      });
    });
    container.insertBefore(new ButtonSet_v2({color1: `grey`, color2: ``, icon1: `fa-list`, icon2: ``, title1: `View Raw List`, title2: ``, callback1: gb_openList.bind(null, {bookmarked})}).set, context);
    container.insertBefore(set.set, context);
    if (popup) {
      popup.open();
    }
    info = insertHtml(context, `beforeBegin`, `
      <div>
        <span>0</span>P required to enter all <span>0</span> giveaways.
      </div>
    `);
    if (esgst.gas || (esgst.gf && esgst.gf_m) || esgst.mm) {
      let heading = insertHtml(context, `beforeBegin`, `
        <div class="page__heading"></div>
      `);
      if (esgst.gas) {
        gas(heading);
      }
      if (esgst.gf && esgst.gf_m) {
        heading.appendChild(filters_addContainer(`gf`, heading, `Gb`));
      }
      if (esgst.mm) {
        mm(heading);
      }
    }
    set.trigger();
    if (esgst.es_gb) {
      context.addEventListener(`scroll`, () => {
        if ((context.scrollTop + context.offsetHeight) >= context.scrollHeight && !set.busy) {
          set.trigger();
        }
      });
    }
  }

  function gb_openList(gb) {
    if (gb.popup) {
      gb.popup.open();
      return;
    }
    gb.popup = new Popup(`fa-list`, `Bookmarked Giveaways (Raw List)`);
    gb.bookmarked.forEach(giveaway => {
      gb.popup.scrollable.insertAdjacentHTML(`beforeEnd`, `
        <div>
          <a class="table__column__secondary-link"${giveaway.name ? ` data-esgst="true"` : ``} href="/giveaway/${giveaway.code}/">${giveaway.name || giveaway.code}</a>
        </div>
      `);
    });
    gb.popup.open();
    gb_loadNames(gb);
  }

  async function gb_loadNames(gb) {
    let giveaways = {};
    for (let i = 0, n = gb.popup.scrollable.children.length; i < n; i++) {
      let element = gb.popup.scrollable.children[i].firstElementChild;
      if (!element.getAttribute(`data-esgst`)) {
        let code = element.textContent;
        element.textContent = parseHtml((await request({method: `GET`, queue: true, url: element.getAttribute(`href`)})).responseText).getElementsByClassName(`featured__heading__medium`)[0].textContent;
        giveaways[code] = {
          name: element.textContent
        };
      }
    }
    lockAndSaveGiveaways(giveaways);
  }

  async function gb_loadGiveaways(i, n, bookmarked, gbGiveaways, info, popup, callback) {
    if (i < n) {
      if (bookmarked[i]) {
        let response = await request({method: `GET`, queue: true, url: `/giveaway/${bookmarked[i].code}/`});
        let endTime;
        let responseHtml = parseHtml(response.responseText);
        let container = responseHtml.getElementsByClassName(`featured__outer-wrap--giveaway`)[0];
        if (container) {
          let heading = responseHtml.getElementsByClassName(`featured__heading`)[0];
          let columns = heading.nextElementSibling;
          let remaining = columns.firstElementChild;
          endTime = 0;
          if (!bookmarked[i].started && !remaining.textContent.match(/Begins/)) {
            endTime = parseInt(remaining.lastElementChild.getAttribute(`data-timestamp`)) * 1e3;
          }
          let url = response.finalUrl;
          let gameId = container.getAttribute(`data-game-id`);
          let anchors = heading.getElementsByTagName(`a`);
          let j, numA, numT;
          for (j = 0, numA = anchors.length; j < numA; ++j) {
            anchors[j].classList.add(`giveaway__icon`);
          }
          let headingName = heading.firstElementChild;
          headingName.outerHTML = `<a class="giveaway__heading__name" href="${url}">${headingName.innerHTML}</a>`;
          let thinHeadings = heading.getElementsByClassName(`featured__heading__small`);
          numT = thinHeadings.length
          info.firstElementChild.textContent = parseInt(info.firstElementChild.textContent) + parseInt(thinHeadings[numT - 1].textContent.match(/\d+/)[0]);
          info.lastElementChild.textContent = parseInt(info.lastElementChild.textContent) + 1;
          for (j = 0; j < numT; ++j) {
            thinHeadings[0].outerHTML = `<span class="giveaway__heading__thin">${thinHeadings[0].innerHTML}</span>`;
          }
          remaining.classList.remove(`featured__column`);
          let created = remaining.nextElementSibling;
          created.classList.remove(`featured__column`, `featured__column--width-fill`);
          created.classList.add(`giveaway__column--width-fill`);
          created.lastElementChild.classList.add(`giveaway__username`);
          let avatar = columns.lastElementChild;
          avatar.remove();
          let element = created.nextElementSibling;
          while (element) {
            element.classList.remove(`featured__column`);
            element.className = element.className.replace(/featured/g, `giveaway`);
            element = element.nextElementSibling;
          }
          let counts = responseHtml.getElementsByClassName(`sidebar__navigation__item__count`);
          let image = responseHtml.getElementsByClassName(`global__image-outer-wrap--game-large`)[0].firstElementChild.getAttribute(`src`);
          let entered = responseHtml.getElementsByClassName(`sidebar__entry-delete`)[0];
          if (entered) {
            entered = !entered.classList.contains(`is-hidden`);
          }
          let popupHtml = `${Date.now() > bookmarked[i].endTime && !gbGiveaways.getElementsByClassName(`row-spacer`)[0] ? `<div class="row-spacer"></div>` : ``}
            <div>
              <div class="giveaway__row-outer-wrap" ${entered ? `data-entered="true"` : ``}data-game-id="${gameId}">
                <div class="giveaway__row-inner-wrap">
                  <div class="giveaway__summary">
                    <h2 class="giveaway__heading">${heading.innerHTML}</h2>
                    <div class="giveaway__columns">${columns.innerHTML}</div>
                    <div class="giveaway__links">
                      <a href="${url}/entries">
                        <i class="fa fa-tag"></i>
                        <span>${(counts[1] && counts[1].textContent) || 0} entries</span>
                      </a>
                      <a href="${url}/comments">
                        <i class="fa fa-comment"></i>
                        <span>${counts[0].textContent} comments</span>
                      </a>
                    </div>
                  </div>
                  ${avatar.outerHTML}
                  <a class="giveaway_image_thumbnail" href="${url}" style="background-image: url(${image})"></a>
                </div>
              </div>
            </div>
          `;
          gbGiveaways.insertAdjacentHTML(`beforeEnd`, popupHtml);
          await endless_load(gbGiveaways.lastElementChild, false, `gb`);
          if (endTime > 0) {
            let deleteLock = await createLock(`giveawayLock`, 300);
            let giveaways = JSON.parse(await getValue(`giveaways`));
            giveaways[bookmarked[i].code].started = true;
            giveaways[bookmarked[i].code].endTime = endTime;
            await setValue(`giveaways`, JSON.stringify(giveaways));
            deleteLock();
            setTimeout(() => gb_loadGiveaways(++i, n, bookmarked, gbGiveaways, info, popup, callback), 0);
          } else {
            setTimeout(() => gb_loadGiveaways(++i, n, bookmarked, gbGiveaways, info, popup, callback), 0);
          }
        } else {
          setTimeout(() => gb_loadGiveaways(++i, n, bookmarked, gbGiveaways, info, popup, callback), 0);
        }
      } else {
        callback(i + 1);
      }
    } else {
      callback(i);
    }
  }

  function gb_getGiveaways(giveaways, main) {
    giveaways.forEach(giveaway => {
      if (main && esgst.wonPath) return;
      if ((!main || !esgst.archivePath) && giveaway.creator !== esgst.username && giveaway.url && !giveaway.gbButton) {
        giveaway.gbButton = new Button(giveaway.headingName, `beforeBegin`, {
          callbacks: [gb_bookmarkGiveaway.bind(null, giveaway, main), null, gb_unbookmarkGiveaway.bind(null, giveaway, main), null],
          className: `esgst-gb-button`,
          icons: [`fa-bookmark-o esgst-clickable`, `fa-circle-o-notch fa-spin`, `fa-bookmark`, `fa-circle-o-notch fa-spin`],
          id: `gb`,
          index: esgst.giveaways[giveaway.code] && esgst.giveaways[giveaway.code].bookmarked ? 2 : 0,
          titles: [`Bookmark giveaway`, `Bookmarking giveaway...`, `Unbookmark giveaway`, `Unbookmarking giveaway...`]
        });
        if ((giveaway.entered || (esgst.enteredPath && main)) && !esgst.gb_se) {
          giveaway.gbButton.button.classList.add(`esgst-hidden`);
        }
      }
    });
  }

  async function gb_bookmarkGiveaway(giveaway) {
    let deleteLock = await createLock(`giveawayLock`, 300);
    let giveaways = JSON.parse(await getValue(`giveaways`, `{}`));
    if (!giveaways[giveaway.code]) {
      giveaways[giveaway.code] = {};
    }
    giveaways[giveaway.code].code = giveaway.code;
    giveaways[giveaway.code].endTime = giveaway.endTime;
    giveaways[giveaway.code].name = giveaway.name;
    giveaways[giveaway.code].started = giveaway.started;
    giveaways[giveaway.code].bookmarked = true;
    await setValue(`giveaways`, JSON.stringify(giveaways));
    deleteLock();
    return true;
  }

  async function gb_unbookmarkGiveaway(giveaway) {
    let deleteLock = await createLock(`giveawayLock`, 300);
    let giveaways = JSON.parse(await getValue(`giveaways`, `{}`));
    if (giveaways[giveaway.code]) {
      delete giveaways[giveaway.code].bookmarked;
    }
    await setValue(`giveaways`, JSON.stringify(giveaways));
    deleteLock();
    return true;
  }

  // [GC]

  _MODULES.push({
    description: `
      <ul>
        <li>Adds tags (which are called "categories" not to be confused with [id=gt]) below a game's name (in any page) that can display a lot of useful information about the game (depending on which categories you have enabled).</li>
        <li>The categories can be reordered by dragging and dropping them. You can also drag and drop them between a giveaway's columns (where the end/start times and the creator's username are).</li>
      </ul>
    `,
    features: {
      gc_lp: {
        description: `
          <ul>
            <li>"Achievements" links to the <a href="http://steamcommunity.com/stats">http://steamcommunity.com/stats</a> page of the game.</li>
            <li>"Full CV", "Reduced CV" and "No CV" link to the <a href="https://www.steamgifts.com/bundle-games">https://www.steamgifts.com/bundle-games</a> page of the game.</li>
            <li>"Giveaway Info" links to your profile page.</li>
            <li>"Hidden" links to the <a href="https://www.steamgifts.com/account/settings/giveaways/filters">https://www.steamgifts.com/account/settings/giveaways/filters</a> page of the game.</li>
            <li>"Owned" links to the <a href="https://www.steamgifts.com/account/steam/games">https://www.steamgifts.com/account/steam/games</a> page of the game.</li>
            <li>"Removed" links to the <a href="http://steamdb.info">http://steamdb.info</a> page of the game.</li>
            <li>"Trading Cards" links to the <a href="http://www.steamcardexchange.net/index.php">http://www.steamcardexchange.net/index.php</a> page of the game.</li>
            <li>"Wishlist" links to the <a href="https://www.steamgifts.com/account/steam/wishlist">https://www.steamgifts.com/account/steam/wishlist</a> page of the game.</li>
            <li>Every other category links to the <a href="http://store.steampowered.com">http://store.steampowered.com</a> page of the game.</li>
          </ul>
        `,
        features: {
          gc_lp_gv: {
            name: `Enable for Grid View.`,
            sg: true
          }
        },
        name: `Link each category to its related page.`,
        sg: true
      },
      gc_b: {
        name: `Show the category colors as a bottom border to the giveaways in Grid View.`,
        sg: true
      },
      gc_il: {
        name: `Show the panel inline (next to the game's name instead of below it).`,
        sg: true
      },
      gc_a: {
        colors: true,
        description: `
          <ul>
            <li>Shows if the game has achievements.</li>
            <li>If you hover over the category, it shows how many achievements the game has.</li>
          </ul>
        `,
        features: {
          gc_a_s: {
            description: `
              <ul>
                <li>Shows the category initials instead of its full name.</li>
                <li>Not compatible with custom labels.</li>
              </ul>
            `,
            features: {
              gc_a_s_i: {
                name: `Use icons instead of initials.`,
                sg: true
              }
            },
            name: `Enable the simplified version.`,
            sg: true
          }
        },
        input: true,
        name: `Achievements`,
        sg: true
      },
      gc_dlc: {
        colors: true,
        description: `
          <ul>
            <li>Shows if the game is a DLC.</li>
          </ul>
        `,
        features: {
          gc_dlc_s: {
            description: `
              <ul>
                <li>Shows the category initials instead of its full name.</li>
                <li>Not compatible with custom labels.</li>
              </ul>
            `,
            features: {
              gc_dlc_s_i: {
                name: `Use icons instead of initials.`,
                sg: true
              }
            },
            name: `Enable the simplified version.`,
            sg: true
          },
          gc_dlc_b: {
            description: `
              <ul>
                <li>The icon <i class="fa fa-certificate"></i> will be added if the base is free, the icon <i class="fa fa-dollar"></i> will be added if it is not, and no icon will be added if the information is unavailable.</li>
              </ul>
            `,
            name: `Indicate if the base game of the DLC is free.`,
            sg: true
          },
          gc_dlc_o: {
            description: `
              <ul>
                <li>The same icon you use for the Owned category will be added if the base is owned.</li>
              </ul>
            `,
            name: `Indicate if the base game of the DLC is owned.`,
            sg: true
          }
        },
        input: true,
        name: `DLC`,
        sg: true
      },
      gc_ea: {
        colors: true,
        description: `
          <ul>
            <li>Shows if the game is in early access.</li>
          </ul>
        `,
        features: {
          gc_ea_s: {
            description: `
              <ul>
                <li>Shows the category initials instead of its full name.</li>
                <li>Not compatible with custom labels.</li>
              </ul>
            `,
            features: {
              gc_ea_s_i: {
                name: `Use icons instead of initials.`,
                sg: true
              }
            },
            name: `Enable the simplified version.`,
            sg: true
          }
        },
        input: true,
        name: `Early Access`,
        sg: true
      },
      gc_fcv: {
        colors: true,
        description: `
          <ul>
            <li>Shows if the game gives full CV when given away.</li>
          </ul>
        `,
        features: {
          gc_fcv_s: {
            description: `
              <ul>
                <li>Shows the category initials instead of its full name.</li>
                <li>Not compatible with custom labels.</li>
              </ul>
            `,
            features: {
              gc_fcv_s_i: {
                name: `Use icons instead of initials.`,
                sg: true
              }
            },
            name: `Enable the simplified version.`,
            sg: true
          }
        },
        input: true,
        name: `Full CV`,
        sg: true
      },
      gc_g: {
        colors: true,
        description: `
          <ul>
            <li>Shows the official genres of the game.</li>
            <li>The genres/user-defined tags are listed in the same category, separated by a comma. If they exceed a certain width, a "..." is added and the rest is hidden (they can be seen by hovering over the category).</li>
          </ul>
        `,
        features: {
          gc_g_s: {
            description: `
              <ul>
                <li>With this option enabled, each genre/user-defined tag will have its own category instead of all of them being listed in the same one.</li>
                <li>This option allows each separate category to be colored individually.</li>
              </ul>
            `,
            name: `Show each genre/user-defined tag as a separate category.`,
            sg: true
          },
          gc_g_udt: {
            description: `
              <ul>
                <li>Shows the user-defined tags that the game has in addition to the official genres.</li>
              </ul>
            `,
            name: `User-Defined Tags`,
            sg: true
          }
        },
        name: `Genres`,
        sg: true
      },
      gc_gi: {
        colors: true,
        description: `
          <ul>
            <li>Shows how many giveaways you have already made for the game and how much real CV you should get for a new giveaway.</li>
          </ul>
        `,
        name: `Giveaway Info`,
        sg: true
      },
      gc_h: {
        colors: true,
        description: `
          <ul>
            <li>Shows if you have hidden the game on SteamGifts.</li>
          </ul>
        `,
        features: {
          gc_h_s: {
            description: `
              <ul>
                <li>Shows the category initials instead of its full name.</li>
                <li>Not compatible with custom labels.</li>
              </ul>
            `,
            features: {
              gc_h_s_i: {
                name: `Use icons instead of initials.`,
                sg: true
              }
            },
            name: `Enable the simplified version.`,
            sg: true
          }
        },
        input: true,
        name: `Hidden`,
        sg: true
      },
      gc_i: {
        colors: true,
        description: `
          <ul>
            <li>Shows if you have ignored the game on Steam.</li>
          </ul>
        `,
        features: {
          gc_i_s: {
            description: `
              <ul>
                <li>Shows the category initials instead of its full name.</li>
                <li>Not compatible with custom labels.</li>
              </ul>
            `,
            features: {
              gc_i_s_i: {
                name: `Use icons instead of initials.`,
                sg: true
              }
            },
            name: `Enable the simplified version.`,
            sg: true
          }
        },
        input: true,
        name: `Ignored`,
        sg: true
      },
      gc_l: {
        colors: true,
        description: `
          <ul>
            <li>Shows if the game is compatible with Linux.</li>
          </ul>
        `,
        features: {
          gc_l_s: {
            description: `
              <ul>
                <li>Shows the category initials instead of its full name.</li>
                <li>Not compatible with custom labels.</li>
              </ul>
            `,
            features: {
              gc_l_s_i: {
                name: `Use icons instead of initials.`,
                sg: true
              }
            },
            name: `Enable the simplified version.`,
            sg: true
          }
        },
        input: true,
        name: `Linux`,
        sg: true
      },
      gc_m: {
        colors: true,
        description: `
          <ul>
            <li>Shows if the game is compatible with Mac.</li>
          </ul>
        `,
        features: {
          gc_m_s: {
            description: `
              <ul>
                <li>Shows the category initials instead of its full name.</li>
                <li>Not compatible with custom labels.</li>
              </ul>
            `,
            features: {
              gc_m_s_i: {
                name: `Use icons instead of initials.`,
                sg: true
              }
            },
            name: `Enable the simplified version.`,
            sg: true
          }
        },
        input: true,
        name: `Mac`,
        sg: true
      },
      gc_mp: {
        colors: true,
        description: `
          <ul>
            <li>Shows if the game is multiplayer.</li>
          </ul>
        `,
        features: {
          gc_mp_s: {
            description: `
              <ul>
                <li>Shows the category initials instead of its full name.</li>
                <li>Not compatible with custom labels.</li>
              </ul>
            `,
            features: {
              gc_mp_s_i: {
                name: `Use icons instead of initials.`,
                sg: true
              }
            },
            name: `Enable the simplified version.`,
            sg: true
          }
        },
        input: true,
        name: `Multiplayer`,
        sg: true
      },
      gc_ncv: {
        colors: true,
        description: `
          <ul>
            <li>Shows if the game gives no CV when given away.</li>
            <li>If you hover over the category, it shows the date since it gives no CV.</li>
          </ul>
        `,
        features: {
          gc_ncv_s: {
            description: `
              <ul>
                <li>Shows the category initials instead of its full name.</li>
                <li>Not compatible with custom labels.</li>
              </ul>
            `,
            features: {
              gc_ncv_s_i: {
                name: `Use icons instead of initials.`,
                sg: true
              }
            },
            name: `Enable the simplified version.`,
            sg: true
          },
          gc_ncv_o: {
            name: `Only display "No CV" if the game also has "Reduced CV".`,
            sg: true
          }
        },
        input: true,
        name: `No CV`,
        sg: true
      },
      gc_o: {
        colors: true,
        description: `
          <ul>
            <li>Shows if you own the game.</li>
          </ul>
        `,
        features: {
          gc_o_s: {
            description: `
              <ul>
                <li>Shows the category initials instead of its full name.</li>
                <li>Not compatible with custom labels.</li>
              </ul>
            `,
            features: {
              gc_o_s_i: {
                name: `Use icons instead of initials.`,
                sg: true
              }
            },
            name: `Enable the simplified version.`,
            sg: true
          },
          gc_o_a: {
            name: `Show if you own the game in any of your alt accounts.`,
            sg: true
          }
        },
        input: true,
        name: `Owned`,
        sg: true
      },
      gc_p: {
        colors: true,
        description: `
          <ul>
            <li>Shows if the game is a package.</li>
            <li>If you hover over the category, it shows how many items are contained in the package.</li>
          </ul>
        `,
        features: {
          gc_p_s: {
            description: `
              <ul>
                <li>Shows the category initials instead of its full name.</li>
                <li>Not compatible with custom labels.</li>
              </ul>
            `,
            features: {
              gc_p_s_i: {
                name: `Use icons instead of initials.`,
                sg: true
              }
            },
            name: `Enable the simplified version.`,
            sg: true
          }
        },
        input: true,
        name: `Package`,
        sg: true
      },
      gc_pw: {
        colors: true,
        description: `
          <ul>
            <li>Shows if you have previously won the game.</li>
          </ul>
        `,
        features: {
          gc_pw_o: {
            name: `Do not show if the game already has the Owned category.`,
            sg: true
          },
          gc_pw_s: {
            description: `
              <ul>
                <li>Shows the category initials instead of its full name.</li>
                <li>Not compatible with custom labels.</li>
              </ul>
            `,
            features: {
              gc_pw_s_i: {
                name: `Use icons instead of initials.`,
                sg: true
              }
            },
            name: `Enable the simplified version.`,
            sg: true
          }
        },
        input: true,
        name: `Previously Won`,
        sg: true
      },
      gc_r: {
        description: `
          <ul>
            <li>Shows the overall rating that the game has on Steam.</li>
          </ul>
        `,
        features: {
          gc_r_s: {
            name: `Show the percentage and number of reviews next to the icon.`,
            sg: true
          }
        },
        name: `Rating`,
        sg: true
      },
      gc_rcv: {
        colors: true,
        description: `
          <ul>
            <li>Shows if the game gives reduced CV when given away.</li>
            <li>If you hover over the category, it shows the date since it gives reduced CV.</li>
          </ul>
        `,
        features: {
          gc_rcv_s: {
            description: `
              <ul>
                <li>Shows the category initials instead of its full name.</li>
                <li>Not compatible with custom labels.</li>
              </ul>
            `,
            features: {
              gc_rcv_s_i: {
                name: `Use icons instead of initials.`,
                sg: true
              }
            },
            name: `Enable the simplified version.`,
            sg: true
          }
        },
        input: true,
        name: `Reduced CV`,
        sg: {include: [{enabled: 1, pattern: `.*`}], exclude: [{enabled: 1, pattern: `^/bundle-games`}]}
      },
      gc_rd: {
        description: `
          <ul>
            <li>Shows the release date of the game.</li>
            <li>If the game has no release date, a "?" will be shown instead.</li>
          </ul>
        `,
        colors: true,
        input: true,
        name: `Release Date`,
        sg: true
      },
      gc_rm: {
        colors: true,
        description: `
          <ul>
            <li>Shows if the game has been removed from the Steam store.</li>
          </ul>
        `,
        features: {
          gc_rm_s: {
            description: `
              <ul>
                <li>Shows the category initials instead of its full name.</li>
                <li>Not compatible with custom labels.</li>
              </ul>
            `,
            features: {
              gc_rm_s_i: {
                name: `Use icons instead of initials.`,
                sg: true
              }
            },
            name: `Enable the simplified version.`,
            sg: true
          }
        },
        input: true,
        name: `Removed`,
        sg: true
      },
      gc_sc: {
        colors: true,
        description: `
          <ul>
            <li>Shows if the game has Steam Cloud.</li>
          </ul>
        `,
        features: {
          gc_sc_s: {
            description: `
              <ul>
                <li>Shows the category initials instead of its full name.</li>
                <li>Not compatible with custom labels.</li>
              </ul>
            `,
            features: {
              gc_sc_s_i: {
                name: `Use icons instead of initials.`,
                sg: true
              }
            },
            name: `Enable the simplified version.`,
            sg: true
          }
        },
        input: true,
        name: `Steam Cloud`,
        sg: true
      },
      gc_tc: {
        colors: true,
        description: `
          <ul>
            <li>Shows if the game has trading cards.</li>
          </ul>
        `,
        features: {
          gc_tc_s: {
            description: `
              <ul>
                <li>Shows the category initials instead of its full name.</li>
                <li>Not compatible with custom labels.</li>
              </ul>
            `,
            features: {
              gc_tc_s_i: {
                name: `Use icons instead of initials.`,
                sg: true
              }
            },
            name: `Enable the simplified version.`,
            sg: true
          }
        },
        input: true,
        name: `Trading Cards`,
        sg: true
      },
      gc_w: {
        colors: true,
        description: `
          <ul>
            <li>Shows if you have wishlisted the game on Steam.</li>
            <li>If you hover over the category, it shows the date when you added the game to your wishlist.</li>
          </ul>
        `,
        features: {
          gc_w_s: {
            description: `
              <ul>
                <li>Shows the category initials instead of its full name.</li>
                <li>Not compatible with custom labels.</li>
              </ul>
            `,
            features: {
              gc_w_s_i: {
                name: `Use icons instead of initials.`,
                sg: true
              }
            },
            name: `Enable the simplified version.`,
            sg: true
          }
        },
        input: true,
        name: `Wishlisted`,
        sg: true
      }
    },
    id: `gc`,
    name: `Game Categories`,
    sg: true,
    sync: `Hidden Games, Owned/Wishlisted/Ignored Games, Reduced CV Games, No CV Games and Giveaways`,
    type: `games`
  });

  async function gc_getGames(games, endless) {
    let gc = {
      apps: Object.keys(games.apps),
      cache: {
        apps: {},
        subs: {}
      },
      subs: Object.keys(games.subs)
    };

    // get categories
    for (let id in games.apps) {
      let elements = games.apps[id];
      for (let i = 0, n = elements.length; i < n; ++i) {
        let element = elements[i];
        if (element.container.getElementsByClassName(`esgst-gc-panel`)[0]) {
          continue;
        }
        if (element.container.closest(`.poll`)) {
          element.container.getElementsByClassName(`table__column__heading`)[0].insertAdjacentHTML(`afterEnd`, `<div class="esgst-gc-panel"></div>`);
        } else {
          element.heading.insertAdjacentHTML(`afterEnd`, `<div class="esgst-gc-panel"></div>`);
        }
      }
    }
    for (let id in games.subs) {
      let elements = games.subs[id];
      for (let i = 0, n = elements.length; i < n; ++i) {
        let element = elements[i];
        if (element.container.getElementsByClassName(`esgst-gc-panel`)[0]) {
          continue;
        }
        if (element.container.closest(`.poll`)) {
          element.container.getElementsByClassName(`table__column__heading`)[0].insertAdjacentHTML(`afterEnd`, `<div class="esgst-gc-panel"></div>`);
        } else {
          element.heading.insertAdjacentHTML(`afterEnd`, `<div class="esgst-gc-panel"></div>`);
        }
      }
    }
    if (esgst.gc_gi || esgst.gc_r || esgst.gc_a || esgst.gc_mp || esgst.gc_sc || esgst.gc_tc || esgst.gc_l || esgst.gc_m || esgst.gc_dlc || esgst.gc_ea || esgst.gc_rm || esgst.gc_rd || esgst.gc_g || esgst.gc_p) {
      gc.cache = JSON.parse(getLocalValue(`gcCache`, `{ "apps": {}, "subs": {}, "timestamp": 0, "version": 3 }`));
      if (gc.cache.version !== 3) {
        gc.cache = {
          apps: {},
          subs: {},
          timestamp: 0,
          version: 3
        };
      }
      let currentTime = Date.now();
      for (let id in gc.cache.apps) {
        if (gc.cache.apps[id].lastCheck) {
          if (currentTime - gc.cache.apps[id].lastCheck > 604800000 || gc.cache.apps[id].price === -1 || (esgst.gc_g_udt && !gc.cache.apps[id].tags) || (esgst.gc_r && !gc.cache.apps[id].rating) || (esgst.gc_rd && gc.cache.apps[id].removed === -1)) {
            delete gc.cache.apps[id];
          }
        } else {
          gc.cache.apps[id].lastCheck = currentTime;
        }
      }
      for (let id in gc.cache.subs) {
        if (gc.cache.subs[id].lastCheck) {
          if (currentTime - gc.cache.subs[id].lastCheck > 604800000 || gc.cache.subs[id].price === -1 || (esgst.gc_g_udt && !gc.cache.subs[id].tags) || (esgst.gc_r && !gc.cache.subs[id].rating) || (esgst.gc_rd && gc.cache.subs[id].removed === -1)) {
            delete gc.cache.subs[id];
          }
        } else {
          gc.cache.subs[id].lastCheck = currentTime;
        }
      }
      setLocalValue(`gcCache`, JSON.stringify(gc.cache));
      let missingApps = [];
      let missingSubs = [];
      for (let i = 0, n = gc.apps.length; i < n; ++i) {
        let id = gc.apps[i];
        if (gc.cache.apps[id] && gc.cache.apps[id].name) {
          continue;
        }
        missingApps.push(id);
      }
      for (let i = 0, n = gc.subs.length; i < n; ++i) {
        let id = gc.subs[i];
        if (gc.cache.subs[id] && gc.cache.subs[id].name) {
          continue;
        }
        missingSubs.push(id);
      }
      let numApps = missingApps.length;
      let numSubs = missingSubs.length;
      if (numApps || numSubs) {
        let promises = [];
        for (let i = 0, n = missingApps.length; i < n; ++i) {
          promises.push(gc_getCategories(gc, missingApps[i], `apps`));
        }
        for (let i = 0, n = missingSubs.length; i < n; ++i) {
          promises.push(gc_getCategories(gc, missingSubs[i], `subs`));
        }
        await Promise.all(promises);
        await lockAndSaveGames(esgst.games);
        setLocalValue(`gcCache`, JSON.stringify(gc.cache));
      }
    }

    // add categories
    let savedGames = JSON.parse(await getValue(`games`));
    for (let i = 0, n = gc.apps.length; i < n; ++i) {
      let id = parseInt(gc.apps[i]);
      gc_addCategory(gc.cache.apps[id], games.apps[id], id, savedGames.apps[id], savedGames, `apps`);
    }
    for (let i = 0, n = gc.subs.length; i < n; ++i) {
      let id = parseInt(gc.subs[i]);
      gc_addCategory(gc.cache.subs[id], games.subs[id], id, savedGames.subs[id], savedGames, `subs`);
    }
    let categories = [`achievements`, `dlc`, `dlcOwned`, `dlcFree`, `dlcNonFree`, `genres`, `linux`, `mac`, `multiplayer`, `package`, `rating`, `removed`, `steamCloud`, `tradingCards`, `earlyAccess`, `releaseDate`];
    for (let i = 0, n = esgst.mainGiveaways.length; i < n; ++i) {
      let giveaway = esgst.mainGiveaways[i];
      if (giveaway.gcReady || !giveaway.outerWrap.querySelector(`[data-gcReady]`)) {
        continue;
      }
      for (let j = 0, numCategories = categories.length; j < numCategories; ++j) {
        let id = categories[j];
        let category = giveaway.outerWrap.getElementsByClassName(`esgst-gc-${id}`)[0];
        if (category) {
          if (id === `releaseDate`) {
            giveaway.releaseDate = category.getAttribute(`data-timestamp`);
            if (giveaway.releaseDate === `?`) {
              giveaway.releaseDate = -1;
            } else {
              giveaway.releaseDate = parseInt(giveaway.releaseDate) * 1e3;
            }
          } else if (id === `genres`) {
            giveaway.genres = category.textContent.toLowerCase().trim().replace(/\s{2,}/g, `, `).split(/,\s/);
          } else if (id === `rating`) {
            giveaway.rating = parseInt(category.title.match(/(\d+)%/)[1]);
          } else {
            giveaway[id] = true;
          }
        } else if (id === `rating`) {
          giveaway.rating = -1;
        } else if (id === `releaseDate`) {
          giveaway.releaseDate = -1;
        }
      }
      if (giveaway.grid && esgst.gc_b) {
        let borders = insertHtml(giveaway.outerWrap, `beforeEnd`, `<div class="esgst-gc-border"></div>`);
        let categoryNames = {
          gc_fcv: `fullCV`,
          gc_rcv: `reducedCV`,
          gc_ncv: `noCV`,
          gc_h: `hidden`,
          gc_i: `ignored`,
          gc_o: `owned`,
          gc_w: `wishlisted`,
          gc_pw: `won`,
          gc_a: `achievements`,
          gc_mp: `multiplayer`,
          gc_sc: `steamCloud`,
          gc_tc: `tradingCards`,
          gc_l: `linux`,
          gc_m: `mac`,
          gc_ea: `earlyAccess`,
          gc_rm: `removed`,
          gc_dlc: `dlc`,
          gc_p: `package`
        };
        esgst.gc_categories_gv.forEach(category => {
          if (categoryNames[category] && giveaway.innerWrap.getElementsByClassName(`esgst-gc-${categoryNames[category]}`)[0]) {
            borders.insertAdjacentHTML(`beforeEnd`, `<div class="esgst-gc-${categoryNames[category]}"></div>`);
          }
        });
      }
      giveaway.gcReady = true;
    }
    for (let i = 0, n = esgst.popupGiveaways.length; i < n; ++i) {
      let giveaway = esgst.popupGiveaways[i];
      if (giveaway.gcReady || !giveaway.outerWrap.querySelector(`[data-gcReady]`)) {
        continue;
      }
      for (let j = 0, numCategories = categories.length; j < numCategories; ++j) {
        let id = categories[j];
        let category = giveaway.outerWrap.getElementsByClassName(`esgst-gc-${id}`)[0];
        if (category) {
          if (id === `genres`) {
            giveaway.genres = category.textContent.toLowerCase().trim().replace(/\s{2,}/g, `, `).split(/,\s/);
          } else if (id === `rating`) {
            giveaway.rating = parseInt(category.title.match(/(\d+)%/)[1]);
          } else {
            giveaway[id] = true;
          }
        } else if (id === `rating`) {
          giveaway.rating = 0;
        }
      }
      if (giveaway.grid && esgst.gc_b) {
        let borders = insertHtml(giveaway.outerWrap, `beforeEnd`, `<div class="esgst-gc-border"></div>`);
        let categoryNames = {
          gc_fcv: `fullCV`,
          gc_rcv: `reducedCV`,
          gc_ncv: `noCV`,
          gc_h: `hidden`,
          gc_i: `ignored`,
          gc_o: `owned`,
          gc_w: `wishlisted`,
          gc_pw: `won`,
          gc_a: `achievements`,
          gc_mp: `multiplayer`,
          gc_sc: `steamCloud`,
          gc_tc: `tradingCards`,
          gc_l: `linux`,
          gc_m: `mac`,
          gc_ea: `earlyAccess`,
          gc_rm: `removed`,
          gc_dlc: `dlc`,
          gc_p: `package`
        };
        esgst.gc_categories_gv.forEach(category => {
          if (categoryNames[category] && giveaway.innerWrap.getElementsByClassName(`esgst-gc-${categoryNames[category]}`)[0]) {
            borders.insertAdjacentHTML(`beforeEnd`, `<div class="esgst-gc-${categoryNames[category]}"></div>`);
          }
        });
      }
      giveaway.gcReady = true;
    }
    if (esgst.gf && esgst.gf.filteredCount && esgst[`gf_enable${esgst.gf.type}`]) {
      filters_filter(esgst.gf, false, endless);
    }
    if (esgst.gfPopup && esgst.gfPopup.filteredCount && esgst[`gf_enable${esgst.gfPopup.type}`]) {
      filters_filter(esgst.gfPopup);
    }
  }

  async function gc_getCategories(gc, id, type) {
    try {
      let categories = {
        achievements: 0,
        dlc: 0,
        earlyAccess: 0,
        genres: ``,
        linux: 0,
        mac: 0,
        multiplayer: 0,
        name: ``,
        price: -1,
        rating: ``,
        ratingType: ``,
        releaseDate: `?`,
        removed: -1,
        steamCloud: 0,
        tags: ``,
        tradingCards: 0
      };
      let responseJson = JSON.parse((await request({method: `GET`, url: `http://store.steampowered.com/api/${type === `apps` ? `appdetails?appids=` : `packagedetails?packageids=`}${id}&filters=achievements,apps,basic,categories,genres,name,packages,platforms,price,price_overview,release_date&cc=us&l=en`})).responseText);
      let data;
      if (responseJson && responseJson[id]) {
        data = responseJson[id].data;
        if (data) {
          if (type === `apps` && data.packages) {
            if (!esgst.games.apps[id]) {
              esgst.games.apps[id] = {};
            }
            esgst.games.apps[id].packages = data.packages.map(x => parseInt(x));
          }
          if (type === `subs` && data.apps) {
            if (!esgst.games.subs[id]) {
              esgst.games.subs[id] = {};
            }
            esgst.games.subs[id].apps = data.apps.map(x => parseInt(x.id));
          }
          if (data.categories) {
            for (let i = 0, n = data.categories.length; i < n; ++i) {
              switch (data.categories[i].description) {
                case `Steam Achievements`:
                  categories.achievements = 1;
                  break;
                case `Multi-player`:
                  categories.multiplayer = 1;
                  break;
                case `Steam Cloud`:
                  categories.steamCloud = 1;
                  break;
                case `Steam Trading Cards`:
                  categories.tradingCards = 1;
                  break;
                default:
                  break;
              }
            }
          }
          if (categories.achievements && data.achievements && data.achievements.total) {
            categories.achievements = data.achievements.total;
          }
          categories.free = data.is_free;
          categories.dlc = data.type === `dlc` ? 1 : 0;
          if (categories.dlc && data.fullgame && data.fullgame.appid) {
            categories.base = parseInt(data.fullgame.appid);
          } else if (data.dlc) {
            categories.dlcs = data.dlc;
          }
          let genres = [];
          if (data.genres) {
            for (let i = 0, n = data.genres.length; i < n; ++i) {
              genres.push(data.genres[i].description.trim());
            }
          }
          genres.sort((a, b) => {
            return a.localeCompare(b, {
              sensitivity: `base`
            });
          });
          categories.earlyAccess = genres.indexOf(`Early Access`) >= 0 ? 1 : 0;
          categories.genres = genres.join(`, `);
          let platforms = data.platforms;
          categories.linux = platforms.linux ? 1 : 0;
          categories.mac = platforms.mac ? 1 : 0;
          categories.name = data.name;
          let price = data.price || data.price_overview;
          categories.price = price ? (price.currency === `USD` ? Math.ceil(price.initial / 100) : -1) : 0;
          if (data.release_date && data.release_date.date) {
            categories.releaseDate = new Date(data.release_date.date).getTime();
          }
        }
      }
      if (esgst.gc_r || esgst.gc_rd || esgst.gc_g_udt) {
        let response = await request({headers: {[`Cookie`]: `birthtime=0; mature_content=1`}, method: `GET`, url: `http://store.steampowered.com/${type.slice(0, -1)}/${id}`});
        let responseHtml = parseHtml(response.responseText);
        if (response.finalUrl.match(id)) {
          let elements = responseHtml.getElementsByClassName(`user_reviews_summary_row`);
          let n = elements.length;
          if (n > 0) {
            let rating = elements[n - 1].getAttribute(`data-tooltip-text`).replace(/,|\./g, ``);
            let match = rating.match(/(\d+)%.+?(\d+)/);
            let percentageIndex = 1;
            let countIndex = 2;
            if (!match) {
              match = rating.match(/(\d+).+?(\d+)%/);
              percentageIndex = 2;
              countIndex = 1;
            }
            if (match) {
              categories.rating = `${match[percentageIndex]}% (${match[countIndex]})`;
              rating = parseInt(match[percentageIndex]);
              if (rating >= 0) {
                if (rating < 40) {
                  categories.ratingType = `Negative`;
                } else if (rating < 70) {
                  categories.ratingType = `Mixed`;
                } else {
                  categories.ratingType = `Positive`;
                }
              } else {
                categories.ratingType = `?`;
              }
            }
          }
          categories.removed = 0;
          let tags = [];
          elements = responseHtml.querySelectorAll(`a.app_tag`);
          for (let i = 0, n = elements.length; i < n; ++i) {
            tags.push(elements[i].textContent.trim());
          }
          tags.sort((a, b) => {
            return a.localeCompare(b, {
              sensitivity: `base`
            });
          });
          categories.tags = tags.join(`, `);
        } else {
          categories.removed = 1;
        }
      }
      if (esgst.gc_dlc_b && categories.dlc && categories.base) {
        if (gc.cache.apps[categories.base]) {
          categories.freeBase = gc.cache.apps[categories.base].free;
        }
        if (typeof categories.freeBase === `undefined`) {
          categories.freeBase = JSON.parse((await request({method: `GET`, url: `http://store.steampowered.com/api/appdetails?appids=${categories.base}&filters=basic&cc=us&l=en`})).responseText)[data.fullgame.appid].data.is_free;
        }
      }
      gc.cache[type][id] = categories;
    } catch (error) {
      console.log(error);
    }
  }

  function gc_checkPackage(id, savedGame, savedGames) {
    const packg = savedGames.subs[id];
    if (!packg || !packg.apps) {
      return;
    }
    const games = packg.apps
      .map(x => {
        const y = esgst.games.apps[x];
        if (!y) {
          return;
        }
        y.id = x;
        return y;
      })
      .concat(
        Object.keys(esgst.games.apps)
        .filter(x => esgst.games.apps[x].packages && esgst.games.apps[x].packages.indexOf(id) > -1)
        .map(x => {
          const y = esgst.games.apps[x];
          if (!y) {
            return;
          }
          y.id = x;
          return y;
        })
      );
    let found = false;
    let isOwned = false;
    const count = {
      num: 0,
      total: packg.apps.length
    };
    let numOwned = 0;
    for (const game of games) {
      if (!game) {
        continue;
      }
      if (game.wishlisted) {
        savedGame.wishlisted = game.wishlisted;
      }
      if (game.owned || packg.apps.indexOf(game.id) < 0) {
        if (!found) {
          isOwned = true;
        }
        if (game.owned) {
          count.num += 1;
        }
      } else {
        found = true;
        isOwned = false;
      }
    }
    savedGame.owned = isOwned;
    count.num = Math.min(count.num, count.total);
    return count;   
  }

  function gc_addCategory(cache, games, id, savedGame, savedGames, type) {
    let active, category, colored, count, cv, elements, encodedName, genre, genreList, genres, giveaway, giveaways, html, i, j, k, n, panel, name, sent, singularType, user, value;
    if (type === `apps` && savedGame && savedGame.packages) {
      for (const subId of savedGame.packages) {
        gc_checkPackage(subId, savedGame, savedGames);
      }
    }
    let packageCount = null;
    if (type === `subs` && savedGame && savedGame.apps) {
      packageCount = gc_checkPackage(id, savedGame, savedGames);
    }
    singularType = type.slice(0, -1);
    name = cache ? cache.name : games[0].name;
    encodedName = encodeURIComponent(name.replace(/\.\.\.$/, ``));
    elements = [];
    let categories = games[0].grid ? esgst.gc_categories_gv : esgst.gc_categories;
    for (i = 0, n = categories.length; i < n; ++i) {
      category = categories[i];
      if (esgst[category]) {
        switch (category) {
          case `gc_fcv`:
            if ((savedGame && !savedGame.reducedCV && !savedGame.noCV) || !savedGame) {
              elements.push(`
                <a class="esgst-gc esgst-gc-fullCV" data-id="gc_fcv" href="https://www.steamgifts.com/bundle-games/search?q=${encodedName}" title="${getFeatureTooltip(`gc_fcv`, `Full CV`)}">${esgst.gc_fcv_s ? (esgst.gc_fcv_s_i ? `<i class="fa fa-${esgst.gc_fcvIcon}"></i>` : `FCV`) : esgst.gc_fcvLabel}</a>
              `);
            }
            break;
          case `gc_rcv`:
            if (savedGame && savedGame.reducedCV && (!esgst.gc_ncv_o || !savedGame.noCV)) {
              elements.push(`
                <a class="esgst-gc esgst-gc-reducedCV" data-id="gc_rcv" href="https://www.steamgifts.com/bundle-games/search?q=${encodedName}" title="${getFeatureTooltip(`gc_rcv`, `Reduced CV since ${savedGame.reducedCV}`)}">${esgst.gc_rcv_s ? (esgst.gc_rcv_s_i ? `<i class="fa fa-${esgst.gc_rcvIcon}"></i>` : `RCV`) : esgst.gc_rcvLabel}</a>
              `);
            }
            break;
          case `gc_ncv`:
            if (savedGame && savedGame.noCV) {
              elements.push(`
                <a class="esgst-gc esgst-gc-noCV" data-id="gc_ncv" href="https://www.steamgifts.com/bundle-games/search?q=${encodedName}" title="${getFeatureTooltip(`gc_ncv`, `No CV since ${savedGame.noCV}`)}">${esgst.gc_ncv_s ? (esgst.gc_ncv_s_i ? `<i class="fa fa-${esgst.gc_ncvIcon}"></i>` : `NCV`) : esgst.gc_ncvLabel}</a>
              `);
            }
            break;
          case `gc_h`:
            if (savedGame && savedGame.hidden) {
              elements.push(`
                <a class="esgst-gc esgst-gc-hidden" data-id="gc_h" href="https://www.steamgifts.com/account/settings/giveaways/filters/search?q=${encodedName}" title="${getFeatureTooltip(`gc_h`, `Hidden`)}">${esgst.gc_h_s ? (esgst.gc_h_s_i ? `<i class="fa fa-${esgst.gc_hIcon}"></i>` : `H`) : esgst.gc_hLabel}</a>
              `);
            }
            break;
          case `gc_i`:
            if (savedGame && savedGame.ignored) {
              elements.push(`
                <a class="esgst-gc esgst-gc-ignored" data-id="gc_i" href="http://store.steampowered.com/${singularType}/${id}" title="${getFeatureTooltip(`gc_i`, `Ignored`)}">${esgst.gc_i_s ? (esgst.gc_i_s_i ? `<i class="fa fa-${esgst.gc_iIcon}"></i>` : `I`) : esgst.gc_iLabel}</a>
              `);
            }
            break;
          case `gc_o`:
            if (savedGame && savedGame.owned) {
              elements.push(`
                <a class="esgst-gc esgst-gc-owned" data-id="gc_o" href="https://www.steamgifts.com/account/steam/games/search?q=${encodedName}" title="${getFeatureTooltip(`gc_o`, `Owned`)}">${esgst.gc_o_s ? (esgst.gc_o_s_i ? `<i class="fa fa-${esgst.gc_oIcon}"></i>` : `O`) : esgst.gc_oLabel}</a>
              `);
            }
            if (esgst.gc_o_a) {
              esgst.gc_o_altAccounts.forEach(account => {
                let game = account.games[type][id];
                if (game && game.owned) {
                  elements.push(`
                    <a class="esgst-gc esgst-gc-owned" data-bgColor="${account.bgColor}" data-color="${account.color}" data-id="gc_o" href="http://steamcommunity.com/profiles/${account.steamId}/games" style="background-color: ${account.bgColor}; color: ${account.color};" title="${getFeatureTooltip(`gc_o_a`, `Owned by ${account.name}`)}">${esgst.gc_o_s ? (esgst.gc_o_s_i ? `<i class="fa fa-${account.icon}"></i>` : `O`) : account.label}</a>
                  `);
                }
              });
            }
            break;
          case `gc_w`:
            if (savedGame && savedGame.wishlisted) {
              elements.push(`
                <a class="esgst-gc esgst-gc-wishlisted" data-id="gc_w" href="https://www.steamgifts.com/account/steam/wishlist/search?q=${encodedName}" title="${getFeatureTooltip(`gc_w`, `Wishlisted${typeof savedGame.wishlisted === `number` ? ` since ${gc_formatDate(savedGame.wishlisted * 1e3)}` : ``}`)}">${esgst.gc_w_s ? (esgst.gc_w_s_i ? `<i class="fa fa-${esgst.gc_wIcon}"></i>` : `W`) : esgst.gc_wLabel}</a>
              `);
            }
            break;
          case `gc_pw`:
            if (savedGame && savedGame.won && (!esgst.gc_pw_o || !esgst.gc_o || !savedGame.owned)) {
              elements.push(`
                <a class="esgst-gc esgst-gc-won" data-id="gc_pw" href="https://www.steamgifts.com/user/${esgst.usename}/won/search?q=${encodedName}" title="${getFeatureTooltip(`gc_pw`, `Previously Won`)}">${esgst.gc_pw_s ? (esgst.gc_pw_s_i ? `<i class="fa fa-${esgst.gc_pwIcon}"></i>` : `PW`) : esgst.gc_pwLabel}</a>
              `);
            }
            break;
          case `gc_gi`:
            if (cache && cache.price) {
              let price = cache.price;
              const heading = games[0].heading;
              if (heading) {
                const points = heading.innerHTML.match(/<span\sclass="giveaway__heading__thin">\((\d+?)P\)<\/span>/);
                if (points) {
                  price = parseInt(points[1]);
                }
              }
              user = esgst.users.users[esgst.steamId];
              if (user) {
                giveaways = user.giveaways;
                if (giveaways) {
                  giveaways = giveaways.sent[type][id];
                  active = 0;
                  count = 0;
                  sent = 0;
                  if (giveaways) {
                    let currentDate = Date.now();
                    let numGiveaways;
                    for (j = 0, numGiveaways = giveaways.length; j < numGiveaways; ++j) {
                      giveaway = esgst.giveaways[giveaways[j]];
                      if (giveaway) {
                        if (Array.isArray(giveaway.winners)) {
                          if (giveaway.winners.length > 0) {
                            giveaway.winners.forEach(winner => {
                              count += 1;
                              if ((giveaway.entries >= 5 || (!giveaway.inviteOnly && !giveaway.group && !giveaway.whitelist)) && winner.status === `Received`) {
                                sent += 1;
                              }
                            });
                          } else if (currentDate < giveaway.endTime) {
                            active += giveaway.copies;
                          }
                        } else if (giveaway.winners > 0) {
                          count += Math.min(giveaway.entries, giveaway.winners);
                          if (giveaway.entries >= 5 || (!giveaway.inviteOnly && !giveaway.group && !giveaway.whitelist)) {
                            sent += Math.min(giveaway.entries, giveaway.winners);
                          }
                        } else if (currentDate < giveaway.endTime) {
                          active += giveaway.copies;
                        }
                      }
                    }
                    value = price;
                    if (savedGame) {
                      if (savedGame.noCV) {
                        value = 0;
                      } else if (savedGame.reducedCV) {
                        value *= 0.15;
                      }
                    }
                    if (sent > 5) {
                      for (j = 0, numGiveaways = sent - 5; j < numGiveaways; ++j) {
                        value *= 0.90;
                      }
                    }
                    cv = (sent + 1) > 5 ? value * 0.90 : value;
                    cv = Math.round(cv * 100) / 100;
                  } else {
                    value = price;
                    if (savedGame) {
                      if (savedGame.noCV) {
                        value = 0;
                      } else if (savedGame.reducedCV) {
                        value *= 0.15;
                      }
                    }
                    cv = Math.round(value * 100) / 100;
                  }
                  elements.push(`
                    <a class="esgst-gc esgst-gc-giveawayInfo" data-id="gc_gi" href="https://www.steamgifts.com/user/${esgst.username}" title="${getFeatureTooltip(`gc_gi`, `You have sent ${count} copies of this game (${sent} of which added to your CV)${active ? `\nYou currently have ${active} open giveaways for this game` : ``}\n\n${price !== -1 ? `You should get $${cv} real CV for sending a new copy of this game\nA giveaway for this game is worth ${Math.min(Math.ceil(price), 50)}P` : `ESGST was unable to retrieve the price of this game (most likely because the game was removed from the Steam store)`}`)}"><i class="fa fa-info"></i> ${count} <i class="fa fa-dollar"></i> ${price !== -1 ? cv : `?`}</a>
                  `);
                }
              }
            }
            break;
          case `gc_r`:
            if (cache && cache.rating) {
              let colors = null;
              let percentage = parseInt(cache.rating.match(/(\d+)%/)[1]);
              for (let i = 0, n = esgst.gc_r_colors.length; i < n; i++) {
                colors = esgst.gc_r_colors[i];
                if (percentage >= colors.lower && percentage <= colors.upper) {
                  break;
                }
              }
              if (!colors) {
                colors = {
                  bgColor: `#7f8c8d`,
                  color: `#ffffff`,
                  icon: `fa-question-circle`
                };
              }
              let match = cache.rating.match(/\((\d+)\)/);
              if (match) {
                cache.rating = cache.rating.replace(/\(\d+\)/, `(${parseInt(match[1]).toLocaleString()})`);
              }
              elements.push(`
                <a class="esgst-gc esgst-gc-rating" data-bgColor="${colors.bgColor}" data-color="${colors.color}" data-id="gc_r" href="http://store.steampowered.com/${singularType}/${id}" style="background-color: ${colors.bgColor}; color: ${colors.color};" title="${getFeatureTooltip(`gc_r`, cache.rating)}">${colors.icon.match(/\w/) ? `<i class="fa fa-${colors.icon}"></i>` : `<span style="font-size: 14px;">${colors.icon}</span>`}${esgst.gc_r_s ? ` ${cache.rating}` : ``}</a>
              `);
            }
            break;
          case `gc_a`:
            if (cache && cache.achievements) {
              elements.push(`
                <a class="esgst-gc esgst-gc-achievements" data-id="gc_a" href="http://steamcommunity.com/stats/${id}/achievements" title="${getFeatureTooltip(`gc_a`, `Achievements (${cache.achievements})`)}">${esgst.gc_a_s ? (esgst.gc_a_s_i ? `<i class="fa fa-${esgst.gc_aIcon}"></i>` : `A`) : esgst.gc_aLabel}</a>
              `);
            }
            break;
          case `gc_mp`:
            if (cache && cache.multiplayer) {
              elements.push(`
                <a class="esgst-gc esgst-gc-multiplayer" data-id="gc_mp" href="http://store.steampowered.com/${singularType}/${id}" title="${getFeatureTooltip(`gc_mp`, `Multiplayer`)}">${esgst.gc_mp_s ? (esgst.gc_mp_s_i ? `<i class="fa fa-${esgst.gc_mpIcon}"></i>` : `MP`) : esgst.gc_mpLabel}</a>
              `);
            }
            break;
          case `gc_sc`:
            if (cache && cache.steamCloud) {
              elements.push(`
                <a class="esgst-gc esgst-gc-steamCloud" data-id="gc_sc" href="http://store.steampowered.com/${singularType}/${id}" title="${getFeatureTooltip(`gc_sc`, `Steam Cloud`)}">${esgst.gc_sc_s ? (esgst.gc_sc_s_i ? `<i class="fa fa-${esgst.gc_scIcon}"></i>` : `SC`) : esgst.gc_scLabel}</a>
              `);
            }
            break;
          case `gc_tc`:
            if (cache && cache.tradingCards) {
              elements.push(`
                <a class="esgst-gc esgst-gc-tradingCards" data-id="gc_tc" href="http://www.steamcardexchange.net/index.php?gamepage-${singularType}id-${id}" title="${getFeatureTooltip(`gc_tc`, `Trading Cards`)}">${esgst.gc_tc_s ? (esgst.gc_tc_s_i ? `<i class="fa fa-${esgst.gc_tcIcon}"></i>` : `TC`) : esgst.gc_tcLabel}</a>
              `);
            }
            break;
          case `gc_l`:
            if (cache && cache.linux) {
              elements.push(`
                <a class="esgst-gc esgst-gc-linux" data-id="gc_l" href="http://store.steampowered.com/${singularType}/${id}" title="${getFeatureTooltip(`gc_l`, `Linux`)}">${esgst.gc_l_s ? (esgst.gc_l_s_i ? `<i class="fa fa-${esgst.gc_lIcon}"></i>` : `L`) : esgst.gc_lLabel}</a>
              `);
            }
            break;
          case `gc_m`:
            if (cache && cache.mac) {
              elements.push(`
                <a class="esgst-gc esgst-gc-mac" data-id="gc_m" href="http://store.steampowered.com/${singularType}/${id}" title="${getFeatureTooltip(`gc_m`, `Mac`)}">${esgst.gc_m_s ? (esgst.gc_m_s_i ? `<i class="fa fa-${esgst.gc_mIcon}"></i>` : `M`) : esgst.gc_mLabel}</a>
              `);
            }
            break;
          case `gc_dlc`:
            if (cache && cache.dlc) {
              let baseOwned;
              if (esgst.gc_dlc_o) {
                if (cache.base && esgst.games.apps[cache.base]) {
                  baseOwned = esgst.games.apps[cache.base].owned;
                }
              }
              elements.push(`
                <a class="esgst-gc esgst-gc-dlc" data-id="gc_dlc" href="http://store.steampowered.com/${singularType}/${id}" title="${getFeatureTooltip(`gc_dlc`, `DLC${esgst.gc_dlc_b && typeof cache.freeBase !== `undefined` ? (cache.freeBase ? ` (the base game of this DLC is free)` : ` (the base game of this DLC is not free)`) : ``}`)}">
                  ${esgst.gc_dlc_s ? (
                    esgst.gc_dlc_s_i ? `
                      <i class="fa fa-${esgst.gc_dlcIcon}"></i>
                      ${esgst.gc_dlc_o && baseOwned ? `
                        <i class="fa fa-${esgst.gc_oIcon} esgst-gc-dlcOwned"></i>
                      `: ``}
                      ${esgst.gc_dlc_b && typeof cache.freeBase !== `undefined` ? (
                        cache.freeBase ? `
                          <i class="fa fa-certificate esgst-gc-dlcFree"></i>
                        ` : `
                          <i class="fa fa-money esgst-gc-dlcNonFree"></i>
                        `
                      ) : ``}
                    ` : `
                      DLC
                      ${esgst.gc_dlc_o && baseOwned ? `
                        <span class="esgst-gc-dlcOwned">(O)</span>
                      `: ``}
                      ${esgst.gc_dlc_b && typeof cache.freeBase !== `undefined` ? (
                        cache.freeBase ? `
                          <span class="esgst-gc-dlcFree">(F)</span>
                        ` : `
                          <span class="esgst-gc-dlcNonFree">(NF)</span>
                        `
                      ) : ``}
                    `
                  ) : `
                    ${esgst.gc_dlcLabel}
                    ${esgst.gc_dlc_o && baseOwned ? `
                      <span class="esgst-gc-dlcOwned">(Owned)</span>
                    `: ``}
                    ${esgst.gc_dlc_b && typeof cache.freeBase !== `undefined` ? (
                      cache.freeBase ? `
                        <span class="esgst-gc-dlcFree">(Free)</span>
                      ` : `
                        <span class="esgst-gc-dlcNonFree">(Not Free)</span>
                      `
                    ) : ``}
                  `}
                </a>
              `);
            }
            break;
          case `gc_p`:
            if (type === `subs`) {
              elements.push(`
                <a class="esgst-gc esgst-gc-package" data-id="gc_p" href="http://store.steampowered.com/${singularType}/${id}" title="${getFeatureTooltip(`gc_p`, `Package${savedGame && savedGame.apps ? ` (${savedGame.apps.length})` : ``}${packageCount ? ` (${packageCount.num} owned)` : ``}`)}">${esgst.gc_p_s ? (esgst.gc_p_s_i ? `<i class="fa fa-${esgst.gc_pIcon}"></i>` : `P`) : esgst.gc_pLabel}${packageCount ? ` (${packageCount.num}/${packageCount.total})` : ``}</a>
              `);
            }
            break;
          case `gc_ea`:
            if (cache && cache.earlyAccess) {
              elements.push(`
                <a class="esgst-gc esgst-gc-earlyAccess" data-id="gc_ea" href="http://store.steampowered.com/${singularType}/${id}" title="${getFeatureTooltip(`gc_ea`, `Early Access`)}">${esgst.gc_ea_s ? (esgst.gc_ea_s_i ? `<i class="fa fa-${esgst.gc_eaIcon}"></i>` : `EA`) : esgst.gc_eaLabel}</a>
              `);
            }
            break;
          case `gc_rm`:
            if (cache && cache.removed === 1) {
              elements.push(`
                <a class="esgst-gc esgst-gc-removed" data-id="gc_rm" href="http://steamdb.info/${singularType}/${id}" title="${getFeatureTooltip(`gc_rm`, `Removed`)}">${esgst.gc_rm_s ? (esgst.gc_rm_s_i ? `<i class="fa fa-${esgst.gc_rmIcon}"></i>` : `RM`) : esgst.gc_rmLabel}</a>
              `);
            }
            break;
          case `gc_rd`:
            if (cache && cache.releaseDate) {
              elements.push(`
                <a class="esgst-gc esgst-gc-releaseDate" data-id="gc_rd" data-timestamp="${cache.releaseDate === `?` ? cache.releaseDate : (cache.releaseDate / 1e3)}" href="http://store.steampowered.com/${singularType}/${id}" title="${getFeatureTooltip(`gc_rd`, `Release Date`)}">
                  <i class="fa fa-${esgst.gc_rdIcon}"></i> ${gc_formatDate(cache.releaseDate)}
                </a>
              `);
            }
            break;
          case `gc_g`:
            if (cache && cache.genres) {
              let filters;
              genres = esgst.gc_g_udt && cache.tags ? `${cache.genres}, ${cache.tags}` : cache.genres;
              genreList = sortArray(Array.from(new Set(genres.split(/,\s/))));
              genres = genreList.join(`, `);
              colored = [];
              if (esgst.gc_g_filters.trim()) {
                filters = esgst.gc_g_filters.trim().toLowerCase().split(/\s*,\s*/);
              }
              for (j = genreList.length - 1; j >= 0; --j) {
                genre = genreList[j].toLowerCase();
                if (!filters || filters.indexOf(genre) > -1) {
                  for (k = esgst.gc_g_colors.length - 1; k >= 0 && esgst.gc_g_colors[k].genre.toLowerCase() !== genre; --k);
                  if (k >= 0) {
                    if (esgst.gc_g_s) {
                      colored.push(`
                        <a class="esgst-gc esgst-gc-genres" href="http://store.steampowered.com/${singularType}/${id}" style="background-color: ${esgst.gc_g_colors[k].bgColor}; color: ${esgst.gc_g_colors[k].color};" title="${getFeatureTooltip(`gc_g_s`, genreList[j])}">${genreList.splice(j, 1)}</a>
                      `);
                    } else {
                      colored.push(`
                        <span style="color: ${esgst.gc_g_colors[k].color}">${genreList.splice(j, 1)}</span>
                      `);
                    }
                  } else if (esgst.gc_g_s) {
                    genreList[j] = `
                      <a class="esgst-gc esgst-gc-genres" href="http://store.steampowered.com/${singularType}/${id}" title="${getFeatureTooltip(`gc_g_s`, genreList[j])}">${genreList[j]}</a>
                    `;
                  }
                } else {
                  genreList.splice(j, 1);
                }
              }
              if (colored.length) {
                colored = sortArray(colored);
                for (j = colored.length - 1; j >= 0; --j) {
                  genreList.unshift(colored[j]);
                }
              }
              if (esgst.gc_g_s) {
                elements.push(`
                  <span class="esgst-gc-genres" data-id="gc_g">${genreList.join(``)}</span>
                `);
              } else if (genreList.length > 0) {
                elements.push(`
                  <a class="esgst-gc esgst-gc-genres" data-id="gc_g" href="http://store.steampowered.com/${singularType}/${id}" title="${getFeatureTooltip(`gc_g`, genres)}">${genreList.join(`, `)}</a>
                `);
              }
            }
            break;
        }
      }
    }
    html = elements.join(``);
    let gc = {
      categoryKey: games[0].grid ? `gc_categories_gv` : `gc_categories`,
      indexKey: games[0].grid ? `gc_indexes_gv` : `gc_indexes`,
      source: null
    };
    for (i = 0, n = games.length; i < n; ++i) {
      panel = games[i].container.getElementsByClassName(`esgst-gc-panel`)[0];
      if (panel && !panel.getAttribute(`data-gcReady`)) {
        if (esgst.gc_il && !esgst.giveawayPath) {
          panel.previousElementSibling.style.display = `inline-block`;
          panel.classList.add(`esgst-gc-panel-inline`);
        }
        panel.innerHTML = html;
        if (!esgst.gc_lp || (!esgst.gc_lp_gv && games[i].grid)) {
          for (j = panel.children.length - 1; j > -1; --j) {
            panel.children[j].removeAttribute(`href`);
          }
        }
        if (games[i].columns) {
          for (j = games[i].columns.children.length - 1; j > -1; j--) {
            let item = games[i].columns.children[j];
            item.addEventListener(`dragenter`, gc_getSource.bind(null, gc, games[i].columns, j, item, null, false));
          }
          games[i].columns.addEventListener(`dragenter`, gc_getSource.bind(null, gc, games[i].columns, 0, null, games[i].columns, true));
          if (games[i].gvIcons) {
            games[i].gvIcons.addEventListener(`dragenter`, gc_getSource.bind(null, gc, games[i].columns, 0, null, games[i].gvIcons, true));
          }
          panel.addEventListener(`dragenter`, gc_getSource.bind(null, gc, games[i].columns, -1, null, panel, false));
          for (j = panel.children.length - 1; j > -1; j--) {
            let item = panel.children[j];
            item.setAttribute(`draggable`, true);
            item.addEventListener(`dragstart`, gc_setSource.bind(null, gc, item, panel, games[i].columns, games[i].gvIcons));
            item.addEventListener(`dragenter`, gc_getSource.bind(null, gc, games[i].columns, -1, item, null, false));
            item.addEventListener(`dragend`, gc_saveSource.bind(null, gc, panel, games[i].columns, games[i].gvIcons));
            let id = item.getAttribute(`data-id`);
            let index = esgst[gc.indexKey][id];
            if (isSet(index) && index !== -1) {
              item.classList.add(esgst.giveawayPath ? `featured__column` : `giveaway__column`);
              if (item.getAttribute(`data-color`)) {
                item.firstElementChild.style.color = item.getAttribute(`data-bgColor`);
                item.style.color = ``;
                item.style.background = ``;
              }
              games[i].columns.insertBefore(item, games[i].columns.children[index]);
            }
          }
        }
        panel.setAttribute(`data-gcReady`, 1);
      }
    }
  }

  function gc_formatDate(timestamp) {
    if (timestamp === `?`) return timestamp;
    let date = new Date(timestamp);
    return esgst.gc_rdLabel.replace(/DD/, date.getDate()).replace(/MM/, date.getMonth() + 1).replace(/Month/, [`January`, `February`, `March`, `April`, `May`, `June`, `July`, `August`, `September`, `October`, `November`, `December`][date.getMonth()]).replace(/Mon/, [`Jan`, `Feb`, `Mar`, `Apr`, `May`, `Jun`, `Jul`, `Aug`, `Sep`, `Oct`, `Nov`, `Dec`][date.getMonth()]).replace(/YYYY/, date.getFullYear());
  }

  function gc_setSource(gc, item, panel, columns, gvIcons, event) {
    event.dataTransfer.setData(`text/plain`, ``);
    gc.source = item;
    setTimeout(() => {
      if (!panel.children.length) {
        panel.style.height = `28px`;
        panel.style.width = `100%`;
      }
      if (columns && !columns.children.length) {
        columns.style.height = `25px`;
        columns.style.width = `100%`;
      }
      if (gvIcons && !gvIcons.children.length) {
        gvIcons.style.height = `28px`;
        gvIcons.style.width = `100%`;
      }
    }, 0);
  }

  function gc_getSource(gc, context, index, item, panel, column) {
    let current = gc.source;
    if (!gc.source || gc.source === item) return;
    if (panel) {
      if (!panel.children.length) {
        panel.appendChild(gc.source);
        esgst[gc.indexKey][gc.source.getAttribute(`data-id`)] = index;
        if (column) {
          gc.source.classList.add(esgst.giveawayPath ? `featured__column` : `giveaway__column`);
        } else {
          gc.source.classList.remove(esgst.giveawayPath ? `featured__column` : `giveaway__column`);
          if (gc.source.getAttribute(`data-color`)) {
            gc.source.firstElementChild.style.color = ``;
            gc.source.style.color = gc.source.getAttribute(`data-color`);
            gc.source.style.backgroundColor = gc.source.getAttribute(`data-bgColor`);
          }
        }
      }
      return;
    }
    do {
      current = current.previousElementSibling;
      if (current && current === item) {
        if (context.contains(item)) {
          gc.source.classList.add(esgst.giveawayPath ? `featured__column` : `giveaway__column`);
          if (gc.source.getAttribute(`data-color`)) {
            gc.source.firstElementChild.style.color = gc.source.getAttribute(`data-bgColor`);
            gc.source.style.color = ``;
            gc.source.style.background = ``;
          }
        } else {
          gc.source.classList.remove(esgst.giveawayPath ? `featured__column` : `giveaway__column`);
          if (gc.source.getAttribute(`data-color`)) {
            gc.source.firstElementChild.style.color = ``;
            gc.source.style.color = gc.source.getAttribute(`data-color`);
            gc.source.style.backgroundColor = gc.source.getAttribute(`data-bgColor`);
          }
        }
        if (item.getAttribute(`data-id`)) {
          esgst[gc.categoryKey].splice(esgst[gc.categoryKey].indexOf(item.getAttribute(`data-id`)), 0, esgst[gc.categoryKey].splice(esgst[gc.categoryKey].indexOf(gc.source.getAttribute(`data-id`)), 1)[0]);
          esgst[gc.indexKey][gc.source.getAttribute(`data-id`)] = isSet(esgst[gc.indexKey][item.getAttribute(`data-id`)]) ? esgst[gc.indexKey][item.getAttribute(`data-id`)] : -1;
        } else {
          esgst[gc.indexKey][gc.source.getAttribute(`data-id`)] = index;
        }
        item.parentElement.insertBefore(gc.source, item);
        return;
      }
    } while (current);
    if (context.contains(item)) {
      gc.source.classList.add(esgst.giveawayPath ? `featured__column` : `giveaway__column`);
      if (gc.source.getAttribute(`data-color`)) {
        gc.source.firstElementChild.style.color = gc.source.getAttribute(`data-bgColor`);
        gc.source.style.color = ``;
        gc.source.style.background = ``;
      }
    } else {
      gc.source.classList.remove(esgst.giveawayPath ? `featured__column` : `giveaway__column`);
      if (gc.source.getAttribute(`data-color`)) {
        gc.source.firstElementChild.style.color = ``;
        gc.source.style.color = gc.source.getAttribute(`data-color`);
        gc.source.style.backgroundColor = gc.source.getAttribute(`data-bgColor`);
      }
    }
    if (item.getAttribute(`data-id`)) {
      esgst[gc.categoryKey].splice(esgst[gc.categoryKey].indexOf(item.getAttribute(`data-id`)), 0, esgst[gc.categoryKey].splice(esgst[gc.categoryKey].indexOf(gc.source.getAttribute(`data-id`)), 1)[0]);
      esgst[gc.indexKey][gc.source.getAttribute(`data-id`)] = isSet(esgst[gc.indexKey][item.getAttribute(`data-id`)]) ? esgst[gc.indexKey][item.getAttribute(`data-id`)] : -1;
    } else {
      esgst[gc.indexKey][gc.source.getAttribute(`data-id`)] = index + 1;
    }
    item.parentElement.insertBefore(gc.source, item.nextElementSibling);
  }

  async function gc_saveSource(gc, panel, columns, gvIcons) {
    gc.source = null;
    panel.style.height = ``;
    panel.style.width = ``;
    if (columns) {
      columns.style.height = ``;
      columns.style.width = ``;
    }
    if (gvIcons) {
      gvIcons.style.height = ``;
      gvIcons.style.width = ``;
    }
    await setSetting(gc.categoryKey, esgst[gc.categoryKey]);
    await setSetting(gc.indexKey, esgst[gc.indexKey]);
  }
  
  // [GCH]
  
  _MODULES.push({
    description: `
      <ul>
        <li>Highlights the number of copies next a giveaway's game name (in any page) by coloring it as red and changing the font to bold.</li>
      </ul>
    `,
    id: `gch`,
    name: `Giveaway Copy Highlighter`,
    sg: true,
    type: `giveaways`
  });

  // [GDTTT]

  _MODULES.push({
    description: `
      <ul>
        <li>Adds a button (<i class="fa fa-check"></i> if the thread is not marked as visited and <i class="fa fa-times"></i> if it is) to the "Comments" column of any <a href="https://www.steamgifts.com/discussions">discussions</a>/<a href="https://www.steamgifts.com/support/tickets">tickets</a>/<a href="https://www.steamtrades.com/trades">trades</a> pages and to the main page heading of any discussion/ticket/trade page that allows you to mark the thread as visited.</li>
        <li>Giveaways/theads marked as visited are faded out in the page.</li>
      <ul>
    `,
    features: {
      gdttt_g: {
        name: `Fade visited giveaways.`,
        sg: true
      },
      gdttt_vd: {
        name: `Mark discussions as visited when visiting them.`,
        sg: true
      },
      gdttt_vg: {
        name: `Mark giveaways as visited when visiting them.`,
        sg: true
      },
      gdttt_vt: {
        name: `Mark tickets as visited when visiting them.`,
        sg: true
      },
      gdttt_vts: {
        name: `Mark trades as visited when visiting them.`,
        st: true
      }
    },
    id: `gdttt`,
    load: gdttt,
    name: `Giveaway/Discussion/Ticket/Trade Tracker`,
    sg: true,
    st: true,
    type: `general`
  });

  async function gdttt() {
    esgst.endlessFeatures.push(gdttt_checkVisited);
    if (!esgst.commentsPath) return;
    let match = location.pathname.match(/(giveaway|discussion|ticket|trade)\/(.+?)\//);
    let type = `${match[1]}s`;
    let code = match[2];
    let savedComments = JSON.parse(esgst.storage[type]);
    if (esgst[`gdttt_v${{
      giveaways: `g`,
      discussions: `d`,
      tickets: `t`,
      trades: `ts`
    }[type]}`]) {
      if (!esgst.ct) {
        let cache = JSON.parse(getLocalValue(`gdtttCache`, `{"giveaways":[],"discussions":[],"tickets":[],"trades":[]}`));
        if (cache[type].indexOf(code) < 0) {
          cache[type].push(code);
          setLocalValue(`gdtttCache`, JSON.stringify(cache));
        }
        let deleteLock = await createLock(`commentLock`, 300);
        if (!savedComments[code]) {
          savedComments[code] = {
            readComments: {}
          };
        }
        savedComments[code].visited = true;
        savedComments[code].lastUsed = Date.now();
        await setValue(type, JSON.stringify(savedComments));
        deleteLock();
      }
    } else if (esgst.discussionPath || esgst.tradePath) {
      if (savedComments[code] && savedComments[code].visited) {
        gdttt_addMarkUnvisitedButton(null, code, document.querySelector(`.page__heading, .page_heading`), /*HERE*/null, type);
      } else {
        gdttt_addMarkVisitedButton(null, code, document.querySelector(`.page__heading, .page_heading`), /*HERE*/null, type);
      }
    }
  }

  async function gdttt_markVisited(code, container, count, diffContainer, type, doSave) {
    if (doSave) {
      let deleteLock = await createLock(`commentLock`, 300),
        comments = JSON.parse(await getValue(type));
      if (!comments[code]) {
        comments[code] = {
          readComments: {}
        };
      }
      if (esgst.ct_s) {
        comments[code].count = count;
        diffContainer.textContent = ``;
      }
      comments[code].visited = true;
      comments[code].lastUsed = Date.now();
      await setValue(type, JSON.stringify(comments));
      deleteLock();
    }
    container.classList.add(`esgst-ct-visited`);
    container.style.opacity = `0.5`;
    setHoverOpacity(container, `1`, `0.5`);
    return true;
  }

  async function gdttt_markUnvisited(code, container, count, diffContainer, type, doSave) {
    if (doSave) {
      let deleteLock = await createLock(`commentLock`, 300),
        comments = JSON.parse(await getValue(type));
      if (esgst.ct_s) {
        delete comments[code].count;
        diffContainer.textContent = `(+${count})`;
      }
      delete comments[code].visited;
      comments[code].lastUsed = Date.now();
      await setValue(type, JSON.stringify(comments));
      deleteLock();
    }
    container.classList.remove(`esgst-ct-visited`);
    container.style.opacity = `1`;
    setHoverOpacity(container, `1`, `1`);
    return true;
  }

  async function gdttt_checkVisited(context, main, src, endless) {
    let matches = context.querySelectorAll(`${endless ? `.esgst-es-page-${endless} .homepage_table_column_heading, .esgst-es-page-${endless}.homepage_table_column_heading` : `.homepage_table_column_heading`}, ${endless ? `.esgst-es-page-${endless} .table__column__heading, .esgst-es-page-${endless}.table__column__heading` : `.table__column__heading`}, ${endless ? `.esgst-es-page-${endless} .giveaway__heading__name, .esgst-es-page-${endless}.giveaway__heading__name` : `.giveaway__heading__name`}, ${endless ? `.esgst-es-page-${endless} .column_flex h3 a, .esgst-es-page-${endless}.column_flex h3 a` : `.column_flex h3 a`}`);
    if (!matches.length) return;
    let values = await getValues({
      giveaways: `{}`,
      discussions: `{}`,
      tickets: `{}`,
      trades: `{}`
    });
    for (let key in values) {
      values[key] = JSON.parse(values[key]);
    }
    for (let i = 0, n = matches.length; i < n; ++i) {
      let match = matches[i];
      let url = match.getAttribute(`href`);
      if (url) {
        let source = url.match(/(giveaway|discussion|ticket|trade)\/(.+?)(\/.*)?$/);
        if (source) {
          let type = `${source[1]}s`;
          let code = source[2];
          let container = match.closest(`.table__row-outer-wrap, .giveaway__row-outer-wrap, .row_outer_wrap`);
          let comment = values[type][code];
          if (comment && comment.visited && container) {
            if ((type === `giveaways` && esgst.gdttt_g) || type !== `giveaways`) {
              container.classList.add(`esgst-ct-visited`);
              container.style.opacity = `0.5`;
              setHoverOpacity(container, `1`, `0.5`);
            }
          }
        }
      }
    }
  }

  function gdttt_addMarkVisitedButton(button, code, context, count, type) {
    let comments;
    let busy = false;
    if (!button) {
      button = insertHtml(context, `afterBegin`, `<div class="esgst-gdttt-button page_heading_btn"><div>`);
    }
    button.innerHTML = `<i class="fa fa-check" title="${getFeatureTooltip(`gdttt`, `Mark as visited`)}"></i>`;
    button.addEventListener(`click`, async () => {
      if (!busy) {
        busy = true;
        button.innerHTML = `<i class="fa fa-circle-o-notch fa-spin"></i>`;
        let deleteLock = await createLock(`commentLock`, 300);
        comments = JSON.parse(await getValue(type));
        if (!comments[code]) {
          comments[code] = {
            readComments: {}
          };
        }
        if (esgst.ct_s) {
          comments[code].count = count;
        }
        comments[code].visited = true;
        comments[code].lastUsed = Date.now();
        await setValue(type, JSON.stringify(comments));
        deleteLock();
        gdttt_addMarkUnvisitedButton(button, code, context, count, type);
      }
    });
  }

  function gdttt_addMarkUnvisitedButton(button, code, context, count, type) {
    let comments;
    let busy = false;
    if (!button) {
      button = insertHtml(context, `afterBegin`, `<div class="esgst-gdttt-button page_heading_btn"><div>`);
    }
    button.innerHTML = `<i class="fa fa-times" title="${getFeatureTooltip(`gdttt`, `Mark as unvisited`)}"></i>`;
    button.addEventListener(`click`, async () => {
      if (!busy) {
        busy = true;
        button.innerHTML = `<i class="fa fa-circle-o-notch fa-spin"></i>`;
        let deleteLock = await createLock(`commentLock`, 300);
        comments = JSON.parse(await getValue(type));
        if (esgst.ct_s) {
          delete comments[code].count;
        }
        delete comments[code].visited;
        comments[code].lastUsed = Date.now();
        await setValue(type, JSON.stringify(comments));
        deleteLock();
        gdttt_addMarkVisitedButton(button, code, context, count, type);
      }
    });
  }

  // [GE]

  _MODULES.push({
    description: `
      <ul>
        <li>Adds a button (<i class="fa fa-gift"></i> <i class="fa fa-search"></i>) to the main page heading of any giveaway/discussion page that allows you to extract all of the giveaways that are linked in the page.</li>
        <li>The giveaways are extracted recursively. For example, if giveaway A has links to giveaways B and C, the feature will extract giveaway B and all of the giveaways linked in it before moving on to giveaway C, and so on.</li>
        <li>The feature keeps extracting giveaways until it no longer finds a giveaway link in the page. To prevent a loop (and consequently duplicate results), it keeps track of which giveaways it has already extracted so that they are not extracted again.</li>
        <li>If you use the feature in a giveaway page, it will add a "Bump" link to the results (when available).</li>
        <li>This feature is useful for extracting trains (multiple giveaways linked to each other).</li>
      </ul>
    `,
    features: {
      ge_b: {
        background: true,
        name: `Highlight giveaways that cannot be entered because of blacklist reasons.`,
        sg: true
      },
      ge_g: {
        background: true,
        name: `Highlight group giveaways.`,
        sg: true
      },
      ge_p: {
        background: true,
        name: `Highlight public giveaways.`,
        sg: true
      },
      ge_o: {
        description: `
          <ul>
            <li>With this option enabled, if you use the feature in the 6th giveaway of a train and the train has links to the previous giveaways, it will not go back and extract giveaways 1-5.</li>
            <li>This method is not 100% accurate, because the feature looks for a link with any variation of "next" in the description of the giveaway to make sure that it is going forward, so if it does not find such a link, the extraction will stop.</li>
          </ul>
        `,
        name: `Only extract from the current giveaway onward.`,
        sg: true
      },
      ge_sgt: {
        features: {
          ge_sgt_l: {
            inputItems: [
              {
                id: `ge_sgt_limit`,
                prefix: `Limit: `
              }
            ],
            name: `Limit how many links are opened.`,
            sg: true
          }
        },
        name: `Automatically open any SGTools links found in new tabs.`,
        sg: true
      },
      ge_t: {
        name: `Open the extractor in a new tab.`,
        sg: true
      }
    },
    id: `ge`,
    load: ge,
    name: `Giveaway Extractor`,
    sg: true,
    type: `giveaways`
  });

  async function ge() {
    if (((esgst.giveawayCommentsPath && !document.getElementsByClassName(`table--summary`)[0]) || esgst.discussionPath) && (document.querySelector(`.markdown [href*="/giveaway/"], .markdown [href*="sgtools.info/giveaways"]`))) {
      let ge = {
        button: createHeadingButton({id: `ge`, icons: [`fa-gift`, `fa-search`], title: `Extract giveaways`})
      };
      setMouseEvent(ge.button, `ge_t`, `/esgst/extracted-giveaways?url=${location.pathname.match(/^\/(giveaway|discussion)\/.+?\//)[0]}`, ge_openPopup.bind(null, ge));
    } else if (esgst.gePath) {
      let ge = {
        context: parseHtml((await request({method: `GET`, url: getParameters().url})).responseText)
      };
      ge_openPopup(ge);
    }
  }

  function ge_openPopup(ge) {
    if (ge.popup) {
      ge.popup.open();
      return;
    }
    ge.count = 0;
    ge.total = 0;
    ge.extracted = [];
    ge.bumpLink = ``;
    ge.points = 0;
    ge.sgToolsCount = 0;
    ge.isDivided = esgst.gc_gi || esgst.gc_r || esgst.gc_rm || esgst.gc_ea || esgst.gc_tc || esgst.gc_a || esgst.gc_mp || esgst.gc_sc || esgst.gc_l || esgst.gc_m || esgst.gc_dlc || esgst.gc_rd || esgst.gc_g;
    if (esgst.gePath) {
      ge.popup = {
        description: esgst.mainContext,
        scrollable: esgst.mainContext,
        open: () => {},
        reposition: () => {}
      };
    } else {
      ge.popup = new Popup(`fa-gift`, `Extracted giveaways:`);
    }
    ge.results = insertHtml(ge.popup.scrollable, `beforeEnd`, `<div class="esgst-text-left"></div>`);
    if (esgst.gas || (esgst.gf && esgst.gf_m) || esgst.mm) {
      let heading = insertHtml(ge.popup.scrollable, `afterBegin`, `
        <div class="page__heading"></div>
      `);
      if (esgst.gas) {
        gas(heading);
      }
      if (esgst.gf && esgst.gf_m) {
        heading.appendChild(filters_addContainer(`gf`, heading, `Ge`));
      }
      if (esgst.mm) {
        mm(heading);
      }
    }
    ge.set = new ButtonSet(`green`, `grey`, `fa-search`, `fa-times`, `Extract`, `Cancel`, callback => {
      if (ge.callback) {
        ge.results.insertAdjacentHTML(`beforeEnd`, `<div></div>`);
        ge.callback();
      } else {
        ge.isCanceled = false;
        if (ge.button) {
          ge.button.classList.add(`esgst-busy`);
        }
        ge.progress.innerHTML = `
          <i class="fa fa-circle-o-notch fa-spin"></i>
          <span>${ge.total}</span> giveaways extracted.
        `;
        ge.results.insertAdjacentHTML(`beforeEnd`, `<div></div>`);
        ge.mainCallback = callback;
        let giveaways = ge_getGiveaways(ge, esgst.gePath ? ge.context : esgst.pageOuterWrap);
        ge_extractGiveaways(ge, giveaways, 0, giveaways.length, ge_completeExtraction.bind(null, ge, callback));
      }
    }, () => {
      ge.isCanceled = true;
      ge_completeExtraction(ge);
    });
    ge.popup.description.appendChild(ge.set.set);
    ge.progress = insertHtml(ge.popup.description, `beforeEnd`, `<div></div>`);
    if (esgst.es_ge) {
      ge.popup.scrollable.addEventListener(`scroll`, () => {
        if (ge.popup.scrollable.scrollTop + ge.popup.scrollable.offsetHeight >= ge.popup.scrollable.scrollHeight && ge.set && !ge.set.busy) {
          ge.set.trigger();
        }
      });
    }
    ge.set.trigger();
    ge.popup.open();
  }

  function ge_extractGiveaways(ge, giveaways, i, n, callback) {
    if (!ge.isCanceled) {
      if (i < n) {
        ge_extractGiveaway(ge, giveaways[i], setTimeout.bind(null, ge_extractGiveaways, 0, ge, giveaways, ++i, n, callback));
      } else {
        callback();
      }
    }
  }

  async function ge_extractGiveaway(ge, code, callback) {
    if (!ge.isCanceled) {
      if (ge.isDivided && ge.count === 50) {
        let children, filtered, i;
        ge.mainCallback();
        ge.count = 0;
        await endless_load(ge.results.lastElementChild, false, `ge`);
        ge.set.set.firstElementChild.lastElementChild.textContent = `Extract More`;
        ge.progress.firstElementChild.remove();
        ge.callback = ge_extractGiveaway.bind(null, ge, code, callback);
        filtered = false;
        children = ge.results.lastElementChild.children;
        for (i = children.length - 1; i > -1 && !filtered; --i) {
          if (children[i].firstElementChild.classList.contains(`esgst-hidden`)) {
            filtered = true;
          }
        }
        if ((esgst.es_ge && ge.popup.scrollable.scrollHeight <= ge.popup.scrollable.offsetHeight) || filtered) {
          ge.set.trigger();
        }
      } else {
        if (ge.extracted.indexOf(code) < 0) {
          let sgTools = code.length > 5;
          if (sgTools && esgst.ge_sgt && (!esgst.ge_sgt_l || ge.sgToolsCount < esgst.ge_sgt_limit)) {
            open(`https://www.sgtools.info/giveaways/${code}`);
            ge.extracted.push(code);
            ge.sgToolsCount += 1;
            callback();
            return;
          }
          let response = await request({method: `GET`, url: sgTools ? `https://www.sgtools.info/giveaways/${code}` : `/giveaway/${code}/`});
          let bumpLink, button, giveaway, giveaways, n, responseHtml;
          responseHtml = parseHtml(response.responseText);
          button = responseHtml.getElementsByClassName(`sidebar__error`)[0];
          giveaway = buildGiveaway(responseHtml, response.finalUrl, button && button.textContent);
          if (giveaway) {
            ge.results.lastElementChild.insertAdjacentHTML(`beforeEnd`, giveaway.html);
            ge.points += giveaway.points;
            ge.count += 1;
            ge.total += 1;
            ge.progress.innerHTML = `
              <i class="fa fa-circle-o-notch fa-spin"></i>
              <span>${ge.total}</span> giveaways extracted.
            `;
            ge.extracted.push(code);
            if (sgTools) {
              callback();
            } else {
              if (!ge.bumpLink) {
                bumpLink = responseHtml.querySelector(`[href*="/discussion/"]`);
                if (bumpLink) {
                  ge.bumpLink = bumpLink.getAttribute(`href`);
                }
              }
              giveaways = ge_getGiveaways(ge, responseHtml);
              n = giveaways.length;
              if (n > 0) {
                setTimeout(() => ge_extractGiveaways(ge, giveaways, 0, n, callback), 0);
              } else {
                callback();
              }
            }
          } else if (!sgTools) {
            let response = await request({anon: true, method: `GET`, url: `/giveaway/${code}/`});
            let bumpLink, giveaway, giveaways, n, responseHtml;
            responseHtml = parseHtml(response.responseText);
            giveaway = buildGiveaway(responseHtml, response.finalUrl, null, true);
            if (giveaway) {
              ge.results.lastElementChild.insertAdjacentHTML(`beforeEnd`, giveaway.html);
              ge.points += giveaway.points;
            }
            ge.count += 1;
            ge.total += 1;
            ge.progress.innerHTML = `
              <i class="fa fa-circle-o-notch fa-spin"></i>
              <span>${ge.total}</span> giveaways extracted.
            `;
            ge.extracted.push(code);
            if (!ge.bumpLink) {
              bumpLink = responseHtml.querySelector(`[href*="/discussion/"]`);
              if (bumpLink) {
                ge.bumpLink = bumpLink.getAttribute(`href`);
              }
            }
            giveaways = ge_getGiveaways(ge, responseHtml);
            n = giveaways.length;
            if (n > 0) {
              setTimeout(() => ge_extractGiveaways(ge, giveaways, 0, n, callback), 0);
            } else {
              callback();
            }
          } else {
            callback();
          }
        } else {
          callback();
        }
      }
    }
  }

  function ge_getGiveaways(ge, context) {
    let elements = context.querySelectorAll(`.markdown [href*="/giveaway/"], .markdown [href*="sgtools.info/giveaways"]`);
    let giveaways = [];
    if (context === ge.context) {
      let match = getParameters().url.match(/\/giveaway\/(.+?)\//);
      if (match) {
        giveaways.push(match[1]);
      }
    } else if (context === esgst.pageOuterWrap && esgst.giveawayPath) {
      let match = location.href.match(/\/giveaway\/(.+?)\//);
      if (match) {
        giveaways.push(match[1]);
      }
    }
    let next = {
      code: null,
      count: 0
    };
    for (let element of elements) {
      let url = element.getAttribute(`href`);
      let match = url.match(/\/(\w{5})\b/);
      if (!match) {
        match = url.match(/(\w{8}-\w{4}-\w{4}-\w{4}-\w{12})/);
        if (!match) continue;
      }
      let code = match[1];
      if (!esgst.ge_o || esgst.discussionPath || element.textContent.toLowerCase().match(/forw|more|next|>|→/)) {
        if (ge.extracted.indexOf(code) < 0 && giveaways.indexOf(code) < 0) {
          giveaways.push(code);
        }
      } else {
        match = element.textContent.match(/\d+/);
        if (match) {
          let count = parseInt(match[0]);
          if (count > next.count && ge.extracted.indexOf(code) < 0 && giveaways.indexOf(code) < 0) {
            next.code = code;
            next.count = count;
          }
        }
      }
    }
    if (next.count > 0) {
      giveaways.push(next.code);
    }
    return giveaways;
  }

  async function ge_completeExtraction(ge, callback) {
    if (ge.button) {
      ge.button.classList.remove(`esgst-busy`);
    }
    ge.progress.firstElementChild.remove();
    if (callback) {
      callback();
    }
    await endless_load(ge.results.lastElementChild, false, `ge`);
    let html = `
      <div class="markdown esgst-text-center">
        ${ge.bumpLink && !esgst.discussionPath ? `
          <h2>
            <a href="${ge.bumpLink}">Bump</a>
          </h2>
        ` : ``}
        ${ge.points}P required to enter all giveaways.
      </div>
    `;
    ge.results.insertAdjacentHTML(`afterBegin`, html);
    ge.results.insertAdjacentHTML(`beforeEnd`, html);
    ge.set.set.remove();
    ge.set = null;
  }

  // [GED]

  _MODULES.push({
    description: `
      <ul>
        <li>Adds an icon (<i class="fa fa-star"></i> if the giveaway is open, <i class="fa fa-star esgst-green"></i> if it is open and new, <i class="fa fa-star esgst-yellow"></i> if it is not open yet and <i class="fa fa-star esgst-red"></i> if it has already ended) next to a comment's "Permalink" (in any page) for each encrypted giveaway that the comment has (if it has any). The icon links to the giveaway.</li>
        <li>Encrypted giveaways are basically invite only giveaway codes that ESGST encrypts using various encryption methods and hides in your comments so that they can only be visible through the source code of the page. Other ESGST users are able to easily see these giveaways if they have this feature enabled, but since the codes are visible through the source code of the page, anyone who finds them and manages to decrypt them can access the giveaways. So it is more like a puzzle that ESGST users can solve instantly and non-ESGST users can solve if they give it some effort, though it is doubtful that someone will check the source code of every page they open on SteamGifts looking for the codes.</li>
        <li>To add encrypted giveaways to your comments, check [id=cfh_g].</li>
        <li>Adds a button (<i class="fa fa-star"></i>) next to the ESGST button at the header of any page that allows you to view all of the decrypted giveaways that you have unlocked (they are unlocked whenever you visit a page that contains them).</li>
      </ul>
    `,
    features: {
      ged_t: {
        name: `Open the list of decrypted giveaways in a new tab.`,
        sg: true
      }
    },
    id: `ged`,
    load: ged,
    name: `Giveaway Encrypter/Decrypter`,
    sg: true,
    type: `giveaways`
  });

  function ged() {
    if (!esgst.sg) return;
    let ged = {
      newGiveaways: []
    };
    if (esgst.gedPath) {
      ged_openPopup(ged);
    } else {
      ged.button = insertHtml(esgst.headerNavigationLeft, `beforeEnd`, `
        <div class="nav__button-container esgst-hidden" title="${getFeatureTooltip(`ged`, `View your decrypted giveaways`)}">
          <div class="nav__button">
            <i class="fa fa-star"></i>
          </div>
        </div>
      `);
      ged.button.addEventListener(`mousedown`, ged_openPopup.bind(null, ged));
      ged_getGiveaways(ged, true);
    }
    esgst.ged_addIcons = ged_addIcons.bind(null, ged);
  }

  async function ged_openPopup(ged, event) {
    if (event) {
      if (event.button === 2) return;
      event.preventDefault();
    }
    if (esgst.gedPath) {
      ged.container = ged.context = esgst.mainContext;
    } else if (esgst.ged_t || (event && event.button === 1)) {
      open(`/esgst/decrypted-giveaways`);
    } else {
      ged.popup = new Popup(`fa-star`, `Decrypted Giveaways`, true);
      ged.container = ged.popup.description;
      ged.context = ged.popup.scrollable;
      ged.popup.open();
    }
    ged.context.innerHTML = `
      <i class="fa fa-circle-o-notch fa-spin"></i> Loading...
    `;
    await ged_getGiveaways(ged);
    ged.context.innerHTML = ``;
    if (esgst.gas || (esgst.gf && esgst.gf_m) || esgst.mm) {
      let heading = insertHtml(ged.context, `afterBegin`, `
        <div class="page__heading"></div>
      `);
      if (esgst.gas) {
        gas(heading);
      }
      if (esgst.gf && esgst.gf_m) {
        heading.appendChild(filters_addContainer(`gf`, heading, `Ged`));
      }
      if (esgst.mm) {
        mm(heading);
      }
    }
    ged.results = insertHtml(ged.context, `beforeEnd`, `<div class="esgst-text-left"></div>`);
    ged.set = new ButtonSet_v2({color1: `green`, color2: `grey`, icon1: `fa-plus`, icon2: `fa-circle-o-notch fa-spin`, title1: `Load More`, title2: `Loading more...`, callback1: ged_loadGiveaways.bind(null, ged)});
    ged.container.appendChild(ged.set.set);
    ged.set.trigger();
    if (esgst.es_ged) {
      ged.context.addEventListener(`scroll`, ged_checkEndless.bind(null, ged));
    }
  }

  async function ged_getGiveaways(ged, firstRun) {
    ged.giveaways = [];
    ged.i = 0;
    let currentGiveaways = {};
    let currentTime = Date.now();
    let deleteLock;
    if (!firstRun) {
      deleteLock = await createLock(`gedLock`, 300);
      esgst.decryptedGiveaways = JSON.parse(await getValue(`decryptedGiveaways`));
    }
    delete esgst.edited.decryptedGiveaways;
    for (let code in esgst.decryptedGiveaways) {
      if (esgst.decryptedGiveaways[code].html) {
        delete esgst.decryptedGiveaways[code].html;
        esgst.edited.decryptedGiveaways = true;
      }
      let isEnded = esgst.decryptedGiveaways[code].timestamp <= currentTime;
      let filtered = true;
      let giveaway = esgst.giveaways[code];
      if (giveaway) {
        let game = null;
        if (giveaway.gameType && giveaway.gameSteamId) {
          game = esgst.games[giveaway.gameType][giveaway.gameSteamId];
        }
        const name = esgst.gf_presetGed;
        if (name) {
          let i;
          for (i = esgst.gf_presets.length - 1; i > -1 && esgst.gf_presets[i].name !== name; i--);
          if (i > -1) {
            const preset = esgst.gf_presets[i];
            filtered = filters_filterItem(`gf`, gf_getFilters(true), giveaway, preset.rules);
          }
        }
        if (filtered && isEnded && !giveaway.started) {
          await ged_getGiveaway(code, currentGiveaways, true);
          isEnded = esgst.decryptedGiveaways[code].timestamp <= currentTime;
        }
      }
      if (filtered && !isEnded) {
        ged.giveaways.push({
          code: code,
          source: esgst.decryptedGiveaways[code].source,
          timestamp: esgst.decryptedGiveaways[code].timestamp
        });
      }
    }
    await lockAndSaveGiveaways(currentGiveaways, firstRun);
    if (esgst.edited.decryptedGiveaways && !firstRun) {
      await setValue(`decryptedGiveaways`, JSON.stringify(esgst.decryptedGiveaways));
    }
    if (deleteLock) {
      deleteLock();
    }
    ged.n = ged.giveaways.length;
    if (ged.n > 0) {
      if (ged.button) {
        ged.button.classList.remove(`esgst-hidden`);
      }
      ged.giveaways = sortArrayByNumberKey(ged.giveaways, `timestamp`);
    }
  }

  async function ged_getGiveaway(code, currentGiveaways, isEnded, source) {
    let response = await request({method: `GET`, url: `/giveaway/${code}/`});
    let giveaway = (await giveaways_get(parseHtml(response.responseText), false, response.finalUrl, false, null, true))[0];
    if (giveaway) {
      currentGiveaways[code] = giveaway;
      if (giveaway.started && isEnded) {
        esgst.decryptedGiveaways[code].timestamp = giveaway.endTime;
        esgst.edited.decryptedGiveaways = true;
      }
    }
    if (source) {
      esgst.decryptedGiveaways[code] = {
        source: source,
        timestamp: (giveaway && giveaway.endTime) || 0
      };
      esgst.edited.decryptedGiveaways = true;
    }
    return giveaway;
  }

  async function ged_loadGiveaways(ged) {
    let i = 0;
    while ((i < 5 || (esgst.es_ged && ged.context.scrollHeight <= ged.context.offsetHeight) || ((ged.results.children.length - ((esgst.gfPopup && parseInt(esgst.gfPopup.filteredCount.textContent)) || 0)) % 5 !== 0)) && ged.i < ged.n) {
      i += 1;
      let giveaway = ged.giveaways[ged.i];
      ged.i += 1;
      let response = await request({method: `GET`, url: `/giveaway/${giveaway.code}/`});
      let builtGiveaway = buildGiveaway(parseHtml(response.responseText), response.finalUrl);
      if (!builtGiveaway || !builtGiveaway.started) {
        continue;
      }
      let context = insertHtml(ged.results, `beforeEnd`, builtGiveaway.html);
      if (giveaway.source) {
        context.getElementsByClassName(`giveaway__columns`)[0].insertAdjacentHTML(`afterBegin`, `
          <a class="esgst-ged-source" href="${giveaway.source.match(/\/discussion\//) ? giveaway.source : `/go/comment/${giveaway.source}`}">Source</a>
        `);
      }
      await endless_load(context, false, `ged`);
      if (ged.newGiveaways.indexOf(giveaway.code) > -1) {
        context.getElementsByClassName(`giveaway__heading__name`)[0].insertAdjacentText(`afterBegin`, `[NEW] `);
      }
    }
    if (ged.i >= ged.n) {
      ged.set.set.remove();
    }
  }

  function ged_checkEndless(ged) {
    if ((ged.context.scrollTop + ged.context.offsetHeight) >= ged.context.scrollHeight && !ged.set.busy) {
      ged.set.trigger();
    }
  }

  async function ged_addIcons(ged, comments) {
    let currentGiveaways = {};
    let currentTime = Date.now();
    let deleteLock = null;
    let hasNew = false;
    for (let i = comments.length - 1; i > -1; i--) {
      let comment = comments[i];
      let icons = comment.actions.getElementsByClassName(`esgst-ged-icon`);
      for (let j = icons.length - 1; j > -1; j--) {
        icons[0].remove();
      }
      if (!comment.displayState) continue;
      let links = comment.displayState.querySelectorAll(`[href^="ESGST-"]`);
      for (let j = links.length - 1; j > -1; j--) {
        let code = links[j].getAttribute(`href`).match(/ESGST-(.+)/)[1];
        if (code.match(/currentVersion/)) {
          continue;
        }
        if (!deleteLock) {
          deleteLock = await createLock(`gedLock`, 300);
          esgst.decryptedGiveaways = JSON.parse(await getValue(`decryptedGiveaways`));
        }
        code = ged_decryptCode(code);
        let isEnded = esgst.decryptedGiveaways[code] && currentTime > esgst.decryptedGiveaways[code].timestamp;
        let isNew = false;
        let isStarted = esgst.giveaways[code] && esgst.giveaways[code].started;
        if (!esgst.decryptedGiveaways[code] || (isEnded && !isStarted)) {
          let giveaway = await ged_getGiveaway(code, currentGiveaways, false, comment.id || location.href);
          ged.newGiveaways.push(code);
          hasNew = isNew = true;
          if (giveaway) {
            isEnded = giveaway.ended;
            isStarted = giveaway.started;
          }
        }
        comment.actions.insertAdjacentHTML(`beforeEnd`, `
          <a class="esgst-ged-icon${isEnded ? ` esgst-red` : (isStarted ? (isNew ? ` esgst-green` : ``) : ` esgst-yellow`)}" href="/giveaway/${code}/" title="${getFeatureTooltip(`ged`, `ESGST Decrypted Giveaway`)}">
            <i class="fa fa-star"></i>
          </a>
        `);
      }
    }
    if (deleteLock) {
      await lockAndSaveGiveaways(currentGiveaways);
      deleteLock();
    }
    if (esgst.edited.decryptedGiveaways) {
      await setValue(`decryptedGiveaways`, JSON.stringify(esgst.decryptedGiveaways));
    }
    if (ged.button && hasNew) {
      ged.button.classList.remove(`esgst-hidden`);
      ged.button.firstElementChild.firstElementChild.classList.add(`esgst-positive`);
    }
  }

  function ged_encryptCode(code) {
    let alphabet, encrypted, i, n, rotated, rotation;
    alphabet = `NOPQRSTUVWXYZABCDEFGHIJKLM`;
    switch (Math.floor(Math.random() * 4)) {
      case 0:
        rotated = rot(code, 13);
        encrypted = ``;
        for (i = 0, n = rotated.length; i < n; ++i) {
          encrypted += rotated.charCodeAt(i).toString(16);
        }
        return encrypted;
      case 1:
        rotated = rot(code, 13);
        encrypted = ``;
        for (i = 0, n = rotated.length; i < n; ++i) {
          encrypted += rotated.charCodeAt(i).toString(16);
        }
        encrypted = encrypted.replace(/\d/g, n => {
          return alphabet[parseInt(n)];
        });
        return encrypted;
      case 2:
        rotation = Math.ceil(Math.random() * 25);
        rotated = rot(code, rotation);
        encrypted = ``;
        for (i = 0, n = rotated.length; i < n; ++i) {
          encrypted += rotated.charCodeAt(i).toString(16);
        }
        encrypted += rotation.toString(16);
        return encrypted;
      case 3:
        rotation = Math.ceil(Math.random() * 25);
        rotated = rot(code, rotation);
        encrypted = ``;
        for (i = 0, n = rotated.length; i < n; ++i) {
          encrypted += rotated.charCodeAt(i).toString(16);
        }
        encrypted += rotation.toString(16);
        encrypted = encrypted.replace(/\d/g, n => {
          return alphabet[parseInt(n)];
        });
        return encrypted;
    }
  }

  function ged_decryptCode(encrypted) {
    let alphabet, code, rotation;
    alphabet = `NOPQRSTUVWXYZABCDEFGHIJKLM`;
    encrypted = encrypted.replace(/-/g, ``).replace(/[A-Z]/g, n => {
      return alphabet.indexOf(n);
    });
    rotation = encrypted.slice(10);
    if (rotation) {
      rotation = parseInt(rotation, 16);
    } else {
      rotation = 13;
    }
    code = ``;
    encrypted.slice(0, 10).match(/../g).forEach(n => {
      code += String.fromCharCode(parseInt(n, 16));
    });
    return rot(code, 26 - rotation);
  }

  async function ged_saveGiveaways(context, source) {
    let codes = [];
    let elements = context.querySelectorAll(`[href^="ESGST-"]`);
    for (let i = 0, n = elements.length; i < n; i++) {
      let encryptedCode = elements[i].getAttribute(`href`).match(/ESGST-(.+)/)[1];
      if (!encryptedCode.match(/currentVersion/)) {
        codes.push(ged_decryptCode(encryptedCode));
      }
    }
    if (!codes.length) {
      return;
    }
    let ged = {
      giveaways: {}
    };
    esgst.decryptedGiveaways = JSON.parse(await getValue(`decryptedGiveaways`));
    let promises = [];
    codes.forEach(code => {
      if (esgst.decryptedGiveaways[code]) {
        return;
      }
      let giveaway = esgst.giveaways[code];
      if (giveaway && giveaway.endTime) {
        esgst.decryptedGiveaways[code] = {
          source: source,
          timestamp: giveaway.endTime
        };
        return;
      }
      promises.push(ged_getGiveaway(code, ged.giveaways, false, source));
    });
    await Promise.all(promises);
    await setValue(`decryptedGiveaways`, JSON.stringify(esgst.decryptedGiveaways));
    await lockAndSaveGiveaways(ged.giveaways);
  }

  // [GESL]
  
  _MODULES.push({
    // by Royalgamer06
    description: `
      <ul>
        <li>If you cannot access a giveaway because of many different reasons, a "Search Links" row is added to the table of the <a href="https://www.steamgifts.com/giveaway/FN2PK/">error</a> page containing 3 links that allow you to search for the game elsewhere:</li>
        <ul>
          <li>A SteamGifts icon that allows you to search for open giveaways of the game on SteamGifts.</li>
          <li><i class="fa fa-steam"></i> allows you to search for the game on Steam.</li>
          <li><i class="fa"><img src="https://steamdb.info/static/logos/favicon-16x16.png"></i> allows you to search for the game on SteamDB.</li>
        </ul>
      </ul>
    `,
    id: `gesl`,
    load: gesl,
    name: `Giveaway Error Search Links`,
    sg: true,
    type: `giveaways`
  });

  function gesl() {
    if (!esgst.giveawayPath || !document.getElementsByClassName(`table--summary`)[0]) return;
    let name = encodeURIComponent(document.getElementsByClassName(`table__column__secondary-link`)[0].textContent);
    document.getElementsByClassName(`table__row-outer-wrap`)[0].insertAdjacentHTML(`afterEnd`, `
      <div class="table__row-outer-wrap" title="${getFeatureTooltip(`gesl`)}">
        <div class="table__row-inner-wrap">
          <div class="table__column--width-small">
            <span class="esgst-bold">Search Links</span>
          </div>
          <div class="table__column--width-fill">
            <a href="https://www.steamgifts.com/giveaways/search?q=${name}" target="_blank" title="Search for active giveaways">
              <i class="fa"><img src="${esgst.sgIcon}"></i>
            </a>
            <a href="http://store.steampowered.com/search/?term=${name}" target="_blank" title="Search on Steam">
              <i class="fa fa-steam"></i>
            </a>
            <a href="https://steamdb.info/search/?a=app&q=${name}" target="_blank" title="Search on SteamDB">
              <i class="fa"><img src="https://steamdb.info/static/logos/favicon-16x16.png"></i>
            </a>
          </div>
        </div>
      </div>
    `);
  }

  // [CF]
             
  _MODULES.push({
    description: `
      <ul>
        <li>Allows you to filter comments.</li>
      </ul>
    `,
    features: {
      cf_m: {
        description: `
          <ul>
            <li>Allows you to hide multiple comments in a page using many different filters.</li>
            <li>Adds a toggle switch with a button (<i class="fa fa-sliders"></i>) to the main page heading of any comment page. The switch allows you to turn the filters on/off and the button allows you to manage your presets.</li>
            <li>Adds a collapsible panel below the same main page heading that allows you to change/save the rules of a preset. The filters are separated in 2 categories:</li>
            <ul>
              <li>Basic filters are related to a numeric value (such as the length of a comment) and have a slider that you can use to set the range of the filter (any comments that do not apply to the range will be hidden).</li>
              <li>Type filters are related to a boolean value (such as whether or not a comment is a bump comment) and have a checkbox that changes states when you click on it. The checkbox has 3 states:</li>
              <ul>
                <li>"Show all" (<i class="fa fa-check-square"></i>) does not hide any comments that apply to the filter (this is the default state).</li>
                <li>"Show only" (<i class="fa fa-square"></i>) hides any comments that do not apply to the filter.</li>
                <li>"Hide all" (<i class="fa fa-square-o"></i>) hides any comments that apply to the filter.</li>
              </ul>
            </ul>
            <li>A preset contains all of your rules and can be saved to be reused later. You can save as many presets as you want.</li>
            <li>Adds a text in parenthesis to the pagination of the page showing how many comments in the page are being filtered by the filters.</li>
          </ul>
        `,
        features: {
          cf_m_b: {
            name: `Hide basic filters.`,
            sg: true,
            st: true
          },
          cf_m_a: {
            name: `Hide advanced filters.`,
            sg: true,
            st: true
          },
          cf_bump: {
            description: `
              <ul>
                <li>Allows you to filter bump comments.</li>
              </ul>
            `,
            name: `Bump`,
            sg: true,
            st: true
          },
          cf_length: {
            description: `
              <ul>
                <li>Allows you to filter comments by their length.</li>
              </ul>
            `,
            name: `Length`,
            sg: true,
            st: true
          },
          cf_words: {
            description: `
              <ul>
                <li>Allows you to filter comments containing certain words.</li>
              </ul>
            `,
            name: `Words`,
            sg: true,
            st: true
          }
        },
        name: `Multiple Filters`,
        sg: true,
        st: true
      }
    },
    id: `cf`,
    load: cf,
    name: `Comment Filters`,
    sg: true,
    st: true,
    type: `comments`
  });

  async function cf() {
    if (esgst.cf_m && (esgst.commentsPath || esgst.inboxPath)) {
      esgst.style.insertAdjacentText(`beforeEnd`, `
        .esgst-gf-container {
          top: ${esgst.commentsTop - 5}px;
        }
      `);
      if (esgst.hideButtons && esgst.hideButtons_cf) {
        if (esgst.leftButtonIds.indexOf(`cf`) > -1) {
          esgst.leftButtons.insertBefore(filters_addContainer(`cf`, esgst.mainPageHeading), esgst.leftButtons.firstElementChild);
        } else {
          esgst.rightButtons.appendChild(filters_addContainer(`cf`, esgst.mainPageHeading));
        }
      } else {
        esgst.mainPageHeading.insertBefore(filters_addContainer(`cf`, esgst.mainPageHeading), esgst.mainPageHeading.firstElementChild);
      }
    }
  }

  function cf_getFilters() {
    return {
      bump: {
        check: true,
        name: `Bump`,
        type: `boolean`
      },
      length: {
        check: true,
        minValue: 0,
        name: `Length`,
        type: `number`
      },
      words: {
        check: true,
        list: true,
        name: `Words`,
        type: `string`
      }
    };
  }

  // [DF]

  _MODULES.push({
    description: `
      <ul>
        <li>Allows you to filter discussions.</li>
      </ul>
    `,
    features: {
      df_s: {
        description: `
          <ul>
            <li>Adds a button (<i class="fa fa-eye"></i> if the discussion is hidden and <i class="fa fa-eye-slash"></i> if it is not) next to a discussion's title (in any page) that allows you to hide the discussion.</li>
            <li>Adds a button (<i class="fa fa-comments"></i> <i class="fa fa-eye-slash"></i>) to the page heading of this menu that allows you to view all of the discussions that have been hidden.</li>
          </ul>
        `,
        name: `Single Filters`,
        sg: true
      },
      df_m: {
        description: `
          <ul>
            <li>Allows you to hide multiple discussions in a page using many different filters.</li>
            <li>Adds a toggle switch with a button (<i class="fa fa-sliders"></i>) to the main page heading of any <a href="https://www.steamgifts.com/discussions">discussions</a> page. The switch allows you to turn the filters on/off and the button allows you to manage your presets.</li>
            <li>Adds a collapsible panel below the same main page heading that allows you to change/save the rules of a preset. The filters are separated in 2 categories:</li>
            <ul>
              <li>Basic filters are related to a numeric value (such as the number of comments of a discussion) and have a slider that you can use to set the range of the filter (any discussions that do not apply to the range will be hidden).</li>
              <li>Type filters are related to a boolean value (such as whether or not a discussion was created by yourself) and have a checkbox that changes states when you click on it. The checkbox has 3 states:</li>
              <ul>
                <li>"Show all" (<i class="fa fa-check-square"></i>) does not hide any discussions that apply to the filter (this is the default state).</li>
                <li>"Show only" (<i class="fa fa-square"></i>) hides any discussions that do not apply to the filter.</li>
                <li>"Hide all" (<i class="fa fa-square-o"></i>) hides any discussions that apply to the filter.</li>
              </ul>
            </ul>
            <li>A preset contains all of your rules and can be saved to be reused later. You can save as many presets as you want. Each preset contains 3 types of rules:</li>
            <ul>
              <li>Basic rules are the ones that you can change directly in the filter panel, using the sliders/checkboxes as explained in the previous item.</li>
              <li>Exception rules are the ones that you can change by clicking on the icon <i class="fa fa-gear"></i> in the filter panel. They are exceptions to the basic rules. For example, if you set the basic rule of the "Created" filter to "hide all" and you add an exception rule for the "Comments" filter to the 0-50 range, none of your created discussions that have 0-50 comments will be hidden, because they apply to the exception.</li>
              <li>Override rules are the ones that you can change by clicking on the icon (<i class="fa fa-exclamation esgst-faded"></i> if set to overridable and <i class="fa fa-exclamation"></i> if set to non-overridable) next to each filter. They are enforcements of the basic rules. Continuing the previous example, if you set the override rule of the "Created" filter to "non-overridable", then all of your created discussions will be hidden, because even if they apply to the exception, the basic rule is being enforced by the override rule, so the exception cannot override it.</li>
            </ul>
            <li>Adds a text in parenthesis to the pagination of the page showing how many discussions in the page are being filtered by the filters.</li>
          </ul>
        `,
        features: {
          df_m_b: {
            name: `Hide basic filters.`,
            sg: true
          },
          df_m_a: {
            name: `Hide advanced filters.`,
            sg: true
          },
          df_comments: {
            description: `
              <ul>
                <li>Allows you to filter discussions by number of comments.</li>
              </ul>
            `,
            name: `Comments`,
            sg: true
          },
          df_announcements: {
            description: `
              <ul>
                <li>Allows you to filter discussions categorized as "Announcements".</li>
              </ul>
            `,
            name: `Announcements`,
            sg: true
          },
          df_bugsSuggestions: {
            description: `
              <ul>
                <li>Allows you to filter discussions categorized as "Bugs / Suggestions".</li>
              </ul>
            `,
            name: `Bugs / Suggestions`,
            sg: true
          },
          df_deals: {
            description: `
              <ul>
                <li>Allows you to filter discussions categorized as "Deals".</li>
              </ul>
            `,
            name: `Deals`,
            sg: true
          },
          df_general: {
            description: `
              <ul>
                <li>Allows you to filter discussions categorized as "General".</li>
              </ul>
            `,
            name: `General`,
            sg: true
          },
          df_groupRecruitment: {
            description: `
              <ul>
                <li>Allows you to filter discussions categorized as "Group Recruitment".</li>
              </ul>
            `,
            name: `Group Recruitment`,
            sg: true
          },
          df_letsPlayTogether: {
            description: `
              <ul>
                <li>Allows you to filter discussions categorized as "Let's Play Together".</li>
              </ul>
            `,
            name: `Let's Play Together`,
            sg: true
          },
          df_offTopic: {
            description: `
              <ul>
                <li>Allows you to filter discussions categorized as "Off-Topic".</li>
              </ul>
            `,
            name: `Off-Topic`,
            sg: true
          },
          df_puzzles: {
            description: `
              <ul>
                <li>Allows you to filter discussions categorized as "Puzzles".</li>
              </ul>
            `,
            name: `Puzzles`,
            sg: true
          },
          df_uncategorized: {
            description: `
              <ul>
                <li>Allows you to filter discussions categorized as "Uncategorized".</li>
              </ul>
            `,
            name: `Uncategorized`,
            sg: true
          },
          df_created: {
            description: `
              <ul>
                <li>Allows you to filter discussions created by yourself.</li>
              </ul>
            `,
            name: `Created`,
            sg: true
          },
          df_poll: {
            description: `
              <ul>
                <li>Allows you to filter discussions that contain polls.</li>
              </ul>
            `,
            name: `Poll`,
            sg: true
          },
          df_highlighted: {
            description: `
              <ul>
                <li>Allows you to filter discussions that you have highlighted.</li>
                <li>This option requires [id=dh] enabled to work.</li>
              </ul>
            `,
            name: `Highlighted`,
            sg: true
          },
          df_visited: {
            description: `
              <ul>
                <li>Allows you to filter discussions that you have visited.</li>
                <li>This option requires [id=gdttt] enabled to work.</li>
              </ul>
            `,
            name: `Visited`,
            sg: true
          },
          df_unread: {
            description: `
              <ul>
                <li>Allows you to filter discussions that you have read.</li>
                <li>This option requires [id=ct] enabled to work.</li>
              </ul>
            `,
            name: `Unread`,
            sg: true
          },
          df_authors: {
            description: `
              <ul>
                <li>Allows you to filter discussions by author.</li>
              </ul>
            `,
            name: `Authors`,
            sg: true
          }
        },
        name: `Multiple Filters`,
        sg: true
      }
    },
    id: `df`,
    load: df,
    name: `Discussion Filters`,
    sg: true,
    type: `discussions`
  });

  async function df() {
    if (esgst.df_m && esgst.discussionsPath && !esgst.editDiscussionPath) {
      esgst.style.insertAdjacentText(`beforeEnd`, `
        .esgst-gf-container {
          top: ${esgst.commentsTop - 5}px;
        }
      `);
      if (esgst.hideButtons && esgst.hideButtons_df) {
        if (esgst.leftButtonIds.indexOf(`df`) > -1) {
          esgst.leftButtons.insertBefore(filters_addContainer(`df`, esgst.mainPageHeading), esgst.leftButtons.firstElementChild);
        } else {
          esgst.rightButtons.appendChild(filters_addContainer(`df`, esgst.mainPageHeading));
        }
      } else {
        esgst.mainPageHeading.insertBefore(filters_addContainer(`df`, esgst.mainPageHeading), esgst.mainPageHeading.firstElementChild);
      }
    }
    if (!esgst.giveawaysPath || !esgst.activeDiscussions || esgst.adots || esgst.oadd) return;
    await checkMissingDiscussions();
  }

  function df_menu(obj, event) {
    if (obj.process) return;

    obj.process = new Process({
      button: event.currentTarget,
      popup: {
        icon: `fa-comments`,
        title: `Hidden Discussions`,
        addProgress: true,
        addScrollable: `left`
      },
      urls: {
        id: `df`,
        init: df_initUrls,
        perLoad: 5,
        request: {
          request: df_requestUrl
        }
      }
    });
    obj.process.openPopup();
  }

  async function df_initUrls(obj) {
    obj. discussions = obj.popup.getScrollable(`
      <div class="table esgst-text-left">
        <div class="table__heading">
          <div class="table__column--width-fill">Summary</div>
          <div class="table__column--width-small text-center">Comments</div>
        </div>
      </div>
    `);
    const discussions = JSON.parse(await getValue(`discussions`));
    let hidden = [];
    for (const key in discussions) {
      if (discussions[key].hidden) {
        const discussion = {
          code: key,
          hidden: discussions[key].hidden
        };
        hidden.push(discussion);
      }
    }
    hidden = sortArrayByNumberKey(hidden, `hidden`, true);
    obj.ids = [];
    for (const discussion of hidden) {
      obj.ids.push(discussion.code);
      obj.items.push(`/discussion/${discussion.code}/`);
    }
  }

  async function df_requestUrl(obj, details, response, responseHtml) {
    const breadcrumbs = responseHtml.getElementsByClassName(`page__heading__breadcrumbs`);
    const categoryLink = breadcrumbs[0].firstElementChild.nextElementSibling.nextElementSibling;
    const usernameLink = responseHtml.getElementsByClassName(`comment__username`)[0].firstElementChild;
    obj.discussions.insertAdjacentHTML(`beforeEnd`, `
      <div>
        <div class="table__row-outer-wrap">
          <div class="table__row-inner-wrap">
            <div>
              ${responseHtml.getElementsByClassName(`global__image-outer-wrap`)[0].outerHTML}
            </div>
            <div class="table__column--width-fill">
              <h3>
                <a class="table__column__heading" href="/discussion/${obj.ids[obj.index]}/">${categoryLink.nextElementSibling.nextElementSibling.firstElementChild.textContent}</a>
              </h3>
              <p>
                <a class="table__column__secondary-link" href="${categoryLink.getAttribute(`href`)}">${categoryLink.textContent}</a> -
                ${responseHtml.querySelector(`.comment [data-timestamp]`).outerHTML} ago by
                <a class="table__column__secondary-link" href="${usernameLink.getAttribute(`href`)}">${usernameLink.textContent}</a>
              </p>
            </div>
            <div class="table__column--width-small text-center">
              <a class="table__column__secondary-link" href="/discussion/${obj.ids[obj.index]}/">${breadcrumbs[1].textContent.match(/(.+) Comments?/)[1]}</a>
            </div>
          </div>
        </div>
      </div>
    `);
    await endless_load(obj.discussions.lastElementChild);
    if (!esgst.giveawaysPath && !esgst.discussionsPath) {
      if (esgst.gdttt) {
        await ct_addDiscussionPanels(obj.discussions.lastElementChild, true);
        await gdttt_checkVisited(obj.discussions.lastElementChild);
      } else if (esgst.ct) {
        await ct_addDiscussionPanels(obj.discussions.lastElementChild, true);
      }
      await discussions_load(obj.discussions.lastElementChild);
    }
  }

  async function df_hideDiscussion(discussion, main) {
    let deleteLock = await createLock(`discussionLock`, 300);
    let discussions = JSON.parse(await getValue(`discussions`, `{}`));
    if (!discussions[discussion.code]) {
      discussions[discussion.code] = {};
    }
    discussions[discussion.code].hidden = discussions[discussion.code].lastUsed = Date.now();
    await setValue(`discussions`, JSON.stringify(discussions));
    deleteLock();
    if (!main || !esgst.discussionPath) {
      discussion.outerWrap.remove();
    }
    return true;
  }

  async function df_unhideDiscussion(discussion, main) {
    let deleteLock = await createLock(`discussionLock`, 300);
    let discussions = JSON.parse(await getValue(`discussions`, `{}`));
    if (discussions[discussion.code]) {
      delete discussions[discussion.code].hidden;
      discussions[discussion.code].lastUsed = Date.now();
    }
    await setValue(`discussions`, JSON.stringify(discussions));
    deleteLock();
    if (!main || !esgst.discussionPath) {
      discussion.outerWrap.remove();
    }
    return true;
  }

  function df_getFilters() {
    return {
      comments: {
        check: true,
        minValue: 0,
        name: `Comments`,
        type: `number`
      },
      announcements: {
        check: true,
        name: `Announcements`,
        type: `boolean`
      },
      bugsSuggestion: {
        check: true,
        name: `Bugs / Suggestion`,
        type: `boolean`
      },
      deals: {
        check: true,
        name: `Deals`,
        type: `boolean`
      },
      general: {
        check: true,
        name: `General`,
        type: `boolean`
      },
      groupRecruitment: {
        check: true,
        name: `Group Recruitment`,
        type: `boolean`
      },
      letsPlayTogether: {
        check: true,
        name: `Let's Play Together`,
        type: `boolean`
      },
      offTopic: {
        check: true,
        name: `Off-Topic`,
        type: `boolean`
      },
      puzzles: {
        check: true,
        name: `Puzzles`,
        type: `boolean`
      },
      uncategorized: {
        check: true,
        name: `Uncategorized`,
        type: `boolean`
      },
      created: {
        check: true,
        name: `Created`,
        type: `boolean`
      },
      poll: {
        check: true,
        name: `Poll`,
        type: `boolean`
      },
      highlighted: {
        check: esgst.dh,
        name: `Highlighted`,
        type: `boolean`
      },
      visited: {
        check: esgst.gdttt,
        name: `Visited`,
        type: `boolean`
      },
      unread: {
        check: esgst.ct,
        name: `Unread`,
        type: `boolean`
      },
      authors: {
        check: true,
        list: true,
        name: `Authors`,
        type: `string`
      }
    };
  }

  // [GF]
  
  _MODULES.push({
    description: `
      <ul>
        <li>Allows you to filter giveaways.</li>
      </ul>
    `,
    features: {
      gf_s: {
        description: `
          <ul>
            <li>Adds a button (<i class="fa fa-eye"></i> if the giveaway is hidden and <i class="fa fa-eye-slash"></i> if it is not) next to a giveaway's game name (in any page) that allows you to hide the giveaway.</li>
            <li>Adds a button (<i class="fa fa-gift"></i> <i class="fa fa-eye-slash"></i>) to the page heading of this menu that allows you to view all of the giveaways that have been hidden.</li>
          </ul>
        `,
        name: `Single Filters`,
        sg: true
      },
      gf_m: {
        description: `
          <ul>
            <li>Allows you to hide multiple giveaways in a page using many different filters.</li>
            <li>Adds a toggle switch with a button (<i class="fa fa-sliders"></i>) to the main page heading of any <a href="https://www.steamgifts.com/giveaways">giveaways</a>/<a href="https://www.steamgifts.com/giveaways/created">created</a>/<a href="https://www.steamgifts.com/giveaways/entered">entered</a>/<a href="https://www.steamgifts.com/giveaways/won">won</a>/<a href="https://www.steamgifts.com/user/cg">user</a>/<a href="https://www.steamgifts.com/group/SJ7Bu/">group</a> page and some popups ([id=gb], [id=ged], [id=ge], etc...). The switch allows you to turn the filters on/off and the button allows you to manage your presets.</li>
            <li>Adds a collapsible panel below the same main page heading that allows you to change/save the rules of a preset. The filters are separated in 3 categories:</li>
            <ul>
              <li>Basic filters are related to a numeric value (such as the level of a giveaway) and have a slider that you can use to set the range of the filter (any giveaways that do not apply to the range will be hidden).</li>
              <li>Type filters are related to a boolean value (such as whether or not a giveaway was created by yourself) and have a checkbox that changes states when you click on it. The checkbox has 3 states:</li>
              <ul>
                <li>"Show all" (<i class="fa fa-check-square"></i>) does not hide any giveaways that apply to the filter (this is the default state).</li>
                <li>"Show only" (<i class="fa fa-square"></i>) hides any giveaways that do not apply to the filter.</li>
                <li>"Hide all" (<i class="fa fa-square-o"></i>) hides any giveaways that apply to the filter.</li>
              </ul>
              <li>Category filters are essentially the same thing as type filters, but for game categories ([id=gc]).</li>
            </ul>
            <li>A preset contains all of your rules and can be saved to be reused later. You can save as many presets as you want. Each preset contains 3 types of rules:</li>
            <ul>
              <li>Basic rules are the ones that you can change directly in the filter panel, using the sliders/checkboxes as explained in the previous item.</li>
              <li>Exception rules are the ones that you can change by clicking on the icon <i class="fa fa-gear"></i> in the filter panel. They are exceptions to the basic rules. For example, if you set the basic rule of the "Created" filter to "hide all" and you add an exception rule for the "Level" filter to the 0-5 range, none of your created giveaways that are for the levels 0-5 will be hidden, because they apply to the exception.</li>
              <li>Override rules are the ones that you can change by clicking on the icon (<i class="fa fa-exclamation esgst-faded"></i> if set to overridable and <i class="fa fa-exclamation"></i> if set to non-overridable) next to each filter. They are enforcements of the basic rules. Continuing the previous example, if you set the override rule of the "Created" filter to "non-overridable", then all of your created giveaways will be hidden, because even if they apply to the exception, the basic rule is being enforced by the override rule, so the exception cannot override it.</li>
            </ul>
            <li>Adds a text in parenthesis to the pagination of the page showing how many giveaways in the page are being filtered by the filters.</li>
          </ul>
        `,
        features: {
          gf_m_b: {
            name: `Hide basic filters.`,
            sg: true
          },
          gf_m_a: {
            name: `Hide advanced filters.`,
            sg: true
          },
          gf_level: {
            description: `
              <ul>
                <li>Allows you to filter giveaways by level.</li>
              </ul>
            `,
            name: `Level`,
            sg: true
          },
          gf_entries: {
            description: `
              <ul>
                <li>Allows you to filter giveaways by number of entries.</li>
              </ul>
            `,
            name: `Entries`,
            sg: true
          },
          gf_copies: {
            description: `
              <ul>
                <li>Allows you to filter giveaways by number of copies.</li>
              </ul>
            `,
            name: `Copies`,
            sg: true
          },
          gf_points: {
            description: `
              <ul>
                <li>Allows you to filter giveaways by how many points they cost.</li>
              </ul>
            `,
            name: `Points`,
            sg: true
          },
          gf_comments: {
            description: `
              <ul>
                <li>Allows you to filter giveaways by number of comments.</li>
              </ul>
            `,
            name: `Comments`,
            sg: true
          },
          gf_minutesToEnd: {
            description: `
              <ul>
                <li>Allows you to filter giveaways by how much time they have left.</li>
              </ul>
            `,
            name: `Minutes To End`,
            sg: true
          },
          gf_chance: {
            description: `
              <ul>
                <li>Allows you to filter giveaways by chance.</li>
                <li>This option requires [id=gwc] enabled to work.</li>
              </ul>
            `,
            name: `Chance`,
            sg: true
          },
          gf_chancePerPoint: {
            description: `
              <ul>
                <li>Allows you to filter giveaways by chance per point.</li>
                <li>This option requires [id=gwc] enabled to work.</li>
              </ul>
            `,
            name: `Chance Per Point`,
            sg: true
          },
          gf_ratio: {
            description: `
              <ul>
                <li>Allows you to filter giveaways by ratio.</li>
                <li>This option requires [id=gwr] enabled to work.</li>
              </ul>
            `,
            name: `Ratio`,
            sg: true
          },
          gf_rating: {
            description: `
              <ul>
                <li>Allows you to filter giveaways by rating percentage of the game.</li>
                <li>This option requires [id=gc_r] enabled to work.</li>
              </ul>
            `,
            name: `Rating`,
            sg: true
          },
          gf_releaseDate: {
            description: `
              <ul>
                <li>Allows you to filter giveaways by release date of the game.</li>
                <li>This option requires [id=gc_rd] enabled to work.</li>
              </ul>
            `,
            name: `Release Date`,
            sg: true
          },
          gf_pinned: {
            description: `
              <ul>
                <li>Allows you to filter giveaways that are pinned.</li>
              </ul>
            `,
            name: `Pinned`,
            sg: true
          },
          gf_public: {
            description: `
              <ul>
                <li>Allows you to filter giveaways that are public.</li>
              </ul>
            `,
            name: `Public`,
            sg: true
          },
          gf_inviteOnly: {
            description: `
              <ul>
                <li>Allows you to filter giveaways that are invite only.</li>
              </ul>
            `,
            name: `Invite Only`,
            sg: true
          },
          gf_group: {
            description: `
              <ul>
                <li>Allows you to filter giveaways that are for groups.</li>
              </ul>
            `,
            name: `Group`,
            sg: true
          },
          gf_whitelist: {
            description: `
              <ul>
                <li>Allows you to filter giveaways that are for whitelist.</li>
              </ul>
            `,
            name: `Whitelist`,
            sg: true
          },
          gf_regionRestricted: {
            description: `
              <ul>
                <li>Allows you to filter giveaways that are region restricted.</li>
              </ul>
            `,
            name: `Region Restricted`,
            sg: true
          },
          gf_created: {
            description: `
              <ul>
                <li>Allows you to filter giveaways created by yourself.</li>
              </ul>
            `,
            name: `Created`,
            sg: true
          },
          gf_received: {
            description: `
              <ul>
                <li>Allows you to filter giveaways that have been marked as received.</li>
              </ul>
            `,
            name: `Received`,
            sg: true
          },
          gf_notReceived: {
            description: `
              <ul>
                <li>Allows you to filter giveaways that have been marked as not received.</li>
              </ul>
            `,
            name: `Not Received`,
            sg: true
          },
          gf_awaitingFeedback: {
            description: `
              <ul>
                <li>Allows you to filter giveaways that are awaiting feedback.</li>
              </ul>
            `,
            name: `Awaiting Feedback`,
            sg: true
          },
          gf_entered: {
            description: `
              <ul>
                <li>Allows you to filter giveaways that you have entered.</li>
              </ul>
            `,
            name: `Entered`,
            sg: true
          },
          gf_started: {
            description: `
              <ul>
                <li>Allows you to filter giveaways that have started.</li>
              </ul>
            `,
            name: `Started`,
            sg: true
          },
          gf_ended: {
            description: `
              <ul>
                <li>Allows you to filter giveaways that have ended.</li>
              </ul>
            `,
            name: `Ended`,
            sg: true
          },
          gf_deleted: {
            description: `
              <ul>
                <li>Allows you to filter giveaways that have been deleted.</li>
              </ul>
            `,
            name: `Deleted`,
            sg: true
          },
          gf_owned: {
            description: `
              <ul>
                <li>Allows you to filter giveaways for games that you own on Steam.</li>
              </ul>
            `,
            name: `Owned`,
            sg: true
          },
          gf_wishlisted: {
            description: `
              <ul>
                <li>Allows you to filter giveaways for games that you have wishlisted on Steam.</li>
              </ul>
            `,
            name: `Wishlisted`,
            sg: true
          },
          gf_hidden: {
            description: `
              <ul>
                <li>Allows you to filter giveaways for games that you have hidden on SteamGifts.</li>
              </ul>
            `,
            name: `Hidden`,
            sg: true
          },
          gf_ignored: {
            description: `
              <ul>
                <li>Allows you to filter giveaways for games that you have ignored on Steam.</li>
              </ul>
            `,
            name: `Ignored`,
            sg: true
          },
          gf_previouslyEntered: {
            description: `
              <ul>
                <li>Allows you to filter giveaways for games that you have previously entered giveaways for.</li>
                <li>This option requires [id=egh] enabled to work.</li>
              </ul>
            `,
            name: `Previously Entered`,
            sg: true
          },
          gf_previouslyWon: {
            description: `
              <ul>
                <li>Allows you to filter giveaways for games that you have previously won.</li>
              </ul>
            `,
            name: `Previously Won`,
            sg: true
          },
          gf_fullCV: {
            description: `
              <ul>
                <li>Allows you to filter giveaways for games that give full CV.</li>
              </ul>
            `,
            name: `Full CV`,
            sg: true
          },
          gf_reducedCV: {
            description: `
              <ul>
                <li>Allows you to filter giveaways for games that give reduced CV.</li>
              </ul>
            `,
            name: `Reduced CV`,
            sg: true
          },
          gf_noCV: {
            description: `
              <ul>
                <li>Allows you to filter giveaways for games that give no CV.</li>
              </ul>
            `,
            name: `No CV`,
            sg: true
          },
          gf_sgTools: {
            description: `
              <ul>
                <li>Allows you to filter SGTools giveaways.</li>
                <li>This option requires [id=ge] enabled to work.</li>
              </ul>
            `,
            name: `SGTools`,
            sg: true
          },
          gf_groups: {
            description: `
              <ul>
                <li>Allows you to filter giveaways by group.</li>
                <li>This option requires [id=ggl] enabled as "Panel (On Page Load)" to work.</li>
              </ul>
            `,
            name: `Groups`,
            sg: true
          },
          gf_creators: {
            description: `
              <ul>
                <li>Allows you to filter giveaways by creator.</li>
              </ul>
            `,
            name: `Creators`,
            sg: true
          },
          gf_removed: {
            description: `
              <ul>
                <li>Allows you to filter giveaways for games that have been removed from the Steam store.</li>
                <li>This option requires [id=gc_rm] enabled to work.</li>
              </ul>
            `,
            name: `Removed`,
            sg: true
          },
          gf_tradingCards: {
            description: `
              <ul>
                <li>Allows you to filter giveaways for games that have trading cards.</li>
                <li>This option requires [id=gc_tc] enabled to work.</li>
              </ul>
            `,
            name: `Trading Cards`,
            sg: true
          },
          gf_achievements: {
            description: `
              <ul>
                <li>Allows you to filter giveaways for games that have achievements.</li>
                <li>This option requires [id=gc_a] enabled to work.</li>
              </ul>
            `,
            name: `Achievements`,
            sg: true
          },
          gf_multiplayer: {
            description: `
              <ul>
                <li>Allows you to filter giveaways for games that are multiplayer.</li>
                <li>This option requires [id=gc_mp] enabled to work.</li>
              </ul>
            `,
            name: `Multiplayer`,
            sg: true
          },
          gf_steamCloud: {
            description: `
              <ul>
                <li>Allows you to filter giveaways for games that have Steam Cloud.</li>
                <li>This option requires [id=gc_sc] enabled to work.</li>
              </ul>
            `,
            name: `Steam Cloud`,
            sg: true
          },
          gf_linux: {
            description: `
              <ul>
                <li>Allows you to filter giveaways for games that have are compatible with Linux.</li>
                <li>This option requires [id=gc_l] enabled to work.</li>
              </ul>
            `,
            name: `Linux`,
            sg: true
          },
          gf_mac: {
            description: `
              <ul>
                <li>Allows you to filter giveaways for games that are compatible with Mac.</li>
                <li>This option requires [id=gc_m] enabled to work.</li>
              </ul>
            `,
            name: `Mac`,
            sg: true
          },
          gf_dlc: {
            description: `
              <ul>
                <li>Allows you to filter giveaways for games that are DLCs.</li>
                <li>This option requires [id=gc_dlc] enabled to work.</li>
              </ul>
            `,
            name: `DLC`,
            sg: true
          },
          gf_dlcOwned: {
            description: `
              <ul>
                <li>Allows you to filter giveaways for games that are DLCs and have a base game that you own.</li>
                <li>This option requires [id=gc_dlc_o] enabled to work.</li>
              </ul>
            `,
            name: `DLC (Owned Base)`,
            sg: true
          },
          gf_dlcFree: {
            description: `
              <ul>
                <li>Allows you to filter giveaways for games that are DLCs and have a free base game.</li>
                <li>This option requires [id=gc_dlc_b] enabled to work.</li>
              </ul>
            `,
            name: `DLC (Free Base)`,
            sg: true
          },
          gf_dlcNonFree: {
            description: `
              <ul>
                <li>Allows you to filter giveaways for games that are DLCs and have a non-free base game.</li>
                <li>This option requires [id=gc_dlc_b] enabled to work.</li>
              </ul>
            `,
            name: `DLC (Non-Free Base)`,
            sg: true
          },
          gf_package: {
            description: `
              <ul>
                <li>Allows you to filter giveaways for games that are packages.</li>
                <li>This option requires [id=gc_p] enabled to work.</li>
              </ul>
            `,
            name: `Package`,
            sg: true
          },
          gf_earlyAccess: {
            description: `
              <ul>
                <li>Allows you to filter giveaways for games that are in early access.</li>
                <li>This option requires [id=gc_ea] enabled to work.</li>
              </ul>
            `,
            name: `Early Access`,
            sg: true
          },
          gf_genres: {
            description: `
              <ul>
                <li>Allows you to filter giveaways by game genre.</li>
                <li>This option requires [id=gc_g] enabled to work.</li>
              </ul>
            `,
            name: `Genres`,
            sg: true
          },
          gf_os: {
            description: `
              <ul>
                <li>Allows you to quickly enable/disable SteamGifts' "Filter by OS" filter.</li>
              </ul>
            `,
            name: `OS (SteamGifts)`,
            sg: true
          },
          gf_alreadyOwned: {
            description: `
              <ul>
                <li>Allows you to quickly enable/disable SteamGifts' "Hide games you already own" filter.</li>
              </ul>
            `,
            name: `Already Owned (SteamGifts)`,
            sg: true
          },
          gf_dlcMissingBase: {
            description: `
              <ul>
                <li>Allows you to quickly enable/disable SteamGifts' "Hide DLC if you're missing the base game" filter.</li>
              </ul>
            `,
            name: `DLC Missing Base (SteamGifts)`,
            sg: true
          },
          gf_aboveLevel: {
            description: `
              <ul>
                <li>Allows you to quickly enable/disable SteamGifts' "Hide giveaways above your level" filter.</li>
              </ul>
            `,
            name: `Above Level (SteamGifts)`,
            sg: true
          },
          gf_manuallyFiltered: {
            description: `
              <ul>
                <li>Allows you to quickly enable/disable SteamGifts' "Hide games you manually filtered" filter.</li>
              </ul>
            `,
            name: `Manually Filtered (SteamGifts)`,
            sg: true
          }
        },
        name: `Multiple Filters`,
        sg: true
      }
    },
    id: `gf`,
    load: gf,
    name: `Giveaway Filters`,
    sg: true,
    sync: `Hidden Games, Owned/Wishlisted/Ignored Games, Won Games, Reduced CV Games, No CV Games and Giveaways`,
    type: `giveaways`
  });

  function gf() {
    if (esgst.gf_s) {
      esgst.giveawayFeatures.push(gf_getGiveaways);
    }
    if (esgst.gf_m && (esgst.giveawaysPath || esgst.createdPath || esgst.enteredPath || esgst.wonPath || esgst.groupPath || esgst.userPath)) {
      esgst.style.insertAdjacentText(`beforeEnd`, `
        .esgst-gf-container {
          top: ${esgst.commentsTop - 5}px;
        }
      `);
      if (esgst.hideButtons && esgst.hideButtons_gf) {
        if (esgst.leftButtonIds.indexOf(`gf`) > -1) {
          esgst.leftButtons.insertBefore(filters_addContainer(`gf`, esgst.mainPageHeading), esgst.leftButtons.firstElementChild);
        } else {
          esgst.rightButtons.appendChild(filters_addContainer(`gf`, esgst.mainPageHeading));
        }
      } else {
        esgst.mainPageHeading.insertBefore(filters_addContainer(`gf`, esgst.mainPageHeading), esgst.mainPageHeading.firstElementChild);
      }
    }
    if (location.pathname.match(/^\/account\/settings\/giveaways$/) && (esgst.gf_os || esgst.gf_alreadyOwned || esgst.gf_dlcMissingBase || esgst.gf_aboveLevel || esgst.gf_manuallyFiltered)) {
      let key,
        inputs = {
          filter_os: null,
          filter_giveaways_exist_in_account: null,
          filter_giveaways_missing_base_game: null,
          filter_giveaways_level: null,
          filter_giveaways_additional_games: null
        };
      for (key in inputs) {
        inputs[key] = document.querySelector(`[name="${key}"]`);
      }
      document.getElementsByClassName(`form__submit-button js__submit-form`)[0].addEventListener(`click`, () => {
        for (key in inputs) {
          esgst.settings[key] = parseInt(inputs[key].value);
        }
        setValue(`settings`, JSON.stringify(esgst.settings));
      });
    }
  }

  function gf_getGiveaways(giveaways, main, source) {
    giveaways.forEach(giveaway => {
      if (giveaway.creator !== esgst.username && !giveaway.ended && !giveaway.entered && giveaway.url) {
        if (source === `gf` || esgst.giveawayPath) {
          if (!giveaway.innerWrap.getElementsByClassName(`esgst-gf-unhide-button`)[0] && esgst.giveaways[giveaway.code] && esgst.giveaways[giveaway.code].hidden) {
            new Button(giveaway.headingName, `beforeBegin`, {
              callbacks: [gf_hideGiveaway.bind(null, giveaway, main), null, gf_unhideGiveaway.bind(null, giveaway, main), null],
              className: `esgst-gf-unhide-button`,
              icons: [`fa-eye-slash esgst-clickable`, `fa-circle-o-notch fa-spin`, `fa-eye esgst-clickable`, `fa-circle-o-notch fa-spin`],
              id: `gf_s`,
              index: 2,
              titles: [`Hide giveaway`, `Hiding giveaway...`, `Unhide giveaway`, `Unhiding giveaway...`]
            });
          }
        }
        if ((source !== `gc` && (esgst.giveawaysPath || esgst.groupPath)) || esgst.giveawayPath) {
          if (!giveaway.innerWrap.getElementsByClassName(`esgst-gf-hide-button`)[0] && (!esgst.giveaways[giveaway.code] || !esgst.giveaways[giveaway.code].hidden || !esgst.giveaways[giveaway.code].code)) {
            new Button(giveaway.headingName, `beforeBegin`, {
              callbacks: [gf_hideGiveaway.bind(null, giveaway, main), null, gf_unhideGiveaway.bind(null, giveaway, main), null],
              className: `esgst-gf-hide-button`,
              icons: [`fa-eye-slash esgst-clickable`, `fa-circle-o-notch fa-spin`, `fa-eye esgst-clickable`, `fa-circle-o-notch fa-spin`],
              id: `gf_s`,
              index: 0,
              titles: [`Hide giveaway`, `Hiding giveaway...`, `Unhide giveaway`, `Unhiding giveaway...`]
            });
          }
        }
      }
    });
  }

  async function gf_hideGiveaway(giveaway, main) {
    let deleteLock = await createLock(`giveawayLock`, 300);
    let giveaways = JSON.parse(await getValue(`giveaways`, `{}`));
    if (!giveaways[giveaway.code]) {
      giveaways[giveaway.code] = {};
    }
    giveaways[giveaway.code].code = giveaway.code;
    giveaways[giveaway.code].endTime = giveaway.endTime;
    giveaways[giveaway.code].hidden = Date.now();
    await setValue(`giveaways`, JSON.stringify(giveaways));
    deleteLock();
    if (!main || !esgst.giveawayPath) {
      giveaway.outerWrap.remove();
    }
    return true;
  }

  async function gf_unhideGiveaway(giveaway, main) {
    let deleteLock = await createLock(`giveawayLock`, 300);
    let giveaways = JSON.parse(await getValue(`giveaways`, `{}`));
    if (giveaways[giveaway.code]) {
      delete giveaways[giveaway.code].hidden;
    }
    await setValue(`giveaways`, JSON.stringify(giveaways));
    deleteLock();
    if (!main || !esgst.giveawayPath) {
      giveaway.outerWrap.remove();
    }
    return true;
  }

  function gf_getFilters(popup) {
    return {
      level: {
        check: (!esgst.parameters.level_min && !esgst.parameters.level_max) && (((!esgst.createdPath || esgst.cewgd) && (!esgst.enteredPath || esgst.cewgd) && (!esgst.wonPath || esgst.cewgd)) || popup),
        maxValue: 10,
        minValue: 0,
        name: `Level`,
        type: `number`
      },
      entries: {
        check: (!esgst.parameters.entry_min && !esgst.parameters.entry_max) && (!esgst.wonPath || popup),
        minValue: 0,
        name: `Entries`,
        type: `number`
      },
      copies: {
        check: (!esgst.parameters.copy_min && !esgst.parameters.copy_max) && (!esgst.wonPath || popup),
        minValue: 1,
        name: `Copies`,
        type: `number`
      },
      points: {
        check: (!esgst.parameters.point_min && !esgst.parameters.point_max) && (((!esgst.createdPath || esgst.cewgd) && (!esgst.enteredPath || esgst.cewgd) && (!esgst.wonPath || esgst.cewgd)) || popup),
        maxValue: 100,
        minValue: 0,
        name: `Points`,
        type: `number`
      },
      comments: {
        check: popup || (!esgst.createdPath && !esgst.enteredPath && !esgst.wonPath),
        minValue: 0,
        name: `Comments`,
        type: `number`
      },
      minutesToEnd: {
        check: !esgst.wonPath || popup,
        minValue: 0,
        name: `Minutes To End`,
        type: `number`
      },
      chance: {
        check: ((!esgst.enteredPath || esgst.cewgd) && !esgst.createdPath && !esgst.wonPath) || popup,
        maxValue: 100,
        minValue: 0,
        name: `Chance`,
        step: 0.01,
        type: `number`
      },
      chancePerPoint: {
        check: ((!esgst.enteredPath || esgst.cewgd) && !esgst.createdPath && !esgst.wonPath) || popup,
        maxValue: 100,
        minValue: 0,
        name: `Chance Per Point`,
        step: 0.01,
        type: `number`
      },
      ratio: {
        check: ((!esgst.enteredPath || esgst.cewgd) && !esgst.createdPath && !esgst.wonPath) || popup,
        minValue: 0,
        name: `Ratio`,
        type: `number`
      },
      rating: {
        category: `gc_r`,
        check: true,
        maxValue: 100,
        minValue: 0,
        name: `Rating`,
        type: `number`
      },
      releaseDate: {
        category: `gc_rd`,
        check: !esgst.parameters.release_date_min && !esgst.parameters.release_date_max,
        date: true,
        name: `Release Date`,
        type: `number`
      },
      pinned: {
        check: esgst.giveawaysPath,
        name: `Pinned`,
        type: `boolean`
      },
      public: {
        check: !esgst.giveawaysPath,
        name: `Public`,
        type: `boolean`
      },
      inviteOnly: {
        check: ((!esgst.createdPath || esgst.cewgd) && (!esgst.enteredPath || esgst.cewgd) && (!esgst.wonPath || esgst.cewgd)) || popup,
        name: `Invite Only`,
        type: `boolean`
      },
      group: {
        check: ((!esgst.createdPath || esgst.cewgd) && (!esgst.enteredPath || esgst.cewgd) && (!esgst.wonPath || esgst.cewgd)) || popup,
        name: `Group`,
        type: `boolean`
      },
      whitelist: {
        check: ((!esgst.createdPath || esgst.cewgd) && (!esgst.enteredPath || esgst.cewgd) && (!esgst.wonPath || esgst.cewgd)) || popup,
        name: `Whitelist`,
        type: `boolean`
      },
      regionRestricted: {
        check: ((!esgst.createdPath || esgst.cewgd) && (!esgst.enteredPath || esgst.cewgd) && (!esgst.wonPath || esgst.cewgd)) || popup,
        name: `Region Restricted`,
        type: `boolean`
      },
      created: {
        check: (!esgst.createdPath && !esgst.enteredPath && !esgst.wonPath) || popup,
        name: `Created`,
        type: `boolean`
      },
      received: {
        check: esgst.createdPath,
        name: `Received`,
        type: `boolean`
      },
      notReceived: {
        check: esgst.createdPath,
        name: `Not Received`,
        type: `boolean`
      },
      awaitingFeedback: {
        check: esgst.createdPath,
        name: `Awaiting Feedback`,
        type: `boolean`
      },
      entered: {
        check: (!esgst.createdPath && !esgst.enteredPah && !esgst.wonPath) || popup,
        name: `Entered`,
        type: `boolean`
      },
      started: {
        check: (!esgst.enteredPath && !esgst.wonPath) || popup,
        name: `Started`,
        type: `boolean`
      },
      ended: {
        check: !esgst.wonPath || popup,
        name: `Ended`,
        type: `boolean`
      },
      deleted: {
        check: esgst.createdPath || esgst.enteredPath,
        name: `Deleted`,
        type: `boolean`
      },
      owned: {
        check: true,
        name: `Owned`,
        type: `boolean`
      },
      wishlisted: {
        check: true,
        name: `Wishlisted`,
        type: `boolean`
      },
      hidden: {
        check: true,
        name: `Hidden`,
        type: `boolean`
      },
      ignored: {
        check: true,
        name: `Ignored`,
        type: `boolean`
      },
      previouslyEntered: {
        check: true,
        name: `Previously Entered`,
        type: `boolean`
      },
      previouslyWon: {
        check: true,
        name: `Previously Won`,
        type: `boolean`
      },
      fullCV: {
        check: true,
        name: `Full CV`,
        type: `boolean`
      },
      reducedCV: {
        check: true,
        name: `Reduced CV`,
        type: `boolean`
      },
      noCV: {
        check: true,
        name: `No CV`,
        type: `boolean`
      },
      sgTools: {
        check: esgst.ge,
        name: `SGTools`,
        type: `boolean`
      },
      groups: {
        check: esgst.ggl && esgst.ggl_index === 0,
        list: true,
        name: `Groups`,
        type: `string`
      },
      creators: {
        check: true,
        list: true,
        name: `Creators`,
        type: `string`
      },
      removed: {
        category: `gc_rm`,
        check: true,
        name: `Removed`,
        type: `boolean`
      },
      tradingCards: {
        category: `gc_tc`,
        check: true,
        name: `Trading Cards`,
        type: `boolean`
      },
      achievements: {
        category: `gc_a`,
        check: true,
        name: `Achievements`,
        type: `boolean`
      },
      multiplayer: {
        category: `gc_mp`,
        check: true,
        name: `Multiplayer`,
        type: `boolean`
      },
      steamCloud: {
        category: `gc_sc`,
        check: true,
        name: `Steam Cloud`,
        type: `boolean`
      },
      linux: {
        category: `gc_l`,
        check: true,
        name: `Linux`,
        type: `boolean`
      },
      mac: {
        category: `gc_m`,
        check: true,
        name: `Mac`,
        type: `boolean`
      },
      dlc: {
        category: `gc_dlc`,
        check: true,
        name: `DLC`,
        type: `boolean`
      },
      dlcOwned: {
        category: `gc_dlc_o`,
        check: true,
        name: `DLC (Owned Base)`,
        type: `boolean`
      },
      dlcFree: {
        category: `gc_dlc_b`,
        check: true,
        name: `DLC (Free Base)`,
        type: `boolean`
      },
      dlcNonFree: {
        category: `gc_dlc_b`,
        check: true,
        name: `DLC (Non-Free Base)`,
        type: `boolean`
      },
      package: {
        category: `gc_p`,
        check: true,
        name: `Package`,
        type: `boolean`
      },
      earlyAccess: {
        category: `gc_ea`,
        check: true,
        name: `Early Access`,
        type: `boolean`
      },
      genres: {
        category: `gc_g`,
        check: true,
        list: true,
        name: `Genres`,
        type: `string`
      }
    };
  }

  function filters_addContainer(id, heading, popup) {
    const obj = {
      basicFilters: {},
      id: id,
      key: `${id}_presets`,
      popup: popup,
      rules: null,
      type: popup || (esgst.groupPath ? `Groups` : (location.search.match(/type/) ? { wishlist: `Wishlist`, recommended: `Recommended`, group: `Group`, new: `New` }[location.search.match(/type=(wishlist|recommended|group|new)/)[1]] : (esgst.createdPath ? `Created` : (esgst.enteredPath ? `Entered` : (esgst.wonPath ? `Won` : (esgst.userPath ? `User` : ``))))))
    };
    switch (id) {
      case `gf`:
        obj.filters = gf_getFilters(popup);
        break;
      case `df`:
        obj.filters = df_getFilters(popup);
        break;
      case `cf`:
        obj.filters = cf_getFilters(popup);
        break;
      default:
        break;
    } 
    if (popup) {
      esgst[`${id}Popup`] = obj;
    } else {
      esgst[id] = obj;
    }

    const headingButton = document.createElement(`div`);
    headingButton.className = `esgst-heading-button esgst-gf-heading-button`;
    headingButton.id = `esgst-${obj.id}`;
    headingButton.innerHTML = `
      <span class="esgst-gf-toggle-switch"></span>
      <i class="fa fa-sliders" title="${getFeatureTooltip(obj.id, `Manage presets`)}"></i>
    `;
    const toggleSwitch = new ToggleSwitch(
      headingButton.firstElementChild,
      `${obj.id}_enable${obj.type}`,
      true,
      ``,
      false,
      false,
      null,
      esgst[`${obj.id}_enable${obj.type}`]
    );
    const presetButton = headingButton.lastElementChild;

    toggleSwitch.onEnabled = filters_filter.bind(null, obj);
    toggleSwitch.onDisabled = filters_filter.bind(null, obj, true);

    obj.container = insertHtml(heading, `afterEnd`, `
      <div class="esgst-gf-container">
        <div class="esgst-gf-box">
          <div class="esgst-gf-filters esgst-hidden">
            <div class="esgst-gf-left-panel">
              <div class="esgst-gf-basic-filters">
                <div class="esgst-gf-number-filters"></div>
                <div class="esgst-gf-boolean-filters"></div>
                <div class="esgst-gf-string-filters"></div>
              </div>
              <div>
                Advanced <i class="fa fa-question-circle" title="Advanced filters offer more options and flexibility, but may be more complex to understand and use. When you change settings in the basic filters, they will also be changed in the advanced ones, and vice-versa. But the two types are not compatible backwards: basic -> advanced conversion works fine, but advanced -> basic conversion does not, and will result in the loss of any settings that are exclusive to the advanced filter. Bear this in mind when saving a preset, since the last applied preset will be saved."></i>
              </div>
              <div class="esgst-clickable">
                Manual <i class="fa fa-book"></i>
              </div>
              <div class="esgst-gf-advanced-filters"></div>
            </div>
            <div class="esgst-gf-right-panel">
              <div class="esgst-gf-steamgifts-filters">
                <div>
                  <span class="esgst-bold">SteamGifts Filters:</span>
                </div>
              </div>
              <br>
              <div class="esgst-gf-preset-panel">
                <div>
                  <span class="esgst-bold">Preset:</span>
                  <i class="fa fa-question-circle" title="If you have both the basic and the advanced filters enabled, the last applied preset will be saved. For example, if the last setting you altered was in the basic filters, it will save the basic preset, and if the last setting you altered was in the advanced filters, it will save the advanced preset. The two presets are not compatible, so they will overwrite each other. Be careful with this, as you might lose some settings."></i>
                </div>
                <input class="form__input-small" type="text"/>
                <div class="esgst-description esgst-bold"></div>
                <div class="form__row__error esgst-hidden">
                  <i class="fa fa-exclamation-circle"></i> Please enter a name for the preset.
                </div>
                <div class="esgst-description">The name of the preset.</div>
              </div>
            </div>
          </div>
        </div>
        <div class="esgst-gf-button">
          <span>Expand</span><span class="esgst-hidden">Collapse</span> filters (<span>0</span> filtered ${obj.id === `gf` ? `- <span>0</span>P required to enter all unfiltered ` : ``}- <span></span>)
        </div>
      </div>
    `);

    if (!obj.popup) {
      esgst.commentsTop += obj.container.offsetHeight;
    }

    const box = obj.container.firstElementChild;
    obj.filtersPanel = box.firstElementChild;
    const leftPanel = obj.filtersPanel.firstElementChild;
    const basicFilters = leftPanel.firstElementChild;
    const numberFilters = basicFilters.firstElementChild;
    const booleanFilters = numberFilters.nextElementSibling;
    const stringFilters = booleanFilters.nextElementSibling;
    const advancedFilters = leftPanel.lastElementChild;
    const rightPanel = leftPanel.nextElementSibling;
    const sgFilters = rightPanel.firstElementChild;
    const presetPanel = rightPanel.lastElementChild;
    obj.presetInput = presetPanel.firstElementChild.nextElementSibling;
    obj.presetMessage = obj.presetInput.nextElementSibling;
    obj.presetWarning = obj.presetMessage.nextElementSibling;
    const button = box.nextElementSibling;
    obj.expandButton = button.firstElementChild;
    obj.collapseButton = obj.expandButton.nextElementSibling;
    obj.filteredCount = obj.collapseButton.nextElementSibling;
    if (obj.id === `gf`) {
      obj.pointsCount = obj.filteredCount.nextElementSibling;
      obj.presetDisplay = obj.pointsCount.nextElementSibling;
    } else {
      obj.presetDisplay = obj.filteredCount.nextElementSibling;
    }

    advancedFilters.previousElementSibling.addEventListener(`click`, filter_manual.bind(null, {}));

    presetPanel.appendChild(new ButtonSet_v2({
      color1: `green`,
      color2: `grey`,
      icon1: `fa-check`,
      icon2: `fa-circle-o-notch fa-spin`,
      title1: `Save`,
      title2: `Saving...`,
      callback1: filters_savePreset.bind(null, obj)
    }).set);

    let name = esgst[`${obj.id}_preset${obj.type}`];
    if (name) {
      let i;
      for (i = esgst[obj.key].length - 1; i > -1 && esgst[obj.key][i].name !== name; i--);
      if (i > -1) {
        obj.rules = esgst[obj.key][i].rules;
      }
    }
    if (!obj.rules) {
      name = `Default${obj.type}`;
      const preset = {
        name,
        rules: {}
      };
      esgst[obj.key].push(preset);
      setSetting([
        {
          id: `${obj.id}_preset${obj.type}`,
          value: name
        },
        {
          id: obj.key,
          value: esgst[obj.key]
        }
      ]);
      obj.rules = {};
    }
    obj.rules_save = obj.rules;
    obj.presetDisplay.textContent = obj.presetInput.value = name;

    if (!obj.popup && esgst.pagination) {
      obj.paginationFilteredCount = insertHtml(esgst.pagination.firstElementChild, `beforeEnd`, `
        <span>
          (<span class="esgst-bold">0</span> filtered by ${obj.id === `gf` ? `Giveaway` : (obj.id === `df` ? `Discussion` : `Comment`)} Filters)
        </span>
      `).firstElementChild;
    }

    presetButton.addEventListener(`click`, filters_openPresetPopup.bind(null, obj));
    button.addEventListener(`click`, filters_toggleFilters.bind(null, obj));

    const filters = [];
    for (const key in obj.filters) {
      const filter = obj.filters[key];
      const rule = {
        id: key,
        label: filter.name
      };
      let context;
      let checkbox;
      let textInput;
      let maxInput;
      let minInput;
      switch (filter.type) {
        case `boolean`:
          rule.input = `radio`;
          rule.operators = [`equal`];
          rule.type = `boolean`;
          rule.values = [`true`, `false`];

          if (!esgst[`${obj.id}_m_b`]) {
            context = insertHtml(booleanFilters, `beforeEnd`, `
              <div ${esgst[`${obj.id}_${key}`] && filter.check ? `` : `class="esgst-hidden"`}>
                <span></span>
                <span class="esgst-gf-filter-count" title="Number of items this rule is hiding"></span>
                ${filter.name}
              </div>
            `);
            checkbox = new Checkbox(context.firstElementChild, `enabled`, true);
            obj.basicFilters[rule.id] = {
              data: {
                basicCount: context.firstElementChild.nextElementSibling
              },
              input: rule.input,
              operator: `equal`,
              type: rule.type,
              filterType: `boolean`,
              checkbox: checkbox
            };
            checkbox.onChange = filters_basicToAdv.bind(null, obj);
          }
          break;
        case `number`:
          rule.operators = [
            `equal`,
            `not_equal`,
            `less`,
            `less_or_equal`,
            `greater`,
            `greater_or_equal`,
            `is_null`,
            `is_not_null`
          ];
          if (filter.date) {
            rule.input = `text`;
            rule.plugin = `datepicker`;
            rule.plugin_config = {
              changeMonth: true,
              changeYear: true,
              dateFormat: `yy/mm/dd`
            };
            rule.type = `date`;

            if (!esgst[`${obj.id}_m_b`]) {
              context = insertHtml(numberFilters, `beforeEnd`, `
                <div ${esgst[`${obj.id}_${key}`] && filter.check ? `` : `class="esgst-hidden"`}>
                  <span class="esgst-gf-filter-count" title="Number of items this rule is hiding"></span>
                  ${filter.name}
                  <span>
                    <input type="date">-<input type="date">
                  </span>
                </div>
              `);
            }
          } else {
            rule.input = `number`;
            if (filter.step) {
              rule.type = `double`;
            } else {
              rule.type = `integer`;
            }
            rule.validation = {
              max: filter.maxValue,
              min: filter.minValue,
              step: filter.step
            };

            if (!esgst[`${obj.id}_m_b`]) {
              context = insertHtml(numberFilters, `beforeEnd`, `
                <div ${esgst[`${obj.id}_${key}`] && filter.check ? `` : `class="esgst-hidden"`}>
                  <span class="esgst-gf-filter-count" title="Number of items this rule is hiding"></span>
                  ${filter.name}
                  <span>
                    <input type="number">-<input type="number">
                  </span>
                </div>
              `);
            }
          }

          if (!esgst[`${obj.id}_m_b`]) {
            minInput = context.lastElementChild.firstElementChild;
            maxInput = minInput.nextElementSibling;
            obj.basicFilters[rule.id] = {
              data: {
                basicCount: context.firstElementChild
              },
              input: rule.input,
              type: rule.type,
              filterType: `number`,
              maxInput: maxInput,
              minInput: minInput
            };
            maxInput.addEventListener(`change`, filters_basicToAdv.bind(null, obj));
            minInput.addEventListener(`change`, filters_basicToAdv.bind(null, obj));
          }

          break;
        case `string`:
          rule.input = `text`;
          rule.operators = [`contains`, `not_contains`];
          rule.placeholder =  `Item1, Item2, ...`;
          rule.type = `string`;

          if (!esgst[`${obj.id}_m_b`]) {
            context = insertHtml(stringFilters, `beforeEnd`, `
              <div ${esgst[`${obj.id}_${key}`] && filter.check ? `` : `class="esgst-hidden"`}>
                <span>
                  <span></span> ${filter.name}
                </span>
                <span class="esgst-gf-filter-count" title="Number of items this rule is hiding"></span>
                <input placeholder="Item1, Item2, ..." type="text">
              </div>
            `);
            checkbox = new Checkbox(context.firstElementChild.firstElementChild, `enabled`,  true);
            textInput = context.lastElementChild;
            obj.basicFilters[rule.id] = {
              data: {
                basicCount: context.firstElementChild.nextElementSibling
              },
              id: rule.id,
              input: rule.input,
              type: rule.type,
              filterType: `string`,
              checkbox: checkbox,
              textInput: textInput
            };
            checkbox.onChange = filters_basicToAdv.bind(null, obj);
            textInput.addEventListener(`change`, filters_basicToAdv.bind(null, obj));
          }
          break;
      }
      if (!rule.data) {
        rule.data = {};
      }
      rule.data.check = esgst[`${obj.id}_${rule.id}`] && filter.check;
      filters.push(rule);
    }

    if (!esgst[`${obj.id}_m_b`]) {
      stringFilters.insertAdjacentHTML(`beforeEnd`, `
        <div class="esgst-gf-legend-panel">
          <div class="esgst-bold">Legend:</div>
          <div>
            <i class="fa fa-check-square"></i> - Show All</i>
          </div>
          <div>
            <i class="fa fa-square-o"></i> - Hide All</i>
          </div>
          <div>
            <i class="fa fa-square"></i> - Show Only</i>
          </div>
        </div>
      `);
      if (obj.rules.rules && obj.rules.rules.length) {
        filters_applyBasic(obj, obj.rules);
      }
    }
    if (!esgst[`${obj.id}_m_a`]) {
      const templates = {
        group : `
          <div id="{{= it.group_id }}" class="rules-group-container">
            <div class="rules-group-header">
              <span class="esgst-gf-filter-count" title="Number of items this group is hiding">0</span>
              <div class="btn-group pull-right group-actions">
                <button type="button" class="btn btn-xs btn-success" data-add="rule">
                  <i class="{{= it.icons.add_rule }}"></i> {{= it.translate("add_rule") }}
                </button>
              {{? it.settings.allow_groups===-1 || it.settings.allow_groups>=it.level }}
                <button type="button" class="btn btn-xs btn-success" data-add="group">
                  <i class="{{= it.icons.add_group }}"></i> {{= it.translate("add_group") }}
                </button>
              {{?}}
              {{? it.level>1 }}
                <button type="button" class="btn btn-xs btn-primary" data-pause="group">
                  <i class="{{= it.icons.pause_group }}"></i> {{= it.translate("pause_group") }}
                </button>
                <button type="button" class="btn btn-xs btn-primary" data-resume="group">
                  <i class="{{= it.icons.resume_group }}"></i> {{= it.translate("resume_group") }}
                </button>
                <button type="button" class="btn btn-xs btn-danger" data-delete="group">
                  <i class="{{= it.icons.remove_group }}"></i> {{= it.translate("delete_group") }}
                </button>
              {{?}}
              </div>
              <div class="btn-group group-conditions">
              {{~ it.conditions: condition }}
                <label class="btn btn-xs btn-default">
                  <input type="radio" name="{{= it.group_id }}_cond" value="{{= condition }}"> {{= it.translate("conditions", condition) }}
                </label>
              {{~}}
              </div>
            {{? it.settings.display_errors }}
              <div class="error-container">
                <i class="{{= it.icons.error }}"></i>
              </div>
            {{?}}
            </div>
            <div class=rules-group-body>
              <div class=rules-list></div>
            </div>
          </div>
        `,
        rule: `
          <div id="{{= it.rule_id }}" class="rule-container">
            <div class="rule-header">
              <div class="btn-group pull-right rule-actions">
                <button type="button" class="btn btn-xs btn-primary" data-pause="rule">
                  <i class="{{= it.icons.pause_rule }}"></i> {{= it.translate("pause_rule") }}
                </button>
                <button type="button" class="btn btn-xs btn-primary" data-resume="rule">
                  <i class="{{= it.icons.resume_rule }}"></i> {{= it.translate("resume_rule") }}
                </button>
                <button type="button" class="btn btn-xs btn-danger" data-delete="rule">
                  <i class="{{= it.icons.remove_rule }}"></i> {{= it.translate("delete_rule") }}
                </button>
              </div>
            </div>
          {{? it.settings.display_errors }}
            <div class="error-container">
              <i class="{{= it.icons.error }}"></i>
            </div>
          {{?}}
            <span class="esgst-gf-filter-count" title="Number of items this rule is hiding">0</span>
            <div class="rule-filter-container"></div>
            <div class="rule-operator-container"></div>
            <div class="rule-value-container"></div>
          </div>
        `,
        filterSelect: `
          {{ var optgroup = null; }}
          <select class="form-control" name="{{= it.rule.id }}_filter">
          {{? it.settings.display_empty_filter }}
            <option value="-1">{{= it.settings.select_placeholder }}</option>
          {{?}}
          {{~ it.filters: filter }}
            {{ var className = filter.data.check ? '' : 'class="esgst-hidden"'; }}
            {{? optgroup !== filter.optgroup }}
              {{? optgroup !== null }}</optgroup>{{?}}
              {{? (optgroup = filter.optgroup) !== null }}
                <optgroup label="{{= it.translate(it.settings.optgroups[optgroup]) }}">
              {{?}}
            {{?}}
            <option {{= className }} value="{{= filter.id }}" {{? filter.icon}}data-icon="{{= filter.icon}}"{{?}}>{{= it.translate(filter.label) }}</option>
          {{~}}
          {{? optgroup !== null }}</optgroup>{{?}}
          </select>
        `
      };
      const options = {
        filters: filters,
        icons: {
          add_group: `fa fa-plus`,
          add_rule: `fa fa-plus`,
          pause_group: `fa fa-pause`,
          pause_rule: `fa fa-pause`,
          remove_group: `fa fa-times`,
          remove_rule: `fa fa-times`,
          resume_group: `fa fa-play`,
          resume_rule: `fa fa-play`,
          error: `fa fa-exclamation`
        },
        plugins: {
          [`bt-checkbox`]: {
            font: `fontawesome`
          },
          [`not-group`]: {
            icon_checked: `fa fa-check-square-o`,
            icon_unchecked: `fa fa-square-o`
          },
          [`sortable`]: {
            icon: `fa fa-arrows`
          }
        },
        sort_filters: true,
        lang: {
          pause_group: `Pause`,
          pause_rule: `Pause`,
          resume_group: `Resume`,
          resume_rule: `Resume`
        },
        templates: templates
      };
      if (obj.rules.rules && obj.rules.rules.length) {
        options.rules = obj.rules;
      }
      $(advancedFilters).queryBuilder(options);
      obj.builder = $(advancedFilters)[0].queryBuilder;
      [obj.rules, obj.rules_save] = filters_changeRules(obj);

      obj.builder.$el.on(`click.queryBuilder`, `[data-pause=group]`, event => {
        const group = event.currentTarget.closest(`.rules-group-container`);
        group.setAttribute(`data-esgst-paused`, true);
        [obj.rules, obj.rules_save] = filters_changeRules(obj, {});
        filters_filter(obj);
      });
      obj.builder.$el.on(`click.queryBuilder`, `[data-resume=group]`, event => {
        const group = event.currentTarget.closest(`.rules-group-container`);
        group.removeAttribute(`data-esgst-paused`);
        [obj.rules, obj.rules_save] = filters_changeRules(obj, {});
        filters_filter(obj);
      });
      obj.builder.$el.on(`click.queryBuilder`, `[data-pause=rule]`, event => {
        const rule = event.currentTarget.closest(`.rule-container`);
        rule.setAttribute(`data-esgst-paused`, true);
        [obj.rules, obj.rules_save] = filters_changeRules(obj, {});
        filters_filter(obj);
      });
      obj.builder.$el.on(`click.queryBuilder`, `[data-resume=rule]`, event => {
        const rule = event.currentTarget.closest(`.rule-container`);
        rule.removeAttribute(`data-esgst-paused`);
        [obj.rules, obj.rules_save] = filters_changeRules(obj, {});
        filters_filter(obj);
      });

      obj.builder.on(`rulesChanged.queryBuilder`, () => {
        try {
          [obj.rules, obj.rules_save] = filters_changeRules(obj, {});
          if (!obj.basicApplied && !esgst[`${obj.id}_m_b`]) {
            filters_resetBasic(obj);
            filters_applyBasic(obj, obj.rules);
          }
          filters_filter(obj);
        } catch (e) {
          console.log(e);
        }
        obj.basicApplied = false;
      });
      obj.builder.on(`getRules.queryBuilder.filter`, filters_changeRules.bind(null, obj));
    }

    if (esgst[`${obj.id}_m_b`]) {
      basicFilters.classList.add(`esgst-hidden`);
      basicFilters.nextElementSibling.classList.add(`esgst-hidden`);
    }
    if (esgst[`${obj.id}_m_a`]) {
      advancedFilters.classList.add(`esgst-hidden`);
      basicFilters.nextElementSibling.classList.add(`esgst-hidden`);
    }

    if (obj.id === `gf`) {
      [
        {
          id: `filter_os`,
          key: `os`,
          name: `OS`
        },
        {
          id: `filter_giveaways_exist_in_account`,
          key: `alreadyOwned`,
          name: `Already Owned`
        },
        {
          id: `filter_giveaways_missing_base_game`,
          key: `dlcMissingBase`,
          name: `DLC Missing Base`
        },
        {
          id: `filter_giveaways_level`,
          key: `aboveLevel`,
          name: `Above Level`
        },
        {
          id: `filter_giveaways_additional_games`,
          key: `manuallyFiltered`,
          name: `Manually Filtered`
        }
      ].forEach(filter => {
        if (!esgst[`${obj.id}_${filter.key}`]) return;

        const sgFilter = insertHtml(sgFilters, `beforeEnd`, `
          <div class="esgst-gf-category-filter">
            <span>${filter.name}
            ${filter.key === `os` ? `
              <select>
                <option value="0">All</option>
                <option value="1">Windows</option>
                <option value="2">Linux</option>
                <option value="3">Mac</option>
              </select>`
            : ``}
            </span>
            <i class="fa fa-circle-o-notch fa-spin esgst-hidden"></i>
            <i class="fa fa-check esgst-green esgst-hidden"></i>
          </div>
        `);
        const check = sgFilter.lastElementChild;
        const spinning = check.previousElementSibling;
        if (filter.key === `os`) {
          const select = sgFilter.firstElementChild.firstElementChild;
          select.value = esgst[filter.id];
          select.addEventListener(`change`, async () => {
            check.classList.add(`esgst-hidden`);
            spinning.classList.remove(`esgst-hidden`);
            await setSetting(filter.id, select.value);
            esgst[filter.id] = select.value;
            await request({
              data: `filter_os=${esgst.filter_os}&filter_giveaways_exist_in_account=${esgst.filter_giveaways_exist_in_account}&filter_giveaways_missing_base_game=${esgst.filter_giveaways_missing_base_game}&filter_giveaways_level=${esgst.filter_giveaways_level}&filter_giveaways_additional_games=${esgst.filter_giveaways_additional_games}&xsrf_token=${esgst.xsrfToken}`,
              method: `POST`,
              url: `/account/settings/giveaways`
            });
            spinning.classList.add(`esgst-hidden`);
            check.classList.remove(`esgst-hidden`);
          });
        } else {
          const checkbox = new Checkbox(sgFilter, esgst[filter.id]);
          checkbox.checkbox.addEventListener(`click`, async () => {
            check.classList.add(`esgst-hidden`);
            spinning.classList.remove(`esgst-hidden`);
            await setSetting(filter.id, checkbox.checked ? 1 : 0);
            esgst[filter.id] = checkbox.checked ? 1 : 0;
            await request({
              data: `filter_os=${esgst.filter_os}&filter_giveaways_exist_in_account=${esgst.filter_giveaways_exist_in_account}&filter_giveaways_missing_base_game=${esgst.filter_giveaways_missing_base_game}&filter_giveaways_level=${esgst.filter_giveaways_level}&filter_giveaways_additional_games=${esgst.filter_giveaways_additional_games}&xsrf_token=${esgst.xsrfToken}`,
              method: `POST`,
              url: `/account/settings/giveaways`
            });
            spinning.classList.add(`esgst-hidden`);
            check.classList.remove(`esgst-hidden`);
          });
        }
      });
    }
    if (sgFilters.children.length === 1) {
      sgFilters.classList.add(`esgst-hidden`);
    }

    return headingButton;
  }

  function filter_manual(obj) {
    if (obj.popup) {
      obj.popup.open();
      return;
    }
    obj.popup = new Popup_v2({
      icon: `fa-book`,
      title: `Advanced Filters Manual`,
      addScrollable: `left`
    });
    obj.popup.getScrollable(`
      <div class="esgst-bold">Interface</div>
      <br>
      <div class="markdown">
        <ul>
          <li><span class="esgst-bold"><i class="fa fa-square-o"></i> NOT</span> - If checked, only items that do not apply to the group will be shown.</li>
          <li><span class="esgst-bold">AND</span> - Turns the group into an AND group, which means that only items that apply to every single rule of the group will be shown.</li>
          <li><span class="esgst-bold">OR</span> - Turns the group into an OR group, which means that only items that apply to at least one rule of the group will be shown.</li>
          <li><span class="esgst-bold"><i class="fa fa-arrows"></i></span> - Allows you reorder/move rules/groups. The order of the rules does not alter the result.</li>
          <li><span class="esgst-bold"><i class="fa fa-pause"></i> Pause</span> - Allows you to pause the rule/group, so that it does not filter anything until you resume it or refresh the page.</li>
          <li>The other buttons in the interface should be self-explanatory.</li>
        </ul>
      </div>
      <br>
      <div class="esgst-bold">Types of Filters</div>
      <br>
      <div class="markdown">
        <ul>
          <li><span class="esgst-bold">Boolean</span> - Presents a choice between true and false. Set to true if you only want to see items that apply to the filter, and to false otherwise. For example, if you only want to see giveaways that are on your wishlist, set wishlisted to "true"; if you only want to see giveaways that you have not entered, set entered to "false".</li>
          <li><span class="esgst-bold">Number</span> - Presents a text field and a choice between equal, not equal, less, less or equal, greater, greater or equal, is null and is not null. Enter the value that you want in the text field and choose the option that you want. For example, if you only want to see giveaways above level 5, you can either set level to "greater than 4" or to "greater or equal to 5". The is null and is not null options regard the presence of the filter. For example, some giveaways do not have a rating. If you still want to see those giveaways when filtering by rating, add an additional rule and set rating to "is null".</li>
          <li><span class="esgst-bold">Text</span> - Presents a text field and a choice between contains and doesn't contain. Enter the values that you want in the text field, separated by a comma followed by a space, and choose the option that you want. For example, if you only want to see giveaways that have the adventure or the action genres, set genres to "contains Adventure, Action". But if you only want to see giveaways that have both the adventure and the action genres, add 2 rules, set one to "contains Adventure" and the other to "contains Action", and turn the group into an AND group.</li>
        </ul>
      </div>
      <br>
      <div class="esgst-bold">Building the Filters</div>
      <br>
      <div class="markdown">
        <div>The process of building the filters might seem intimidating at first, but it is actually quite simple. Just think of it like this:</div>
        <ul>
          <li>Show me a="true" AND b="false".</li>
          <li>Show me a="false" OR b="true".</li>
          <li>Do NOT show me a="true".</li>
        </ul>
        <div>The building process for the filters above becomes, respectively:</div>
        <ul>
          <li>Turn group into AND, add rule a="true", add rule b="false".</li>
          <li>Turn group into OR, add rule a="false", add rule b="true".</li>
          <li>Check NOT option, add rule a="true".</li>
        </ul>
        <div>For more advanced filters, think in parenthesis:</div>
        <ul>
          <li>Show me (a="true" AND b="false") OR c="greater or equal to 5".</li>
          <li>Show me (a="false" AND b="true" AND c="false") OR (d="true" AND e="false") OR f="equal to 2".</li>
          <li>Show me (a="true" AND b="false" AND c="true" AND d="false") AND do NOT show me e="contains Adventure, Action".</li>
        </ul>
        <div>Each parenthesis represents a new group. NOT filters also represent a new group, since there isn't a NOT option for rules. So the building process for the filters above becomes, respectively:</div>
        <ul>
          <li>Turn group into OR, add group (turn group into AND, add rule a="true", add rule b="false"), add rule c="greater or equal to 5".</li>
          <li>Turn group into OR, add group (turn group into AND, add rule a="false", add rule b="true", add rule c="false"), add group (turn group into AND, add rule d="true", add rule e="false"), add rule f="equal to 2".</li>
          <li>Turn group into AND, add group (turn group into AND, add rule a="true", add rule b="false", add rule c="true", add rule d="false"), add group (check NOT option, add rule e="contains Adventure, Action").</li>
        </ul>
        <div>Real example: suppose you only want to see giveaways that are for level 5 or more and that have achievements or trading cards. The sentence for that system is:</div>
        <ul>
          <li>Show me level="greater or equal to 5" AND (achievements="true" OR tradingCards="true").</li>
        </ul>
        <div>And the building process is:</div>
        <ul>
          <li>Turn group into AND, add rule level="greater or equal to 5", add group (turn group into OR, add rule achievements="true", add rule tradingCards="true").</li>
        </ul>
        <div>The final result is illustrated in the picture below:</div>
      </div>
      <img src="https://i.imgur.com/F1UXcKs.png">
    `);
    obj.popup.open();
  }

  function filters_convert(presets) {
    const minValues = {
      level: 0,
      entries: 0,
      copies: 1,
      points: 0,
      comments: 0,
      minutesToEnd: 0,
      chance: 0,
      chancePerPoint: 0,
      ratio: 0,
      rating: 0,
      releaseDate: 0
    };
    const maxValues = {
      level: 10,
      points: 100,
      minutesToEnd: 43800,
      chance: 100,
      chancePerPoint: 100,
      rating: 100,
      releaseDate: 3187209600
    };
    const newPresets = [];
    for (const preset of presets) {
      let newPreset = {
        condition: `AND`,
        not: false,
        rules: []
      };

      // Convert basic rules.
      for (let key in preset) {
        if (key.match(/^(authors|creators|exceptions|genres|groups|words|name|overrides)$/)) {
          continue;
        }

        const isMax = key.match(/^max/);
        const isMin = key.match(/^min/);
        const value = preset[key];
        key = key.replace(/(^(max|min))|List$/, ``);
        key = `${key[0].toLowerCase()}${key.slice(1)}`;
        if (isMax) {
          if (value !== maxValues[key] && !value.toString().match(/^9+$/)) {
            newPreset.rules.push({
              field: key,
              id: key,
              input: key === `releaseDate` ? `date` : `number`,
              operator: `less_or_equal`,
              type: key === `releaseDate` ? `text` : (key.match(/^(chance|chancePerPoint)$/) ? `double` : `integer`),
              value: value
            });
          }
        } else if (isMin) {
          if (value !== minValues[key]) {
            newPreset.rules.push({
              field: key,
              id: key,
              input: key === `releaseDate` ? `date` : `number`,
              operator: `greater_or_equal`,
              type: key === `releaseDate` ? `text` : (key.match(/^(chance|chancePerPoint)$/) ? `double` : `integer`),
              value: value
            });
          }
        } else if (value && typeof value === `string` && !value.match(/^(enabled|undefined)$/)) {
          if (value === `disabled`) {
            newPreset.rules.push({
              field: key,
              id: key,
              input: `radio`,
              operator: `equal`,
              type: `boolean`,
              value: false
            });
          } else if (value === `none`) {
            newPreset.rules.push({
              field: key,
              id: key,
              input: `radio`,
              operator: `equal`,
              type: `boolean`,
              value: true
            });
          } else {
            const rule = {
              field: key,
              id: key,
              input: `text`,
              operator: preset[key] === `disabled` ? `not_contains` : `contains`,
              type: `string`,
              value: value
            };
            if (preset[key] === `enabled`) {
              rule.data = {
                paused: true
              };
            }
            newPreset.rules.push(rule);
          }
        }
      }

      // Convert exceptions.
      let newExceptions = null;
      if (preset.exceptions) {
        newExceptions = {
          condition: `OR`,
          not: false,
          rules: []
        };
        if (newPreset.rules.length) {
          newExceptions.rules.push(newPreset);
        }
        for (const exception of preset.exceptions) {
          const newException = {
            condition: `AND`,
            not: false,
            rules: []
          };
          for (let key in exception) {
            if (key.match(/^(authors|creators|exceptions|genres|groups|words|name|overrides)$/)) {
              continue;
            }

            const isMax = key.match(/^max/);
            const isMin = key.match(/^min/);
            const value = preset[key];
            key = key.replace(/(^(max|min))|List$/, ``);
            key = `${key[0].toLowerCase()}${key.slice(1)}`;
            if (isMax) {
              if (value !== maxValues[key] && !value.toString().match(/^9+$/)) {
                newException.rules.push({
                  field: key,
                  id: key,
                  input: key === `releaseDate` ? `date` : `number`,
                  operator: `less_or_equal`,
                  type: key === `releaseDate` ? `text` : (key.match(/^(chance|chancePerPoint)$/) ? `double` : `integer`),
                  value: value
                });
              }
            } else if (isMin) {
              if (value !== minValues[key]) {
                newException.rules.push({
                  field: key,
                  id: key,
                  input: key === `releaseDate` ? `date` : `number`,
                  operator: `greater_or_equal`,
                  type: key === `releaseDate` ? `text` : (key.match(/^(chance|chancePerPoint)$/) ? `double` : `integer`),
                  value: value
                });
              }
            } else if (value && value !== `undefined`) {
              if (key.match(/^(authors|creators|genres|groups|words)$/)) {
                if (exception[key]) {
                  newException.rules.push({
                    field: key,
                    id: key,
                    input: `text`,
                    operator: `contains`,
                    type: `string`,
                    value: value
                  });
                }
              } else {
                newException.rules.push({
                  field: key,
                  id: key,
                  input: `radio`,
                  operator: `equal`,
                  type: `boolean`,
                  value: true
                });
              }
            }
          }
          if (newException.rules.length) {
            newExceptions.rules.push(newException);
          }
        }

        // Apply overrides.
        if (preset.overrides) {
          for (let i = newPreset.rules.length - 1; i > -1; i--) {
            const rule = newPreset.rules[i];
            if (preset.overrides[rule.id]) {
              for (const exception of newExceptions.rules) {
                if (exception === newPreset) continue;

                exception.rules.push(rule);
              }
            }
          }
        }

        if (newExceptions.rules.length) {
          newPreset = newExceptions;
        }
      }

      if (newPreset.rules.length) {
        newPreset.valid = true;
        newPresets.push({
          name: `__old-preset__${preset.name}`,
          rules: newPreset
        });
      }
    }
    return newPresets;
  }

  function filters_changeRules(obj, event) {
    let out = [{
      condition: `AND`,
      not: false,
      rules: [],
      valid: true
    }, {
      condition: `AND`,
      not: false,
      rules: [],
      valid: true
    }];
    let valid = false;
    try {
      valid = obj.builder.validate();
    } catch (e) {
      return out;
    }
    if (!valid) {
      if (event) {
        event.value = out;
      }
      return out;
    }

    out = (function parse(group) {
      const groupData = {
        condition: group.condition,
        data: {
          count: group.$el[0].getElementsByClassName(`esgst-gf-filter-count`)[0]
        },
        rules: []
      };
      const groupData_save = {
        condition: group.condition,
        rules: []
      };
      group.each(function(rule) {
        if (!event) {
          if (rule.data && rule.data.paused) {
            rule.$el[0].setAttribute(`data-esgst-paused`, true);
          } else {
            rule.$el[0].removeAttribute(`data-esgst-paused`);
          }
        }

        let value = null;
        if (!rule.operator || rule.operator.nb_inputs !== 0) {
          value = rule.value;
        }
        const ruleData_save = {
          id: rule.filter ? rule.filter.id : null,
          field: rule.filter ? rule.filter.field : null,
          type: rule.filter ? rule.filter.type : null,
          input: rule.filter ? rule.filter.input : null,
          operator: rule.operator ? rule.operator.type : null,
          value: value
        };
        if (rule.$el[0].getAttribute(`data-esgst-paused`)) {
          ruleData_save.data = {
            paused: true
          };
        } else {
          const ruleData = {
            data: rule.data,
            id: rule.filter ? rule.filter.id : null,
            field: rule.filter ? rule.filter.field : null,
            type: rule.filter ? rule.filter.type : null,
            input: rule.filter ? rule.filter.input : null,
            operator: rule.operator ? rule.operator.type : null,
            value: value
          };
          if (groupData.condition === `AND`) {
            if (!ruleData.data) {
              ruleData.data = {};
            }
            ruleData.data.count = rule.$el[0].getElementsByClassName(`esgst-gf-filter-count`)[0];
            ruleData.data.count.classList.remove(`esgst-hidden`);
          } else {
            rule.$el[0].getElementsByClassName(`esgst-gf-filter-count`)[0].classList.add(`esgst-hidden`);
          }
          groupData.rules.push(obj.builder.change(`ruleToJson`, ruleData, rule));
        }
        groupData_save.rules.push(obj.builder.change(`ruleToJson`, ruleData_save, rule));
      }, function (model) {
        if (!event) {
          if (model.data && model.data.paused) {
            model.$el[0].setAttribute(`data-esgst-paused`, true);
          } else {
            model.$el[0].removeAttribute(`data-esgst-paused`);
          }
        }

        const [data, data_save] = parse(model);
        if (data.rules.length !== 0) {
          if (model.$el[0].getAttribute(`data-esgst-paused`)) {
            data_save.data = {
              paused: true
            };
          } else {
            groupData.rules.push(data);
          }
          groupData_save.rules.push(data_save);
        }
      }, obj.builder);

      return [
        obj.builder.change(`groupToJson`, groupData, group),
        obj.builder.change(`groupToJson`, groupData_save, group)
      ];
    }(obj.builder.model.root));

    out[0].valid = valid;
    out[1].valid = valid;

    if (event) {
      event.value = out;
    }

    return out;
  }

  function filters_basicToAdv(obj) {
    const adv = {
      condition: `AND`,
      not: false,
      rules: [],
      valid: true
    };
    for (const id in obj.basicFilters) {
      const filter = obj.basicFilters[id];
      switch (filter.filterType) {
        case `boolean`:
          if (filter.checkbox.value === `enabled`) break;

          adv.rules.push({
            data: filter.data,
            field: id,
            id: id,
            input: filter.input,
            operator: filter.operator,
            type: filter.type,
            value: filter.checkbox.value === `none`
          });
          break;
        case `number`:
          if (filter.maxInput.value) {
            adv.rules.push({
              data: filter.data,
              field: id,
              id: id,
              input: filter.input,
              operator: `less_or_equal`,
              type: filter.type,
              value: filter.maxInput.value
            });
          }
          if (filter.minInput.value) {
            adv.rules.push({
              data: filter.data,
              field: id,
              id: id,
              input: filter.input,
              operator: `greater_or_equal`,
              type: filter.type,
              value: filter.minInput.value
            });
          }
          break;
        case `string`:
          if (filter.checkbox.value === `enabled`) break;

          if (!filter.textInput.value) break;

          adv.rules.push({
            data: filter.data,
            field: id,
            id: id,
            input: filter.input,
            operator: filter.checkbox.value === `none` ? `contains` : `not_contains`,
            type: filter.type,
            value: filter.textInput.value
          });
          break;
      }
    }
    obj.rules = adv;
    if (obj.rules.rules) {
      if (esgst[`${obj.id}_m_a`]) {
        obj.rules_save = obj.rules;
        filters_filter(obj);
      } else {
        if (!obj.rules.rules.length) {
          obj.rules = {
            condition: `AND`,
            rules: [
              {empty: true}
            ],
            valid: true
          };
        }
        obj.basicApplied = true;
        obj.builder.setRules(obj.rules);
      }
    }
  }

  function filters_applyBasic(obj, rules) {
    if (rules.condition !== `AND`) return;

    for (const rule of rules.rules) {
      if (rule.condition) continue;

      const filter = obj.basicFilters[rule.id];
      switch (rule.type) {
        case `boolean`:
          filter.checkbox.change(false, rule.value ? `none` : `disabled`);
          break;
        case `date`:
        case `double`:
        case `integer`:
          if (rule.operator === `less_or_equal`) {
            filter.maxInput.value = rule.value;
          } else if (rule.operator === `greater_or_equal`) {
            filter.minInput.value = rule.value;
          }
          break;
        case `string`:
          filter.checkbox.change(false, rule.operator === `contains` ? `none` : `disabled`);
          filter.textInput.value = rule.value;
          break;
      }
    }
  }

  function filters_resetBasic(obj) {
    for (const id in obj.basicFilters) {
      const filter = obj.basicFilters[id];
      switch (filter.filterType) {
        case `boolean`:
          filter.checkbox.change(false, `enabled`);
          break;
        case `number`:
          filter.maxInput.value = ``;
          filter.minInput.value = ``;
          break;
        case `string`:
          filter.checkbox.change(false, `enabled`);
          filter.textInput.value = ``;
          break;
      }
    }
  }

  async function filters_savePreset(obj) {
    const name = obj.presetInput.value;

    if (!name) {
      obj.presetWarning.classList.remove(`esgst-hidden`);
      return;
    }

    obj.presetWarning.classList.add(`esgst-hidden`);
    const preset = {
      name,
      rules: obj.rules_save
    };
    let i;
    for (i = esgst[obj.key].length - 1; i > -1 && esgst[obj.key][i].name !== name; i--);
    if (i > -1) {
      esgst[obj.key][i] = preset;
    } else {
      esgst[obj.key].push(preset);
    }
    await setSetting([
      {
        id: `${obj.id}_preset${obj.type}`,
        value: name
      },
      {
        id: obj.key,
        value: esgst[obj.key]
      }
    ]);
    createFadeMessage(obj.presetMessage, `Saved!`);
  }

  async function filters_openPresetPopup(obj) {
    const popup = new Popup(`fa-sliders`, `Manage presets:`, true);
    popup.description.insertAdjacentHTML(`afterBegin`, `
      <div class="esgst-description">To edit a preset, apply it and save it with the same name. To rename a preset, click the edit icon, enter the new name and hit "Enter". Drag and drop presets to move them.</div>
    `);
    let deleted = [];
    const undoButton = insertHtml(popup.description, `beforeEnd`, `
      <div class="esgst-clickable esgst-hidden">
        <i class="fa fa-rotate-left"></i>
        <span>Undo Delete</span>
      </div>
    `);
    undoButton.addEventListener(`click`, filters_undoDeletePreset.bind(null, obj, deleted, undoButton));
    const table = insertHtml(popup.scrollable, `beforeEnd`, `
      <div class="esgst-text-left popup__keys__list"></div>
    `);
    for (const preset of esgst[obj.key]) {
      const row = insertHtml(table, `beforeEnd`, `
        <div ${obj.presetInput.value === preset.name ? `class="esgst-green-highlight"` : ``} draggable="true">
          <div class="esgst-float-left">
            <input class="esgst-hidden" type="text" value="${preset.name}"/>
            <strong class="esgst-clickable">${preset.name}</strong>
          </div>
          <div class="esgst-clickable esgst-float-right">
            <i class="fa fa-edit" title="Rename preset"></i>
            <span title="Delete preset">
              <i class="fa fa-trash"></i>
            </span>
          </div>
          <div class="esgst-clear"></div>
        </div>
      `);
      const renameInput = row.firstElementChild.firstElementChild;
      const heading = renameInput.nextElementSibling;
      const renameButton = row.firstElementChild.nextElementSibling.firstElementChild;

      row.addEventListener(`dragstart`, filters_setSource.bind(null, obj, preset, row));
      row.addEventListener(`dragenter`, filters_getSource.bind(null, obj, row, table));
      row.addEventListener(`dragend`, filters_saveSource.bind(null, obj));
      renameInput.addEventListener(`keypress`, filters_renamePreset.bind(null, obj, heading, preset));
      heading.addEventListener(`click`, filters_applyPreset.bind(null, obj, popup, preset));
      renameButton.addEventListener(`click`, filters_showRenameInput.bind(null, heading, renameInput));
      renameButton.nextElementSibling.addEventListener(`click`, filters_deletePreset.bind(null, obj, deleted, preset, row, undoButton));
    }
    popup.open();
  }

  async function filters_setSource(obj, preset, row, event) {
    event.dataTransfer.setData(`text/plain`, ``);
    obj.source = row;
    let i;
    for (i = esgst[obj.key].length - 1; i > -1 && esgst[obj.key][i].name !== preset.name; i--);
    obj.sourceIndex = i;
  }

  function filters_getSource(obj, row, table) {
    let current = obj.source;
    let i = 0;
    do {
      current = current.previousElementSibling;
      if (current && current === row) {
        obj.sourceNewIndex = i;
        table.insertBefore(obj.source, row);
        return;
      }
      ++i;
    } while (current);
    obj.sourceNewIndex = i - 1;
    table.insertBefore(obj.source, row.nextElementSibling);
  }

  async function filters_saveSource(obj) {
    esgst[obj.key].splice(obj.sourceNewIndex, 0, esgst[obj.key].splice(obj.sourceIndex, 1)[0]);
    await setSetting(obj.key, esgst[obj.key]);
  }

  async function filters_applyPreset(obj, popup, preset) {
    if (!preset.rules || !preset.rules.rules || !preset.rules.rules.length) {
      preset.rules = {
        condition: `AND`,
        rules: [
          {empty: true}
        ],
        valid: true
      };
    }

    if (!esgst[`${obj.id}_m_b`]) {
      filters_resetBasic(obj);
      filters_applyBasic(obj, preset.rules);
    }
    if (!esgst[`${obj.id}_m_a`]) {
      obj.builder.setRules(preset.rules);
      [obj.rules, obj.rules_save] = filters_changeRules(obj);
    }
    popup.close();
    obj.presetDisplay.textContent = obj.presetInput.value = preset.name;
    filters_filter(obj);
    setSetting(`${obj.id}_preset${obj.type}`, preset.name);
  }

  function filters_showRenameInput(heading, renameInput) {
    heading.classList.add(`esgst-hidden`);
    renameInput.classList.remove(`esgst-hidden`);
    const value = renameInput.value;
    renameInput.value = ``;
    renameInput.focus();
    renameInput.value = value;
  }

  async function filters_renamePreset(obj, heading, preset, event) {
    if (event.key !== `Enter`) return;

    const oldName = preset.name;
    const newName = event.currentTarget.value;
    let i;
    for (i = esgst[obj.key].length - 1; i > -1 && esgst[obj.key][i].name !== oldName; i--);
    preset.name = esgst[obj.key][i].name = newName;
    const values = [{
      id: obj.key,
      value: esgst[obj.key]
    }];
    heading.textContent = newName;
    if (obj.presetInput.value === oldName) {
      obj.presetDisplay.textContent = obj.presetInput.value = newName;
    }
    const types = [``, `Wishlist`, `Recommended`, `Group`, `New`, `Created`, `Entered`, `Won`, `Groups`, `User`, `Gb`, `Ge`, `Ged`];
    for (const type of types) {
      if (esgst[`${obj.id}_preset${type}`] === oldName) {
        values.push({
          id: `${obj.id}_preset${type}`,
          value: newName
        });
      }
    }
    event.currentTarget.classList.add(`esgst-hidden`);
    heading.classList.remove(`esgst-hidden`);
    await setSetting(values);
  }

  async function filters_deletePreset(obj, deleted, preset, row, undoButton, event) {
    const deleteButton = event.currentTarget;
    deleteButton.innerHTML = `<i class="fa fa-circle-o-notch fa-spin"></i>`;
    let i;
    for (i = esgst[obj.key].length - 1; i > -1 && esgst[obj.key][i].name !== preset.name; i--);
    esgst[obj.key].splice(i, 1);
    await setSetting(obj.key, esgst[obj.key]);
    deleteButton.innerHTML = `<i class="fa fa-trash"></i>`;
    row.classList.add(`esgst-hidden`);
    deleted.push({
      details: preset,
      row: row
    });
    undoButton.classList.remove(`esgst-hidden`);
  }

  async function filters_undoDeletePreset(obj, deleted, undoButton) {
    const preset = deleted.pop();
    preset.row.classList.remove(`esgst-hidden`);
    preset.row.parentElement.appendChild(preset.row);
    esgst[obj.key].push(preset.details);
    await setSetting(obj.key, esgst[obj.key]);
    if (deleted.length === 0) {
      undoButton.classList.add(`esgst-hidden`);
    }
  }

  function filters_toggleFilters(obj) {
    obj.collapseButton.classList.toggle(`esgst-hidden`);
    obj.expandButton.classList.toggle(`esgst-hidden`);
    obj.filtersPanel.classList.toggle(`esgst-hidden`);
  }

  function filters_filter(obj, unfilter, endless) {
    if (!unfilter && !esgst[`${obj.id}_enable${obj.type}`]) return;

    let items;
    if (obj.id === `gf`) {
      items = obj.popup ? esgst.popupGiveaways : esgst.mainGiveaways;
    } else if (obj.id === `df`) {
      items = obj.popup ? esgst.popupDiscussions : esgst.mainDiscussions;
    } else {
      items = obj.popup ? esgst.popupComments : esgst.mainComments;
    }
    const counters = document.getElementsByClassName(`esgst-gf-filter-count`);
    for (const counter of counters) {
      counter.textContent = `0`;
    }
    for (const item of items) {
      if (unfilter) {
        if (item.outerWrap.classList.contains(`esgst-hidden`)) {
          item.outerWrap.classList.remove(`esgst-hidden`);
        }
        if (obj.id === `cf` && item.outerWrap.parentElement.classList.contains(`esgst-hidden`)) {
          item.outerWrap.parentElement.classList.remove(`esgst-hidden`);
        }
      } else if (filters_filterItem(obj.id, obj.filters, item, obj.rules)) {
        if (item.outerWrap.classList.contains(`esgst-hidden`)) {
          item.outerWrap.classList.remove(`esgst-hidden`);
        }
        if (obj.id === `cf` && item.outerWrap.parentElement.classList.contains(`esgst-hidden`)) {
          item.outerWrap.parentElement.classList.remove(`esgst-hidden`);
        }
      } else {
        if (!item.outerWrap.classList.contains(`esgst-hidden`)) {
          item.outerWrap.classList.add(`esgst-hidden`);
        }                
        if (obj.id === `cf` && !item.outerWrap.parentElement.classList.contains(`esgst-hidden`)) {
          item.outerWrap.parentElement.classList.add(`esgst-hidden`);
        }
      }
    }
    filters_updateCount(obj, endless);
  }

  /**
  * Checks if an item passes a set of filter rules.
  * @param {object} filters An object containing all the filters.
  * @param {object} item An object containing information about the item to be checked.
  * @param {object} rules An object containing the rules to check.
  * @returns {boolean} True if the item passed the filters and false otherwise.
  */
  function filters_filterItem(id, filters, item, rules) {
    if (
      !rules ||
      (!rules.id && (!rules.condition || (isSet(rules.valid) && !rules.valid))) ||
      (rules.id && !esgst[`${id}_${rules.id}`])
    ) {
      return true;
    }

    let filtered;

    if (rules.condition) {
      if (rules.condition === `AND`) {
        // The giveaway must be filtered by all rules.
        filtered = true;
        for (const rule of rules.rules) {
          filtered = filtered && filters_filterItem(id, filters, item, rule);
          if (!filtered) break;
        }
      } else {
        // The giveaway must be filtered by at least 1 rule.
        filtered = false;
        if (rules.rules.length) {
          for (const rule of rules.rules) {
            filtered = filtered || filters_filterItem(id, filters, item, rule);
            if (filtered) break;
          }
        } else {
          filtered = true;
        }
      }
      filtered = rules.not ? !filtered : filtered;
      if (!filtered && rules.data && rules.data.count) {
        rules.data.count.textContent = parseInt(rules.data.count.textContent) + 1;
      }
      return filtered;
    }

    filtered = true;
    const key = rules.id;
    const filter = filters[key];

    if (
      !filter.check ||
      (filter.category && (!esgst.gc || !esgst[filter.category] || !item.gcReady))
    ) {
      return filtered;
    }

    switch (rules.type) {
      case `date`:
        rules.value = new Date(rules.value).getTime();
      case `integer`:
      case `double`:
        if (key === `minutesToEnd` && (item.ended || item.deleted)) break;

        const value = key === `minutesToEnd`
          ? ((item.endTime - Date.now()) / 60000)
          : item[key];
        switch (rules.operator) {
          case `equal`:
            filtered = rules.value === value;
            break;
          case `not_equal`:
            filtered = rules.value !== value;
            break;
          case `less`:
            filtered = value < rules.value;
            break;
          case `less_or_equal`:
            filtered = value <= rules.value;
            break;
          case `greater`:
            filtered = value > rules.value;
            break;
          case `greater_or_equal`:
            filtered = value >= rules.value;
            break;
          case `is_null`:
            filtered = !isSet(value) || value < 0;
            break;
          case `is_not_null`:
            filtered = isSet(value) && value > -1;
            break;
        }

        break;
      case `boolean`:
        if (key === `regionRestricted` && esgst.parameters.region_restricted) break;

        if (
          (
            key !== `fullCV` || (
              (rules.value || item.reducedCV || item.noCV) &&
              (!rules.value || (!item.reducedCV && !item.noCV))
            )
          ) &&
          (
            key === `fullCV` || (
              (!rules.value || item[key]) && (rules.value || !item[key])
            )
          )
        ) break;

        filtered = false;

        if (!item.deleted && key === `ended` && !rules.value && (esgst.createdPath || esgst.enteredPath || esgst.wonPath || esgst.userPath)) {
          esgst.stopEs = true;
        }

        break;
      case `string`:
        const list = rules.value.toLowerCase().split(/,\s/);

        if (rules.operator === `contains`) {
          if (!item[key]) {
            filtered = false;
            break;
          }

          let i;
          for (i = list.length - 1; i > -1 && item[key].indexOf(list[i]) < 0; i--);
          filtered = i > -1;
        } else {
          if (!item[key]) break;

          let i;
          for (i = list.length - 1; i > -1 && item[key].indexOf(list[i]) < 0; i--);
          filtered = i < 0;
        }

        break;
    }
    if (!filtered && rules.data) {
      if (rules.data.count) {
        rules.data.count.textContent = parseInt(rules.data.count.textContent) + 1;
      }
      if (rules.data.basicCount) {
        rules.data.basicCount.textContent = parseInt(rules.data.basicCount.textContent) + 1;
      }
    }
    return filtered;
  }

  function filters_updateCount(obj, endless) {
    let filtered = 0;
    let points = 0;
    let paginationFiltered = 0;
    let key;
    if (obj.id === `gf`) {
      key = obj.popup ? `popupGiveaways` : `mainGiveaways`;
    } else if (obj.id === `df`) {
      key = obj.popup ? `popupDiscussions` : `mainDiscussions`;
    } else {
      key = obj.popup ? `popupComments` : `mainComments`;
    }
    for (let i = esgst[key].length - 1; i > -1; i--) {
      const item = esgst[key][i];
      if (document.body.contains(item.outerWrap) || endless) {
        if (!item.pinned || !esgst.pinnedGiveaways.classList.contains(`esgst-hidden`)) {
          if (item.outerWrap.classList.contains(`esgst-hidden`)) {
            if (!item.pinned) {
              paginationFiltered += 1;
            }
            filtered += 1;
          } else if (item.points && !item.entered) {
            points += item.points;
          }
        }
      } else {
        esgst[key].splice(i, 1);
      }
    }
    obj.filteredCount.textContent = filtered;
    if (obj.id === `gf`) {
      obj.pointsCount.textContent = points;
    }
    if (!obj.popup && obj.paginationFilteredCount) {
      obj.paginationFilteredCount.textContent = paginationFiltered;
    }
  }

  // [GLWC]

  _MODULES.push({
    description: `
      <ul>
        <li>Adds a button (<i class="fa fa-folder"></i> <i class="fa fa-star"></i>) to your <a href="https://www.steamgifts.com/account/manage/whitelist">whitelist</a>/<a href="https://www.steamgifts.com/account/manage/blacklist">blacklist</a> pages and any <a href="https://www.steamgifts.com/group/SJ7Bu/">group</a> page that allows you to check how many of the whitelist/blacklist/group members have a certain game in their libraries/wishlists.</li>
        <li>The results are separated in 2 sections ("Libraries" and "Wishlists"). The games in each section are ranked based on the number of members that have them in their libraries/wishlists (each game also has a percentage that represents that number).</li>
        <li>Only the first 100 results are shown for each section, but you can use the search fields to find games that are outside of the top 100. If you are searching in the "Libraries" section, it is more accurate to search for games using their app id instead of their name, because the games in that section only have a name if they can also be found in the "Wishlists" section, as game names are not available in the libraries data and retrieving them would generate more requests to Steam, which is not good.</li>
        <li>If you hover over the number of libraries/wishlists for a game it shows the usernames of all of the members that have the game in their libraries/wishlists.</li>
        <li>A Steam API key is required to retrieve libraries data. If a key is not set in the last section of this menu, the feature will only retrieve wishlists data.</li>
      </ul>
    `,
    id: `glwc`,
    load: glwc,
    name: `Group Library/Wishlist Checker`,
    sg: true,
    type: `groups`
  });

  async function glwc() {
    if (esgst.whitelistPath || esgst.blacklistPath || esgst.groupPath) {
      let parameters;
      if (esgst.whitelistPath) {
        parameters = `?url=account/manage/whitelist`;
      } else if (esgst.blacklistPath) {
        parameters = `?url=account/manage/blacklist`;
      } else {
        parameters = `?url=${location.pathname.match(/\/(group\/(.+?)\/(.+?))(\/.*)?$/)[1]}/users&id=${document.querySelector(`[href*="/gid/"]`).getAttribute(`href`).match(/\d+/)[0]}`;
      }
      createHeadingButton({id: `glwc`, icons: [`fa-folder`, `fa-star`], title: `Check libraries/wishlists`}).addEventListener(`click`, () => {
        open(`/esgst/glwc${parameters}`);
      });
    } else if (esgst.glwcPath) {
      let glwc = {}, parameters;
      glwc.context = document.body.firstElementChild.nextElementSibling.firstElementChild;
      glwc.progress = insertHtml(glwc.context, `beforeEnd`, `<div></div>`);
      glwc.overallProgress = insertHtml(glwc.context, `beforeEnd`, `<div></div>`);
      parameters = getParameters();
      glwc.id = parameters.id;
      glwc.url = parameters.url;
      glwc.users = [];
      glwc.games = {};
      if (glwc.id) {
        glwc.overallProgress.textContent = `Preparing...`;
        glwc.members = [];
        const members = (await request({method: `GET`, url: `http://steamcommunity.com/gid/${glwc.id}/memberslistxml?xml=1`})).responseText.match(/<steamID64>.+?<\/steamID64>/g);
        members.forEach(member => {
          glwc.members.push(member.match(/<steamID64>(.+?)<\/steamID64>/)[1]);
        });
        glwc.overallProgress.textContent = `Step 1 of 3`;
        glwc_getUsers(glwc, 1);
      } else {
        glwc.overallProgress.textContent = `Step 1 of 3`;
        glwc_getUsers(glwc, 1);
      }
    }
  }

  async function glwc_getUsers(glwc, nextPage) {
    if (glwc.isCanceled) return;
    glwc.progress.innerHTML = `
      <i class="fa fa-circle-o-notch fa-spin"></i>
      <span>Retrieving users (page ${nextPage})...</span>
    `;
    let elements, i, n, pagination, responseHtml;
    responseHtml = parseHtml((await request({method: `GET`, url: `/${glwc.url}/search?page=${nextPage}`})).responseText);
    elements = responseHtml.querySelectorAll(`.table__row-inner-wrap:not(.is-faded)`);
    for (i = 0, n = elements.length; i < n; ++i) {
      glwc.users.push({
        username: elements[i].getElementsByClassName(`table__column__heading`)[0].textContent
      });
    }
    pagination = responseHtml.getElementsByClassName(`pagination__navigation`)[0];
    if (pagination && !pagination.lastElementChild.classList.contains(`is-selected`)) {
      setTimeout(() => glwc_getUsers(glwc, ++nextPage), 0);
    } else {
      glwc.overallProgress.textContent = `Step 2 of 3`;
      glwc_getSteamIds(glwc, 0, glwc.users.length);
    }
  }

  async function glwc_getSteamIds(glwc, i, n) {
    if (glwc.isCanceled) return;
    if (i < n) {
      glwc.progress.innerHTML = `
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <span>Retrieving Steam ids (${i + 1} of ${n})...</span>
      `;
      let steamId = esgst.users.steamIds[glwc.users[i].username];
      if (steamId) {
        glwc.users[i].steamId = steamId;
        setTimeout(() => glwc_getSteamIds(glwc, ++i, n), 0);
      } else {
        glwc.users[i].steamId = parseHtml((await request({method: `GET`, url: `/user/${glwc.users[i].username}`})).responseText).querySelector(`[href*="/profiles/"]`).getAttribute(`href`).match(/\d+/)[0];
        setTimeout(() => glwc_getSteamIds(glwc, ++i, n), 0);
      }
    } else {
      glwc.overallProgress.textContent = `Step 3 of 3 (this might take a while)`;
      glwc.memberCount = 0;
      glwc_getGames(glwc, 0, glwc.users.length);
    }
  }

  async function glwc_getGames(glwc, i, n) {
    if (glwc.isCanceled) return;
    if (i < n) {
      glwc.progress.innerHTML = `
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <span>Retrieving libraries/wishlists (${i + 1} of ${n})...</span>
      `;
      if (!glwc.id || glwc.members.indexOf(glwc.users[i].steamId) >= 0) {
        try {
          glwc.users[i].library = [];
          let elements = JSON.parse((await request({method: `GET`, url: `http://api.steampowered.com/IPlayerService/GetOwnedGames/v0001/?key=${esgst.steamApiKey}&steamid=${glwc.users[i].steamId}&format=json`})).responseText).response.games;
          if (elements) {
            elements.forEach(element => {
              let game = {
                id: element.appid,
                logo: `https://steamcdn-a.akamaihd.net/steam/apps/${element.appid}/header.jpg`,
                name: `${element.appid}`
              };
              if (!glwc.games[game.id]) {
                game.libraries = [];
                game.wishlists = [];
                glwc.games[game.id] = game;
              }
              glwc.games[game.id].libraries.push(i);
              glwc.users[i].library.push(game.id);
            });
          }
        } catch (e) { /**/ }
        glwc.users[i].wishlist = [];
        let responseText = (await request({method: `GET`, url: `http://store.steampowered.com/wishlist/profiles/${glwc.users[i].steamId}`})).responseText;
        let wishlistData = responseText.match(/g_rgWishlistData\s=\s(\[(.+?)\]);/);
        if (wishlistData) {
          let appInfo = responseText.match(/g_rgAppInfo\s=\s({(.+?)});/);
          let games = appInfo ? JSON.parse(appInfo[1]) : null;
          JSON.parse(wishlistData[1]).forEach(item => {
            let id = item.appid;
            let game = {id};
            if (games && games[id]) {
              game.logo = games[id].capsule;
              game.name = games[id].name;
            } else {
              game.logo = `https://steamcdn-a.akamaihd.net/steam/apps/${id}/header.jpg`;
              game.name = `${id}`;
            }
            if (glwc.games[id]) {
              if (game.logo && game.name) {
                glwc.games[id].logo = game.logo;
                glwc.games[id].name = game.name;
              }
            } else {
              game.libraries = [];
              game.wishlists = [];
              glwc.games[id] = game;
            }
            glwc.games[id].wishlists.push(i);
            glwc.users[i].wishlist.push(parseInt(id));
          });
        }
        glwc.memberCount += 1;
        setTimeout(() => glwc_getGames(glwc, ++i, n), 0);
      } else {
        setTimeout(() => glwc_getGames(glwc, ++i, n), 0);
      }
    } else {
      glwc_showResults(glwc);
    }
  }

  function glwc_showResults(glwc) {
    let game, i, id, j, library, libraryInput, libraryResults, librarySearch, n, user, users, wishlist, wishlistInput, wishlistResults, wishlistSearch;
    glwc.context.classList.add(`esgst-glwc-results`);
    glwc.context.innerHTML = `
      <div>
        <div class="esgst-glwc-heading">Libraries</div>
        <input placeholder="Search by game name or app id..." type="text"/>
        <div class="table">
          <div class="table__heading">
            <div class="table__column--width-small text-center">Rank</div>
            <div class="table__column--width-fill">Game</div>
            <div class="table__column--width-small text-center">Libraries</div>
          </div>
          <div class="table__rows"></div>
          <div class="table__rows"></div>
        </div>
      </div>
      <div>
        <div class="esgst-glwc-heading">Wishlists</div>
        <input placeholder="Search by game name or app id..." type="text"/>
        <div class="table">
          <div class="table__heading">
            <div class="table__column--width-small text-center">Rank</div>
            <div class="table__column--width-fill">Game</div>
            <div class="table__column--width-small text-center">Wishlists</div>
          </div>
          <div class="table__rows"></div>
          <div class="table__rows"></div>
        </div>
      </div>
    `;
    libraryInput = glwc.context.firstElementChild.firstElementChild.nextElementSibling;
    libraryResults = libraryInput.nextElementSibling.lastElementChild;
    librarySearch = libraryResults.previousElementSibling;
    wishlistInput = glwc.context.lastElementChild.firstElementChild.nextElementSibling;
    wishlistResults = wishlistInput.nextElementSibling.lastElementChild;
    wishlistSearch = wishlistResults.previousElementSibling;
    library = [];
    wishlist = [];
    for (id in glwc.games) {
      if (glwc.games[id].libraries.length) {
        library.push(glwc.games[id]);
      }
      if (glwc.games[id].wishlists.length) {
        wishlist.push(glwc.games[id]);
      }
    }
    if (library.length > 0) {
      library = library.sort((a, b) => {
        if (a.libraries.length > b.libraries.length) {
          return -1;
        } else if (a.libraries.length < b.libraries.length) {
          return 1;
        } else {
          return 0;
        }
      });
      for (i = 0, n = library.length; i < 100 && i < n; ++i) {
        game = library[i];
        if (i <= 0 || game.libraries.length !== library[i - 1].libraries.length) {
          j = i + 1;
        }
        users = [];
        game.libraries.forEach(k => {
          user = glwc.users[k];
          users.push(`<a href="http://steamcommunity.com/profiles/${user.steamId}/games?tab=all">${user.username}</a>`);
        });
        createTooltip(insertHtml(libraryResults, `beforeEnd`, `
          <div class="table__row-outer-wrap">
            <div class="table__row-inner-wrap">
              <div class="table__column--width-small text-center">
                <span class="table__column__rank">${j}.</span>
              </div>
              <div>
                <div class="table_image_thumbnail" style="background-image:url(${game.logo});"></div>
              </div>
              <div class="table__column--width-fill">
                <p class="table__column__heading">${game.name}</p>
                <p>
                  <a class="table__column__secondary-link" href="http://store.steampowered.com/app/${game.id}" rel="nofollow" target="_blank">http://store.steampowered.com/app/${game.id}</a>
                </p>
              </div>
              <div class="table__column--width-small text-center">
                <span class="table__column__secondary-link esgst-clickable">${game.libraries.length} (${Math.round(game.libraries.length / glwc.memberCount * 10000) / 100}%)</span>
              </div>
            </div>
          </div>
        `).firstElementChild.lastElementChild.firstElementChild, users.join(`, `));
      }
    } else {
      libraryResults.innerHTML = `To get libraries data you must have a Steam API key set in the settings menu.`;
    }
    wishlist = wishlist.sort((a, b) => {
      if (a.wishlists.length > b.wishlists.length) {
        return -1;
      } else if (a.wishlists.length < b.wishlists.length) {
        return 1;
      } else {
        return 0;
      }
    });
    for (i = 0, n = wishlist.length; i < 100 && i < n; ++i) {
      game = wishlist[i];
      if (i <= 0 || game.wishlists.length !== wishlist[i - 1].wishlists.length) {
        j = i + 1;
      }
      users = [];
      game.wishlists.forEach(k => {
        user = glwc.users[k];
        users.push(`<a href="http://store.steampowered.com/wishlist/profiles/${user.steamId}">${user.username}</a>`);
      });
      createTooltip(insertHtml(wishlistResults, `beforeEnd`, `
        <div class="table__row-outer-wrap">
          <div class="table__row-inner-wrap">
            <div class="table__column--width-small text-center">
              <span class="table__column__rank">${j}.</span>
            </div>
            <div>
              <div class="table_image_thumbnail" style="background-image:url(${game.logo});"></div>
            </div>
            <div class="table__column--width-fill">
              <p class="table__column__heading">${game.name}</p>
              <p>
                <a class="table__column__secondary-link" href="http://store.steampowered.com/app/${game.id}" rel="nofollow" target="_blank">http://store.steampowered.com/app/${game.id}</a>
              </p>
            </div>
            <div class="table__column--width-small text-center">
              <span class="table__column__secondary-link esgst-clickable">${game.wishlists.length} (${Math.round(game.wishlists.length / glwc.memberCount * 10000) / 100}%)</span>
            </div>
          </div>
        </div>
      `).firstElementChild.lastElementChild.firstElementChild, users.join(`, `));
    }
    libraryInput.addEventListener(`input`, () => {
      const value = libraryInput.value.toLowerCase();
      if (value) {
        game = glwc.games[value];
        if (game) {
          if (game.libraries.length) {
            users = [];
            game.libraries.forEach(k => {
              user = glwc.users[k];
              users.push(`<a href="http://steamcommunity.com/profiles/${user.steamId}/games?tab=all">${user.username}</a>`);
            });
            librarySearch.innerHTML = `
              <div class="table__row-outer-wrap">
                <div class="table__row-inner-wrap">
                  <div class="table__column--width-small text-center">
                    <span class="table__column__rank">-</span>
                  </div>
                  <div>
                    <div class="table_image_thumbnail" style="background-image:url(${game.logo});"></div>
                  </div>
                  <div class="table__column--width-fill">
                    <p class="table__column__heading">${game.name}</p>
                    <p>
                      <a class="table__column__secondary-link" href="http://store.steampowered.com/app/${game.id}" rel="nofollow" target="_blank">http://store.steampowered.com/app/${game.id}</a>
                    </p>
                  </div>
                  <div class="table__column--width-small text-center">
                    <span class="table__column__secondary-link esgst-clickable">${game.libraries.length} (${Math.round(game.libraries.length / glwc.memberCount * 10000) / 100}%)</span>
                  </div>
                </div>
              </div>
            `;
            createTooltip(librarySearch.firstElementChild.firstElementChild.lastElementChild.firstElementChild, users.join(`, `));
          } else {
            librarySearch.innerHTML = `Nothing found...`;
          }
        } else {
          librarySearch.innerHTML = ``;
          for (i = 0, j = 0, n = library.length; j < 100 && i < n; ++i) {
            game = library[i];
            if (game.name.toLowerCase().match(value)) {
              users = [];
              game.libraries.forEach(k => {
                user = glwc.users[k];
                users.push(`<a href="http://steamcommunity.com/profiles/${user.steamId}/games?tab=all">${user.username}</a>`);
              });
              createTooltip(insertHtml(librarySearch, `beforeEnd`, `
                <div class="table__row-outer-wrap">
                  <div class="table__row-inner-wrap">
                    <div class="table__column--width-small text-center">
                      <span class="table__column__rank">-</span>
                    </div>
                    <div>
                      <div class="table_image_thumbnail" style="background-image:url(${game.logo});"></div>
                    </div>
                    <div class="table__column--width-fill">
                      <p class="table__column__heading">${game.name}</p>
                      <p>
                        <a class="table__column__secondary-link" href="http://store.steampowered.com/app/${game.id}" rel="nofollow" target="_blank">http://store.steampowered.com/app/${game.id}</a>
                      </p>
                    </div>
                    <div class="table__column--width-small text-center">
                      <span class="table__column__secondary-link esgst-clickable">${game.libraries.length} (${Math.round(game.libraries.length / glwc.memberCount * 10000) / 100}%)</span>
                    </div>
                  </div>
                </div>
              `).firstElementChild.lastElementChild.firstElementChild, users.join(`, `));
              j += 1;
            }
          }
          if (!librarySearch.innerHTML) {
            librarySearch.innerHTML = `Nothing found...`;
          }
        }
        librarySearch.classList.remove(`esgst-hidden`);
        libraryResults.classList.add(`esgst-hidden`);
      } else {
        libraryResults.classList.remove(`esgst-hidden`);
        librarySearch.classList.add(`esgst-hidden`);
      }
    });
    wishlistInput.addEventListener(`input`, () => {
      const value = wishlistInput.value;
      if (value) {
        game = glwc.games[value];
        if (game) {
          if (game.wishlists.length) {
            users = [];
            game.wishlists.forEach(k => {
              user = glwc.users[k];
              users.push(`<a href="http://store.steampowered.com/wishlist/profiles/${user.steamId}">${user.username}</a>`);
            });
            wishlistSearch.innerHTML = `
              <div class="table__row-outer-wrap">
                <div class="table__row-inner-wrap">
                  <div class="table__column--width-small text-center">
                    <span class="table__column__rank">-</span>
                  </div>
                  <div>
                    <div class="table_image_thumbnail" style="background-image:url(${game.logo});"></div>
                  </div>
                  <div class="table__column--width-fill">
                    <p class="table__column__heading">${game.name}</p>
                    <p>
                      <a class="table__column__secondary-link" href="http://store.steampowered.com/app/${game.id}" rel="nofollow" target="_blank">http://store.steampowered.com/app/${game.id}</a>
                    </p>
                  </div>
                  <div class="table__column--width-small text-center">
                    <span class="table__column__secondary-link esgst-clickable">${game.wishlists.length} (${Math.round(game.wishlists.length / glwc.memberCount * 10000) / 100}%)</span>
                  </div>
                </div>
              </div>
            `;
            createTooltip(wishlistSearch.firstElementChild.firstElementChild.lastElementChild.firstElementChild, users.join(`, `));
          } else {
            wishlistSearch.innerHTML = `Nothing found...`;
          }
        } else {
          wishlistSearch.innerHTML = ``;
          for (i = 0, j = 0, n = wishlist.length; j < 100 && i < n; ++i) {
            game = wishlist[i];
            if (game.name.toLowerCase().match(value)) {
              users = [];
              game.wishlists.forEach(k => {
                user = glwc.users[k];
                users.push(`<a href="http://steamcommunity.com/profiles/${user.steamId}/wishlists">${user.username}</a>`);
              });
              createTooltip(insertHtml(wishlistSearch, `beforeEnd`, `
                <div class="table__row-outer-wrap">
                  <div class="table__row-inner-wrap">
                    <div class="table__column--width-small text-center">
                      <span class="table__column__rank">-</span>
                    </div>
                    <div>
                      <div class="table_image_thumbnail" style="background-image:url(${game.logo});"></div>
                    </div>
                    <div class="table__column--width-fill">
                      <p class="table__column__heading">${game.name}</p>
                      <p>
                        <a class="table__column__secondary-link" href="http://store.steampowered.com/app/${game.id}" rel="nofollow" target="_blank">http://store.steampowered.com/app/${game.id}</a>
                      </p>
                    </div>
                    <div class="table__column--width-small text-center">
                      <span class="table__column__secondary-link esgst-clickable">${game.wishlists.length} (${Math.round(game.wishlists.length / glwc.memberCount * 10000) / 100}%)</span>
                    </div>
                  </div>
                </div>
              `).firstElementChild.lastElementChild.firstElementChild, users.join(`, `));
              j += 1;
            }
          }
          if (!wishlistSearch.innerHTML) {
            wishlistSearch.innerHTML = `Nothing found...`;
          }
        }
        wishlistSearch.classList.remove(`esgst-hidden`);
        wishlistResults.classList.add(`esgst-hidden`);
      } else {
        wishlistResults.classList.remove(`esgst-hidden`);
        wishlistSearch.classList.add(`esgst-hidden`);
      }
    });
  }

  // [GR]

  _MODULES.push({
    description: `
      <ul>
        <li>Adds an icon (<i class="fa fa-rotate-left"></i>) next to the game name of a giveaway created by yourself that ended with 0 entries (in any page) that opens the <a href="https://www.steamgifts.com/giveaways/new">new giveaway</a> page with all of the details of the giveaway prefilled so that you can quickly recreate the giveaway.</li>
      </ul>
    `,
    features: {
      gr_a: {
        name: `Show the icon for all created giveaways.`,
        sg: true
      },
      gr_r: {
        name: `Remove the button for giveaways that have been recreated.`,
        sg: true
      }
    },
    id: `gr`,
    load: gr,
    name: `Giveaway Recreator`,
    sg: true,
    type: `giveaways`
  });

  async function gr() {
    if (!esgst.newGiveawayPath) return;
    let template = await getValue(`grTemplate`);
    if (template) {
      await delValue(`grTemplate`);
      template = JSON.parse(template);
      gts_applyTemplate(template);
    }
  }

  async function gr_recreateGiveaway(button, giveaway) {
    button.innerHTML = `<i class="fa fa-circle-o-notch fa-spin"></i>`;
    if (esgst.createdPath) {
      let response = await request({method: `GET`, url: giveaway.url});
      gr_saveTemplate(button, (await giveaways_get(parseHtml(response.responseText), false, response.finalUrl, false, `giveaway`))[0] || giveaway);
    } else {
      gr_saveTemplate(button, giveaway);
    }
  }

  async function gr_saveTemplate(button, giveaway) {
    let context, elements, giveaways, i, keys, n,
      template = {
        delay: 0,
        description: ``,
        duration: giveaway.endTime - giveaway.startTime,
        gameName: giveaway.name,
        groups: ``,
        level: giveaway.level,
        region: `0`
      };
    if (giveaway.group || giveaway.whitelist) {
      template.whoCanEnter = `groups`;
      if (giveaway.whitelist) {
        template.whitelist = `1`;
      }
    } else if (giveaway.inviteOnly) {
      template.whoCanEnter = `invite_only`;
    } else {
      template.whoCanEnter = `everyone`;
    }
    elements = parseHtml(JSON.parse((await request({data: `do=autocomplete_giveaway_game&page_number=1&search_query=${encodeURIComponent(giveaway.name)}`, method: `POST`, url: `/ajax.php`})).responseText).html).getElementsByClassName(`table__row-outer-wrap`);
    for (i = 0, n = elements.length; i < n && elements[i].getAttribute(`data-autocomplete-name`) !== giveaway.name; ++i);
    if (i < n) {
      template.gameId = elements[i].getAttribute(`data-autocomplete-id`);
    }
    keys = [];
    if (giveaway.entries === 0 || giveaway.entries < giveaway.copies) {
      context = parseHtml(JSON.parse((await request({data: `xsrf_token=${esgst.xsrfToken}&do=popup_keys&code=${giveaway.code}`, method: `POST`, url: `/ajax.php`})).responseText).html).getElementsByClassName(`popup__keys__heading`);
      if (context) {
        context = context[context.length - 1];
        elements = context.nextElementSibling.nextElementSibling.children;
        for (i = 0, n = elements.length; i < n; ++i) {
          keys.push(elements[i].textContent);
        }
      }
    }
    if (keys.length > 0) {
      template.gameType = `key`;
      template.keys = keys.join(`\n`);
    } else {
      template.gameType = `gift`;
      template.copies = giveaway.copies;
    }
    await setValue(`grTemplate`, JSON.stringify(template));
    giveaways = JSON.parse(await getValue(`giveaways`));
    if (!giveaways[giveaway.code]) {
      giveaways[giveaway.code] = {};
    }
    giveaways[giveaway.code].recreated = true;
    await setValue(`giveaways`, JSON.stringify(giveaways));
    button.remove();
    open(`/giveaways/new`);
  }

  // [GS]

  _MODULES.push({
    description: `
      <ul>
        <li>Adds 5 columns ("Sent", "Received", "Gift Difference", "Value Difference" and "Users") to your <a href="https://www.steamgifts.com/account/steam/groups">groups</a> page that show some stats about each group.</li>
      </ul>
    `,
    id: `gs`,
    load: gs,
    name: `Group Stats`,
    sg: true,
    type: `groups`
  });

  function gs() {
    if (!esgst.groupsPath) return;
    document.getElementsByClassName(`table__heading`)[0].insertAdjacentHTML(`beforeEnd`, `
      <div class="table__column--width-small text-center">Sent</div>
      <div class="table__column--width-small text-center">Received</div>
      <div class="table__column--width-small text-center">Gift Difference</div>
      <div class="table__column--width-small text-center">Value Difference</div>
      <div class="table__column--width-small text-center">Users</div>
    `);
    esgst.endlessFeatures.push(gs_getGroups);
  }

  function gs_getGroups(context, main, source, endless) {
    const elements = context.querySelectorAll(`${endless ? `.esgst-es-page-${endless} .table__row-inner-wrap, .esgst-es-page-${endless}.table__row-inner-wrap` : `.table__row-inner-wrap`}`);
    for (let i = 0, n = elements.length; i < n; i++) {
      gs_addStatus(elements[i]);
    }
  }

  async function gs_addStatus(context) {
    let responseHtml = parseHtml((await request({method: `GET`, url: `${context.getElementsByClassName(`table__column__heading`)[0].getAttribute(`href`)}/users/search?q=${esgst.username}`})).responseText);
    let element = responseHtml.getElementsByClassName(`table__row-inner-wrap`)[0];
    if (!element || element.getElementsByClassName(`table__column__heading`)[0].textContent !== esgst.username) return;
    let elements = element.getElementsByClassName(`table__column--width-small`);
    for (let i = 0, n = elements.length; i < n; i++) {
      context.appendChild(elements[0]);
    }
    context.insertAdjacentHTML(`beforeEnd`, `
      <div class="table__column--width-small text-center">${responseHtml.getElementsByClassName(`sidebar__navigation__item__count`)[1].textContent}</div>
    `);
  }

  // [GT]
  
  _MODULES.push({
    description: `
      <ul>
        <li>Adds a button (<i class="fa fa-tag"></i>) next to a game's name (in any page) that allows you to save tags for the game (only visible to you).</li>
        <li>You can press Enter to save the tags.</li>
        <li>Each tag can be colored individually.</li>
        <li>There is a button (<i class="fa fa-list"></i>) in the tags popup that allows you to view a list with all of the tags that you have used ordered from most used to least used.</li>
        <li>Adds a button (<i class="fa fa-gamepad"></i> <i class="fa fa-tags"></i>) to the page heading of this menu that allows you to manage all of the tags that have been saved.</li>
      </ul>
    `,
    id: `gt`,
    name: `Game Tags`,
    sg: true,
    type: `games`
  });

  async function gt_openPopup(id, name, type) {
    let popup = new Popup(`fa-tag`, `Edit game tags for <span>${name}</span>:`);
    let set = new ButtonSet(`green`, `grey`, `fa-check`, `fa-circle-o-notch fa-spin`, `Save`, `Saving...`, gt_saveTags.bind(null, id, popup, type));
    popup.description.insertAdjacentHTML(`beforeEnd`, `<div class="esgst-description">Drag the tags to move them.<br/><br/>When editing a tag color, it will also alter the color for all games with that tag (you have to refresh the page for it to take effect).</div>`);
    popup.tags = insertHtml(popup.description, `beforeEnd`, `<div class="esgst-gt-tags"></div>`);
    popup.input = insertHtml(popup.description, `beforeEnd`, `<input type="text"/>`);
    insertHtml(popup.description, `beforeEnd`, `<i class="esgst-ut-existing-button esgst-clickable fa fa-list" title="Select from existing tags"></i>`).addEventListener(`click`, gt_showExistingTags.bind(null, popup));
    popup.input.addEventListener(`keydown`, triggerSetOnEnter.bind(null, set));
    popup.input.addEventListener(`input`, gt_createTags.bind(null, popup));
    popup.description.insertAdjacentHTML(`beforeEnd`, `<div class="esgst-description">Use commas to separate tags, for example: Tag1, Tag2, ...</div>`);
    popup.description.appendChild(set.set);
    popup.open();
    let savedGames = JSON.parse(await getValue(`games`));
    let game = savedGames[type][id];
    popup.input.focus();
    if (game) {
      let tags = game.tags;
      if (tags) {
        popup.tags.innerHTML = ``;
        for (let i = 0, n = tags.length; i < n; ++i) {
          gt_createTag(popup, tags[i]);
        }
        popup.input.value = tags.join(`, `);
      }
    }
  }

  async function gt_showExistingTags(mainPopup) {
    let key, list, popup, savedGames, selectedTags, tag, tagCount, tags;
    popup = new Popup(`fa-list`, `Select from existing tags:`, true);
    tagCount = {};
    savedGames = JSON.parse(await getValue(`games`));
    for (key in savedGames.apps) {
      tags = savedGames.apps[key].tags;
      if (tags) {
        tags.forEach(tag => {
          if (!tagCount[tag]) {
            tagCount[tag] = 0;
          }
          tagCount[tag] += 1;
        });
      }
    }
    for (key in savedGames.subs) {
      tags = savedGames.subs[key].tags;
      if (tags) {
        tags.forEach(tag => {
          if (!tagCount[tag]) {
            tagCount[tag] = 0;
          }
          tagCount[tag] += 1;
        });
      }
    }
    tags = [];
    for (tag in tagCount) {
      tags.push({
        count: tagCount[tag],
        tag: tag
      });
    }
    list = insertHtml(popup.scrollable, `beforeEnd`, `<div class="esgst-ut-existing-tags popup__keys__list"></div>`);
    selectedTags = [];
    tags = sortArrayByNumberKey(tags, `count`, true);
    tags.forEach(tag => {
      let checkbox, item;
      tag = tag.tag;
      item = insertHtml(list, `beforeEnd`, `
        <div>
          <span></span> ${tag}
        </div>
      `);
      if (esgst.gt_colors[tag]) {
        item.style.color = esgst.gt_colors[tag].color;
        item.style.backgroundColor = esgst.gt_colors[tag].bgColor;
      }
      checkbox = new Checkbox(item);
      checkbox.onEnabled = () => {
        selectedTags.push(tag);
      };
      checkbox.onDisabled = () => {
        selectedTags.splice(selectedTags.indexOf(tag), 1);
      };
    });
    popup.description.appendChild(new ButtonSet(`green`, ``, `fa-check`, ``, `Add Tags`, ``, callback => {
      selectedTags.forEach(tag => {
        gt_createTag(mainPopup, tag);
      });
      mainPopup.input.value = mainPopup.input.value ? `${mainPopup.input.value}, ${selectedTags.join(`, `)}` : selectedTags.join(`, `);
      callback();
      popup.close();
    }).set);
    popup.open();
  }

  function gt_createTags(popup) {
    let i, n, tags;
    tags = popup.input.value.replace(/(,\s*)+/g, formatTags).split(`, `);
    popup.tags.innerHTML = ``;
    for (i = 0, n = tags.length; i < n; ++i) {
      gt_createTag(popup, tags[i]);
    }
  }

  function gt_createTag(popup, tag) {
    let bgColorInput, colorInput, colors, container, deleteButton, editButton, input, tagBox, tagContainer;
    container = insertHtml(popup.tags, `beforeEnd`, `
      <div class="esgst-gt-preview" draggable="true">
        <div class="esgst-gt-tags">
          <span class="global__image-outer-wrap author_avatar is_icon">${tag}</span>
        </div>
        <input class="esgst-hidden" type="text"/>
        <input title="Set text color for this tag" type="color"/>
        <input title="Set background color for this tag" type="color"/>
        <i class="esgst-clickable fa fa-edit" title="Edit tag"></i>
        <i class="esgst-clickable fa fa-trash" title="Delete tag"></i>
        <i class="esgst-clickable fa fa-rotate-left" title="Reset tag color"></i>
      </div>
    `);
    tagContainer = container.firstElementChild;
    tagBox = tagContainer.firstElementChild;
    input = tagContainer.nextElementSibling;
    colorInput = input.nextElementSibling;
    bgColorInput = colorInput.nextElementSibling;
    editButton = bgColorInput.nextElementSibling;
    deleteButton = editButton.nextElementSibling;
    const resetButton = deleteButton.nextElementSibling;
    colors = esgst.gt_colors[tag];
    if (colors) {
      colorInput.value = tagBox.style.color = colors.color;
      bgColorInput.value = tagBox.style.backgroundColor = colors.bgColor;
    }
    container.addEventListener(`dragstart`, gt_startDrag.bind(null, container, popup));
    container.addEventListener(`dragenter`, gt_continueDrag.bind(null, container, popup));
    container.addEventListener(`dragend`, gt_endDrag.bind(null, popup));
    input.addEventListener(`keydown`, gt_editTag.bind(null, bgColorInput, colorInput, input, popup, tagBox, tagContainer));
    colorInput.addEventListener(`change`, gt_saveColor.bind(null, colorInput, `color`, `color`, tagBox));
    bgColorInput.addEventListener(`change`, gt_saveColor.bind(null, bgColorInput, `backgroundColor`, `bgColor`, tagBox));
    editButton.addEventListener(`click`, gt_showEdit.bind(null, input, tagBox, tagContainer));
    deleteButton.addEventListener(`click`, gt_deleteTag.bind(null, container, popup));
    resetButton.addEventListener(`click`, gt_resetColor.bind(null, bgColorInput, colorInput, tagBox));
  }

  function gt_startDrag(container, popup, event) {
    event.dataTransfer.setData(`text/plain`, ``);
    popup.dragged = container;
  }

  function gt_continueDrag(container, popup) {
    let current;
    current = popup.dragged;
    do {
      current = current.previousElementSibling;
      if (current && current === container) {
        popup.tags.insertBefore(popup.dragged, container);
        return;
      }
    } while (current);
    popup.tags.insertBefore(popup.dragged, container.nextElementSibling);
  }

  function gt_endDrag(popup) {
    let children, i, n, tags;
    tags = [];
    children = popup.tags.children;
    for (i = 0, n = children.length; i < n; ++i) {
      tags.push(children[i].firstElementChild.firstElementChild.textContent);
    }
    popup.input.value = tags.join(`, `);
  }

  function gt_editTag(bgColorInput, colorInput, input, popup, tagBox, tagContainer, event) {
    let colors, tag;
    if (event.key === `Enter`) {
      tagContainer.classList.remove(`esgst-hidden`);
      input.classList.add(`esgst-hidden`);
      tag = input.value;
      tagBox.textContent = tag;
      colors = esgst.gt_colors[tag];
      if (colors) {
        colorInput.value = tagBox.style.color = colors.color;
        bgColorInput.value = tagBox.style.backgroundColor = colors.bgColor;
      }
      gt_endDrag(popup);
    }
  }

  function gt_saveColor(input, key, saveKey, tagBox) {
    let tag;
    tag = tagBox.textContent;
    if (!esgst.gt_colors[tag]) {
      esgst.gt_colors[tag] = {
        bgColor: ``,
        color: ``
      };
    }
    esgst.gt_colors[tag][saveKey] = tagBox.style[key] = input.value;
  }

  function gt_resetColor(bgColorInput, colorInput, tagBox) {
    bgColorInput.value = ``;
    colorInput.value = ``;
    tagBox.style.backgroundColor = ``;
    tagBox.style.color = ``;
    delete esgst.gt_colors[tagBox.textContent];
  }

  function gt_showEdit(input, tagBox, tagContainer) {
    tagContainer.classList.add(`esgst-hidden`);
    input.classList.remove(`esgst-hidden`);
    input.value = tagBox.textContent;
    input.focus();
  }

  function gt_deleteTag(container, popup) {
    container.remove();
    gt_endDrag(popup);
  }

  async function gt_saveTags(id, popup, type, callback) {
    let tags = popup.input.value.replace(/(,\s*)+/g, formatTags).split(`, `);
    if (tags.length === 1 && !tags[0].trim()) {
      tags = ``;
    }
    let deleteLock = await createLock(`gameLock`, 300);
    let savedGames = JSON.parse(await getValue(`games`));
    if (!savedGames[type][id]) {
      savedGames[type][id] = {};
    }
    savedGames[type][id].tags = tags;
    await setValue(`games`, JSON.stringify(savedGames));
    deleteLock();
    await setSetting(`gt_colors`, esgst.gt_colors);
    gt_addTags(null, id, tags, type);
    callback();
    popup.close();
  }

  async function gt_addTags(games, id, tags, type) {
    let prefix = `<span class="global__image-outer-wrap author_avatar is_icon">`;
    let suffix = `</span>`;
    let html = tags.length && tags[0] ? `${prefix}${tags.join(`${suffix}${prefix}`)}${suffix}` : ``;
    if (!games) {
      games = games_get(document, true, JSON.parse(await getValue(`games`)))[type][id];
    }
    if (!games) {
      return;
    }
    for (let i = 0, n = games.length; i < n; ++i) {
      let game = games[i];
      let button = game.container.getElementsByClassName(`esgst-gt-button`)[0];
      button.classList[html ? `remove` : `add`](`esgst-faded`);
      let tagsContainer = button.lastElementChild;
      tagsContainer.innerHTML = html;
      let children = tagsContainer.children;
      for (let j = 0, numTags = children.length; j < numTags; ++j) {
        let tagsBox = children[j],
          colors = esgst.gt_colors[tagsBox.textContent];
        if (!colors) {
          continue;
        }
        tagsBox.style.color = colors.color;
        tagsBox.style.backgroundColor = colors.bgColor;
      }
    }
  }

  // [GTS]

  _MODULES.push({
    description: `
      <ul>
        <li>Adds a section 9 to the <a href="https://www.steamgifts.com/giveaways/new">new giveaway</a> page that allows you to save the details that you have filled (except for the name of the game and the number of copies/keys) as a template so that you can reuse it later. For example, if you often make public level 5 giveaways that last 2 days, you can save a template with those details so that when you create a new giveaway all of the fields in the page are automatically filled and all you have to do is select the game and set the number of copies/keys.</li>
        <li>Also adds a button (<i class="fa fa-file"></i>) to the main page heading of the same page that allows you manage all of the templates that have been saved and select the template that you want to use.</li>
      </ul>
    `,
    id: `gts`,
    load: gts,
    name: `Giveaway Templates`,
    sg: true,
    type: `giveaways`
  });

  function gts() {
    if (!esgst.newGiveawayPath) return;
    let rows = document.getElementsByClassName(`form__rows`)[0];
    if (!rows) return;
    gts_addButtonSection(createHeadingButton({id: `gts`, icons: [`fa-file`], title: `View/apply templates`}), rows);
  }

  function gts_addButtonSection(button, rows) {
    let createGiveawayButton, delay, endTime, message, preciseEndCheckbox, preciseEndDateCheckbox, preciseEndOption, preciseEndDateOption, preciseStartCheckbox, preciseStartDateCheckbox, preciseStartOption, preciseStartDateOption, reviewButton, section, set, startTime, warning;
    if (!rows) return;
    let gts = {};
    gts.deletedTemplates = [];
    reviewButton = rows.lastElementChild;
    createGiveawayButton = new ButtonSet(`green`, `grey`, `fa-plus-circle`, `fa-circle-o-notch fa-spin`, `Create Giveaway`, `Creating...`, async callback => {
      let data = `xsrf_token=${esgst.xsrfToken}&next_step=3&`;
      data += `game_id=${document.querySelector(`[name="game_id"]`).value}&`;
      data += `type=${document.querySelector(`[name="type"]`).value}&`;
      data += `copies=${document.querySelector(`[name="copies"]`).value}&`;
      data += `key_string=${encodeURIComponent(document.querySelector(`[name="key_string"]`).value)}&`;
      data += `timezone=${new Date().getTimezoneOffset()}&`;
      data += `start_time=${encodeURIComponent(document.querySelector(`[name="start_time"]`).value)}&`;
      data += `end_time=${encodeURIComponent(document.querySelector(`[name="end_time"]`).value)}&`;
      data += `region_restricted=${document.querySelector(`[name="region_restricted"]`).value}&`;
      data += `country_item_string=${encodeURIComponent(document.querySelector(`[name="country_item_string"]`).value.trim())}&`;
      data += `group_item_string=${encodeURIComponent(document.querySelector(`[name="group_item_string"]`).value.trim())}&`;
      data += `who_can_enter=${document.querySelector(`[name="who_can_enter"]`).value}&`;
      data += `whitelist=${document.querySelector(`.form__row--who-can-enter [name="whitelist"]`).value}&`;
      data += `contributor_level=${document.querySelector(`[name="contributor_level"]`).value}&`;
      data += `description=${encodeURIComponent(document.querySelector(`[name="description"]`).value)}`;
      const response = await request({data: data.replace(/start_time=(.+?)&/, mgc_correctTime), method: `POST`, url: `/giveaways/new`});
      if (response.finalUrl.match(/\/giveaways\/new/)) {
        callback();
        const errors = parseHtml(response.responseText).getElementsByClassName(`form__row__error`);
        let message = `Unable to create giveaway because of the following errors:\n\n`;
        for (const error of errors) {
          message += `* ${error.textContent.trim()}`;
        }
        alert(message);
      } else {
        location.href = response.finalUrl;
      }
    });
    rows.appendChild(createGiveawayButton.set);
    button.addEventListener(`click`, gts_openPopup.bind(null, gts));
    section = insertHtml(reviewButton, `beforeBegin`, `
      <div class="esgst-form-row">
        <div class="esgst-form-heading">
          <div class="esgst-form-heading-number">9.</div>
          <div class="esgst-form-heading-text">Template</div>
        </div>
        <div class="esgst-gts-section esgst-form-row-indent">
          <div>
            <span>Use precise start time.</span>
            <i class="fa fa-question-circle" title="For example, if you picked 12:00 pm for the start date in section 4, when you apply the template the start date will be set to the next 12:00 pm hour, so if you apply the template on January 1 11:00 pm, the start date will be set to January 1 12:00 pm, and if you apply the template on January 1 13:00 pm, the start date will be set to January 2 12:00 pm. The end date will then be set based on the time range that you picked."></i>
          </div>
          <div>
            <span>Use precise end time.</span>
            <i class="fa fa-question-circle" title="For example, if you picked 12:00 pm for the end date and a time range of 2 days in section 4, when you apply the template the end date will be set to the next 12:00 pm hour after 2 days, so if you apply the template on January 1 11:00 pm, the end date will be set to January 3 12:00 pm, and if you apply the template on January 1 13:00 pm, the end date will be set to January 4 12:00 pm. The start date will then be set based on the time range that you picked."></i>
          </div>
          <div>
            <span>Use precise start date.</span>
            <i class="fa fa-question-circle" title="With this option enabled, the template will use the exact start date that you picked in section 4. This is only useful if you are creating multiple giveaways and want all of them to begin at a specific later date, because the template is not reusable after the date has passed."></i>
          </div>
          <div>
            <span>Use precise end date.</span>
            <i class="fa fa-question-circle" title="With this option enabled, the template will use the exact end date that you picked in section 4. This is only useful if you are creating multiple giveaways and want all of them to end at a specific later date, because the template is not reusable after the date has passed."></i>
          </div>
          <div class="esgst-description">By not selecting one of the options above, the template will use the time range that you picked in section 4. For example, if the time range that you picked was 2 days, when you apply the template the start date will be set to your current date and the end date will be set to 2 days later.</div>
          <input class="form__input-small" type="text"/>
          <span class="esgst-description esgst-hidden">Saved!</span>
          <div class="esgst-hidden form__row__error">
            <i class="fa fa-exclamation-circle"></i> Please enter a name for the template.
          </div>
          <div class="esgst-description">The name of the template.</div>
        </div>
      </div>
    `).lastElementChild;
    preciseStartOption = section.firstElementChild;
    preciseEndOption = preciseStartOption.nextElementSibling;
    preciseStartDateOption = preciseEndOption.nextElementSibling;
    preciseEndDateOption = preciseStartDateOption.nextElementSibling;
    gts.input = preciseEndDateOption.nextElementSibling.nextElementSibling;
    message = gts.input.nextElementSibling;
    warning = message.nextElementSibling;
    preciseStartCheckbox = new Checkbox(preciseStartOption, esgst.gts_preciseStart);
    preciseEndCheckbox = new Checkbox(preciseEndOption, esgst.gts_preciseEnd);
    preciseStartDateCheckbox = new Checkbox(preciseStartDateOption, esgst.gts_preciseStartDate);
    preciseEndDateCheckbox = new Checkbox(preciseEndDateOption, esgst.gts_preciseEndDate);
    preciseStartOption.addEventListener(`click`, () => {
      setSetting(`gts_preciseStart`, preciseStartCheckbox.input.checked);
      esgst.gts_preciseStart = preciseStartCheckbox.input.checked;
    });
    preciseEndOption.addEventListener(`click`, () => {
      setSetting(`gts_preciseEnd`, preciseEndCheckbox.input.checked);
      esgst.gts_preciseEnd = preciseEndCheckbox.input.checked;
    });
    preciseStartDateOption.addEventListener(`click`, () => {
      setSetting(`gts_preciseStartDate`, preciseStartDateCheckbox.input.checked);
      esgst.gts_preciseStartDate = preciseStartDateCheckbox.input.checked;
    });
    preciseEndDateOption.addEventListener(`click`, () => {
      setSetting(`gts_preciseEndDate`, preciseEndDateCheckbox.input.checked);
      esgst.gts_preciseEndDate = preciseEndDateCheckbox.input.checked;
    });
    set = new ButtonSet(`green`, `grey`, `fa-check`, `fa-circle-o-notch fa-spin`, `Save Template`, `Saving...`, async callback => {
      let i, n, template, savedTemplates, startDate, endDate;
      if (gts.input.value) {
        warning.classList.add(`esgst-hidden`);
        startDate = new Date(document.querySelector(`[name="start_time"]`).value);
        startTime = startDate.getTime();
        endDate = new Date(document.querySelector(`[name="end_time"]`).value);
        endTime = endDate.getTime();
        delay = startTime - Date.now();
        if (delay < 0) {
          delay = 0;
        }
        template = {
          countries: document.querySelector(`[name="country_item_string"]`).value.trim(),
          delay: delay,
          description: document.querySelector(`[name="description"]`).value,
          duration: endTime - startTime,
          gameType: document.querySelector(`[name="type"]`).value,
          groups: document.querySelector(`[name="group_item_string"]`).value.trim(),
          level: document.querySelector(`[name="contributor_level"]`).value,
          name: gts.input.value,
          region: document.querySelector(`[name="region_restricted"]`).value,
          whoCanEnter: document.querySelector(`[name="who_can_enter"]`).value,
          whitelist: document.querySelector(`.form__row--who-can-enter [name="whitelist"]`).value,
          createTrain: esgst.mgc_createTrain,
          removeLinks: esgst.mgc_removeLinks
        };
        if (preciseStartCheckbox.input.checked) {
          template.startTime = startTime;
        }
        if (preciseEndCheckbox.input.checked) {
          template.endTime = endTime;
        }
        if (preciseStartDateCheckbox.input.checked) {
          template.startDate = {
            day: startDate.getDate(),
            month: startDate.getMonth(),
            year: startDate.getFullYear()
          };
        }
        if (preciseEndDateCheckbox.input.checked) {
          template.endDate = {
            day: endDate.getDate(),
            month: endDate.getMonth(),
            year: endDate.getFullYear()
          };
        }
        let deleteLock = await createLock(`templateLock`, 300);
        savedTemplates = JSON.parse(await getValue(`templates`, `[]`));
        for (i = 0, n = savedTemplates.length; i < n && savedTemplates[i].name !== template.name; ++i);
        if (i < n) {
          if (gts.edit) {
            savedTemplates[i] = template;
            message.classList.remove(`esgst-hidden`);
            setTimeout(() => {
              message.classList.add(`esgst-hidden`);
            }, 2000);
          } else if (confirm(`There already exists a template with this name. Do you want to overwrite it?`)) {
            savedTemplates[i] = template;
            message.classList.remove(`esgst-hidden`);
            setTimeout(() => {
              message.classList.add(`esgst-hidden`);
            }, 2000);
          }
        } else {
          savedTemplates.push(template);
          message.classList.remove(`esgst-hidden`);
          setTimeout(() => {
            message.classList.add(`esgst-hidden`);
          }, 2000);
        }
        await setValue(`templates`, JSON.stringify(savedTemplates));
        deleteLock();
        callback();
      } else {
        warning.classList.remove(`esgst-hidden`);
        callback();
      }
    });
    section.appendChild(set.set);
    rows.insertBefore(createGiveawayButton.set, rows.firstElementChild);
    rows.insertBefore(reviewButton, rows.firstElementChild);
    createGiveawayButton.set.style.display = `inline-block`;
    createGiveawayButton.set.style.margin = `20px 5px`;
    reviewButton.style.margin = `20px 0`;
    let first, last;
    first = true;
    last = false;
    addEventListener(`scroll`, () => {
      if (scrollY < 138) {
        if (!first) {
          rows.insertBefore(createGiveawayButton.set, rows.firstElementChild);
          rows.insertBefore(reviewButton, rows.firstElementChild);
          createGiveawayButton.set.style.margin = `20px 5px`;
          reviewButton.style.margin = `20px 0`;
          first = true;
          last = false;
        }
      } else if (!last) {
        rows.appendChild(reviewButton);
        rows.appendChild(createGiveawayButton.set);
        reviewButton.style.margin = ``;
        createGiveawayButton.set.style.margin = `0 5px`;
        last = true;
        first = false;
      }
    });
  }

  async function gts_openPopup(gts) {
    let popup = new Popup(`fa-file`, `View/apply templates:`, true);
    popup.description.insertAdjacentHTML(`afterBegin`, `
      <div class="esgst-description">Drag and drop templates to move them.</div>
    `);
    gts.undo = insertHtml(popup.description, `beforeEnd`, `
      <div class="esgst-clickable esgst-hidden">
        <i class="fa fa-rotate-left"></i>
        <span>Undo Delete</span>
      </div>
    `);
    gts.undo.addEventListener(`click`, gts_undoDelete.bind(null, gts));
    let templates = insertHtml(popup.scrollable, `beforeEnd`, `
      <div class="esgst-text-left popup__keys__list"></div>
    `);
    let savedTemplates = JSON.parse(await getValue(`templates`, `[]`));
    for (let i = 0, n = savedTemplates.length; i < n; ++i) {
      let savedTemplate = savedTemplates[i];
      if (!savedTemplate.gameType) {
        savedTemplate.gameType = `gift`;
      }
      if (!savedTemplate.whoCanEnter) {
        savedTemplate.whoCanEnter = savedTemplate.type;
      }
      let details = `${savedTemplate.gameType}, `;
      if (savedTemplate.startTime || savedTemplate.endTime) {
        if (savedTemplate.startTime) {
          let time = new Date(savedTemplate.startTime);
          if (savedTemplate.startDate) {
            details += `${savedTemplate.startDate.year}-${savedTemplate.startDate.month + 1}-${savedTemplate.startDate.day} `;
          }
          details += `${`0${time.getHours()}`.slice(-2)}:${`0${time.getMinutes()}`.slice(-2)} to`;
        } else {
          details += `? to`;
        }
        if (savedTemplate.endTime) {
          let time = new Date(savedTemplate.endTime);
          if (savedTemplate.endDate) {
            details += ` ${savedTemplate.endDate.year}-${savedTemplate.endDate.month + 1}-${savedTemplate.endDate.day}`;
          }
          details += ` ${`0${time.getHours()}`.slice(-2)}:${`0${time.getMinutes()}`.slice(-2)}`;
        } else {
          details += ` ?`;
        }
        details += `, `;
      } else if (savedTemplate.startDate || savedTemplate.endDate) {
        if (savedTemplate.startDate) {
          details += `${savedTemplate.startDate.year}-${savedTemplate.startDate.month + 1}-${savedTemplate.startDate.day} to`;
        } else {
          details += `? to`;
        }
        if (savedTemplate.endDate) {
          details += ` ${savedTemplate.endDate.year}-${savedTemplate.endDate.month + 1}-${savedTemplate.endDate.day}`;
        } else {
          details = ` ?`;
        }
        details += `, `;
      }
      let hours = Math.floor(savedTemplate.duration / 3600000);
      if (hours > 23) {
        let days = Math.floor(hours / 24);
        if (days > 6) {
          let weeks = Math.floor(days / 7);
          if (weeks === 1) {
            details += `1 week`;
          } else {
            details += `${weeks} weeks`;
          }
        } else if (days === 1) {
          details += `1 day`;
        } else {
          details += `${days} days`;
        }
      } else if (hours === 1) {
        details += `1 hour`;
      } else {
        details += `${hours} hours`;
      }
      if (savedTemplate.region !== `0`) {
        details += `, region restricted`;
      }
      if (savedTemplate.whoCanEnter === `everyone`) {
        details += `, public`;
      } else if (savedTemplate.whoCanEnter === `invite_only`) {
        details += `, invite only`;
      } else {
        if (savedTemplate.whitelist === `1`) {
          details += `, whitelist`;
        }
        if (savedTemplate.groups.trim()) {
          details += `, groups`;
        }
      }
      details += `, level ${savedTemplate.level}`;
      let template = insertHtml(templates, `beforeEnd`, `
        <div draggable="true">
          <div class="esgst-clickable" style="float: left;">
            <span class="esgst-bold">${savedTemplate.name}</span>
          </div>
          <div class="esgst-clickable" style="float: right;">
            <i class="fa fa-trash" title="Delete template"></i>
          </div>
          <div style="clear: both;"></div>
          <div class="esgst-description">${details}</div>
        </div>
      `);
      template.addEventListener(`dragstart`, gts_setSource.bind(null, gts, savedTemplate.name, template));
      template.addEventListener(`dragenter`, gts_getSource.bind(null, gts, template, templates));
      template.addEventListener(`dragend`, gts_saveSource.bind(null, gts));
      gts_setTemplate(gts, popup, template, savedTemplate);
    }
    popup.open();
  }

  function gts_setTemplate(gts, popup, template, savedTemplate) {
    let applyButton = template.firstElementChild,
      deleteButton = applyButton.nextElementSibling;
    applyButton.addEventListener(`click`, () => {
      gts_applyTemplate(savedTemplate);
      gts.input.value = savedTemplate.name;
      gts.edit = true;
      popup.close();
    });
    deleteButton.addEventListener(`click`, async () => {
      deleteButton.innerHTML = `
        <i class="fa fa-circle-o-notch fa-spin"></i>
      `;
      let deleteLock = await createLock(`templateLock`, 300),
        savedTemplates = JSON.parse(await getValue(`templates`, `[]`)),
        i = 0;
      for (const n = savedTemplates.length; i < n && savedTemplates[i].name !== savedTemplate.name; ++i);
      savedTemplates.splice(i, 1);
      await setValue(`templates`, JSON.stringify(savedTemplates));
      deleteLock();
      deleteButton.innerHTML = `
        <i class="fa fa-trash"></i>
      `;
      template.classList.add(`esgst-hidden`);
      gts.deletedTemplates.push({
        template: template,
        savedTemplate: savedTemplate
      });
      gts.undo.classList.remove(`esgst-hidden`);
      gts.edit = false;
    });
  }

  async function gts_undoDelete(gts) {
    let deletedTemplate = gts.deletedTemplates.pop();
    deletedTemplate.template.classList.remove(`esgst-hidden`);
    deletedTemplate.template.parentElement.appendChild(deletedTemplate.template);
    let savedTemplates = JSON.parse(await getValue(`templates`, `[]`));
    savedTemplates.push(deletedTemplate.savedTemplate);
    await setValue(`templates`, JSON.stringify(savedTemplates));
    if (gts.deletedTemplates.length === 0) {
      gts.undo.classList.add(`esgst-hidden`);
    }
  }

  function gts_applyTemplate(savedTemplate) {
    let context, countries, currentDate, days, endTime, groups, i, id, j, matches, newEndTime, newStartTime, startTime, selected;
    if (!savedTemplate.gameType) {
      savedTemplate.gameType = `gift`;
    }
    if (!savedTemplate.whoCanEnter) {
      savedTemplate.whoCanEnter = savedTemplate.type;
    }
    currentDate = new Date();
    document.querySelector(`[data-checkbox-value="${savedTemplate.gameType}"]`).click();
    if (savedTemplate.edit) {
      document.querySelector(`[name="start_time"]`).value = savedTemplate.startTime;
      document.querySelector(`[name="end_time"]`).value = savedTemplate.endTime;
    } else {
      if (savedTemplate.startTime && savedTemplate.endTime) {
        startTime = new Date(savedTemplate.startTime);
        newStartTime = new Date(currentDate.getTime());
        newStartTime.setHours(startTime.getHours(), startTime.getMinutes(), startTime.getSeconds(), startTime.getMilliseconds());
        if (newStartTime.getTime() < currentDate.getTime()) {
          newStartTime.setDate(newStartTime.getDate() + 1);
        }
        endTime = new Date(savedTemplate.endTime);
        newEndTime = new Date(newStartTime.getTime());
        if (endTime.getMonth() !== startTime.getMonth()) {
          days = (new Date(startTime.getFullYear(), startTime.getMonth() + 1, 0).getDate()) - newStartTime.getDate() + endTime.getDate();
        } else {
          days = endTime.getDate() - startTime.getDate();
        }
        newEndTime.setDate(newStartTime.getDate() + days);
        newEndTime.setHours(endTime.getHours(), endTime.getMinutes(), endTime.getSeconds(), endTime.getMilliseconds());
        document.querySelector(`[name="start_time"]`).value =
          getDate(`[MMM] [D], [YYYY] [H12]:[HMM] [XX]`, newStartTime);
        document.querySelector(`[name="end_time"]`).value =
          getDate(`[MMM] [D], [YYYY] [H12]:[HMM] [XX]`, newEndTime);
      } else if (savedTemplate.startTime) {
        startTime = new Date(savedTemplate.startTime);
        newStartTime = new Date(currentDate.getTime());
        newStartTime.setHours(startTime.getHours(), startTime.getMinutes(), startTime.getSeconds(), startTime.getMilliseconds());
        if (newStartTime.getTime() < currentDate.getTime()) {
          newStartTime.setDate(newStartTime.getDate() + 1);
        }
        newEndTime = new Date(newStartTime.getTime() + savedTemplate.duration);
        document.querySelector(`[name="start_time"]`).value =
          getDate(`[MMM] [D], [YYYY] [H12]:[HMM] [XX]`, newStartTime);
        document.querySelector(`[name="end_time"]`).value =
          getDate(`[MMM] [D], [YYYY] [H12]:[HMM] [XX]`, newEndTime);
      } else if (savedTemplate.endTime) {
        endTime = new Date(savedTemplate.endTime);
        newStartTime = new Date(currentDate.getTime() + savedTemplate.delay);
        newEndTime = new Date(newStartTime.getTime() + savedTemplate.duration);
        newEndTime.setHours(endTime.getHours(), endTime.getMinutes(), endTime.getSeconds(), endTime.getMilliseconds());
        if (newEndTime.getTime() < newStartTime.getTime()) {
          newEndTime.setDate(newEndTime.getDate() + 1);
        }
        document.querySelector(`[name="start_time"]`).value =
          getDate(`[MMM] [D], [YYYY] [H12]:[HMM] [XX]`, newStartTime);
        document.querySelector(`[name="end_time"]`).value =
          getDate(`[MMM] [D], [YYYY] [H12]:[HMM] [XX]`, newEndTime);
      } else {
        newStartTime = new Date(currentDate.getTime() + savedTemplate.delay);
        newEndTime = new Date(currentDate.getTime() + savedTemplate.delay + savedTemplate.duration)
        document.querySelector(`[name="start_time"]`).value =
          getDate(`[MMM] [D], [YYYY] [H12]:[HMM] [XX]`, newStartTime);
        document.querySelector(`[name="end_time"]`).value =
          getDate(`[MMM] [D], [YYYY] [H12]:[HMM] [XX]`, newEndTime);
      }
      if (savedTemplate.startDate) {
        newStartTime.setFullYear(savedTemplate.startDate.year);
        newStartTime.setMonth(savedTemplate.startDate.month);
        newStartTime.setDate(savedTemplate.startDate.day);
        document.querySelector(`[name="start_time"]`).value =
          getDate(`[MMM] [D], [YYYY] [H12]:[HMM] [XX]`, newStartTime);
      }
      if (savedTemplate.endDate) {
        newEndTime.setFullYear(savedTemplate.endDate.year);
        newEndTime.setMonth(savedTemplate.endDate.month);
        newEndTime.setDate(savedTemplate.endDate.day);
        document.querySelector(`[name="end_time"]`).value =
          getDate(`[MMM] [D], [YYYY] [H12]:[HMM] [XX]`, newEndTime);
      }
    }
    if (!savedTemplate.region.match(/^(1|0)$/)) {
      savedTemplate.region = `0`;
    }
    document.querySelector(`[data-checkbox-value="${savedTemplate.region}"]`).click();
    if (savedTemplate.countries) {
      matches = document.querySelector(`.form_list[data-input="country_item_string"]`).children;
      countries = savedTemplate.countries.trim().split(/\s/);
      for (i = matches.length - 1; i > 0; --i) {
        context = matches[i];
        id = context.getAttribute(`data-item-id`);
        selected = context.classList.contains(`is-selected`);
        j = countries.indexOf(id);
        if ((selected && j < 0) || (!selected && j >= 0)) {
          context.click();
        }
      }
    }
    document.querySelector(`[data-checkbox-value="${savedTemplate.whoCanEnter}"]`).click();
    if (savedTemplate.gameName) {
      document.getElementsByClassName(`js__autocomplete-name`)[0].value = savedTemplate.gameName;
    }
    if (savedTemplate.gameId) {
      document.querySelector(`[name="game_id"]`).value = savedTemplate.gameId;
    }
    if (savedTemplate.keys) {
      document.querySelector(`[name="key_string"]`).value = savedTemplate.keys;
    } else if (savedTemplate.copies) {
      document.querySelector(`[name="copies"]`).value = savedTemplate.copies;
    }
    if (savedTemplate.whoCanEnter === `groups`) {
      matches = document.querySelector(`.form_list[data-input="group_item_string"]`).children;
      context = matches[0];
      if ((savedTemplate.whitelist === `1` && !context.classList.contains(`is-selected`)) || (savedTemplate.whitelist !== `1` && context.classList.contains(`is-selected`))) {
        context.click();
      }
      if (savedTemplate.groups) {
        groups = savedTemplate.groups.trim().split(/\s/);
        for (i = matches.length - 1; i > 0; --i) {
          context = matches[i];
          id = context.getAttribute(`data-item-id`);
          selected = context.classList.contains(`is-selected`);
          j = groups.indexOf(id);
          if ((selected && j < 0) || (!selected && j >= 0)) {
            context.click();
          }
        }
      } else {
        for (i = matches.length - 1; i > 0; --i) {
          context = matches[i];
          if (context.classList.contains(`is-selected`)) {
            context.click();
          }
        }
      }
    }
    if (savedTemplate.level > 0) {
      document.getElementsByClassName(`ui-slider-range`)[0].style.width = `${savedTemplate.level * 10}%`;
      document.getElementsByClassName(`form__level`)[0].textContent = `level ${savedTemplate.level}`;
      document.getElementsByClassName(`form__input-description--no-level`)[0].classList.add(`is-hidden`);
      document.getElementsByClassName(`form__input-description--level`)[0].classList.remove(`is-hidden`);
    } else {
      document.getElementsByClassName(`ui-slider-range`)[0].style.width = `0%`;
      document.getElementsByClassName(`form__input-description--level`)[0].classList.add(`is-hidden`);
      document.getElementsByClassName(`form__input-description--no-level`)[0].classList.remove(`is-hidden`);
    }
    document.getElementsByClassName(`ui-slider-handle`)[0].style.left = `${savedTemplate.level * 10}%`;
    document.querySelector(`[name="contributor_level"]`).value = savedTemplate.level;
    document.querySelector(`[name="description"]`).value = savedTemplate.description;
    if (esgst.mgc_createTrainSwitch) {
      if (savedTemplate.createTrain) {
        esgst.mgc_createTrainSwitch.enable();
      } else {
        esgst.mgc_createTrainSwitch.disable();
      }
    }
    if (esgst.mgc_removeLinksSwitch) {
      if (savedTemplate.removeLinks) {
        esgst.mgc_removeLinksSwitch.enable();
      } else {
        esgst.mgc_removeLinksSwitch.disable();
      }
    }
  }

  async function gts_setSource(gts, name, template, event) {
    let i, n, savedTemplates;
    event.dataTransfer.setData(`text/plain`, ``);
    gts.source = template;
    savedTemplates = JSON.parse(await getValue(`templates`, `[]`));
    for (i = 0, n = savedTemplates.length; i < n && savedTemplates[i].name !== name; ++i);
    if (i < n) {
      gts.sourceIndex = i;
    }
  }

  function gts_getSource(gts, template, templates) {
    let current, i;
    current = gts.source;
    i = 0;
    do {
      current = current.previousElementSibling;
      if (current && current === template) {
        gts.sourceNewIndex = i;
        templates.insertBefore(gts.source, template);
        return;
      }
      ++i;
    } while (current);
    gts.sourceNewIndex = i - 1;
    templates.insertBefore(gts.source, template.nextElementSibling);
  }

  async function gts_saveSource(gts) {
    let savedTemplates = JSON.parse(await getValue(`templates`, `[]`));
    savedTemplates.splice(gts.sourceNewIndex, 0, savedTemplates.splice(gts.sourceIndex, 1)[0]);
    setValue(`templates`, JSON.stringify(savedTemplates));
  }

  // [GV]
  
  _MODULES.push({
    description: `
      <ul>
        <li>Turns each giveaway in the main page and some popups ([id=gb], [id=ged] and [id=ge]) into a small box where only the game's image is shown. Overlaying the image you will find the start/end times, type and level of the giveaway. To get the other details of the giveaway (such as the game name, the number of points it costs to enter, the number of entries/comments and the creator's username), you can hover over the box and a popout will appear containing them. This allows multiple giveaways to be shown per line, which reduces the size of the page and allows you to view all of the giveaways in the page at a single glance.</li>
        <li>Also adds a button (<i class="fa fa-th-large"></i>) to the main page heading of the same page that allows you to set the size of the space between each box.</li>
      </ul>
    `,
    features: {
      gv_gb: {
        name: `Extend to Giveaway Bookmarks.`,
        sg: true
      },
      gv_ged: {
        name: `Extend to Giveaway Encrypter / Decrypter.`,
        sg: true
      },
      gv_ge: {
        name: `Extend to Giveaway Extractor.`,
        sg: true
      }
    },
    id: `gv`,
    load: gv,
    name: `Grid View`,
    sg: true,
    type: `giveaways`
  });

  function gv() {
    if (esgst.giveawaysPath || esgst.gv_gb || esgst.gv_ged || esgst.gv_ge) {
      esgst.giveawayFeatures.push(gv_setContainer);
      esgst.style.insertAdjacentText(`beforeEnd`, `
        .esgst-gv-creator {
          margin: ${esgst.ib ? 10 : 5}px 5px 5px;
          width: ${esgst.ib ? 127 : 132}px;
        }

        .esgst-gv-popout .giveaway__links {
          display: block;
          height: auto;
          margin: 5px 5px ${esgst.ib ? 10 : 5}px;
          text-align: center;
          width: ${esgst.ib ? 127 : 132}px;
        }
      `);
      if (esgst.giveawaysPath) {
        let button, display, element, elements, i, n, popout, spacing, slider;
        button = createHeadingButton({id: `gv`, icons: [`fa-th-large`], title: `Set Grid View spacing`});
        popout = new Popout(`esgst-gv-spacing`, button, 0, true);
        spacing = esgst.gv_spacing;
        element = insertHtml(popout.popout, `beforeEnd`, `
          <div>
            <div></div>
            <div>${spacing}px</div>
          </div>
        `);
        slider = element.firstElementChild;
        display = slider.nextElementSibling;
        $(slider).slider({
          slide: (event, ui) => {
            spacing = ui.value;
            elements = document.getElementsByClassName(`esgst-gv-container`);
            for (i = 0, n = elements.length; i < n; ++i) {
              elements[i].style.margin = `${spacing}px`;
            }
            popout.reposition();
            display.textContent = `${spacing}px`;
            setSetting(`gv_spacing`, spacing);
            esgst.gv_spacing = spacing;
          },
          max: 10,
          value: spacing
        });
      }
    }
  }

  function gv_setContainer(giveaways, main, source) {
    if ((!main || !esgst.giveawaysPath) && (main || ((source !== `gb` || !esgst.gv_gb) && (source !== `ged` || !esgst.gv_ged) && (source !== `ge` || !esgst.gv_ge)))) return;
    giveaways.forEach(giveaway => {
      giveaway.grid = true;
      let popup = giveaway.outerWrap.closest(`.esgst-popup-scrollable`) || esgst.menuPath;
      if (popup) {
        giveaway.outerWrap.parentElement.parentElement.classList.add(`esgst-gv-view`);
        giveaway.outerWrap.parentElement.style.display = `inline-block`;
        giveaway.outerWrap.classList.add(`esgst-gv-container`);
        giveaway.outerWrap.style.margin = `${esgst.gv_spacing}px`;
      } else {
        giveaway.outerWrap.parentElement.classList.add(`esgst-gv-view`);
        giveaway.outerWrap.classList.add(`esgst-gv-container`);
        giveaway.outerWrap.style.margin = `${esgst.gv_spacing}px`;
      }
      giveaway.innerWrap.classList.add(`esgst-gv-box`);
      giveaway.gvIcons = insertHtml(giveaway.innerWrap, `afterBegin`, `
        <div class="esgst-gv-icons giveaway__columns">
          <div class="esgst-gv-time" data-columnId="time" draggable="true">
            <span title="${giveaway.started ? `Ends` : `Starts`} ${giveaway.endTimeColumn.lastElementChild.textContent}">${getRemainingTime(giveaway.endTime)}</span>
            <i class="fa fa-clock-o"></i>
            <span title="Created ${giveaway.startTimeColumn.lastElementChild.previousElementSibling.textContent}">${getRemainingTime(giveaway.startTime)}</span>
          </div>
        </div>
      `);
      giveaway.endTimeColumn_gv = giveaway.gvIcons.firstElementChild.firstElementChild;
      if (!esgst.lockGiveawayColumns) {
        giveaway.gvIcons.addEventListener(`dragenter`, giveaways_getSource.bind(null, giveaway, false));
        let item = giveaway.gvIcons.firstElementChild;
        item.addEventListener(`dragstart`, giveaways_setSource.bind(null, giveaway));
        item.addEventListener(`dragenter`, giveaways_getSource.bind(null, giveaway, false));
        item.addEventListener(`dragend`, giveaways_saveSource.bind(null, giveaway));
      }
      if (giveaway.inviteOnly) {
        giveaway.gvIcons.appendChild(giveaway.inviteOnly);
      }
      if (giveaway.regionRestricted) {
        giveaway.gvIcons.appendChild(giveaway.regionRestricted);
      }
      if (giveaway.group) {
        giveaway.gvIcons.appendChild(giveaway.group);
      }
      if (giveaway.whitelist) {
        giveaway.gvIcons.appendChild(giveaway.whitelist);
      }
      if (giveaway.levelColumn) {
        giveaway.levelColumn.textContent = giveaway.levelColumn.textContent.replace(/Level\s/, ``);
        giveaway.gvIcons.appendChild(giveaway.levelColumn);
      }
      giveaway.innerWrap.insertBefore(giveaway.image, giveaway.gvIcons);
      giveaway.summary.classList.add(`esgst-gv-popout`, `global__image-outer-wrap`);
      giveaway.summary.insertBefore(giveaway.avatar, giveaway.links);
      giveaway.avatar.insertAdjacentHTML(`afterEnd`, `
        <div style="clear: both;"></div>
      `);
      giveaway.headingName.insertAdjacentHTML(`afterEnd`, `<br>`);
      giveaway.pointsContainer.insertAdjacentHTML(`afterEnd`, `<br>`);
      giveaway.endTimeColumn.classList.add(`esgst-hidden`);
      giveaway.startTimeColumn.classList.add(`esgst-hidden`);
      giveaway.entriesLink.lastElementChild.textContent = giveaway.entriesLink.textContent.replace(/[^\d,]+/g, ``);
      giveaway.commentsLink.lastElementChild.textContent = giveaway.commentsLink.textContent.replace(/[^\d,]+/g, ``);
      let creator = insertHtml(giveaway.links, `beforeBegin`, `
        <div class="esgst-gv-creator">
          <span>by</span>
        </div>
      `);
      creator.appendChild(giveaway.creatorContainer);
      new Popout(``, giveaway.outerWrap, 100, false, giveaway.summary);
    });
  }

  // [HBS]

  _MODULES.push({
    description: `
      <ul>
        <li>Hides the blacklist stats of your <a href="https://www.steamgifts.com/stats/personal/community">stats</a> page.</li>
      </ul>
    `,
    id: `hbs`,
    load: hbs,
    name: `Hidden Blacklist Stats`,
    sg: true,
    type: `general`
  });

  function hbs() {
    if (!location.pathname.match(/^\/stats\/personal\/community/)) return;

    let chart = document.getElementsByClassName(`chart`)[4];

    // remove any "blacklist" text from the chart
    let heading = chart.firstElementChild;
    heading.lastElementChild.remove();
    heading.lastElementChild.remove();
    let subHeading = heading.nextElementSibling;
    subHeading.textContent = subHeading.textContent.replace(/and\sblacklists\s/, ``);

    // create a new graph without the blacklist points
    let script = document.createElement(`script`);
    script.innerHTML = chart.previousElementSibling.textContent.replace(/,{name:\s"Blacklists".+?}/, ``);
    document.body.appendChild(script);
    script.remove();
  }

  // [HGEBD]

  _MODULES.push({
    description: `
      <ul>
        <li>Disables the enter button of any giveaway if you have hidden the game on SteamGifts so that you do not accidentaly enter it.</li>
      </ul>
    `,
    id: `hgebd`,
    load: hgebd,
    name: `Hidden Game's Enter Button Disabler`,
    sg: true,
    sync: `Hidden Games`,
    type: `giveaways`
  });

  function hgebd() {
    if (!esgst.giveawayPath || document.getElementsByClassName(`table--summary`)[0]) return;
    let hideButton;
    hideButton = document.getElementsByClassName(`featured__giveaway__hide`)[0];
    if (esgst.enterGiveawayButton && !hideButton) {
      let parent = esgst.enterGiveawayButton.parentElement;
      if (esgst.enterGiveawayButton) {
        esgst.enterGiveawayButton.remove();
      }
      parent.insertAdjacentHTML(`afterBegin`, `
        <div class="sidebar__error is-disabled">
          <i class="fa fa-exclamation-circle"></i> Hidden Game
        </div>
      `);
    }
  }

  // [HGR]

  _MODULES.push({
    description: `
      <ul>
        <li>Adds a button (<i class="fa fa-eye-slash"></i> <i class="fa fa-times-circle"></i>) to your <a href="https://www.steamgifts.com/account/settings/giveaways/filters">giveaway filters</a> page that allows you to remove all of the games that you have hidden.</li>
        <li>There is also an option to remove only the games that you own.</li>
      </ul>
    `,
    id: `hgr`,
    load: hgr,
    name: `Hidden Game Remover`,
    sg: true,
    type: `giveaways`
  });

  function hgr() {
    if (!location.pathname.match(/^\/account\/settings\/giveaways\/filters/)) return;
    let button = createHeadingButton({id: `hgr`, icons: [`fa-eye-slash`, `fa-times-circle`], title: `Remove games from the list`});
    button.addEventListener(`click`, hgr_openPopup.bind(null, {button}));
  }

  function hgr_openPopup(hgr) {
    if (hgr.popup) {
      hgr.popup.open();
      return;
    }
    hgr.popup = new Popup(`fa-times`, `Remove hidden games:`);
    hgr.removed = insertHtml(hgr.popup.scrollable, `beforeEnd`, `<div class="markdown"></div>`);
    new ToggleSwitch(hgr.popup.description, `hgr_removeOwned`, false, `Only remove owned games.`, false, false, `If disabled, all games will be removed.`, esgst.hgr_removeOwned);
    hgr.popup.description.appendChild(new ButtonSet_v2({color1: `green`, color2: `grey`, icon1: `fa-arrow-circle-right`, icon2: `fa-times`, title1: `Remove`, title2: `Cancel`, callback1: hgr_startRemover.bind(null, hgr), callback2: hgr_stopRemover.bind(null, hgr)}).set);
    hgr.progress = insertHtml(hgr.popup.description, `beforeEnd`, `<div></div>`);
    hgr.popup.open();
  }

  async function hgr_startRemover(hgr) {
    hgr.canceled = false;
    hgr.lastPage = ``;
    hgr.button.classList.add(`esgst-busy`);
    hgr.progress.innerHTML = `
      <i class="fa fa-circle-o-notch fa-spin"></i>
      <span>Removing games...</span>
    `;
    hgr.removed.innerHTML = `<span class="esgst-bold">Removed Games:</span>`;
    let url = `/account/settings/giveaways/filters/search?page=`;
    let nextPage = 1;
    let pagination = null;
    do {
      let context = null;
      if (nextPage === esgst.currentPage) {
        context = document;
      } else if (document.getElementsByClassName(`esgst-es-page-${nextPage}`)[0]) {
        nextPage += 1;
        continue;
      } else {
        context = parseHtml((await request({method: `GET`, url: `${url}${nextPage}`})).responseText);
      }
      if (!hgr.lastPage) {
        hgr.lastPage = lpl_getLastPage(context);
        hgr.lastPage = hgr.lastPage === 999999999 ? `` : ` of ${hgr.lastPage}`;
      }
      hgr.progress.innerHTML = `
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <span>Removing games (page ${nextPage}${hgr.lastPage})...</span>
      `;
      let elements = context.getElementsByClassName(`table__row-outer-wrap`)
      for (let i = 0, n = elements.length; i < n; i++) {
        let element = elements[i];
        let info = games_getInfo(element);
        if (!info) continue;
        let game = esgst.games[info.type][info.id];
        if (esgst.hgr_removeOwned && (!game || !game.owned)) continue;
        let button = element.getElementsByClassName(`table__remove-default`)[0];
        if (context === document) {
          button.dispatchEvent(new Event(`click`));
        } else {
          request({data: `xsrf_token=${esgst.xsrfToken}&do=remove_filter&game_id=${button.parentElement.querySelector(`[name="game_id"]`).value}`, method: `POST`, url: `/ajax.php`});
        }
        hgr.removed.insertAdjacentHTML(`beforeEnd`, `
          <a href="http://store.steampowered.com/${info.type.slice(0, -1)}/${info.id}">${element.getElementsByClassName(`table__column__heading`)[0].textContent}</a>
        `);
      }
      nextPage += 1;
      pagination = context.getElementsByClassName(`pagination__navigation`)[0];
    } while (!hgr.canceled && pagination && !pagination.lastElementChild.classList.contains(`is-selected`));
    hgr.button.classList.remove(`esgst-busy`);
    hgr.progress.innerHTML = ``;
    if (hgr.removed.children.length === 1) {
      hgr.removed.innerHTML = `<span class="esgst-bold">0 games removed.</span>`;
    }
  }

  function hgr_stopRemover(hgr) {
    hgr.canceled = true;
    hgr.button.classList.remove(`esgst-busy`);
    hgr.progress.innerHTML = ``;
  }

  // [HR]

  _MODULES.push({
    description: `
      <ul>
        <li>Refreshes the header icons (created/won/inbox for SteamGIFTS and inbox for SteamTrades) and the points on SteamGifts (in any page) every specified number of minutes.</li>
        <li>There are also options to notify you when there are new wishlist giveaways open, when the key for a game you won is delivered, when you reach 400P and when you receive a new message.</li>
        <li>You can upload a custom sound for the browser notifications.</li>
        <li>If you enable the options to show browser notifications, you will be asked to give the permission to ESGST by your browser.</li>
      </ul>
    `,
    features: {
      hr_w: {
        features: {
          hr_w_n: {
            features: {
              hr_w_n_s: {
                name: `Play a sound with this notification.`,
                inputItems: true,
                sg: true
              }
            },
            name: `Also show as a browser notification.`,
            sg: true
          },
          hr_w_h: {
            name: `Only indicate for giveaways ending in a specified number of hours.`,
            inputItems: [
              {
                id: `hr_w_hours`,
                prefix: `Hours: `
              }
            ],
            sg: true
          }
        },
        inputItems: [
          {
            id: `hr_w_format`,
            prefix: `Format: `,
            tooltip: `Use # to represent a number. For example, '(#❤)' would show '(8❤)' if there are 8 unentered wishlist giveaways open.`
          }
        ],
        name: `Indicate if there are unentered wishlist giveaways open in the tab's title.`,
        sg: true
      },
      hr_g: {
        features: {
          hr_g_n: {
            features: {
              hr_g_n_s: {
                name: `Play a sound with this notification.`,
                inputItems: true,
                sg: true
              }
            },
            name: `Also show as a browser notification.`,
            sg: true
          }
        },
        inputItems: [
          {
            id: `hr_g_format`,
            prefix: `Format: `
          }
        ],
        name: `Indicate if there are unviewed keys for won gifts in the tab's title.`,
        sg: true
      },
      hr_b: {
        name: `Keep refreshing in the background when you go to another tab or minimize the browser.`,
        sg: true,
        st: true
      },
      hr_c: {
        description: `
          <ul>
            <li>With this option disabled, notifications will automatically close after a few seconds.</li>
          </ul>
        `,
        name: `Only close notifications manually.`,
        sg: true,
        st: true
      },
      hr_fp: {
        features: {
          hr_fp_s: {
            name: `Play a sound with this notification.`,
            inputItems: true,
            sg: true
          }
        },
        name: `Show a browser notification if there are 400P or more.`,
        sg: true
      },
      hr_p: {
        inputItems: [
          {
            id: `hr_p_format`,
            prefix: `Format: `,
            tooltip: `Use # to represent a number. For example, '(#P)' would show '(100P)' if you have 100 points.`
          }
        ],
        name: `Show the number of points in the tab's title.`,
        sg: true
      },
      hr_m: {
        features: {
          hr_m_n: {
            features: {
              hr_m_n_s: {
                name: `Play a sound with this notification.`,
                inputItems: true,
                sg: true,
                st: true
              }
            },
            name: `Also show as a browser notification.`,
            sg: true,
            st: true
          }
        },
        name: `Show the number of unread messages in the tab's icon.`,
        sg: true,
        st: true
      },
      hr_a: {
        description: `
          <ul>
            <li>With this option disabled, clicking on a notification will always open a new tab.</li>
          </ul>
        `,
        extensionOnly: true,
        features: {
          hr_a_r: {
            name: `Refresh the page after setting it as active.`,
            sg: true,
            st: true
          },
          hr_a_a: {
            name: `If the page is not open, set any SteamGifts/SteamTrades tab as active.`,
            sg: true,
            st: true
          }
        },
        name: `When clicking on a browser notification, check if the related page is open and set it as active.`,
        sg: true,
        st: true
      }
    },
    inputItems: [
      {
        id: `hr_minutes`,
        prefix: `Refresh every `,
        suffix: ` minutes`
      }
    ],
    id: `hr`,
    load: hr,
    name: `Header Refresher`,
    sg: true,
    st: true,
    type: `general`
  });

  function hr() {
    let hr = {
      messages: 0,
      points: esgst.points,
      wins: 0
    };
    esgst.hr = hr;
    hr_notifyChange(hr);
    setLocalValue(`hrCache`, JSON.stringify(hr_getCache()));
    hr_startRefresher(hr);
    if (!esgst.hr_b) {
      addEventListener(`focus`, hr_startRefresher.bind(null, hr));
      addEventListener(`blur`, () => clearTimeout(hr.refresher));
    }
  }

  function hr_getDefaultSound() {
    return `//uQxAAB1MYI8KMM3gqqwV+AYZpBBAAEOmeT08nttJ5Mnd3zCCGXpiDk7P2IMUQz9yZNO4w8Bhe/wnsRER/dnpuDrjIhyeuTu0IOwADMISf8AKTAAAQ96xhBNnTh073uDhadkydJxNt/EMQgxAsBrjXJpnk0+yZSD2eDgMnl3zCDpmBZMmmZlmINabZd7BO2MIEMJpuTJkwcL0hjk02jxlx2j3ZNdmIPrdoJp60fwh7KACGHp2g+mIOnTCjTMCA6NJRgGfmJu1kjWIp8LtgtBXijXwh0UIgq0RLWS7rTWdNTsQakRJOgS8LwiZpaF2QlEGLRS1G+TdiB5GzlGsilxSjieMHGVCzy0aKLbhymNZPGs+ie3ZF0gsQNhpoRp1LNI6bBAgNVpCjzTtMKIaHcxZbyzFwYxyxRiZWGkDAgYYrmAzIOQZKem+Taz5PPc4yoU4Xt3i0mJ12dpJWGwAh3IEaSlDDnWTzcUitNywAMPdaY/p31QkaFPzXMsFAKB8YWSXgSC2zL0UkUM6RFHqUPOAyTihaT3o58O1NwAniZFPCR//uSxB2D1Y4K/AMU0ALqwd9AYyW4z0cMVKTUSP1NjzxKyJqAvDnKt6kmkBqoEQkZdnkrPdKVFIMbunlQN4OfHLBrgwzbejae3RwNJmFxZyjEJhsV2GgYxYHaT3y6UWBaw2kcfDFzT7ASDkpctKaFSjGtkdjThZph7J9P4g5JyiaCSJtAFDVEDzBie7mA4YhHlHEVE4JJCz9QYpZpSiZyIOyrAnxKTkJIEnYogLQhyY9A5R5wgvKYim22OubNSVbPeepwkk1GKO2Seyea7dTWlYncadKqi5NUhRsEse8zTGyQMYlUBEZdSBnrFlZ4jWi2rBSBhEQF5RUPkHYlJJ8kGtIGmstIQFBQjvLyRuJlGMPZnKXVbqShxh8H457nyVZVe1uLMakQtC4nksyURMlcI2Uk11LbYVXUKrJISKjRhy76Ec2OCQBwRB8udiILEpmT7rlLKJAhRr9lW/K5sSmJUcrmzhmDWk2Za+u8FFGrlWCiOXHEBQtsy6JplDBaT3sWWKxXS3CSSmN5Oatsqws7PKdCtkjkzF+S59ZbU62WNv1JNf/7ksQwgBcCCvwUxIAMSDqi5z9AAA+jaWfBWJyOvYjqBIyioohVnBR3WtCitx5Di69uMNNJeKRAQSuSUKcxTbcYLoUZyX1dt0Wob3sL2lOZ/UL0ZOypCRnSmQJFXTtdJElGEIoJJdNlZSajpAAAIIMIAAAAADAxAe4wjQDeMl1LjjO7gC4yAV8NMSEEDzBGQOEwJwBkMOPBVzBLwV8wW4JIMgrBHQMAcmAMgAZgHYJ6YHCAZmACBNJg6oDKAEAC2AG7JAKWRJRgGYnMh4Ay8DJgAUKjVIgM4LjE7izxOYLEwLAgtJDaxek2RQolw1L6RIBywbCJzFxAVAmJTHWTILFU003dYbWKWGiN8ZIZEPuxQOrLDs16ZJjiIKSZBidJcurc6aqMU6dalVk0TpWIsTpbIcSx8zVRuZFUz3Zab6pNE6WzYOLEPLxqfLyJ846IhKDgaPX3/XSz5ki6Rq6SLpIuky1qtdrNTZ3tX3auqtv/n0jIMm3Ay8Yaf7Xe1ZEEDBsA1cxQpRtMhhLVDFXQnowXkEcMA1AkyICJMB6AYzBaRjT/+5LEEgMZZY0WPfoAEwkxYwX9UboxqAPbMX3BaRoGGMB3ADTA6gLMwjgSSMB+AZDAbQDoKgAwjUDEAw0AFghiaOXy8TRiLUNckimgbmqi4gXygkaFwplBzGMkyZuT5XPnSsEIIBheZMbJDHma2SY6nUzJE2LepE0Kh7WgXziS2TWgcLjGCz9VqBdKz2aarl5zE8y5gmtGm291LKoCEwuArKWjbT7srv2rq+mtXUvqdtXoFxBGru/9/Ir9NAQGCPguRhaxlSajUKfGEGAgJgX4CcBgNAwHkBNMDMA1DCpyUswnROmMUsB/TCRwJswDYAKMA3AMDBKRXU7ogJsBUCzdlrljxuTzvLNDR27kDwY/d2cpt/blfMs8+fu5FIdxuxujq4WZTJw41R52e1JPSFAn01oFAnFnSNEvGMJgnTBNNk3dJCtFNOyUsO27JmBNmnpIIu56Z6RqgvME2e70jEDApSCpVum9aVlrqZA8/XQr71KZb2//qUTrlZD9af1dKgBFAKkIlYOJjzEjH3QKKYrAERgxgCmAgAEYAQHJgthRGYUk//uSxBGCFpmNIO89scM3sWWp1474obXuMpmnA2mOSCUYIwEpgGgdmDacAPAVoc3Plya0nRg2r3Uj+PGTyeetV0RiR0yNb2Cu64jw4926Np1eXE24KSiWxldU8N/h/e0d/XLojpoJpqxsjNSlhVcITNd3SDEokVMzrW61GLoJqoqRekuaqQVXo6vWmAiB1am7bNU6Dr09Ppsmv2ZtfX/1zI3UroX//6iAAARESCglmJXkHrzRmGwcGB4Jy4AA8QDWbTggfcH2bPnIDgzMFwAMIAAMcFpZYCQWHgFBQALCphr+TEf1TeAncrWK0PS9/IowOHlLyeI1R6wrG9bT9nmr39O8gq9sZFyqy6HSOgb58IEWMvitVcl7TP2yJDVkrhDtEh7pnefjXzuBml/6Q51ZBcH8Cu9f/FFexODnG04T0v3NsbXJkZGNqexwlSwr7XxTL+EyG+tE7NgxSFm4qWfdN01fcCr/AuI7JTL+OaUxcK/B/8cUTQAAAHnNtbJLKR1gHfz9egiaZBNKYtRmmp5wZKUPgAw3ET4YchRE49DitrlPpv/7ksQWgBuRZ1ms4e3jEyyqqa3TkuG5+xUlLbv4z1VzjKkbjG0w14RlhaANSKD7XgIBOkyhTaWFLjtxcduD8IC3adRTeOonlnKZbZGD3LmuHUBOKVpeLtemmiSpJNJ8OMBPEEAQA/CGEHOoJAPch5BFCZC5PM5G1jTEE9SlQ9NtEJwT7c4PNQWlkeu2S/gKxtNNLxID+Hm0u/WHPamssDyGx2PUF0CVVz+tIH3umrx3kRniP4ysiP/AcoMAwGxVWRIEzn6gQAJCbciknVjE7t72W51VWmZcgFyYKGUN5FiIAZgBxzkqQMxC5PZa7GaGKvrP7na1rvMt/NP85V/kqkVEzqBoyz5FZw0eUJkbpqtmak8OySjflHUmURyXzkuoZbWpcKbv/rLLWdWSQsGAR5wKGBq0nlZVC3Jepgz4whrUQa9N2Iap6WempRLqWW403bNBYyfe40kUVGTrb/7JjtLqBNECLZBR0g0QiGk8tE1quoyNjE1JonikViZLRNHzEzMiUsWW7FyP+xUAMAB2OAYYYsOcZlIYNgWyxCsQAGYUg2b/+5LEDAIXGbk2zuaPgy03ZUHtyji6MoAqZMJhuKOPGhVJgSMIwwMPUePZ0ZARNEKILHAVT5M6tS6/HGms5fmJS5G2WzNPGu1q/M6vunXqX5xr0ani5tn7+rfMdWrdACjZrOrpb76JsiZGIFTgHheiARMm5dHp2au2gpE6w1EHsik6iitFAvHzEwDrhyBqWjZik7IsjUuY65HkRdGZkykbBQCJOeTbeqz/6Vf26r/tt//+RxJ/qMCcFwwTkFzJ4G2MDgEUiA3RoEYHIsBUaPII5lro3GMoxQZP4WRgZAKmBGAeYcAOZhlmbmuWa8YZIPJgggniQtJgyAFBwDbNIHnI01Sihq1UjSh1NOTtFLZJ/LVSWsMiM5HqaJS6JCEQk9ec7Z/PdamWUNIUH2dYzWOP61f73mt1t0kFqKBUvOdri0bSJA66rZzL/4plOkYrWYiRDJqqdaKSkTyF3cugtpsyk1I/oLa1h9oWRY4kRwCcINev2tXZa/v/7ft///ykMJPpADAAUmBSBEYVQzJrFBFGDkASGAPFQAcwHAODB5BFMwAx//uSxBCDF9m7LM9qr4K4p6XN7tD4swVjazBNVQMcYKYwFQFR4BgwtQqjDEH/NtYgYwugAQQ4OwCN4ZR+YjMXo1qtVps6zN5BG4hVzxsdtZdc/dmplHa1p44phl9zuee7MlUAs6Qd3ro6SKNTGxqXgEAMDZArDSB7MyUK69DutGy1G5El7m6WpmqQTEQD9ZWc2Y8hu6zqTKprHSb00FJIkyF6xvO+h2pUavV//////+mW36UQSC5DABAPMHQeg0Mg2TBOAOCAG1QhcDYlBsNSfANWjMN5UQJ35FiPMIgOMUiRMbpcP1q7MfBcMKAuByJAYj0RG/g6/Yp7+HbFVYtPO08aW13TKo5p5A4WCwboE666jM0zZSxHJ5Fk7WezsnppLSKINQAHfDixGqi6XklvV1X41yu2unZUyXTYZ4HBjyS2MW/SU/UYm60LnVF4NtIOgdcuKiQCvDDSVelOsKi+z9oBzA0CbMB1oowOS1zAHB6HQMQMAQYFoNhhEARmL28+ZLaIhg/utmkkHiYG4FgQAUYYIMhirnAHjyVaEFNGf8n7Fv/7ksQgg5ptuSIvao9TOSfjhe5R8HvgGEDpfMha9DsGvJ2YiFReWV14bFe5Zq361t4qfO5FpZZtvtavucMXdbpGYYKPsgeWdRMkEHoH6jJZoZkYDUKB9LQ1y5PiyUDI+pA8taSlrZxIS4pFCSheMkl1XMVDPhq48gbJkyzoMtnJlys1TyepugkbpBbodyRtSVWyk0qaCrVb2VdmZ2s/poPqU1etX6s6wjCcC3McVlI9JyiTE/ByMHIDMwMQEAIByDgRDWmcYMB6C0yJLxzElGHMEYH4wKQlTGqCOMUdo04q33DEPErNLpU9wSTeQcMVgEmBiz5NDcFXn7qUEuSfltNlZpZDaklW9AUN6pqZfd21GYLl1+3KJJPSfW6unUs0hxlmvNrObMkVTQnjAcsEAADe/QywQ8xLQnJNjA+ZKW1RguiOkZFLmRoZFtqSkcsiBU1JLdn0nWZJFNWgpKrSUWSHmRsbrA4xReImzA3bbxKp+yjCtytFAELjAsAIMQMj84VRFDC1AVHgUC4wNBVMFwHUziwLTFaHUMOAtszSwQwEDAj/+5LEFgIUYU8kT2qOQqonJJnuzDjyYcoNhh7EInFgHcAiBDMWAh4bZKW6WjEozpE2MZxY1Fkc6M6jaWjVjFIlSSNS+gizIJoKVWmV6T2roVZ9a3RZZoXwDFBfSOSqg6WrVovMCp5meU63ZbozAnadBJ2+dYy1n1OyvOjwZsbslet1HAmyWo9slKsxiQyKF5gHg3GBuoyd5x0YRiyDAYLVmAgVmDY2na2Lmi85GtGwHgozGGgShUJjI4kTGS9jrLgzEgcjCwJjLkEAwwx4BBUiRK5qOszk4kiH7pqY2SRRUpaSSalEMMUD7sgzrRRWfsXmrrU620ndKp3dSAJ1JBNM0K1B2ahrvkcar51l1ruylmRbQdSkzta01Ocu1TVsfWxk7DqUBn3ME6VCwqOpbGH7VhqNUoX+hRkMHMKYxLmSzjUKYMNIHMwOwIgEAyCABzBRCiMj1gwxI0FQI0oYi4bxgIAcmBGBAUCRGJCNELnlmJiBGYFYNqCMwJwLBAAKuaAYlQmCaJ2pAou5c8sfe1zB4TjVG4qXTQRp+4ej0xiEG9yk//uSxDWCE/E3Hi8uc0JzoSQZ7sk49z7fX73TrQ1EPAf4i55JZozpH31qbXJR1KW5ir6qaS0M4p7exiijU9f+R7Db/2P/4V9ivuDAASmCeAMYqAWx02BBiQ7gYEEYCAAIXBSMBcD0w/UgTH8GuNy+AOXhIDheCgOmTQxGHuKmm+6GDIzmE4KmWQEjxkFADNWgain5iUXaKtRPHenct6qasdtVahmgyZcKR4mKklJOqyJkRJN1+tq9DZtyYAysiCZ1JNaCZsgkyP1HD9Wgv021uYqd0ZiYNRA5rMaMOp9pbrq5rUB2s/0KABCSQFzCZ5jggzzAwCGLgYCACApgGGhnAYxhGShiCSIc2qol6kQtGFwYnIQTg4aAsAjLlyy67xTpJGl4LekkYf62cjChaLaU44p98rKv6v4ysYTrRCydbaq1IsK+MyZvW9nkrmwRX8sd5WP9e9Y8DV3wdTfPDjKyCzsFX8ee6K+7CA7AFeCwivBAdhAh2Pp8+TFVDCFcoJwwTInBwAggAALz99pdbVSeST0IQAXhxZAhLV6zl6Wvz0seh//7ksRdgBONATBOvHHU8y/r/czrX6/pL9/hiMLmJSGDiuYKERpnJmyomPI412OzKK5MPlUyOEAwdGLiSYJCxjoAiocaMBAapWLB8mAQsIUKwgKhUZhCOMHCQxUGTEhYMTjMzSqxwUGQAeBQCg4gTXyBlmcgoBSwwZzrjCJzLPM/013DOyPwg9JBFCZbBlmiSgWEUdMkcve3J93Qjcll8kgSCZVJoCydV4GvvTLk81zLTSPQBs8SeBgaHwhFAgIFKHARogs8wNEVQcabGCLQGMoMA0EoqDjozaOQDCw9sACHuqyqMSxaiOiFZbdTdW9TMHB0v4g/0awnY5KJxgD5KZmGOGoNIoqTfRlDTKSH30vTtSLtzZ3CnQizSHNf9nbD5E4EmqXpuL425XT36mTK5DRWlsfVAAAADzcsEvimphcWBLnMMgIgAKiCmIKKpkDLDJgNT49gYUXBrkMP2jka3BREE1pvzGHWL8izmIxMvyDGmngZ5lz0F6550jiQt6+ipi70WikFNs6Kxm5sxZywtpymIElAr9rNC4QYWAOc11hqyGL/+5LENwIfZWc9rmNvQoAsJgHcwfijriBQxOVS1IlDEwFRAwC0CKT8y/NLdhl9XFx/K1a+3rmW8ccdVu2ZVRwSpioK4s6/JABsGfqHpU/1qtKV2Z2pdDTvS7NMoeH6kPfyghp/oahqGb1bK1jVlMZh7sZdmGbMaUOgZBoz+xM2EQMEoKurRQ0/0tubqY7hlyX5777EI0n1TxmyQDoaKgq///SKAMYbrqc7kwBg3EgERpMDwBMKh9N5bJMPyYM0PvNxQ1MTqQMxwMAwWFQjzFYmEOLhkTqEMna9e1adqHt4wHOLY5XQUpcfyx1D0SuUsZlsod6jf0LC61f3jzmuMlES4aZGYzhBpnSOvnvdnWW/56qqmMkW27p+taKli0k49qM4N4xRRRZFimIBM1Tf//qOkNUbgTRRzR//92ELDsNf/+/2KiAAAwJCowUn80IQQwICkQgIyAYEswZHE+CYYx2Tk1mHcnxYwu2IzUFYwXBUwWA42oE8DB4XsQudOAkS67Cx71WJxT3UAD2zK2AzSx1CrDxzrN/WEDiS9zxgXlLQKxkL//uSxC+DE4FjLE6+kRKjK+UJ7dG4JAzgkkDE+OYBpQInw+bnDJ9tVnUgRFFv5t6tBJh29lrLA00X+NUT5NaP/f/5xIsALjhxI//+sSseX///6DgQAwIwIDCUGzNNAJgwZAERoC4AACCoL4JABNE0wgxMxcDEuYmMzcNQwbzDjKuBiGACwrgHl4YBBGSDRkNA1JHp+mqR3LdmxcnKOnLIvLIY7Jr8sfC1Ju195416V14pQZaq49+glzMh4qi3mAvwM0hDfycNC+Z/sb0zhSHG6LOzIqNSpatVqhTB4fW9Mc5u7LNA31L/+pvW+pJExDoxspf/9BYroe///6YwEAMAkA8wlB+jUsDlMGYAQMASJQATAiA+MIUIszFl3zCeDuMKeAoxrg7DNkJD5oDjDUDzBkNTdceAcIaIYcAqgDVae32mq2rufaqysMiEBKWGpRPWZbbZ9aQnKaoyqa6zjuZGqI+wxQi5iPgE0AXKPHCii11VueWtSyaQQSoVsgY6ttQkRN9aDojZoqrrJQg9//X6rd5jMxCr9/1/qKBb/////6SBDv/7ksRTgBSZYyZPdouCSywl2ded+AAQEB0cgAxwNMkBZrrVhEFhg2QRgZqwUIM0rfQDqIYssCbsBCBgiCwwmOwiJ0sI8TFljPly5v1w93CepPEVa3GrM+cXm5n7KtyuC29aluTxLfX9Iidvr8czJe+sXzi/wZZLMrLdUedRdbqPEksjIi1er4a22fbbbfffMCzt/09z4jExZoAsU0WWwZaPNkvf/ooAABxgwcC0xziA/jNMxJA4MBV8QaIRg0BZwL1ZgCcxorp56kUpjjf5tYM4wAwGGE0SDVHAVwXI92hsUjEftVLGcp14+Nu2WGrYs2a/PpCn3Jmjm45/3a2MWXlFqtXpVn1ndrWtj/8/6V3NTLZas08edB5eFw/ic1iquclVtqDU6Io+Og2dCR5ySzTtNqqbPH8+oXHbdduc2mtRBRX8EBmQwFQw7xhzetDEMKkBMaBgBwBaBABAoGncUIYVBDZgTvSmMEJuYTyZpgvBTkwG4ACcCwNICASWWRABEQAz0tjfavLGrOFKotHQ6Et0kCl5fSdumKyH18ZXUoOlcrf/+5LEfgMToU8obr1vyn8sJAnmNpiCaftykY/ZRmCel1kXX6GkrWS9FSnopKNWrQWYLsGkljVO1lGtSlPrGTq//Uja7PVnB6qb1Muowd2XztqdqrreagSa2yQSIBhjtJ0qvBg2GIwBjADAkRxImT2N0jKcADVjazj0czJSszVUFTC4DDB8EDPcBA4I1jxF2nlMw5VFtcKZiYKTtGjcOy7t2+lh+uomoFJ25mQ//6l+cY6YK+/bnJiS2nCWBC/h956e9Mois9N+lJ7Oa5yWc0DIm51lOHW51TiPtv2qyWr79CJu23kACYAwUwhDDSU7NlIiwwlgWzAtAaEAB5gGAmmCWHKZ9SpZgwBOGModgaKIIRiIFamYKBgYEADxgDhBmC+EYCgJ0jxIAVWnFNxscoiaxFqOo2Z0yoPy4Zhg0sXDza2q4d388stluPujtW1ukTDh7FaEDAXO3n9bZ2/nG9AJTEPpSpREVSJSG4kih0MmO6Hp9Tvava/t29ort0ylbDC+u99Oj/+2nvRVEC8jAxAKMOIEE3PACSITQaA3AgA4iAgE//uSxKYDEdE5JG69UcKSpuOJ5iqgCScp+QZiC+bF3cc/iGYyDkcGhEYtAuYKjGYmBmXWTzVUUQf5ozYKeYfaIyyW5iqNXGgYKSmBfE0fEpehzjqKY6msm1xBDEzOAmnbfo6aAROePrMdc03a+oqCac3zq62PZm6LZKHI//8sHf8s9d4p0PRKxstCwBDtMZKoQ9QkxTEcDKMGMFswBAFDAXAFMBsS8zxFuzD+CaMNocszJw1DCdHZMiUO4wDQXDBeDBM6QRQMBVIHGgxUOvqH2dskkSXaOq1LMAQmQX2kCSm2lL7ubG5198K9qkg2ZkVmq50I19Nhjnl2am0sq9crNgFsZLpsrs7ImqkFGoDJIc6bmc+6l1K/Mm36HWtSehT3vs2rUvVUztUTh9JRNBkFxqBEMa4OIeIVuFUlIsSSd86lvU4b9COpAO/zBqDNMM9941xTXTCLCYMCwEMwEwJBgEchBaMEU9YwpQhTGXMPDj40UrTpYdEAhMZw41c9zBAELeBxeEge4Lqy57HCSQZa3tmfRExqqOk+Tbfa7jrVIegsiP/7ksTSg5GFNyBPdUXC9qbiCew18HoQKzn0eXu6oRShXXJIkIc5bULbd7eH+4h3xcbYq/r57vh823qXx8c8xX8/93W/99Nmm//aok1O8/ziDYqPpqnf5Pz13/0rQRB8wVwEbMQ3H2jfJQtEww8CUMEGARTAmwBIwGgBHMCzAVTDCSO0wEUEWMCzHYjBKANowIwAbMP1APjASgCowFEEyMWVBgTAuwAgwBMA5MArAITAHQAooACEqkn2gsRMAVAHGoySnSJF8AITIIyAPmgwU+ch0N7KeyWSq038vDFIA5I2aFWE/aqRpihJa/VzzRGlMt4raeFLvV76nzSoYDMu61tiuPy0hQlWOQSu/mtZiaRRy8ipzOVUFW3plRC1HG3eGl54Y4CajhmqhMrCJBjdadWfuv55hjj07KoeNO1Ozb/J31Nux3N271VMQU0JTAWgNQwncpNNOxEzDBxwO0wJQBaMBPAOzAKAFIwD8BUMMaFCjA0gTcwX0TsMOKAEDFJ0jb8SDIcXzE1SzfGGjCcQzAMARovRIRFRroSye5wWWNedF+L/+5LE9AMUcTcWT3FpS6c0IQX3jqkejzsQWiAzl1aGfc2dk8WkeT/0sLmLz/R9ikQvOXTFE1QNGFiJ0mTDZAZRQmRcZGtNSTKrYaAmqafdBFSupTtrQtQ7qWtWhTskpTo1GGm/n+uPcRsbL8lV/ecKzevPWbqf2EDHHkVf+bX/Z39FZV6/a+tdr/cjTQITcbZgkhcGCU7+Y3BnxgYBImASB4FAEwSBUYBgEhj5iLmBsKEYW5EpkCAbmA+HIYQIHAYDAFQPwMfAPAWhQAKMLFdgkrR1KYKFQwiZLqd1CIC1dir4ttutNqGdYM3K5Zn1lVustRM94OvuzmRdM29n5uA9JT+ipR2pnrXWnZSLoXf7JKWtVHqVdnrRrWpm11rmB2TQ0ith5wuQUFl2vKNF5ymlTEFNRTMuOTkuNVVVVVUCDBSQWQw5otbNpMEjDCmgPUwPEAyMCMAQzAXQBIwBwAMMSwB2zARwkUwKki5MJUAVTMiCDMEfzRE6TDU+jMSQzGsKg4CDF8AiYVlFGhGCgBo/M1C4EoJiICZNRrtHNo4hByTj//uSxPIDGcUTDC/1q8qOpuLN5jYwbcT9nfp1tbjQgPXrA/IS1vXcWkO0Oj+qkMdYfZbhyYv66x75v7ffo2kQ9ntqm8wcZ1qtqWtubNL5h5pfMy0QAWtq5MHaeJ+hySV22F6vwKzVdxMehIjHEXYqd9cm5VjUl2P/Pfth2gHOnBtnpnxhy39BTjkcMDsCUxUDbDqoGjMOwDgwOwFQMBoYCoHJgSARGJiG8YYQWZg3GEmLiDGYJwLRg1gMGCcCMLADmKyBoPA/oI1LIg3VeUyZgSnIgqz5ozZUoQzqlOm6yallAaotbXRntmoO3egtNi1LUa0BZrBTWsyte//np8V2rkz8E/aoVkS+fDqMTU5mViGZrWk8mt/O8h3P1/znfzyTfiO6Hg+1FdpLQj82pVVVlSHrowRA+TBSoMNIhHEwPAyhGC6IQIBwGcwMgYzCeAPMOsUIxag8DLvD0EQM5gAgMAIHIwQguTFGDAMAEAu2UAYpAt0bqnO6srQkMkjOD+COSztAqWtTiU8Tzuq+Dz6OI/UGs3ZR+1iFWqQWQSeNAYOFjf/7ksT4gxqo6wgv9esKpC1izeYOOVm6ZXq/ad/GzqO2z/fPae0bVszqEtak/TIhTO24axpCAeehiv8uZwzSRf/2ikxHmtQsz3hc38TPhKThA5cfVVbb/4lbocIDLGCTAw5hb5qcalOLFmELghRgXQCiYDuAmGAnAFpgJoC6YIOB2mADAMhgLI6kYJ2ApGCDAYhgQwCUYFUA/GBDAnhhnAImYAKAbJcGAQgBReNcw6ABpeJXumJMRknCVJywuStbRhJRFrZoSohMZP/LVCN9HRm8Y51wo0smqSTc9Ca5keRy91mxT1pjON+mJJWwpZ6x8VvNi1tYNVnbT4ebJqBDv2rDHxsrqhm3stqqv4f7mfJN15ysy81++0vyc/SIE+ZSVsjN21doZG+Ya5xz5mv7SLFqPwThyF1hCPX/OhhpzNPWdOH+LSVVUwKgABMKdCrzUCwZIwd0AvNDBIBKMxEIggDmHjqYJBp8M5HshcYxhwchTKqpMBxg36yQhtI2hBHEhUsUlJECYJULQV6HvEUcypYmERxxXKvT7yKXGGt0utP0Ner/+5LE/4MW7YMQTzB1Q6W0IQn3mnEUKiSDm+tO74wulh9p9glrnSt9X3nN8apq2bEOnv8/cD6tj61j6xbOsf41je/81t/nXhV5C6W+IUON5Y5p3+ZaLVDnckwTLhs+pnfqPJ7u6P/G9v5od97V8/33o//vskCZMB0TIxV8uzvtW4MPkQ8wQgeguByMgMGAWAKYB4nxhQA5GBKfuYIQPpgjgtkQhJgaATGBuG6Zi4Uhg7gLjoAI0A4hgw1xGvw+/ip1zqbw09brzM2opNzeDK3Zpaa69DOXFwlD91uzqzocnGPq4t7ygcLW9YB0tPMVP7/aGDCF2lZ+N3HmnojkozkIHhOWyWU7XPvHBlZAmcLQpwGnRnKg8ZKBIkJ3+ehFto5n7vDO7BjWkN3BdCruNH9TFDvqw/YF+OuwpsP0MFJCCDCtkk00tAfSMHwBgTAsQKgwGgBPMBRAZTABgAUyKuk1hRw880U9lI00KYs2xN8wDGkwpcU7eb4wfBNGYeLUHCSLAWKACpELABCxUEFMIHfqG7615CvAwIAR/CceF4fjx0g6//uSxPWDF5EDDE/x44shtKFJ5Y9JVJpOHc0d4IaQ7ST2oaHVSVY9Gp3TYAqvd2bwyaPSg1tXAGTzDzauImmNYstKrN2+n3tdfzdLst8xEq9RUsn5j5uN8RzbXxPERtrhnbqUl8e7bFMe5yvKrqvj7Q6ufmLp1Mp0d0i+66j2st0L03i96pxqiY9CvmI0nMDRAeDCygsM1R4CeMICAITApwAQIAsTAcKTEYJjEk0jNJDzRbMDlsajBY8za0mgEFpkgZhz0XZhUDhagaEIs2wR+QgBV8vwhznHNgdtgJj49mw2j6VIEwnqnTNNMqqxyQ4hDsSm4NbbxZ4G3mm0RD3UxH/F3xOF2x3HMNvir+v2fU7+Ou++F7MTcY53+++71sq/NNdx3O8wYW/WN9PgufNY0ExDVMX6f//H1rj8r1jMWsIdnDG6MAvBKzCYDTQ02oYNMGuBADAlwHEwEgAkBQAOYCGA9mEChHpgVgXgYFsLSGAdATBgJQG6YMKAZmAeAZpmGkH7XyYVDIGAIGLQYLkHAKA1AaOSkoDa6p7B3XCkcPUDO//7ksT5g9vZ6wQP9WfK1x/hQf6suZY1+C5i1jJ4nSS2kjsol8MRh56a9WqdqU/d5yVi09iHMg2EUYlsbNPCp1DoBCf0l2q/u9+04pKhoSnn+VXuZRPtZe/qKnHxNLt3FJH/bP1N1cVd3CTGOiHu+71ujJ6ifiOY5u34uH794HxELFr+OnS/dEb+eSOzJ+oGML4XcxM97DffYJMNERYwVAdwSBYAgKTBvAMMjQTYw+yqzCjNCMnQG4wOg1DHdAYBALBg+hAmMCFsJABLvFgKURF3t4m28jGi6jEZa9cBMyiV/BrTULr1sHqTxKVFMKp46fDxeW51XPtv9QtOaujHnp+v3/v6emZhqEkH3XapffnuecZiiw7md1bUqm5dSv8KkrkrxcVFq5bU585FU4c45Nl8P0LfZWlidvFJ+6GlU3z4eh8ucgUl9MltlMhU4moAJlKsYSwRJjwo9Hx+NWYrIKBloNmIwQHBSQnJVUbaUxmkhnzhoYX1BvsDBURhdNmdB+t1ubC2mxV9myxe+82Mw9JlC7zgeR9EclDcTBoIEeh4Oor/+5LE9YPbAgEGD/ENyvk7YQHmDtmmrVTQllzl0bTY9N4jm7zi1kpSulZZW/d7/But7PY/7qrm7q5c3i4nuJ+qbxHP88OqL9lXs289Ro3Nfx/t54ipt9uiZnexrLUZJIND4lBMR5OlCxXZ9FtajENCKDJgPAFsYVqTCmqriPxg9YGCYFcAeGAhgEpgBwBcYBuAimCHCKZg44S8YA8FVmCgAARiBwBhwUAwCJgABJk+D4cR6QCz04IcXkp+BqheR8GYW5DDLq3aZfUjgmcitqBJVELcDV5HQSHHJolXRbZAprHaoKRyo1FAUTijqi2tupc66ySPmvM79rZqpbKFRTaOTTavbNn2rHEXxa7K7qHnY4qH1pvYa2mdh0nl1VvOw47MLOOSfg6cqWVyflrV2KKV0elLXanmn8hoEBOxP/bkWq4wALJJorTKSyaNJ9VADCXGCMEDtcxA2hjAME1MBsIgCAfoCQKDyYBRyRiDEtmJbUmJASmPfYHJALGDYRGCxNmaoamDoFJFlx1PMTlqf7VokjZII3Puk8baWYyzGHpM+0nj//uQxPCCFc17Ds9xY8N2MWDJ/q15EWeyPWxNL0JRELgFrHwb11QHjltDAKJqU24f7n1YFtVffwnxMynonXVw8TMek+Xcvolz3UN18TTzzFNKPapafD89/0kL2u8RExdXUXQ26Ti+bXmluYR+UqlMRxuMl01DhzUGJGd3OTiUJgf4JUYVoT5mnnCBRg+wGeYFGAoGAsAEIKFoFIoY/MuYksQZrCqNCwZ9w0Tz6CQEC5wmBYxBwRvRE4YdBVIqgC/TpLWYc2svlY9E1o8AsICRoBJetI6yk68fEzEdhgTT5x6hmqjsYajRbZsFz55J9bbRYjU/UEMasfvdLHS63zxp8Me26mnqS1s7T1d+6/Ujri+n7tk9XbKtk3C192x251s7uZq9v99Rur99pVmZkcr6CvaWV38dJKGt31jZd5B6zuiHSDA3QFMw6odANwiDqzCpAJAwOkAxMCIADDAOwA0EACRCDbGAqgzZgtYbaYJmAtmB+hJoKHhTAXwJIwG4BtMGCAwAgAFdMwAgACRpfeGWNxpQ5WV04cpZCyBUklhuHZCT//uSxPCDV7m7Bi91CdsQsSDF/qy5yCFjqaFoxL6JN0JwtILS3m96JuGMaB9YSbEcR1Y+l8yY82b230TlH3q2z2oQyBzGSHJsWQKQkPnmCRMnoqwwi7HUPpjFirToVaChEU0BI0UYUxm6UqOW7bg72lE5UJHQkBPXREFVlBtqCQGhOsOTRSUb0hZHnbkZ44im5hzAluREoswCAYTA2SSMt4f8wIASgqGwoAiEAgAGhYumFBiYAoYKpY63TQwPGACYGDRmoDhAMWI0OF3R1COxw1rILID0O81LATCxM5ZMKbO2bIjuOpmpmUFiJ8+aWi2pIALnTaVzpMiXtq5ufj4kvp39W2+rj4ZVqTcccvpkNhkGi6rvfNTPr1y5txcezdW5nLjs3V8vhzrUtkIcGyOB6GyCYsRVZFQofJIQDBVAeMwyNCMNZBG/TCQQVowMQCrMA3ATjAQAHkwBsBtMAFC9jBDweQwnwI3CCCowC4PXMCUAKTAKgAwwDwBkMNzBey/BgEIAaDgEsSABnsgEcAA3LtkAAE60h9eINk6V2hJmGUiXFP/7ksT2AhuKDQIPsHcCnizi6e4sdTnBaZEazn91M5P5HjBBrH0u30R1iw2DKuZFYQ+nT2DC1f4Zp9Y+M+CZFp739IFr4xSBjfznhKpk4wmcY9TvKOTy5tNmpmX3IeRf7yYe9Ses9XznTmyjtdS0/Woa2RPQQDEI3I6Kf2kpmj275Up1Ktky0dIXSeQ80SvxDWi6tkmVCsOtuXlHVp2uSRLmfZhEAQmQmF2f+4WgGL3Hg3RoGYwFABQKCOYFwyphThNGDEUEYqYDhgdDemCCBUYCoBhgZgLmEaIgIgEVMyIEQeAIqCQbjwenaGeUKkTy+qJpbVvcaYybrmOZOY4/tDNJ3fLi/e7Bpbzd/8rltsV1QK/dzaX2Q7N3T/1q5uyr5uyInrSyEdUqVGdD5XuedrWTLfOtRmMoExF7eKuuHoQLnCdZaBwLP2mlNRUAKUiEP4xba+zxLT2MQMN0wSgTjAfAtMCIBAwZwNDCKEcMKMH8xITKjDoBSMIgScwTwJTBSApMEgA8yygIQgKQYAIRuW2rpRFyTZsgbG4fiMgJ9x2hRVP/+5LE+oNepgcAL7zVWqEw4UHmCjAzg4N07lZ8i4sF5uIztR0Zdxo1K4xjc5H2tDqXSNGzrObzVtgubqCb2Zp2Ih5wbMURoCDhOMivSTIkcjuTnZuLtqsiMxtSuTlCjJpOlCPMTkpCHBMZukgxJvVzJhKG1B1jIljHMmj0WtBnGoWsjuMnOiWKYeCY7eyYFAwsxODFouBOdxOww/A7zBVBmMBgCcwBQRjAiB5MbMRcwMAoDDLDSMUQAsAhtGHuA0YFIKpim4GKH2YCDAIAA8UyITNcZ601xHpcpzYEkFPEZqvGHBpKJ3M8pJW7JKXGvMbhukcOv8qtRXLLOrYjr7a7gxadanarMSwgeIJaxF3MRpo+MfSLQRATMTvU5opmpsGwqGKqEp3al1lE0i+Z6f1YqbcJJuhc9YCRm/KSM6wjLLnRDTSGX5ZxuyXhObs123Jz8SpKCZIKMDBAiDCfA8s0s4E4MHMAJzJcGDD4DTBcFh0DTo4WjDQKDIAbDYgXzARdDB0IjGwLxCHJ2KAZgqA4XAduaty0Y4u1scAgRAAAXIjB//uSxPICGdndBq88cYsmwGDJ7g25gFYoBgCTkMO4t1GCtMcKDwWUtZvpRMhrYiCaibpl5Ud1tTNMLXzA77obLUroVfVQ2yVxpPM7vMQU6QkxSytW3XC1NNX3FPVzxQxuVvmV7r4+J9amVue8bLjC7Cpiy0VBME0Dqc30u+HrqY8zsRgmURMC8LExxofD6GPpMT4KgwZQMTA0AkCAVwuB8YwpLxh6grmAGJIYygGoiEsMJIB4BBHmBWF+FxDh0A9B8aBVFgHW/ksNtngiBGTTc/YFEfHxi0OZoUUx6Xj1GytW3cM1gXuOwHyukD/QLzvp7kK6+bTdvpcw0cWYJXK/A+4kLIX3hVqdIiKUOZRVBBjcgYcQasIMhWgk9JexIkcZ1I/GvxCnG5AuYLfVoymWLJRZkfaEEvKEnfqvlctxB5LwOMJKeHJOGuv7ic8wtBgTDr54NY1k8wmRMDAmBlMBMDwDAKAQHw1I50wsJUxfNszeE8ylNI0CBUSHwwIQg9qAMxWAIGAoxIVAFRqDVK5iUwFTQ5Jaz0P1bjMazoIQ9LHqP//7ksTsAxchlwYP9QPLI7QgyeYOoSzw7gXLsOjxsoxljKGoAQuFHDxzq6cRcsMka7jQ+s0jihjLnfDefaOX5qcQ1NNo4+B2TFTNJUVB0XB5Raq1Wu/2a7VY+h6zENbksMa7Gs6yP66o9hqRNPJvuOESO5YwbSVDInEw7Wt1rNLdcIlyeK3CySfVjHlakfI6BgXAF2YRSMSGgRhMZgxoDUYDkAZgYBiDgxMIQ6Ms0MMTjaMBZHMWAlMUSzBzmmLYPmGqcGK6PmAYCFxBoYysG1cydyZHim/DUOUU4IwQhsBgKhYk8XP7KGrQrlknA0KjRSzX4cIeqLEzddSjvffEwoiUt7ukE2ft9Xxfc9Q/99R7TdPp3RVcVtvbStX6crPLRNVVj7n+utZta5ZaSm9ujo66vndo17enZOy6TedqnGWZpSeKZbH2i/ZJfnVADAbAGwwj0aXNGfDJjBkwHEwH4AmDAGswKBkEiYaCFgaTluI4bNPSrMBHBMgA/MTgkMQw4PbwcDCSMAQTEAAoEIjGm4wNFY44UpfjMVBdINgUmxYihcP/+5LE8YNZ+gcCD3UHyu85oMX+oLmBwgB5yJ3gUckciwNoTSg9jdroYzlzd1Uwq+8B0IcLcJLysxbNpP5Q7WptHRosZa3rerdxff3E2KI7RXEXU1EJOuvNmIfDTS3HKQfKRNTumTojOlW0kPY9ndJqaG9xHZaybV2N5nHL2fcpbzKXEW0znLo/ZDBxFSMCnUM0HV2jAnELMBRiHQ9IApEAeGYIQgYPTKQujkcXzA6FxY/jCUAjDBtTG9mjA4Mw4ByIkCYRE+m0aVOSIFAoWIoLjiTwUgGExoscHklsNMDkYEIoMEEOD3ciXy2RrHUJpnYpamoVLWiIeBbdLhaUdVUltwdVmCssUQ0urmVy8L59rA52ux1RMWKwhPjWmVo5F4P5v7HPcktVLc3vakoat9WzzE+lXCzXL3SaHa7Hy00xSNBAzSZkWh1ud6k5DORlW1psNZswN8EcMJMJwzQ0hAQwaQDNMB5ANDAMABcwFCQIJgw+aswTX4yPoI2HA4wwc8zXAow8AYxuEMD8YBjgAgOIvIIXaglnLWouxao/3xEGjsDg//uSxPIDWU4DBC/1BcsqwSBF7qB5OiWhFOQRkcLC9JJxZ4gmQ4pUxPz1AyJmkqxuOeafmUPT6elhYuaobqMkZN2OdJH1ixCULisOWt1fI4zW+ZhSbqht3Q7mkWequr6SE6iuqhxkDy7S5huXPqnWbbX+5jipx5LQv73Y3WaGoQOgcOrRbmdO7V4VVWZfodRIDAiZhIAaIaL4DemDRAFxgSIAGAgGAwBkAOMA1ATjIttjOsxwRPAgDAw2LE0xAswHCcwTUIxkXUwSBwtILDkTBVCJO+sVkLkzUiuxp9JTqGne6gCjhzA1ycQgUEbPtRBRI5QoEGyl1iGwmARZkRrndSyNSnpkmOHEuCYM5QHzSm+SIoxism7PL3NbCNqf/CiPTzYuugm9rQtVlklBasZm9aQlhmZ4Q67O9IvIiJadcyC4HAkWSKRh0Ze62MJEKiAMCgRUw/rgjlMUlMLAOwwMQazAEAeEIGimBk/UJpsHJnGagdgBgwLhq+B5gYBpiiFx6GJAGHMAg6pqmlAPW3i91n0gzp39giGInm6l0VHknGSWPP/7ksTuA9k6CQIP9QXK9cEggf6M+aUFggOHAqKYgwcI1m1yo6LocHS3Uab225V2O5qbuWXYmxAqrReiFXZom0ualZRYLU/8meDVeJkaNmyXe8eixdra3Ka2rMyXSTRI0wlJe8q5tSlHSx9Q72oydzjZQ+0sYhEu1jN25GQ6NlSOiVGkDNSi6Q+p04UyqMML4SUxtakDw7R3MTUN4xYG0wlCQCAQHBcaISwZFhcYZ0ubMCWI2sFqXMExKMCV1MOUKCoPoXjQwlAWS9+H/ylQNAKHnJAjmmHB7IiuNERxo8Vig6HiYRDWD6ZGGNTQNWWtQlWku3nSL0FJhhhMmo9XnS/rSQeTPVn2lSt8wOgmJmLl46Xqod1nq61n5c6Id1yGR5pK0Vy+VbLFkmqPhtrhPXbR7hWLdTx8wyo1vMKqMMmrQ2800yF3t745FCXQVr5EU1UwKwBRMJ1BTDSsQAQwcEAKIgS0eAfzBgAwgZjaVlTGQ4TGR2zIAKzD90DEMIDAwIyJIRtUTD4Ai5DpJUvdI5XY90XWiWcTYRkcRTBBEEffQxH/+5LE8INZkfUCL3UHywq+YEHuoHlOEccgnGB+bcysQKJQghqiFhrneDGlJeNG55ITOXHPEFHohyJBXQ65ZoJxrmVCM7DYWjotutFX1OJpLjepmRlHt1krbTbzU7vav/HcJXb3UTo4we42FRR9pfw3Pbq73d8PNXY+2kyVikqRtDBl08WiWNgUGAMHkY1tV58HptGJuGaYLwLBgSgVg4DQwOAETIuEoMPIQwLQkwCcjBbiEiyYxHhBVDQkFMKBIsoGE4oFzFKZj1umS8hqrcg65PWo9DNgkYjT24Ox0Yzhxhz3xiYZoo6TH5TzT2fOt/25fMpjWhn3I+9WM2TDtZaWZa8qWjLOGbjXWfbi5PI9olk2aNuJ7zZdd7zUdnas9+nLY1NlfTdQaikcK05LLlJWzcnWZk7blLqlbGOznZhniqV7Y9U36lE7shGPJTHH7aGmlXIwlRGjEOqfN1BJIwwA3THJIMPCUwaFCYuHP58VtkxgaAcawEegclDEh3MSpg/GHQcPxUBlq0foJCcGx7g4WCsg8wRLGMScKNQ+JTp4MOGC//uSxO8D2IYDAg/1BcsqQSAB7hkw70PgajDCVHAygzS2GOdmTdKqXI9xR9FGGwt414Z3q+XSl3mVGL6DtnTUbmTyZUE9VBAxyIeTPRKtJFpr7XgcsERvQ1Fteb+kPIYtkHpD8UtcElEGqrVuhBfCDJ4WmZomHUqJeitUNkfApVMwCMcHmBXgSBhGgjmaE8DMGDJAHZgPoBAUAOph8OA4Jmf26agCpllZnNwaYNZZooOmJRMYCWZx9kGIwSXLFhCRACF3IndrtClUbq0qA0MEgWPIhxNNls1PDjXIZphpv2Gh9Z6KSqvNIlM5tRa8heShsyNldTdnKtzNZlFncwxSqunxxlQ0K11NEQ4osVdVD2k3RaURdD2moXihhekbprm3MdW0j3GmIXcFVw0p15bCajxiaypCMUXNXeRV0OpFdDBlsNG+PTlD5qI9ljBJCdMfh/Q/4jtTFqCgMG0EUwIAEjAYDMlm0z0FxEBzOS4OqioxM5TOpPMRA8wMfz2xuL8I8BwEQGy5/aeRSxvIKzu5sJkGAWuWF/mp06GXe0pWJmWeKP/7ksTuA9fF8QIPcQOLGr9gQf4gubY3LeTDzkmop2pT5zLnkCwjTWMztamZPs3bTtt+mXMbKd3uwyX1HNrDk/V4htV58fqekW687oGIdakGuJyUbh5aXQ8pTRu52k58Wl5h92SMT29HJcpsCfB+F2W573OZGkaQxZNcLkty7vWfuVR+4pswehKTBrt6MfVQMwQw9DB4ZTA0MBAE5gGDxncvQgF0xYkgyLEYWOU0hBgMA4wsKY0yIkDBoXACASRrdyNu3F7QCQBTRGHQPHWIJggjBWlQILvPctDhBcWrHFHk2xF2w2iYNqxlDeKvkvmAhRNJLUZcIPVkNoqEHQnFOepkjCEayni9HsbT5O8UVVuLFUJpdkEa80tstEKlLlR1jJZmYumIyDGhGe7qyGJkcS5aNKSVBnC000LtFqNfIVFhkV3RJcelnHj4gfElVQyrS6Q6ajC+DVMiNyI/5S2TGJCIMIICUwSwCjAeAODAKj6qzCq0Nv+44YZjCM4A1GMOCEwqxDg5TBoAdMOAaI0y+nK0cgmllNvOvneisipynE2cKKP/+5LE8gPY4gcAD3DFyzVBYAHuoHism65KLBHX6mLTdzH5ZbvHxUKMLbl+yVbB6NI6tpeIyLbtH/d5IXEIiyVUVNe7282jKK1JbPVOR9ItdmO7AWFz5QvXY+TjnO7mpwfUQbUCWhN2q2x/WUaxrkob4QhmZaT9qkxe5Dp6YgcyyJmxUOUaY2xNlYdqNVTkdO7IQYLgGhjpoynzWREYpoJJmIVGKwiYWFxgUXnRC6Y1aZgN8nkAUYFogckhYYmKzKc7Iic6c6zWcU5ISFAenF0jK0CkBzLLWzb4pPS5SmqV9ureoXl3zt9GdsmsW900NWKa4jXr9fr3M23vMytatc/X3f7Kzf8TQS3zvjLrKKpm7Zp5v1HzTmZfr4nj4+5S2h0D79zrzh5e3Rm9vL85218ik3WgWu3h7/lkVeI1CrQZ/z11fRuNzD+RgsUQDBDD+MGulE1LUkDBNDLBAKxVAhBIFRgYAbGQbEGQwfGXNFmdwamAbeGQwrGD4DChUmSwxAYAWdFAEFAC7mqeTcciHZrtyPTX4z1laFVmnwYtRuyfXJ0S//uSxO4D2XYNAA9wx8LgQCBB7hhxUTQVY0ECDUxVhd2v0zszmtSFQXMEEej93Tm8dNaDy9uQPMPzO23r6z7eav6blxl7twdXfWW9kNaFU87S4Q0x6IU8YhyyC+ppLNpGGa1JMQL6yp7tMYjAN99Eo6G2y8WTZy4MuiKfncs0KQinl2+cy4K8tDJJAYR4Yxi7OfnWsX8YhgQ5gmgbGAwAGBgHgIBKY7xaYhoMZGSaZ2gqF0EM2gTTYGgwNKgVBwcJyNaeuYkMQhdq7P7v08/K90USqfblHLJnpWN7CURRDoL90XCqIs8O/iUsfWnUP05qSk0Xfo5uZNRno4uiDL3u6W89M+Xmm18x65ZaR5xaT/VVLZubM3Wey8yXMNThE8+vvvcF+XtWNLE8iWbchpfEq9PSFflM3Qghu47WhBvwzTHZH1pT6j2hsdu9rzLxVej9GAADCDAGMg4cY/9hGTF6AgARzgYVDA8H1FTRqjjIlNRpeDcsDzCcEAVNhEQZhGWAhHdTCGCIClXSaSS6tKhcFRrQOiyG3FRMQMnOMDwOQkEER//7ksTyg1mN9QAvdMfLGsGgSe6Y+BQNMH3byPi2Y9SBmGO7isfm9xaFHMHTwNo9XZXdqSi0+BHd2abLqaKd5mJepJWB8nNezowxhAQxLdBU6BjNpaTU2cPZ0MYWQ0qZge8a3xOMkRqQ8eZkvdZjj0pjLnVlaTVuTlWSbQbN2y0PR8UGw8dHoVElIrOxgCBkmHlGEcUB9phUBZGA2CCBAGhUAswFgPTIRETC4hRivyHbwUAH2GX0FEgwCDRMrBgjLrwS+0zOwxG8JPJLPZ2nmcoGeek5Av/T9NHl4lrHKk4pkAJRwUHQxmkeqNxJqPQ3mPPviP8jDTkkdULxmlRpayveT9bXIY+poOrZfZvXc/WS/udzvZBdGc2EC4my7vddaaXnLgq90xVJYibu1WIGrcvbJxqrto+XmhlwUR153NTSahpaGdi7bKUQYmnOFeeVT9UZBqZRbyL4DCKDpMS+K44hTrzDXCkMDoD8wJQGCyJg+gOmRwM6EAMGA+WcIQQCDhDxUKFxjNaY7GIT2nhwgiRJ7k7n2G4Yu2dTFepOwmlNKAj/+5LE74NZAfEAT3UDyy7BIAXuGTHyiqNMQLfMJhsJkTKTo61H5YGDHhKLkDm3BT/HrsuivdI3U4yfdE9jUdu3s/W2tmogs3724RcF65TW97NlHQlGV8VMWaye4cnyrQ2vrSo6KiT8vc6BK5nlfz9hnVNujuUxxHCbQhqSbP2q8qNSXTVa/uWS3M3UTT2Nhrfc0CC6NEMHQEUxqx6DzhB7MS0AYmZAcSjAABMLkg7L1jBAzNH4YPAoVQ4jEoMAJlIanUA8PDheDSHBlQEQSxE42ZJJdVzEmRG4ZRemyQOAf6SO7iEHPqsx91Npeqz4ZscvamtqrxfqLX1FzM69Y/f0t11iVsS/17jPn2a2N82fm+pT12i9+POXnw3N9P7XdyVSLtVtbpot5qb2SFs1nRkSnm/05l67RWsVc54RrHfHnZ/9vBB38VeFIFkqKkAMBII4xQ27TqjMoMOcH8wNAMDAJARMAYDAwEASyr/zH6gMNLQ50CjBACAzDCgqAh6NNHcFBRYg0CkY5ZSXc60ns2eTc5T2exDwIgPIlkEAiBbxNGof//uSxOwDWV4DAC9sy0rZwCBF7hhx7qMaBURJ7N6eW5BdQz5rZ73zZUzl1+gkamz2TcD4O6sWx64dt6WJtOMUddwHra2fT5Eruv9VkmM2HvV7hVS+bL+YPsuDO960JElF9mmeYRrM6+zhj6ZAr7SEI3ux4MRLStzGN3HnHzJZ+x1kU+zbDQcsJlGgwZw2jCkiHNGQ6wwbgqTCo+AghEI6MCjc4QpDHRXM/vMPXBg8NGMQEYLIJgU6HESCJAZqqV6vqJihGSiRYVLCay4s48WdxFkxTAgkaJzBMHrCAwmFxHE83AmACCKQ5G7ZTuK11cOxHlChZj7Io5ldT0ujFqVvg+EoUPbi4NIlqEpQvN3CsQU5j41as63PF9BwwlpEViySWeZQ0+7g10ezsmiIUecw2xcu1sa9GowvXZBsDXRZshj4XdTGc8xz7MuEGUp6qLpTdbtW0Lrj6jCHB+Ma5D08yBljEwBDMrhIxMBzDIWMXDYxG7DNKSMO2018JR5HgoghQaGK0OchJwOBaY6MLBJnCYkfQwDHESiHk4BfYujsKaGLm//7ksTxg1kyAwAvcMfLN0EgCe4gcKM7MUmRuYc/oZlvhjy+6rqdCU3JSkhsJ57mNnXLgxNlS9tuViG0a/yrOQ3aK13Re9nU9qeVjbGbBqFRqKN+FnTzNgwyZyo+41XF0dTttEvOu3Leje/Dw0bHgosnESMjvP1hG1q3dXOsvF8Snm2ouKNlkEi7LDA3BRMWxOg7liSzEEBWMEMAswEAAjBoCHgsaV0Zj4UmKOaYHCZgQdGBQWISeYeUJvpCA4SxASBiEM/OyLDk5DV/t/MWQuSQolR4pCDCRJkKCAZ7RQNMV+cZr7b3RXfCLJIblLfE7UtfvDoa2/o5OEbKHNNeUjYydamR8oTV0r3cbTtaKO3NF2+5tPdXR/dbVhqe0kkVV1j4ou8q+UzzqOUvHKjwmXLtdpblCEpnmPFR2tfr1aMNi0lMF9oGuxU+6VDLfZQojs8wDBADBMAN+wxGjdRGEwDAOyUBYZCI8ADeFoJSoFqqJXcwAZhEAgAODBQ8OjHsDCRGwrAa934n61JyHq35440JQdeFyooyMCLsjyIlBOEV7l7/+5LE7ANX7f8AD3DDyx5BYAXuGLnCNkyfTqYt6xEqur4ZmWVM1S8k3W0jeRiFW6KKUKNXrt3h0l68TTfbjV6ghjeKvGUYvWPRVh+qerrCj33cLObauHwVarx3z+Ny5IIuVlHES3SMWjrU+9NaOc8yK1DSyl+DrwCMg/ZPs/3emf7RpZTImpsAEAA3JbCiSjBgIzGt2D58szEcEAMCKPyE0MAww3BkwRAMBBCGEEDAmb0YAkdBgxHA2Hoit9e1L8gwgVXWgoQzYBxyARwYRWRKFWzR96ZxYSUY6Za1C/AxVnvbec2V/7eb7OZTHqKPMgysxqh+ho2bU9HZjAUTU778ZiRUVVtFuXNrddfWTd0iPQMc+paGgPlM0TiUGJKOme2cnRz//DcW+lFr+IbMGmnS9nT69RntpqVgDBsAWMfE5k/Mx0jFjA9M3AoDHcw8DDE4COfbc2oUBHmDQYSC6cM3BIweNDCprOymwwKAUTxIGqWb7a8p0wlpZPbe4o9/EBEIlWHJJIIjYlYg3JnVEkcsw8glC1vbeS1SZlPUT1yuYbnB//uSxO8AGGYJAC9wxcLBtGI11JokV8qtE4pcxpYmmguoxQolnnIsU0yRQhDYZb4FlMRTvfJyeL3iaOSauLyikfZOSScRNqoU5QpGjnrEZPNJobabbmoafPFXXOCJicqepVTjrbLD5YpSNjIHVEyp0+9bUkjs2mGGLk3rDUlEdrRijqUGbTIrXgxAwHQujCBf3NWk4YwWQnTBALjAEDRECRg2BRljMRk2EhhGqBiUEQkCgcohKD5gQOZkMDScslVpRZl4GSIOBS4ZBFakYRDTBvP1LVEoWEEKrtWUhDrMoqi6vaREmK8+6KrGdZm0xkGFU8SVlQU55yaLmyaxmGMyomtEio7X4OoEKMRRWe826YKOVCRCkyjOecyBbxBpT6iSLFcti7JaRjqu6T08jCsS9JFaCfkH8wTVLRBIto92RIN/vlBPwQe9MYFdAatOk7xoSEndkOSSbTBpCeMQpg031igjC8BzMXiwwYFwKEBEJzK+1MDDUxqDTPACMVl0BR0wmCAALRLYJiOA+0N0szen7oTsQuVczZiB2hkDqFqLD5h8wP/7ksT7g1vaDPwvcSODNEEfwe6YcftZk9ZoeWtWoy2GEIaPrnL5VhaTB6qMq6FZHoK1yq5wvD7sQbLl5TLmyPhepHKPsxjTCeznhXLTsmbGpJRqrNmmpCtFVOl1FnSlJ/Ynt+pyTVILMzizrHc+bEIetOULUMd9UNjNPmKspB3RNFxZjJLHyc0IZUhg0gOGNABMeVwNJQSaDlkLEkHBcLiQ4kVDIQzMqzEysBTJcFMMC1uYoTiAtsqfhLNqU6RFmSUvLJuFc2XSky25DHNe2lWsJG6buDcLlqNys0t2basYvmn4XKSHMSu2oWsGydbXIVY2ujyoI6UkpKU1k0tRtv1+S07SPJyulJPTm1UdzYd8EvbTVwThVRnTF1XW8Za0fXjLGrbSpZJJWaRxB+1eVs/FO7e90Ow1qjrtCkjl6tC9nJp5OexSVcstCOFYpOzF4daHjivRsCAJQeTC+XGNsYpcwhAaDEIpAAIBIVMKB85CyjBJgM2KMWYYWiYQp2eg4JgazEQHbnFYhmCHAM0yhyb27sjz1a0NKwhJTs2nkyc/cn7/+5LE7APYHgcAD3EDyyxAn8HuJHFirWMtetqSBnOpZqovLpZbnTbNtf3sl/NzUFFuRXJ3jEvCTQZqBHmlmwkazkk9m0ZuNbbg7EYpklzWUlWHnNp7e26Ksc9p7pt5MzkDy9Sd9YrpmySrD/p5SEvWNKOYd/vtDXM1yE1rYZj26AunIp5iJaQkwYgtTDJcQNbswEwiQgjEw1MBhACA8w2IzM1vASzMRCgeqRlBXg69iILEBbABKaS46rGO5+tJCGwLJ06FDkYB5Q3dX199cgl6Nv/SaGhar/a+QJ6xtIqKi0DILOhLKAlw1tlUxz+q+oQCw5Z96tz3lApGV1FtWOkgyGmSgTyTckp1Ock8JesPwK1C3UUS6tPjSnNVGWozUDzznwpy0DEFbb2mEBrrGo9JiUqYGsoxvokt3wlXk5CgYRp2IOx2wTVaDpwFlkS0VvUQDBsBNMXsno7cQzTENAcMFIAMDAfGCAOl0aepgiSZjVmByqMIHY2OClmDgOIuwjCtCmfG1XpN00GRerbslJn01Zadtj3pT6iXdF1YJo42iiKi//uSxOyDV9oFAC9ww4sewZ/B7hhwdA0dacbOImUPhNPazpvSCd50tZgPwo3XdRmbUWqcKPJ5pzQRpMsfIgtbhWESsir8VSjLxBDYkhcFtQlE1XEmTfExO/mynzy0ni/OonkSGJaaiY7dFVJUdSyKLWa7Xi+6dtolWemPh9MhWarLXjFDiAjWSD3KmbMBYFwxE1CzkJJMMMEFkxUDjB4JQGFUCGpamYLWQJFxEZzGEMNKgwuOVS4YhN6g0gKAG0Kzag6DKysU8IMdc0zvUY6QGaeXqY5ngwiSLenxGqbkrIn6RSLbZzpkkpR2HHLJU1DsOL5hyOQdmJFbEQ0qtEt2g1F+QXjFXZtzZ6ypNW56F3jwfJTPXYgQMQbHY0nq7otkOiTAopKO0nag6xDP9ezITebZWi3vWc8wtinghZq0eWtR1UXfznIIL1HEyaJT2zou5CEwDBFCmMFJs0yNi7jAwCDEIuFAik8AgOZ+CBiFfjgNMJgYwDFgsIAQDQKAjbYMGg+yttYIrm46sVJYZzc5yW3GWNxfHkuCOYnSksKAXYYxfP/7ksTvg1kSCP4vcMXLGUGfwe4YcEJOlFVUhk5q4SxtONtpxyaW5N8zircF15vrJoE8Ta1IXlN2PVdVPlvkqhk3JnN2Url2GmkEffkeyOT2TtnC155eKN2wkul4tTnK5zvVjLbiZW54pWMpW32Gl1e0pGCNKPO+SCSq8WK20FN2lksP3FafmiYlGa9RnqWXB8U4mpQxlmRgzg1GKIe6c3wvhhzAgmjggKNUBwkagRsN2SguwAoaMnqAF8swEJKZooMBoE2GoWlKWkJI2aIrMY3o6fRac1I9BqPJW1GFHb7StMnN1YPCbGbDyk7rpHGSfdNPImg59QRyG1/KD0RktlFkCaMUeQuanNerMmXz27+BhRo5gdviMDZkpm8HK4x4hgfFkcZMobuyydGmQWYRs3EeG3NvW3wQUh9NA72XLewiH8aSsvfkzKSzZSoeYcfKT6cfpSNKwqpmFTAnAhMQIu44WhYTC0AmMpCwggSjIQY0dEPBlDNLYygQMLNQWMIDzEAI6gVT4fSBof1qdZVHzpaq6eeXu8lF1fcpNr9PJ6K8tyr/+5DE7oNaPgz+L3EjgwXAn8HtmHHZyZeF3LXO7hetGa24nn1sq9282uafi+01tx3x7Y29bGncQydjFQ0QSy+soutye4vlE6Qk41k80nTckWfmTr3EKyTFeXpcv2zWlFi87VUw0sw4t+Rm7FMyNS24YjGkaWVia35kWUXp8N62ulOYFgVJgNOIGUUYuYBgQRIBWOADMQMAUAAADWmDUIGFeIB3oruk5IDhAVYDT0VSqyt9i1LQ0tFSY59zncJVuk1qZu0EkpK26gwxHD/DoaR1CMkpK08qEjJ9s7sJndIQdZRSZM6xpHgaa0mktZxEREakWooZ0jAGRZl4W/KTQcmm7z1IueP9hOHPGSeSC6DEd3lnUopP7CelAvNkL9QRYUHCyhgEHuNMMSOJJVB8v4k6ciCxYIfYGfRGI6SbYWYyW8yGTugzy92QURJokYvopGv0CcpuMFoHkxA0pjfBHjMLcEYxgIzA4CThMFhIzR3jApiMhlEBXkwOxRAEw4FuWHXpCNrcM0Fp8vrWYgMiHLK0eaBCT1UDIlkWwy1vssNSXhj/+5LE6oPWpgcAD2zDi0tBn4HtmThSO4hKlGc42JotAHxyqc5B/CdqJY5kVDa1HyyNIusD7qW6iylFsSUTOqIT3RcsWc1JFUYsUdWjiCd5Gm1T7MX81rpZSElPDJdLCRE9VwR07dc4kjuY6HRiQKGtKc8GuRgOB9l0fjnF05sVaG84hiY/0oLa0C4W+Vrl6QhMDIYgYqpwfhZGFqAKVgVEwB6tKYphXifmCuAaYY9mlBYpCgKjMGAgSWiE0a3F2OPlTUVSn/lvCkz7b1Xt2qtPSZSvUZiaCB88kVy74owkgbh/NJFOYWa8aUUg+IVsvpXS8TD25KvJ9WGz7tSju9zpaKepMOn50att8KRfD1lI08qkq5uUUi4KBTCpXzfeMVN7uRR7u0UkVsvaEK2dVkGXr8tmhpPPqsc5izbdJi/B07rhR3swofGIrOo7EnP0ueRxqknw+gAkAYAIORg4qqmkaS0YJoL5hQ0OhagCXx9TgbQCmBWIJJTChkeugCFpMEbynw/lalmEEAP9KC1T4ikfM0meXbBRAlbizCYWUZF70ZJ1//uSxO0DWNYM/g9ww4MXwSAJ7Zk5+RaicQz66LczUCFhEQmjZpxi1oakHMJW5Mg4fGMQSzvlI+USjUTM3O048xElktl9ayRdxU5lQo7rO10DUILuH6DZlhXQX6hBimSZVGrLOd8XMFPoEekb15sEspzKe8hboTUJTGp8+Do9Ec3xqDJYzpeIW1Jglg+GFwn+axhChg/AsmQhwKEUIzDAM9tsNdMjDZM3EDACELWwKFBgyCx20iypy1KiYDUIFjdslJtxaSD/1OFlojyzkcLQXG7ETTFaShNpY0PSTO/WvETqdNkizGVll9AqcEEzGTgKs/lQbybXZhmUusRcy/kNyW9j8k/4XCKGxtZsHTdHyt37PHst0qeNF7Oc98gjrEUTFOapy1Y6c6+7wJbf9ogGIOI0uF7M0gcY4QBSYfyaGcs3U5L9EiGsXSZWIjBRAiMUQOM6AABgEOKPP4YWo1hACddmmXEpjUOceBmFPgOihUHJgMNlkB8NwdOVShR9FOFxPBZIkmCe6HJkXtG7k0ooswrBBxIzziyaIi6klCKPLD4BpP/7ksTtAlgeBv6vbMODB8Ffwe2YcMmtEKQuK3ludCI1IUB4T1PseGXAs04NLYBHpkjSB8JC6QyjEEGQpeKYwkk0nwekx5nF8D3ZOAliufBMugyQ00KRJ3Zn0gYo84iYCXuEU168FZVqJnq8k0+PwCll8wLOQDwLbkZQIPRgs80FMLdMuJ5xxdZZc0QBZQgGgvmGEnQbYRGphEAoGQjpggQFw0ZBDEcw00mM+WBr6AjgPBQECCqdmWIUMwMt1zb9yBkTvj9YFNyHTKh3nQnDCBDQGcjwhKaiLdiXZzAKxWG7EXUqHKgFKUmh2P9ZiC6xZqZKM662z4oJv4wMf+MrPSAfmDGp6wiRkMhjEh8wg9eRkU6QXdshAHv1uoULB6BEUThX/Ai3Pp02OKMqKTMa9sDyic6mXYEim7IjRZA4cooSahrryRikgY5WgSSGfmowa0J0YTw8D6mqIAwNAdzBrT8MzEh0wQwWDDB0CgAiA0djFRsxcdMSpDPQgLHwGKAaAlyDdg9SAIBpdOaGu+BhWGpVI5TOoYswowmvhGYySA8JtjH/+5LE8gPaAgz8D2zDgyVBn4HtmHDVI1WYn537jzdz6DaatWSbEI5rCyUy7fQronSh6cjS90yiV8b6b5yVhckUpJ7k14xxHtyuK8cWRpM25NbsbmJFb82stVBUUkoX1vSKNNS9MRZQ6ku2/MV8o2QxMq9lHcIbqdbUWDWTX07lRTxuEZ5lNr2ytBWSPK1xhBsDTaSwgwOALzDXHiNssKUwlwEAxFGhZLEwkBMLSzJiwwS4CEwQHQOGVmA0KMJG366+c9etSsN7viyV1bNMFqw849YKgo6j93HdDO8CPurNejtM6zW+TgHeUxyoVNOfklSXJKV9RBGHUmJxlnu2wjVYxKotzfxyZtSxZT1FEET6OiYVmmJszsjs5VEKVb5SLGsxE+S36eaYV2ytJvJZWG0XdEtyt1TMrdfJuUayyk4gDMsq54kqNrSiqxNGIEZSMA4CwwxTJTahFuMIkCsx4EDg9SC0jWNIBERm7sHghg5oaAAIHITTPwyDwsMEGkSjHwkVEGoYqMcupNYovs2mlmYdS7wijKNP3USvSoZYbbcw5BV1//uSxOuD2TIE/i9tI1rlPmAB7ZhxSOxsNhxle2PIGTRzu5UylhRN9OnN5jmEEGqfpyVmHSQgbbpGT5OIOkcrsZrj2XKdlyTnUTdPaEhVRdP3enlV2SlWpQmlqikW1VFT6+UQd9KJHvhjJ0p0SLoFwfA0kHj0bmFHEdw1cPF1SCRISW6VUwREowG5sxIYgEByKgQn6vJXBiOLJKF5guN40XINAYSGFvRwAQcHEhSc58U5EaSFnJtWl5OrrOWWITLXmiieuUCxcpFk4HkZIfzfBR6OnA6wCpMoWTd7k5vZ+oDLTliVQYRnXJrovJJF60avGei8wsI9/suYjGHwc7OSmT4kpGIJUWi8NAepotTnGIviSR1JPZ6cLJlUcdKWRRiUT294UzY9Metn7wVc7KEMzlPMMfhptb1u2pPtbtzlbc9A4pQwWwZjEUPnOGQYgwxAPzHYMAwRL1A4GmhC6ZiIRjWomJBOYNEI0rR4DAQIGFALgJDT23MugYi0OSpiCDKolNze3XQKsRWZipgoURmFiKRqCiJ5vF4QkyRsWmMDjDovnP/7ksTwghf6Cv4PbMNLCUFgZdSZ8fv5Zk6jrt/XcjLkaOF4btlsgkownpFaU1kEi8KMo2g8kIWlItvkLz3FmcWTWn5p8l7M1WEQuoZcusyyq9c667JjM2oCch80aU2j+PLihjoV0S7pMF14UoI0apO2fmRVpI+BEREtsUyUYyo+bHOFYTkkRkDV6gcv9moSpmrs5khgPgDmGgPQbaAc5hHAJApDEgQAgKUBisETQZpUebOHglXDlFIVEwHC8PWLsPbTnDVxGdKpQyENw4hfVXfYlxCXJ8soqUMneTwqKQazZuDDDyykNgs8qINPTe8lD88GvaVRTwm7QISM9sMTpzNIWDyRDJGKQIlJrLg5bkeklpZSsRKsegkqZeoouuT1ZVzSEXY48ynwvoFNFAVNXKuZLnJUxSUKtzL+V8svJYpKJw4y9pR+0HCzT8Pfdlwv6ykpempQAwEEkwa6o38ZcwODoRgWjoSACl6YSjiFA1MDBUEiKMAhPgVlypw4Wo3NBTCc0uxHYwQTTQx0hZQHWnPHm1hOdIlzqzC6rRcwYgjTQrP/+5LE9gPbvgr6D3EjSvrAn8HtmHELtKXZA01pxhYIKqIYU6aKBmBaaOWeND/Eu6eJFWakia8PqE415WGzLcx0oxuzGx78+fOMrDRCONMa9O7m810VZRWy1F87Nl+t+ptG1h0MgY2yUxweTCiR+Y1/Mlmk1Htkm+04xzpO8lVXZSsgtUkMWRMD4GEwuT6DWpGZMH8DwxwJBQEglEg405qMgNjP7geNjCDsSI2uCgiZAFRWYsJZ2MTk0gYzGW/NVaJRdd6K3JM3F+zWhKMUkTFLsEVO36gi9kPSerCjrk1EeIdcsqVRMJOWlkdT1k0eQqyTX7a6cmxHGLSS9ocFGa1BNLWVS7yeBxQ+iyzy8JYu2xCKi80KpZ9yXhkLwumtFtFUayTZa4aeYYZnJaNRXIx2rbUXkxTEceupDwXWvCI4pHpCNMgtiPxKGI4IVmjJRRphWSFiEUcnxK9ykDADATTDLCHNpMFQIEXHnKB6RIcDO+lC44wQYvUGBRZteReATmHCAfRo9i63ZNp0IR1L7qrUYw7SJ2JvXNI48iNoJIxHqIrR//uSxO4DGBH5AE6kz8tSQZ+B7aRoHs9/mvibWIJ9OCSjB+snm6735QbvJpclOzucYnVr15KuzCHi133L41a9IU4wUyUamnyq3uooE5ooYr4wVam1JVZ0tQViOpQTMec0Xx3rGY3FvVySoUg2UIrlkF2tfO3XW61Qai+Tdd8HtyXYb2HnO5XaUczr1sXFxlFQTDBpQJNC0cYwRQQTCgov+xQiADijMzAhBpYmkCCIOFmsEoIZaBy5KRqm14qpm11FspjGGEqXvzIh2BQ6qJtdQLjDkkCkjqJRGR69JGwheWFZweQSTYPk09mxkcZNyVQrWo5aQgSiu1LE0jNt7NqoYixQhbJcKqRbg03FvGWknIDeQ7D5G4n8rKY6TUlMOViR6KE2pzO+4Ub8YJpoKbxFVzJ2sqlClJzjCLC80a67LkC7R+bcm3tIWpRx+vZadJiM04tTeT4kliyxdSDUWJI55EVIajCcUDGbkz1ZejEINzFii4K0kqDv4gaBMngKzgqyZgymCzEgoHvQmxhaEEdkwrecimWGTZtdtja64dlELJlrVv/7ksTqA1fqBv4vaSNLVEGfie2kaDVc6mDVPsy1l1dNjJzGUezQh9iGzKPchvVkHJXHKKRfnr0piB0m3dJKur0rWLbTKqTkgLCRiKZKs4tLMkyv3Ob2cxC7SNzBeWyEAzky8NtVJV3CZSMs/TDDVWuEEaXeZacvaDsWxMYZJZpgElUtEWigXZi8cpM4SWlpgfgRGH0KOb6gKRhXABhFYeKlohGBC/s1SQ1og7QoBCiZ4hEk6UOKBLR1t1NLxT2acsVMtwMnf+lFzpNGO1IiQ0hNKrkz1I5GimMPORQEH1VGzSSLIM4rGczdPehM4apleDqlLe2giQm3sGHvLNoKREy+683Sqilu3YtsmUUBBUlRALSWQxSqToAgTCSqljMI0nPt6abp9xGUSFmoC1qbqNowjXQMTe8shuCFBaTT4xeii+JgnjRlaVqNybcoUo0lNFSBxMKmTCDESOc9jkIHkElEQqoKg+YzTMfyIeYiA0CiaYDT16kBohABWWGYTFrxZQtV9EDbME/p/lGPUHrU7kXg+WQE47X0ZMh9cqVHfnR+h7j/+5LE5gPXFgj+DujDg07BX0HtJGmgOZqmqS8dJyIsvoQh+T6pM0vTi8q9IaSxONaEcXjzRmMxc6sE7VOzBhmKh/sJv0TUZSmjtdLcbFhuV8n6oo69xHpbqONMtGNRtDrF0tLJs79VE5UpUJucRpksJdzVltkY2Ia+MzJTuvmxTQqNOecwgFcw3/w3TbEwhEAEB6NxUAx0GM4FQAIhaJUVES6OAKumBDRHPq1iHVElpoLnKpLRZZZbYjro9VlAuhRTRpIycQMqvjFS0ktlG4KMI11IwlIiuqVqloP1plUq3KMNNivqZKMLQrU9CSxOkFJpShhl9WgUi2QVpdzWLLrktJPsvA6IizmI1F/tjWENJRkhucp6XtKbzrS2UnCEKQNtJJwhEwrzmrJyQF02qlztosittWfpyCS8pqykcXifVySCquCkJJMtxUalvxmaN88AAAhkAAwMALzC7IINe8L0wgQEgM1Dgxd1Dw5roBBjIUwj2FppEzSYql9KfmECHWVVMuCCUlF3QnR+5vXgobDwqEINKhfH5476E5Unm2ojfLUa//uSxOYD1cIJAA7ow0svwV+B3aRppGnrFZFiCO6UZUludaSaJnzZTchkhQ3R/NUW1C9DBRPJ4cWVTY6R5pVhA2inWIM6NOaZI5Oz7k8W88kyw2qrGKt3uaTEGPTYjsklNYNs6dvFDTOzRHXlJm4SgRdJlaC8lWLj21FtzUshS6V1BAwg5ATorlLMnrCznNJxOY3VYthDAGAKMIkec0zQ2jBfARDjiNbFSAGYLmDAhniBF+Bg0evxJghWS7Cm2lEDaUaZhD6mp8rMUjsiZheocsuhQlWdlB0EciBWNxha2wUajUZRj5/U00VxpVOW5C02lXxpnaisrGevM7B1J71kTeprI45vUuWsrx6Dvi5a6zIz6OD01ZPUWRJdtDOkl9uKSpfUo1HnIyeS59TRY12r1BTudekxii0ZQye7WpTtnJWm3kIe4h443kzFpvdFK2IXC5pI8pWB5JUAI0AAYGiYVOvMtWSLAcjIGJvtEBQBmDRIBcLwaSBhKAxgAEQ8NSjCNzG6zB8faxa1sLMMGT0Gy0y9KZAVtFOotPDQRUKyRHkAhf/7ksTvglo+DP0vaSNDCcGfxe0kaBiM6IFSwpWJnRK434449BQgIwUYqTSSOG8R0r5ZF5CiWEHOW1JDFcxoQuKIUce5M9yZnRIQiaPOKB+Pk6j0XoJx0iQeITZBr5YIXhp2nIwmMESQPBhBgqaMR0265Z8d5ij7xIh8J80k+mEzVYaGDFwieCVVo1kHwi4EsmSPQZHnVrPDMkuk0G2GCYOGLjannBSGHQFg4CmCv0tgwTE0wWCgwFE4SBQhBxA6B7xQD1t8r7R3m7zTtnf8OkLc4wxlIMBMBGJJ6nnNri0J6KpC1iC45WCAbk6Lsgs2I4DvRgoMiqClzkKY4RwaBIzhAI21Iopif9ASplRPyRlUiMQuGUGKV6Avg5RV8MHih3ZnMkscRjPhB2INeTLiGgH0Y7qQgqpLh1CHKyLVKWHiLI4OjACGgHAXmFEJIawARpg4AAD1aNDN07j0UJrxwkJlMOBVsVVTSMibWLQTSkYQ/XslF0k5zeQK7Aqw2wqgtyrjxK4s8mhMgVUWPDrBO6rim8sKmi0WGJyL3ImLqtkeGDP/+5LE64JaOgj8zqTPip1A4EXTDekELfPNyKJIek5yipmRpR52ppN1qarMpNIImk0SjCAlmrRjxWTey2/WmUiXd1C3K1WkD2yROa+LV0UIG8fJA4qorpvS8CRvYYosnjSCdIVoI6VuZWaVMI3LNQ3TOoFM97aqLsTZmqwhhVtMpm3NjNuaisegIAgkmGnWHUzNmDwcA0ajYkeiKd3oYCyMvSaAk2jSx5tCahQKHW6iwT3NknIFnKIYv7EnWsq3A/Z1pSGRxeWrr84qy10lbW589CbYw8LoTRxeaLdggEBYbI1UzkKVlD6ysmJGUmTRgjRo5Ix/NkQRXnGVzRRPYSwbtjQkSokTFWlBQoecm7GFp2g1wy2dQObaWZSaSOp3hmoHDsGU1XGTzG3c5tMJJJkDDKZo5Nszq2zYYZXnOEpr2ZaSaeTSRMS6h5owaQNmULS551ibBVizpwTZxuYwgD0xttY+LSUxHCYwIANIZ1aMwmKMECwdFj1RWMKaaqsFQ6JTZNGiBpA3NqD5XiNJJRNfGVtd49md63s28QrNnJ02mOQ2//uSxPWCGjoI/K9lI0tMwZ9B3SRotKIEDNsoWULGWov3Oi3qK+RzlFKVsvUVkvGd88gjBWlpQn2FHwNUlPFrRMkbVoXNKYulNifQuTSSYa2cGW5rS6cJanGC+stNr4TncsjtypuOlW5vb0gHG1i6qXglOEesVlGFIHK+126ivCfe3cCjaB1+K2x3okWxTLrw1dWUG5GIlAcBKYQ4ARpGgDFAWY8ZTyZynMSWAarAqlTUVErrjzRxZdI5eExaDPQzZcozY0wgmdW7hsHLI2+ESglySZailrxAzMuVoGO+leKDTiOnwUX+CUtIcgW+iU2Cae01nKggVOWmZ5k8041bGl5CeQmgZboEniyrNOUQ2Fmyt80E7r27x2cyTjPZeUy0ub7AiKREwsye0VT2o6E6/N0MUejSihG2f4oT8QuNcmtBN5ZnYh7ujg+65FIpZToETmrACQKDE+ozz9JjDUIzABFh6RDEw4MyQ0Z5hyt7iYO6pUBqUXdBBVSy7NxTQoVmECAlJ2ybrGWTEkiXWsV10FfPXy7dRmopL0krz50mfpIhhf/7ksTpg9kCCvwO4SiK6kHfwe0YaM+icMJKIyc0iYmjkyVxJJs+ZX9bU3W/LmpZtrcLruSgj1ltFfIZPQuUZZnoikzrTcljpPd05hBFlyHtLQxq46upJqNpr4/Ja5yPZNNvUpD0lFXF12OnJ1PaZTurlCWvNprOxA9cmQTSpOidODU/TLJiMYvl67k5IoqyMFQ6MPrjOMEwMJglMEJSmNDBo7CMpG4qP9ghYoPgprI+BFCJLxbkpJVeDqXPounetxXkuzspIZOR41qT0TUI6eXybKhMzzVNUpBisaZQqzmp7rYeDUYJSUkinCl1mVbuTMcjFJhhzeyjOK8YsT5MWhTDo3zLlVKIxGkUVkkmsw25aDePnOF5bCQo1eLGI9xlKR6DiKBKq3iN2ROK0rBq5yEzdKNG8J0924vunqRaaig0+xC8gVpZHBJqaFAhI21ZtOatswpIsokpMCUBYwohNTVSBaAQbokVIwtTgozYmBAmY5BGYgRYLENmckgAFAOUKDzUJiJHWPYxeD25ICfHQoiMvNlpzKs/ZldCbFGEJqUyhm7/+5LE7oNZQgz8LukjQyPBX4HcpGmghRMNRSIVwk3K4UiYbXWyC3KCPdL3RongpD0qSLWokjaXYX4ktY65i7XcoqhztxIsVbb1GO6WWhs1IU1sfStYQt6o1ixRbFJt+E6INXUNITDRITYOQJMLGCgoOJXFhqJCvK5uP2gxbcIkhHBZdHJotJkggT524LChxDSihA2myVkiu+n9toULHmSziHEICmHSmHQBGmEgCI5uJL4uGB8YBgIFxMFgAIQAdS3mTAvm+tdRBlplRrNOx4t2c4suoNS0043EX3t+DLTitJJs+h5NPSkVTqzQrCDQV0jflRJEV9WtAHkQnd4HfAUSxiZqLRnDu/ToN0OgwoY91R2NaTjqCYWNw0NRZrwagjIcUiJTHELGMkGMGcvcCJVBoHCDrCVXWA42tDB5O2yJsADvdE8SMBkwWEswZ5wzvYcwNDoKA6i2aVxiUKYcBmNrg9csiKBCGiUJFQTYPEh5QnVkWSUICU01iEmIiFLuYRpJQSIh+E5RKJuSKMzgKyhtVmKZxGiuCUBlhklQomyd7Rcj//uSxOuCWqoM+g9tI0KaQKBV0w35qJIaTaQKIBWwrFZtJZJtvWiNNAitFJPPu8TygqSsIeQn+XJY8qocER2OxEpJzSqjchlCjyDBokSPI4Il4lfWo0E+gSSPsXOa7K9qh9ijYfZxZlZyFpeLf0ZUaIT8i2psF4vVYV0kYnMRTs6ampbBp6aJckUONpSgSi6kiBBALzaS85g0DpjmzB/iSZiaBAkRVicVnggvPSFSY+FYcRCIPdwmiQcljOlVYMpRUWSVy2SBi+vT2K6bTUJVOcUTLUp9PZ3BBIV7I7WpMEJxSqfJdRc2yjTm3Oqg35XstQKksdS1CqzBeXsRkTMkGwrV4yUsqvSk9WXYyalP8SSDS8ZxMPFKKqTmbYIEU7ZvFpIsO5F0kc4NM6ofteMHroEkJjqXlNpPUOwu3FGYMrJq3Ao7FpIpLCRyGNOiynUjTcSW7potGj2KNu6JvqQVAwAGNqin95IGJIBiRBdbgKUmDxpmkEkaQx5C3RAAL60hBImNRiEVWeQSoso20YKQA5ksn79EkUTJIKxJJo1Nk8FSbP/7ksT0A9umCPgO7SNLHMGfgd0kaBNE+rN/s8qq54bUkkSJBEo5BiDEkmqyEKSr4ecDYcrllMSeTKpbk3UHLNohFvKUJH1E4Yfi1SjEkJHoWm48qCzCZMjJKapgGlEscfaaGXidqSLWtioQgm08Wb00klayB3SgoUdKayRMgZU5JRdkkxIEWIvAu2PTBwMfpDSzrmcCQoAs/mfqGCEHyAAxl4GtmslGGEjDlp7CE8a8aKH8PF1Fk0KnQ4vt/k5hndXgeRsygfMk8l5on6gI3bEzix8hBxy601Uo7BRqT0NrVrE4t3SVY9Cg7FTZlFmRK0TY2uom91qXOSs3opSlnUmrF+ssb19rZdlJAuzMwg3G2rjGbc3sUtBpHYqayqejKoFo05iakWy5uCstUvF8OGV/JZvzTYwgkgZamGq+xJ4YieSsM0ghBca7MjimpqyY8lyyqBhTJL9iGtzVEAwVCIxWec8WLww4A8HBLVc9lpG8FyjMfIrlFCISNJtoSrZ0lchvYtt3QlI6WxNeLoTR32CLn05UYnZEkRYUf0cNeoKVdiT/+5LE6ANYMgr8DujDSxtBn4XdJGgSRaojzzQIIJKJXcpeUY+kbKWpKolyRVZ+k6Z9uNPQz6bLmt62qzQVUY6gRlpLoL1KewnBOMF1kGIG1e2dd0E3lSVtEjkJTCj6JD8POLlSJBC0VprI21l27S3YodLNoUtr65HrcoX1JEiJIur1HSnLprMosd11IwlBWNfVsaOok1pwlJgKMXBqPXgzFh0JjtWht1Dl9QZa5N+TkSZt9ScFJbbMGrUUbk+OqnUNd9KSYQKRk1p8ZiGlnmTKVLNyQ2TqLrOVZUL9k1c2mCGR2fQZBO4cyhXm9m8hnWuaq7eIWNIl3z2bKxSS0U46ik7EcFWU18k3PGIZ7njMGmK3YJaTXHdZpqGRktS6rs8r9s60+Ou5qSqOPtBjZ17Mme35t+UGq6GTQ69pFySOycrIqyundrq5aaS12lG6fJHFNCvI+qoATADAOmEEQG9BzmCALJzug3eSA1wq8KzKRjJ08IuoYj7SaKoxfJ3jcyTWrkkXoWMqOZXimUUOUqykVXjRJOaorR69dVR+xR9e4KXJ//uSxOoDWRIE/C7lI0r7wJ/J3CRpObRBCz9wJWUGyxvaevSHW10bKlvZWTxqfQL3rDdqo3RxJOcjGRJqtATaRso7guQ7BUtNS7xcwJV0FzjiTmE0puQFV4Nrzehdis0LmGFZEiNRHKaCaSBuEZvyLSnZkqTLStSCb3romp9NCrCGCtBIjpEszZyMUFLndYxmHUWgbpkEy/KKYCCpiXFHo0yYVBCgrvP7SPIIQE0weF4oA4zLW7DwPrdHFV7JtZW/FNSRDSStoiPXoGFZibSUCHiyYJqLXY0GwbBUUEQWFLTmCaHHWhAZWXlSNA88kxo4zy8LOILbU6l1mvDOwmbJPZknqR89HvSXzIBiui6iqY3tesQZsWC2kBmW6VlPSNvIfobyfRY5NZE/SDlJTJ0r05jKEpApR+H4aeG72pLIcqyS0Whfc2oSo6px9PMmzMalu74hkosAIioFAqYxiwG42PEETASuN7IPMAAFHgPCgTDwHFgC2nzCwZb6vHMRQVtyi0rShFZFo/h+0/kSRhLfPSkFrazCDNRUTZ2CY6jb6NHWVP/7ksTsgBmCCvyu4SNLCT/gGcSZ+cRKjKCiZENIcc4IZ7PEhgtTZcw56Y5nECDTJomyROi7IXiZImxE2Sw2fD7SXyzixqKSMxNH1zH1FRZMmk9WgHWSw6g806Hu8sJDMKWSScqWZyaeiTyKIUaTJDkyKZJ94LjpUSIRPSQ7KO+Zy/qQsHLLvYwWUURE0dQQTtcG1cqiQAQxDPz66GMIgNYRy4AXchyTFEYiVgZyt7CDUaJCotacFXKvrJG5rihG9pqqOBmiGwomydkMhkROjo+ZI1lHo0iUVFVuYTfTimdOkjZKjiii0JSBFSyj4J0biFJGXdhB3XJoKH55RyJxIjCytYpiUUe4G5qChrO5LdZql/DB9T+NqblUjr4kTNClJLLfDLIW1aniRC450CkPPUClJRPTOghJNzXbXcpRyGr15g667zRh0kEsy++xtao/WXswLCgwekM1QOowOBdE5nLcn2BoTCYGgHwIcGhSl4EFaVU2bQqvz9lasWFetB5Coqo2NUhZNSaWbt5SPWgzxVvm20yevG2WF1qUNrYhRKsLLE3/+5LE64AYwgr8DqTPyv/BYBnEmfA1kC0/TcorYo0OrKjU2z7LC8CRJxV1NI3Tw3qEruNzpeR6DSuoYijNNIMLtGG0SSBqkS7JEk15uTUXyRthSbQErXrBY+iUKFEKBli9YMKkZrqN0joktpjBUkkqswUb0jUZOqipq4IYHpo4IBNOL+qq9U6mtNGKy6xWQ9NRdIVpIyRsMcYFgIYpG6eDB8DhtQicVr2KCUQNSpSgIRRSliSr8V2mGl31CkJG2rSDT3qJ43zyJEo6YeBeSMQOHEziziYQp6Gl4FoUzsVEKAoylSk8NGW10Dl5LSxlEzKldk1NkiWj5MXWsU0xmNI7li8MozBsowpPsLE7Kb6jtRminBDaG14oUy6o5raJllaK6O5pXBGsfVlv9tYu06oRyMSp7paotWdNAqkVxfdhsTSdQ5SMoIqe3FVpToNvuutYMMsHNdGnwvXZNa0KWoFC55h8kR00QIGEhHNrj7qHAAFkyl7MceBitQ7HKNPA9VOsaVRbekCc5jWt3vC7AoPr0VL1XmB1V0cWSufuqUhiYxOB//uSxO8DWnoK+g7hI0sSwV+F3CRoMhvg8oGVCybEAUIkKNEH8nqsYJpIGzZo+soJHZBhnWjmVytvQSlIbUQ99eGTUNoo0pJxHUrKkyaqBqDC3eFidiWKoSRNo8sLuags2WWKlFSqBjaTkrDE4NZaKcZjC0ZJPiyhjFnW9WY1WU/PWV9cxBjzjGcqeVklJt1PmqhXYQWqqyw5I4vdxWToKAEhvqRUEI7wEqmm89M12dMFDYtBG25wjVDINZZ407WZMxKRKfCjsQ08DEgQ8GJmBJDS5M0ScjZcmWdqwJHmaaTKiycPQG6RMKbycGiEXutIntqIMQYQdwqQckD10BXTBubnJOvxaje2hAsLc6YMXyEagz3VbLazmqPBiQrBRC6LZI8i7QuLmt5w/RKRv6L1L8wc4TldD0UhK/jpWiAMFgfMbW6PnyhMQwKDBLBmKqSOw6DDpceBSEuvWXvwrRSFGAobJK6FtWHgqnNJglExGOlUUAPNBQBwbgRAiMikjBBIdwPa0Q0EyJCQbGYlGGzJPQiMkSCUDNa22083EhbkzM6KCP/7ksTpAhoaBPxOsS3Kazrg5bMOOaoTsZUJSoqWUIAodD50TDQIxRkhQ23ciSdL6mtIjIYxA0ZUaMkQ2Qqtg0G3+GIRx1FVChssuH0EUZlgVEB1GWJemJ0Unj40aZTWFQXRp/qHmWZGUQmlMYC5CYVPCyrBHixQxJ6hXBsiLlR8jPMI2XIyx6cx62JWTSIVikFwtg+8UJCDCySiNBh+Tp0qIgYJ6cD3YtiDXgEkkbLxwl18Yak9cpNJdGYWkVQxBMyPqZmGlMeKSMIxQIHXqiCFED6PKAjsLRPMgWkYQjutAupIRXOQIFnFaHFSfVMhQL7xJNNAgBWvSnpFaCz3KclpdVRYNZKyiB1/HSTNJByd7llG2SRPNK7J0ZhBTJlFyJZI9a9bnnAE4Dv84SU5xJQ88cVH0KyXYThZrHKTOYk5hiHoJHikFAzIpJilwiCqOxR8cfhgeDegahWFQAVCABwpt9QBcDqOQG7jIzCwjMAA92F/oMoE7Ftb9PepJqqpPlR1KMWf4HomkZAEkKIReitKPpIxFEBlOYTqzyQ89PuciSH/+5DE+YPddgr2LukjSwBBX4HcmGlvgG6ykENUOdG3SPKGmHk+gQwiUaCRUmn7al0EpHh0UVjiRpNYM6LIHECAym2SNlgNYEmR0xgnlkPXcshRC1m3SZiVA2rymTCjkBh7iz+iCoNJZ59y8Ki0rJY1p7jmg6J/11hKZdF4mhHSHnkaASgkCwdKoM/QpIeSNjJPYs0EQ0wJBgw6ak5SKAwkAlBZ3a1IZGQKDCVAziKFAedib4VtFLKaqMT9uK6BAaBZCiRsMEJdgmmsFWGCLQ9MR0WCmlx4UjxonbIU1YkKNCdbEM5wRz9liUCkCxtx0xGEWMXRdV/QlxUXQbw5bSNrrviXXKyXFl5NQZXMQsoVNz7QPMrvtQs3cECdpfUWYgwkO4u2ULzXmojyVqtJKkZkLokojDC6E40FRLA0PNaMG2NWQoEYfZR3B15A4IZnHDp69cg3zKnuq0yrqNqBpVY22qRMkRNBJRCRGzK0NzVIKlfGJgAfSAJQJFPyaXQ4FgO08EMEwRg27uite4VblS75bdF2bryZLlqK7FNmPzI+J9r/+5LE6YNY6g78LiTPA2fBnwHdJGjMraOiT0Ky3ZtYt4L1KfN3EE9zUFFSjc5Ul7u5R+l4TVjTKHxFdoN4eTjsT3NleHlH+q7UV02zKj7aO/OSp4KPj3MYXbsnZyzN9ailty+8hRsyg6Gt2TlXhRzR3QSjoJNU3GqjGPuNcxBOLu2JCCqc05gIyFgFmFrMeIS5gYDLDvRlEAUJFgKrJokomp05Eh81iBEwy1qBulK2KhylpoiRFBMjGyATI3MgKoijxSiiwce3MwhJBDA6yZQWhJfOW1qNuB5GhbkiXRFOimntjgpVRSgsh1yNHIwouw98UaJLFYSYk0WSaVUlUiakc2LYmdcgihYrymlzmSnKak/Bshb8TyBJ4meqUVVFAlFC0Fi1QaL9OMF4rzN+mCAgSNTxRXCVY2trXxEsqm6KSCcyyKA60QIjC8mlEClrMr6fIEaxpJNcqjX2BlBAICzCdAONnkwKAlyvtKYYhxkxYEq9UCqemstTrlMgfpCUQxqbVKFooETjzYQpXFE0IWOTUEhUvEoiFABzwZhESLA4/DpI//uSxN8CVGIFAA48yItLQd9ZzCRgQQmWcqcQhQ7AVoXFmFVFmgoTxQtt1I8zOkl2k5qt2zM3ia8Ci17JAef21nXbMpW1W9VVB0MXHkjszOomUHRHkc8kicZQNNnyYSjhSnJoYdbqPZNrNsIfL6sQKYTqGzLIpIEUUno0M2miF0aVokdKDqqK7dY0hNm7NnUGpuhHWN1ha5sIV0JRAwDAAhFE08Y+uAR4VMVh6QuGkG3URBdUask5vF1u4tSrzqMrTY1zUhRfp8mDNi80g40t8bT0hx0F0juny8hLCYSKIYhpSjEk9zuhEJuz2zMtQXUHGFwKOLRL5Ai5vKSPxOGtJN4ydpJM1SCEMRnGO68dJSikq+PpkHZps+qhhkpshSkneomU98X0hxdYniSYGmc1NU05WWySVTibq7lfSduWaii5PX8t7Ojk3a33clFqACYAwAhhWl5waQBgqAKdDrwdD43FKx+SucScygp16VEb3ImCvYzX6wrWtXPvYO6wG6xqBdWxwdWSI3Dqh5xKPiApYM1R+mf9SiUxYqcN5RROEZ91iv/7ksTqghouCPxOGS8KuMGf0a4YMDjSk7yBxGtgSrI1ap35judRTdDjXFdF2upXqMJ2H1pMOnDqX+2rFXoT1Fp+uUNsoeUabvkTd7Ma46rxdLeMuqj5SYKkOzNzxIdOP8ePrHso/FeyhamtQ/PGr25YqWrWlq/0N4pq1Z8uP3EUGFrD4YPULSxu4kV0nr0Ty15fx087Auo0tPmVzqy61hURgIEQMy8YEBLtR2a6ZULWKhFGb7yZzTa45OQ7RFn9XnzJbKhOzLRJAUGL5+phPfDix9OZDUh0JiCIPrGMxs4234NQXJE3KX7NQkp4KlHUUaISTE1OEIKrLOOJQckpkmstnungwpF/qLh6KLezaZycrLlbcUl9Yi7p2+qMbr00kbOFHIoYPSQKfW39R7Jo0eXFNZE5iel3zibG4RZGZTuHi1nLc5wjeh4v46SRTNUwMCM2yzkgOgcIqSUtmn/CgQqYhcFGPRFoM23J16GI89tbtqTQisuqycNQZ1KBrSBgSRbhychRsEB9sq9rtoYnDrGWR+EJnzpKhP2wRRkPGdEo2Sr/+5LE8QJcAgr4ruGDSrTBX8HMGGkmVUKIjUQNUKmTTa3QlTS8tgyT6wbPNL4fXLY5noxaV0wGRNOIrwgRdu12yIhKXjdroulHH4RTdB+F/JsrNZCTpWVtC4VqNmDXUZsmHiZGaHzrEF5K1FZjFBk+wwiIW1Cu+R8wZxRVUgs4sdJvJgQG2F2YkTC+qMmkCM2R2w0sjeLJKDmJFIfYIoYJFY34k8GDFGAEBMXTeWaxX9beaITija2wrSzbO72ImVGmpnV1UQeIyBuem4ml3qtELJIQKhg2hWKsSXiTUugK5C5qKOqaE2q1SsE6+SDknICdqEVBQUamSSZX1tWU1IfY/VEeQRsK2cQxLEyGasWoqopqym7UktUYOTxhjTojhFqEZmJqtQQtL1bclWyMkWllzSbQDMsRNssoWqSlPESSJ7xMWJJSmavwQLlC01pzkbZqpnlUzSiAhaZTYLtEjCk4smVqcAUAZBBjZZUCnxjlBYLnucvhtHplMsGwxH3BKbnLPqmzeajRmkmjrJMiKwJe1OBdJkmtzbMsBA2j5G7UBhMo//uSxPCD2sYM+A31IYMvwd9BzCRouuRMKKN6jjyFSQqg0xJt6qHKrFW2FCLimotl5WyWtk1hgY+b9Y3wWZeqtT0EtWmrFo61az0VM3K1GIMeEJW+WsSSYjJ8y6qznsrNzjNQ6aXZoqvcZsqlttISsPORmyiu1YqKKt7BpBOOui9KKzZu7ybpQgsnso0g3DKBqSI6hQo3gBKF1TDK2OqjkMCS6XevPO2aHW6ObS09fTm0mq9zPcqs14rXB0VKOI9RowNGBZoLFcaUVXRqI7fwHJ1BEiPLT0sWRK4bVMx6m+b9tHhuJlC/Eci7cJ21OCzWo5womkVEe1RhbYzRpMlpRzoE0xxVsgP2Q706EEKlSVWBSeWnd5cAZZhcQYQ77WJzEjTgNA2g/MopCiTyZpAw0zAUuzswVOByTp5WXVMYRJVCZEitW1JbF8qzD6NSizTK1JAODCBpNJRM9mAYoaWGfJDhEJ2KRqMTSwy+lg1aSA+uMBso9ARTZTa1nTMmILPYggHESiyMKoDBqQpCg+dPk6hG1NRCRZKVTMf6TH8YQwdM9P/7ksTmA1gmBvwuaSFLC8HficSaeIpNAuommnTTazLDGmFrQrKFESJi5ELRVSajJLibE7dF5lqbDKvXRZ8meX3zJauKiSjTC5CSQJ5KptQYlOmCojUWbZKWaRRw2qcXQj7oRKYwNId0xRDyRofQoVCFSLsMRkgI9uOoGSqxGhqT+90UqTJ4ymK0Ka4qScfWg8WiuxaEkpebcg9D4E/Z3rAX/cCvhbSFkpUEYS9EqpsYGp+mKtRAPFp7WnEElrCemsBNZAkFE4BKJIUcWL0hBDNcZ8kKNNIUiEFo0IwEtGRKmGXLNqHUppkCK1NttkiRk8y4mZVigZPnXJH0fMKrJtN0nA4yjRWRk6aq1TafCclU3QOLqf0zUULZk/a0UcWl4LVKZRcpM1JxEozaGIXJGjS2rsWrA0hUIb5C0cW3EowPtpwexhPZ8gxpJa1GLx6yiGZHBqcWpr0UbRF2GInS0SgrXbmqLdGFX59B8GALXojfusydVP1i7xRTaYAnRp0pqNQPBY4c9yipIC6ezhKtSvmoE26kTI9NyipdqexYrJmbWnL/+5LE6oNZogj6LXEhCyTB30GzJfhEuzCkb7hFCVbpBsYLfILxlk2C8fKTLsRq2xJXZqJUNRPoZTgqzCNa9df/GppW5tHuQhibpJUfYnG3oV7yE17dJiDT9xYo2QbGHetTK85otmvq7UHYo+O+SB2WbFN8nphRAnrME9qCXv1VroJr4TpvrFkNlYoZKoWSSYYDL/Sy6wYGkealjCrO7Ltxx+Gz6g7eGbXi61ySbSjeNVCUrSsngRkKzZoCd6E3qap+iJwjgT2rIdZQJj2VQS6ZOJyY7xgGEIoj9PsUC6kgjbnzDoIH5YlTkUSisocJjSQaD8tFyQMSJucjJdQhV0YcYrn49YJLdE7oQTMRRPTUqiddSGVIS8wXvfGk1rJpNNZRbp4cuE2q2zGNnlm1HfcX9k35ra57zrwqvd0ZfSP7nMPJVQE003I3YkSDNjEx9Bw5G72qd5JKk5LqGQ3VEca1Bc8PYRomr1bSI5I2mQvjkpFnjgJSA2yTCI+J4tWLQQ4SpGGkZWnmtgtVGQ6WIkr1zikZhFMOixZei1nKjELYi2sB//uSxOWCFyYK/A2ZLYrIQKBltJm5GSRktFPmNhhppijDGxGrc+yjmTAz3wXnlog/Cr6bnLzM+LOI07tRHyg76jKnZ4jxHrK6saih3tEsYNrrMpVIEFfZIUaQArSgAIBpgulG6T+YBAjIW7VX+TDVgEYIU8mW2aQvDXb2fbEtOcCVgoq3jK+dKRWn8rn6fSczBJJOo1OrherSHqk/FC1J+GXVqH0Yg9CAYDhQo80QuKgRLVwwGJGHN48NEsTRfH0QS6pJwDSc6anZN8+K5TSLH1a9QVYTFG8wqEtJAZGTdDkiNVYXHq6TGjNkM3LD49pzJOta+l0pOPl46yP8Ck9s2iXRPn5JpCtPJTN1ufqDw4dUHZDODwfETZufD2vPSsfsGa2MnRGiAenV2jUpnVTqykfuTnK1lwu7GoVwz/Fo7iWn7AloZabbQjk5ho1BAcLcebxIlaQ3zs7jTXmVAACmrqRa6YCPBMOq6Hb/Mn8iU1CXpqZ40mdNhhcm0CptLsGJCWy0+rj9/3kJ5z/xt+G8UK11rjAyLs3MNdGqik5zVVrl5f/7ksT2ABRxow2spM3kB0FemcexubElvDtK6YHXWrl1qVxe0WcMQjRSsLPpAi5IQeMqiNpk32c08nU9R75S/SKT74Ordnqyi7pHJKshJkl9jUPr7pfOmSNOJRbTnK2SWOpaSBXrNpOD4+xk9K0NycXrN2aP4p+zvmUaa/hmx6iSowp1mkGGVedzIwOB7iW5RtPdsKyX5C0nroB1LcKy9z9LhmyTnzKCqCetPqq3UJTInLCyibQ24WFKj1iIE0iI6uGIRIA+wGnY8ka5AbVXMjrzZYgbPmFE4CBAbLk0Q8gpQG2A+8ViqRP3EjC5gyq/Bx4MDxdCumQEJA5FKplotuIYC0QEZODBZOALEsmiY5iOCNGGi6KbU4rhYRnlaP+ZxbGXqKisdXPIllXmYahWXatYlW1DS4yygYHUYneSHGEOGVBKjasbI9QHxIRk5MicXOpCp84jbc+i1iCqzAkH2TcknSJNIUwzFEJYEeoVy0BlBNNbC83WR2bRytdpCiusnaPETeqH0D0cWU4PQPRMKoE2CZDBaTTzQq46WfUJ/zLmiyf/+5LE6YIWigsDLbDRy33BXsHGJXEpOHKdkVYIovJXLIIrRcFGFTLaTFEd5NeTFsZLW1ThZJZRpqOKLQPkC3iTLMO1BpREbgVWmbXWfOkU5SkhE0mDNLdmDUEPWkPvSh2UK82W3PtAeTEBApS0CqhcmVdBLyatlZ6qhnU35iJCg9xlZlaSrBGKcHW2ESyqDJs2tMmOntfA01WqYx2s4oGBICvdFT5QC4hfDI9i5MgQsKEKHZiKbI0uWnApEjynPO8WafqCmkK6qyhPBI0cyCxFHFEOcaTbu8RxqZEvyFPksUWIJFZTkqZWe+1YpIyUn6LCyXYIp4PoIm3Yv5kS7FnTUFDtrWzNomJBQjJZW8ke9uLEUCN6modWi9rrdemZv7fdjdWPM3tQZoo4iYMkLK7Mk3ETa2nCS0mTiJycjeEhZUhlZQ6iYMFn7ElJVk4KtrodMTKTQJ0jIp7bVKkMw6oALwQ+YMbH4CKNEjsVohYjzh4SSe5N1L0zGJrx/LqKzxe2xGpaAhJU3GxO8aYcjQClEQsJl4iMnOidCuQNkxceQJAe//uSxOYD2GYK+g2xIwsUwV9BriQJaSjj7PsFkQg0BJjgg1PFi2KXbmQUdCUrMOaCthSFEg7podPsccFo7diGStKRhKT6CZJ8qKnwQxKglrbQCDjnSmXSZRZ0CBSQKjcYtjQ6Za3RWmKKIQiiUckWwkpikjpEopWPR6zP41IYLRHoLQht5xSZgqOcNZItatJHzJg7TXSJRUgojPDtpA9poYhHAODrTAsXXHCzysBrEZg8iko0MVFaaKKNfbYMqKjTCRNSFxc0RzaTEJfRNYpIEbMVUn0KiiNRrFFpIWmzhKWgQJk8OaxfxI5SojmYx7RFFzcaKtC3dM03S8nr/DMeKcNMCkqVRkxIdQuxWGwQXF7SyJ7TNusqyn0poFBE4siF1ll0ZhODBVGJrTQMvIy8kc17dNmipCswMEacYlItKks1HqJkGr6c6jBwf/F0lVVhWiJZKkRpWK0yY0ty2HW4kiaSYCAWY60ZWsDImIR4CQioDZ412uWWfhjHHcmOIUYKN4izJtAwllJ4dqmg9zyrFuxHMCiSrPtAxM2sOMB9CEiAPv/7ksToAlhmCvytpM/DMsFfRbYkWReixCzif9loSkXSbpEkDiwqmLSeSCBFVy3BkoxxpAayOn0xtpuVybktIBlDMTQaaMEvpSbIU5yRtCEkUaa9UiwxgSh97DHkXihistHqWdzSZSzh43m73TctBapdFG4BjLk8sMJykZsyCkgERokYrQUeiogWla3pvWcpABWA3srzsrUuZ8tr7T5Q6ZTq3I6Ph9GrWI2+TOccWKoTm6y2KS27E23WRYmQsoFHnlY00GmyBCKhCzMGD4JxQMzd0xcjgeMnZLnlrJV9aWkfVPHUjaTjrS7T3jpOgiSMI1YULJkjBxpy0B0qIRMb7JRSbCEj6fcocaUmESbzREpZAJ50szqiBSaxO61SE+zElUtfuIFMD5hALzLQWMkTcSmHWY6eIzgpUIz0BCtI6kKEIXEdTVETaKmVjpA7CHDwiJYpqtli0SUvhhi17XoDBEWpUBuwh2nnRM7lF3V1+WxtwkHxuVXcMLW5qkwxrVYJcMvtdLE/lCWbNNVOGj4qtltchldCGCl3B8NLHQ5n6i3LmaP/+5LE5oPWrgj8DaTCw0jBXwGOJCEXdM+PkNSyy6rPVqnk91qw/w715q8BssfSGaeyyJBocr1h5fXF6tuE0xcn6Wbgc9vMZULRRMfCbEdBqAywZgQm2Qri6n2gtXw7JwasxNjkkyEJzKXKOo4EMtV6i9InhaDItKMzMMmeF1/DYcZhw4ejwo6CMcMhOFFS0+LMWnGLRTLddNIwCnOoNkNVNBXow5l0SNGHERHqFmCdsheIqKwB0kNJohWueOIBUgNNxQRRk0npjloqgywQFyTtzChc085s1mgeNGykl0BGaXkshTI0ESYeP8kJE2BQomWhRUVErExEYVMNajkGRUK2o4cWnMTKKChAKUUiNFukwaSpDMlGAyrtI/MTEE0zxBGxW/jRxNnWzUK0qK14JRCJAmWXXNr2hPgmaFYUISElUdqh0wULaQsRwuRqB8jIWxEY0RqJIVkbCZQmZZKNYuXOkpKskqcTTSaEhghZYaJkfaeTtx4ATqU5EmkkhWoUwEi9OPs3R2ftXrNfXrcac19fdJ0x0yiq4ORJLTMB9LR1QgMW//uSxOkAGPIK/S0w08txQV7Bt6RZilSFQycgcrBSPIw4N1RPUUPuRbuwkCDBEsFkCRmcCNohzqL8cM0as9dVTyYJhaRVTrufFi70iYTAq5ZnSpRlvpkGYw4omoyeYACKnxZEYi+bfsuNn5liFhzBJI+g3RwcugwpUbGGxOLRkMxCQ2kRoC48QE0V3s9YTnoFBsRrrKmiAEpH9IlVNRiXiM5Y5IJi+nSIS18incr4SYfl1UJBIP3YGToxUHjDa4pFyh+PLB3rJUpEmXoRM06M1U4STo5tPQGKEuIapvmNjVEs5PqNOv8XXolJaooPViaxYOiqndUiSQDxxOeFI6NLoEJKD1aykLSpEVsLh8hpzeq545UL6F2I+HSxIuWDw5NDJYW8K5XPTZmquhdOjUnHrZdQ0ykeVLAuLJeqsLXNLl76F1zAtmJUXLSUZFR5YeVUHY7HBUjM1kKypWoABIWpkB2RmgaEnDVLju5G41UlVDXuTNJfprXaTDWGG2G4ml2mfTUGpIIMFcJzttFQIHb1yMeRr0K2B+BgWXZV1Fi+l2lJNv/7ksTdgBCpiw1KGG3DuEDegbSxeSZkKM2iAwIC4PiNuGHw9ZGoDlpUPQSToILCHYGrSYFtDZsvDF17DvdGrLU1xzLDy5T6ayRSyrfUFURh+mSxRp45E03bLWcN8FFpUy9Sl9BGSN10aotM32MWBnOfcKlI+3IIXmQTpZBZInJlsGmopkrpR3fCF93UzAIDgZyYKYAOnTiMXzA5Ayl7TI+yeVNUfwXmCCDiM2pGJLN51oVrOmappxCoSjweaEw0AIHyVALsj4iDYqC4NHDJ0VgqTCThsbSYWFRJ1JnKhqAaIGRQf18VkkBBBywqc9dtrCXW6Kq0hycHEbTuSsaKn0kRHFtP9GTTaQjD50byU8LI0m2oM4gZihogaQtNI7QOJ2HkGrjZyE5+kDMTZBgpaOLzRHVYQJmTVPkT6UeuRPaG3EDLR1CKA9qhMjhBBCDJOXcQ6w2mWaVRQFEURhHAshghEygDEAAEoCqE+YRtzDqaC1HOQ2iCRDoF6ySgreWot2+Dbazfp56pT3oYnkKNNom0Yk5NXh63XNxGEr1dv4hMraj/+5LE6gAX5gj/LSTRy1tBXxW2JFFH7FIRDHoU7zasJo6Ru9QHKh8murKqz7IXRI6neDGKdoMnRy1wimtaWrCNSCchjGU+So8mYXZZRDcorY+NKSN8minYW266rSInEB6ZW4insNURh9Ok1HKpEWGmjD4PRu0CC+y9XDGAU/nSKkOISxqt+AaaWMEp7luIT8NpDwyPky0pNL2VdXjBf4hFg/bJC0lpk6NDiHAG58htDs+WoXTw+PBCFROVImokqoRjA2ZEbFJAiJHSsykSniEugC7chSREJEOISZtEQoajjU9o76QkUVDtESIUEc4h9uBZZpcOo4lijE2pCgaWNmzxtodVeiWmqsaYGoIVInSeYOj2KikfVuAURMgusoR4sOIGg0ujeZYFSOLPGDxoFlTqyoxCVY0qWPuA5JgfVWZRkKO+TSLoYoZjsE2RS46OSFi9h9YSOwZPJsoonCorLTLOAKVSAQ0FkoDiOLTXsqlPUl1yprHWFS9yzaVQs2nONp0vZ9NIncITRsU0aZKDEmdOkKpKKW5lBShioVbznTfFRFof//uSxOWBVMYE/q0kwouLwZ7FtiW4LhhtGJShFtLqNsqshhQwvJI+SoDeck4kpaLaXjovdENx0NXr3rnGIG4rCWbKIHOInlmBy4dG9zU/iCGlrXJpfKIfS39aRvnF5BZdCFIWqkJgPDKkqkVhBhEwuR1GSQs24L+oUnxlxKBbG6pRRFBdIHo0tMqKiO1BeyU4IFAGsr8LRE+5ZjGqJrDtKEszS4pTbJxKFswhOnDsnLNtkKKImVEa0rFzRgF0yRWSARvJ2FDAtiBxsQw00tclxng+u2wOpSaOikSiyEkavTaqSxZn0w0sqSnlqsqbPwgTkBCwsTSaCzB+VCo+sofJWaRrTJzkpspJoEEW7WIjSMQChEh0GCx1ZdlRWQzyixRGmvZtK3GEnUSm3QUpQgQk5tFUSF50y2RjJoihR4UGCZunG1EbNLQtd5FaBzBlM9FAS9NaMUCiFupmjNkpD1CiofP6EAcEMjnx+bKBGxbQdcaMJEqOB/Z6wm04rbyTatHrezx89iYJzkvNUhbk2kKizSBCKiNBNJpZELtkVCJdV90ikP/7ksTnghd2CP7NJNHLTUHfAbYkWFVZM4tmQnKZJVLRZYmosigyxBSFkPXJVF+jlvthVdkTojccWjSpu1mNFSiMn+F2W2CqA3SOosNoN6saXlUdkw30yCivcpmNE2G20DAoZUQT8Y+DT8XtObkDket0lBRGzcv2mqpKy8zMCm2qusriU15nNITxwqam9NFMzalLYh9Qu8OyJbYxIFFAsWDYhL8qjmjU08zFtA0ljLSWo0GTL1WolCSUnmSVhMwndKGYlEkkK+SS9GVRXEyjXLIbIsTJ5RkKSc8/DPMsH1KkbFaEjaVVNZJNZRDjNYKBZlQwdaQkC7JiDGCCFiPcg/SsCFkwUi85HuyJBZGwjKdhFhpVmCKBk5PV1LbgwdKlKmpEgLtGCeK6No40+BXWdjsy4pgWRI8dWNnYLxaRCWVWeyidBC1GsM0StwagsRa9jFqEVqkpWbDjClVEh7FzJj4GJoiMNDwVQjLJLdJmRVpCjiqobKrICpBsRQpCCOBhljrLI1TLJGmnRKTMTRi0ESblXGYqmk8VkdQnSKtXrwEhVeD/+5LE5oFXygr8rOEgAxfBn0GmJFBnrtl5ESpG1OUcwUGoIVEA29BFlE0TJEi6ZC9GjQTVVUK05DdQgaMdar6c2hWXSXuSB1kxsNRTTeq2ygJSQUTZxQuSqyVWaRAqdOuDsiNIuqWWFaFHTCEvNCoPFjUWBYUTI1w3bKM+gbioV1GggQZBdGomx7JkkETYi1qdF1DkESBtSjRkmQ1AckEep/mNbhySzmMlmy4PShYTaZzh+iXo/CYwi4O0QpmJFpajrSiBAfhr6RaFiw0km9AlIuy2RyYAKTzOToDsqxB0m6YagQG6absmtDNYmrE0adIEGrnpbbcotkE8u0Z5PEGKNHljzoJRWofWjR+X6JtGj2B12RE5Vs7SsUKyOVz1CyVyR/abPwmn6Q6Sr7JxXpwK32DySG2LNqyQSbLssnmUZxtWBM1OUjqDUKBCdtWM05ubezF+JITbWLiNGXpFaACMyokPAh4RVlUBvxA0ReKafqK4LVKO4r3xillaVySyxSyYnBlQbPoCdjgJky1oZuJC1EQQ9AdaeoaZyTvmkjLPfJxR//uSxOqCWeYO+AftIAMHwV9VkyUwiGvkk1uyirGnruzlooKFkaoTFhSzofn+DvpVxbQVJdOafrUYSVRcEzYTdPKFGJyui5NKG0USmrFwfVoYt7Y4ya3CiqvdmrSYFiUt5sd2z1k6jbs5UzKaCJrN0zMt+ajTr8EWg1SDuWcDIeBUkWWLcRD47PiCRzocH7FqhVWFNbcr53+iMeaOLslOM7YK6ommqxSbkBdc5GkyUrloaL1D6AbrXydY2cLB+clclNj4tKKI5q+IaZwqDzApBEKOFgacIwI111YDRwjjqyiEYMi8UIno+mqzsRfDwnbSUHV2lgQTpEbRJqOFBCzSBRcogVXXMEjZEnJRAmqqmw2oIz4gclWISVxVVtQjFCBgiDCFI9GQWRMkhORn5uZxlgCC8xdJCu2sRRJCeLhUY1tW6lahpUSEM7FElBnUxAMrE5cVSoCwoDKzEUlVEAAElVfqkpGDuk2E2p6VZJBUlpx7MloqvMusd7z08Oc/sWiYQTCAIsbYHDjptKh5VAMgIJoESYEk56AKATSiT9BJk+lAQP/7ksToghWmAwDMJMnLdcFe1MMnwcJ3vkhwhwoQkEaaCoTKEoEB4yRJ4hBZ6DCgM8/Zs8FTM0Qacimhk1DWEZyWoMD3FBdxLbKayF+pRxd2wRIlGj9RnSJJU2o6Ez5DiKTh3eYhtqRWcsnSHHIxJtSEzSROhGEK8ylGYrKeaBcnbxztZZiNpKTew1yq05mvBCv+pTBFEwO9MPOAuib5Sd+6bvSvBA53GmdxvRPU2SJyQyEYIzArQKErMQ9MYc5YPU3otgJnYohgSQOIxLkzKAhLyFlCpJqkuqG4RJwqxuFuxhMIjnLRkiKA+aTkdKRKRhhEiah5AVSOhFd45WrLRrbMm24FbEcUf51A1obEWRnCZdaoDpImgpSCUM96cyBlL6TY8tvapd78FQZtQUpE6HY3OrLeNkx9LjUco0vOA240sLiAaFYpNLhgMBFAsjaTCgyjaOOlhZsVvYBENiMgRCEbGRidCIfjS8atuOieDQ9K5VgqwIh+0cL7ojpW+U7lw2W4+fohLQ0O7b62iAUw+xk4pQ7TF8uVeEIrHGojWNCSurH/+5LE6YAX2gr6pJk3mry/oGRkmqE7qJaZi3R8P164Sz9awasHTexvmCzFb1yKUlhYMz8aSywbi9GcwGxu6lKqcfpjVHhWdOb3QmjAHCxoChpx4NID4WBshJSRAqKSZgpGKMlmKRAU5YVLTEaJGdORLqEhLEuhDsZUaIiANMEALWPnwohOFZclFUw+dRBsTooikRrnEbI0jIRkydLv0RKSN0LWTtVEFlYeRBdQjFajaMy9vGFVCkVH0WexgYeTCaIrLePkom+VTFMyNxKR/K4ss4iURiYs+Dwuu+paWomkmbZyzVikwM15yUHnOmVEba/KMpsWcpHGSeTyJDDS2Im1piI1AgTPTTcprogkPaozFNQo/17MOT5ZK+5H6BnlKkbtyU4ScNcxhaRFC0mnLpLSoND0QU1IWTmYhkSZ5mFyjTsVemXVbTGEUixkxTiWLJAKQfsySkdh0XdMecWImES82BS0IhtssuGTTUFqEMVHqrHGz7hKgUTQHiEZYQqlIEdhUnxhZGKyNql0lTh3JjKMyVUYRmmiVePIw8OvT7kcVzpd//uSxPkB3bIO9ASxN8KbwR+UYxigACCjDCGoXEk60pLFKyh0UzdchVGhUtRX1ETTA5NmGlK5W4lTOpi89ZKsXGcZDXF8kEtAWCCwPDZxY750prmlxZXGloFr0LpaZiW8ycKiedOIkM4VHhsyvxxJCZcUkiGVFzR4nmr6RIWFi1RVBKq6Ma05aSrkFBbfdbNKJ62SFW7lErrh1AcJ7Q+XmvyRZDAmWHYI1BGQSQpIEEN0LWhgUQMI3yGaxzEScrNNGiiH1ijiRlBKo5MnpsyuU5w0u9/ZTWixAaQlaOzkNK4mu0gRjbDTMGT5ggElwD5wuXt+sEqjJhLYcT68qoxFc2LR2ROcQ6ZFbQuig2XSDyd2SyIF9eurBYgNNu3JFUTa+zEqnTnibaJReiBpkieICjMjGE6FNibDnanTU0Tai1LRKNWs0gfBQtIQtNxKpvC6qOBAkm6Bm4YiRIhSQossgJLvPru7hiZhql7cPyMavirCLV5G7eekooRUgbxxRJQnaDnKgwEWZmjptM+XR5RmaJPV0TROLqRZVSJFCJUqjQAo2P/7kMT1A9veDPYEpZPDE0FfAJGkiSxc/EDTkFguuUojVQzVLkJC3yVCsYbHT7g8qSLspsk1dDMsP3AuQnDbmLRGKnOw0MbtWFnmHVU+jnTiiIxAGPRPAO1CulUHG2mk2ORPkq1zSzYNtzT1JKq5PQPEXOlFos5G9989KNDkAbLUne+KaxBolHLoxmOgyCADQqEUaKaTsQNSP6INkkjUN055GRIPAibo1zdMbfhbSJ/J7tgUNiAMaQkkmkMQ3oXB6JZegklAxIwTsrPTIElvkrfsBUSoNQhdNUTvJGLLKtMMM6qhXRk8TsyQ5oXDSNppwLoUApPn6RsktiPkE6RoiRRhNSRMdMORTnFIuk46jXXhFYQyiwdw65aEE7bPJ1LLgNwWZk3UoKMzezT5sFD6qJLpddNTLVmosTspRMnouQttKYbmRmys4rzaiYXJprE6KGoGXkwebPpxViNqZNymNGERUKmRoUH+USOELZkqNCeI2nlTRIfB3Z9dU6KN7MJlriGXvvGcpKMNxIrGbX0X4qLXK1h6lX6VDw6Vn50c0JWq+v/7ksTpABfCDPzEpNXDNUFfWJYmYayY8SlCzFyNCUicqQnykhGpEXOp3WyUhyYnS64njTxbD9qmmxGG03FBXQjJ8RiWYgE6I0ZJDUS5VEPPxERCKjrjTCBEhYI0SwmJNWIRATIS0iBEyi1CzIXLlBXsyQ5Nch1pATCohOCCY22gB1RAYSHlcXESIsXDxOXVF2CY4ZRniAS8yXcblUy6yEH37KQ2bkqTnT53pvIgTeE0logRYMW2IC1MvBhyEJpdMGA2Ci5StKWJBKiLjwIMAJAYQTA7MKtnFLY1AF6RJ4RUzMBkblkUeY/QSJ3EG6IKNvNk0jQtqEpyZgGgEy5jxSbrWkXQQ1oF28cjbmfq8kglAk1tZjH4x8n4cMwmPY4JR4g1RJEPok9fqaqXxc/dqIfH6hk1I3iaqKMU1k1orM0hVNwkQKMpymcjy9xlrZXEoIiqNTTM7V1GsiRsKMmC7dUQIptswVtaBSXIK1MijqBKuoggSQc0l76x06yIE2IqmagfRswbVXJUbjIkGTgoLIiw8qiweYsXJPuyYGacGAaYosP/+5LE6YNbkgz2BLEzwtDB34RjJvhpBxJLnEkDh60gpJhrpI2tqQXItwg3wGvjLTME2id9CVrhQ4KAwoPKNah1CixkV6m0iSr2y6GonEkEKJ5GrLZQYgXFa7THNyNLqTmKMktJzoPkozE2gSYFaRYnJlb3TIgpkbT9qqKOUh9IFiPTqhNdsSTPqTJWG5RPuY1NRUQEEM20oJrdoawec5aIodowN4JMbA7E5UAALCKBtInHhQxabYnHTjCRCOt5OmRaE0SxwQH0MOhCM1qRyEDY0eJEtqUiky6Ad2ZrwXLLoURZkSkhRCSitCrN3ID0GGGVROiNSbaETDptJqMs7GV0jYRBFAgQ8mBLVxtDBR0h1UnVRORkLKqJSBjXoy58nIJvRwJVmyNUiwminRGYWVeNUQmSBVZ7FHUJ9d6JytH1MEglHGFE2zo4iUbIIeTkDAiJgyhI9FLlqUWRA6qiF8WqAlZEzCB6NHM5F7cXp4UlYeu0zqMmOGSsKTkRFG0fXLGy1kLFhSachqRjEZdEkLpqihEXKDJki5AsgkYLVzAKqGhh//uSxOeBV+oK+iSZPMszwV8UkyWoUqdWrD6gSFVEE4rk7mTRICQfVCqUhIlJuCrCxNNtvIoqi1GZGe1hmCN41A/iBNyhO0wURo11alZIueQ38RkmEDKus6+xiSUsK8wgiWVQHoQSCya5mUkKpaGMqSqJApG2Yimaa7TrIokzckKZY1nk+5sJo3mR6mQqSo5ImTSTWK1NEo1NAAACwG7TnFycYtJNSOkKGmYCtEKNatlhlY64qkgRVqBHZC2uXIGLKMmV83wUH5HkxCjHwugFShIqRCgiKE7IkXEenQCA2QOGjzrgqSEImJYeHRLwSB+Ekj6CUGhRnQe+8xh7bmqLPayZl7RckTvRghifKa9JtRRNA0WXSTcZe87UobFBHVyOCIf0ssfhT+li6Z2evUYlrDB2GI4kEc1V51EwkgRvhSk+gguhUQhokjraG3bAugcweRC5qbJhNdTJoZQbkogPAhSyjZNR6RikCJAJMIE9MmlOB5mrKiEinqDEpmgqdNzcCJlcumRIBdRxPM6PTgQkGm5nxASmBgZAVAGiQVigmDiPqP/7ksTngBi+CvqkmTxLD8EfYJMnyayp9JFWiQ6i75ucszvK4wTzhu6JWHPtLQ4OggfBhuILODmqI4QKoHPs6+ipE1BIaRs+yBzTJA0PpyTsgefIGDA3SRCQj3+TiwYzdIw6h2ccDHixwlCkEwQoHJDSIsSpCw9aLFkBikpuDiRhqZoQNDEyQGURPNAhhQQmmcfqeydKEDCL60gOCBs4UkskXiwqgZowiL5ZDeP0quYEpOSBgbH4nMB+amSw6dB20qriNkoQjpG0UbcCYaUHunM8RqxkJ5rMr5hickmOVxPosPRW6pZjNRitOR5po+Q5Ag3chbbTkVdp2RPRbmxk2WbQCNRrSJGkwfQ3DUmYJpkLBto5h1iBCw9yF6DIEhtt6GT4lEbR1pxFSEniujdRNrzFRKIHOg5yfhBs9kMcyogWXZUo2NCx57FR09EiUIiGDLmkMYJmFsXpCkrVGFpxh7pLTk0iFjZSP1aIkBmIANCtBi4erNCFGkSYMKXqyjDV3aOHFER9OQAoDp6xGmWacskxjVMIhYnMq6feZPwkyTimEjD/+5LE6QFYlgz6oyTTwxZBX2SWJsG6AjnZxKLLamybkSrtJIlUhCSkBQw9uZlRZNQgtgE2yxImMNmzDLDXUXZNIIyE9SS1NNoUkZk0cxfleQOZIzK1yWEcUSorJ4ozmro3wLyaVyytmtDwYYiMt2aLIlxRm0wiRTZiBWoYRbiOllhCk0pBOidtRabUTih9fQonInbjiSHV1ILrI0DTSEaakebshlarjZGE9UVg2VOHWyGc/R6TDyiR5EpJzJDkT5pI1x8BhTELEAxpQLKQmQkC6Jc0YmOBSSUjCFnjQgBsNJOYPwUYWIIgIJBJ1Gw6XNbbximW4olm0c9Ll0bkJMs2PJjhIzMrSCTSiSNMQE5snkyIlVEazbxAjXXRBEpTBAPmUmFC8TYoHkSBpi2CFCmPt0usqW1QggsuJY0emwTMvFaZRqIrFD0ESQZTaG0BbOSkq7QqZUEK9kjGmyrCFI+oTwLMyMSswag0HBTzTMkoaKfuoyYiibwseWnOWgDaGWgzqMGFlkivTxZxsRVisFlKPSxF7+oHhKDw5zIEig9z6tFY//uSxOoDWMYK+AMZLcs/QV8EkyfJiUE5bAVV0ZOgSGmaSOJSzFFtCaTgx4QTIKNNU1dmLKZFJGYUVC9HUzIFEbqzWkCgos2CBmOHZA9M9bM8xqtTm6rGsnhqyinmx4GaYm1mpGFqSNEr+pJlqCU08gjzrmyuvoFOwEJRJcm6OIMFBKBRRxElSdwBDpJTZ4VhUQFhwsTn0PSTagyeMtRQCjEiYZHpNLvNHEYgKxQkCSaJGcGyaZRdAiNqSQQRo0eKwTRpQ0tF5aDAoX0LzmoTFigZcYEzJR6M22jlIBA0JWEAkDAHETBGmq1qSxOuWmSqo/I6gRqrwFJg2gQkpBAUsBQNIT/FZcEueRoiUnB4lxdUTzJioqQxI6gKUpBIS2jcKXuiCbiVtOCpgXICok5DkB5C+0S8G1jb1pLguMlBKFWDhMiPCFBNEw2jBs5ImMrmTcEYLBtEX+wMKUADAiFG2MMgAHxscWQCvkikPPFSirKVO7LDtJRNooUmqSkQfNaoj1FFZOiI4MEp1gfKhkJguQDAhQoLER8G0Inm0smQikaPkP/7ksTlgdUmDPwDDM4DZ0Ge1GSluKI6s8iTE70LcDU4ONLhjSzkkCvkwyfVaL6iRzecQ8+RLdIEiexCMrpcQkwB5MLsDysiCYoXMGl2jxFAxIusaelGeq3ArSyDVyRSM2K2JHuiMdihRMMrvWJ0jhGkDiI3JkmgiRQhicYRYaETkC5DnPOxlEwpGiy59oVtk5/WyF0krNMKr2qMCh6YhPtbH20jcyjpZqU+096qAvFNBvYNb8JOrGoUgWs/dw8nYzObko8cgqRMSezaiaZTKJmsBZIGgQM9KmWvZO0JLxSCVpPBIuFECOFIlR8YQRBHSF7CHvkzylHHelJ5RxADPgymWQQfCsktAgKRrMiMqNgP2ACN8wQa9oPpI56VFMkkXmKJJkkFmRaWlYievC+ow+TEYsaskncDi+lmVVS3KLLLucX7mxQrHHWqXb0gBgIx8hCg+OJSRURnyh1A8BkTB9CS2K0YKiMfmuyorARk0yhcqmSQOFCAyUJNTZ5CbIRMNBQ6ZRisyZk5I/A8isdKTkWRmQwu2oTIlC+NiggXVo1FGQD/+5LE6oFaMgz4oxkgirJB34CTJ6iYqOqnJSjhcRFNOuoqdiwqtBFhQogttAZhB71hNizM2IoU2hVGERWWahMySpMylPSecg9gzkzpN4TJFUVDKMffcpJGDTZlmJFEmtlRluZ4gRHUlqoyiJyhcUdAYiigUxEThmA+SuInaRzd0Q88+KVYGGxJqjULVxtASbEnack0B9FIRvbI4WEwaINDVEq08uophgNTPNksRIje2jIUTWRUJUPQjB1UmTOMzMIBiTw8ZZYpsskR4fVMEZMX0/YeQHJpiteLOEjC7BtEmbDxREXWRn5jJ9VEygUFzoFCojpEmlBpLZIxSd1SMy6766DEc0l4FTEz+oE5NNLKI5CtMnRTQaTwggNigNLOf5sHy5WUW0zeSJE2yNBiMw0F5G2JMD6whMoTaO2pFDCCypkhg+KiiMlsntZzTS0MPIZNIxxo03dRVkcSdioEAAEhgnMAE4DFtycxrNtpEybOcYLI0UZIg4gHWThMVFRSOrKih7LKEKEzJ64JKJlVMkrDsKyPSx0bjR48unAkSZX0j7BA//uSxPIBWkoK+KSZIEsrwd8AkyUgQyTEw0qrsXRXGGly7yZdC0mpaSKk12iVdz5qmWTpWaDRNFjCU9mkUEeRsqzT7kiHLorCNkYgsw8gJQCmKwCpiNMDsJJukbYOaDI0INogYmBLKTMOPPgiDES5soXCZVIlIDTKMAKGjWTnDAZRxMcGTC6kBoUYdiZR6VAqTJwWTlk1RQgCiEENFESYMFBSzC9RB6oipIgDMErwmiUshokLhIgH5yh5DCdaeQVJPFMXhRMSGycXQMoUaz2S8YEh1pxpAtEu2l12FmV1CRG0CWeahEmMKJGQo2dSFWJnylJqTtQwibi5I6D1dZVmRp8ViY3AGiVNm0Q2S4qbe2jaICqiBNcqqoec9CoerSCJEbZFREsgUtd8kMOSrbGU4nmaRSBhGwIkBd9Ntc2jRrI4UwUQONLjnWYstMgUnROO0tnM6oowgQrh1cCIppIjSRS6fUMJa4BJnJOLUZA/hZG0wQmwkmdRGRhrbwVLLJKillJC5QkaQQcZ5s8iQxQJCOE0hWsTmILpIEdJkjDnn1QFfP/7ksTpgdguDPqjJNeTJEFfAJMleRoZXEGFSdVJhVE9lNvBtcQqxPLoUBK7CMQKmEbjFKFDxsgXQrLW5EQG2ZjKx3CIoXXZYKEbcEjkRWdbpA5hKUjoQnRgoyWIiehKXaQoL4yTvSYTkqSs2keM0j9tmSRCgd0l22NXYHSQkZRR1OC4nKo044aVRWimaogiu0cCxcjbxihIQrruWVVRqCNlAQtwQpem2SFY6kg1OAg3EjApgY2gUBUqRCQQOKojIMgsLahFQEMl4kizorHUSg1rBRCugxo0RiAU/ihm0z69Ea6JpOR/oESZsfsRl5JlGWRShWlsZrI4NoU1Dh1omfLZahtR6Hihsss0MkC+MwjT1eHG4J21JRCYNtkRr64Em70+HkUXPo0jJ2V1EkW5MkOWgnAjecp56llJolReZmaJaNECRCYbRwTkYJGCFYxE2zJJmKMnFBySI6tZiiA/TKowIRTwSEINihwPoWzEDhJNHk0SsOfC7k4STQFSSPRNSKLLj7RiRslLFSpyJGVQMOcmdaZWkucmkhwVtlGPJgSyY0X/+5LE6oPZOgz4AxkpwyHBXwCTJpF2uyuzBWrXitaJPyUSRKsTgRa0qXYekSEKFD0aG26kY3akolBmoF2Zo23KfGV01Ec3IXTeiXQi8PM27LlkKcgTnc+el1xHFWjakh0m2ctYXXI0+wx0B06cIEyrj6Um04wgiOScoxc/FpcREcjbkmFSx9pY0s+T3yl8XfOQKEAae1EZnR3RxCPFTjz687zbJMMandD7zh9Y/msL2FvRR43YxL4UrF5WEBzD/i4WVZSBdIZlUkHKUrRyCP5ATaRjn2osFEQmHAOmy5ZEKRk41d4o3LSkoL1A94hGKFeUyJWnASCD0geNC5KJhYTRBFcMqCZhBQEZYuw4UsUHKEIGBZpP4lZJJSEl0WSGpgqS0TKJpyyJxcKJrJ3fSINnBlpQ3BSSKolo2QoFENsHNW2MFpSwgt0lydDbVUsfJiMhZkpAgYwgIqohd6RE1IoESWMWjoZDxBNc3zjCdHtLr4dHYLGnL1ZUVcXn5YLxw6FrpdPrix86wjQtI7LMwJTKISo/BeF0RCReCxkhZ0UniM+o//uSxOeCF6YK+iMZKcsXwd9YwyeoZtd7ix008Kxbmo2hFMJiegwpUUBU6qQYYdKLaTKNCTpomnhdZk8oabKAtROQoq0bNa2QFJNUoekOCA9KnHjx5R6xoiINxVGJBQQlxCixVkfWiyYUMRtEZFm1kHIEKBdCPXRDdxbFSZIqugOtkr3MaVeoONIziGUR9CfgPWacImWIOzSTIARiqZAkRJ6gmVhmjUzqwouk+PDpbdxz6EozKRiRw4NRbyRkLjpZo8wDSBtA2oiPgqjTjZGCqKi0iEJnQyG5oR8iORSySFZ/JNmgOzdNjGo6MN4D58nOjIxegqKMIMRWiWmSHJTpRIsucAyS40wqYRJXRKrt4srVx7dCiNoO8j5/xNW9X8WmakQMNPhXlA1aizCUygVGvRLOMqjTqnBjpeCBAtE2kyOlHEnDJNi+spD7RllHeNJySUIDgwAowUeSEJLw8FCWgS8a8MmXroGpWIUCenl4oTopZt2LArBeKL9ZMmuQCnibQ8HaCxUwSCY2QCcFJg4bmicsdA0D0VxRA0FhXIGMMFYoQ//7ksTsgBomCvgksTZK20Cf2GSbISEjxxQU2mZItnABjSOAI3sIYgJhklsa1U6JFgHQMqlkKFyzaStohiwgm1FpJy4iXOuosmusjHBkRGkPSRpkopNLMpNpGUmx44ysaiVcRkrIyQDZ4iQ+NEzLKwZeYNqUi0uKidokG0iFGgaZmZtESyIzaFCmYFWzi04jYtJZV+yBJZ9dE+b05ywCgFbVxWNEJLYpcRNKu96rklUmoxlcY5JE8KtoY50mlarfcVtVZKmSxpXFXAkgDSaGiJ4VPRITwqapMUnCWpWkTEJkiZIm2cqVwxEmZInoXETKyLbIWSJoqgBJGGYTwVQalPFkyU4GSga2yFkiJkhUuhikTLhkqw0rm1K7SJipLBZFKiImEIlIkW3JpNlaebUa2tQ5LZWsmys1yqIuCJQ1iIqJVWY1rKzyGeWhqVbHrTZ2KSJNq2UlukxBTUUzLjk5LjWqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqr/+5LE7wAawgr2pBkhiu/AHIBgJQGqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq`;
  }

  async function hr_createPlayer(string) {
    let binary = atob(string);
    let buffer = new ArrayBuffer(binary.length);
    let bytes = new Uint8Array(buffer);
    for (let i = buffer.byteLength - 1; i > -1; i--) {
      bytes[i] = binary.charCodeAt(i) & 0xFF;
    }
    if (!esgst.audioContext) {
      try {
        esgst.audioContext = new AudioContext();
      } catch (e) {
        return null;
      }
    }
    return {
      play: hr_playSound.bind(null, await esgst.audioContext.decodeAudioData(buffer))
    }
  }

  function hr_playSound(buffer) {
    let source = esgst.audioContext.createBufferSource();
    source.buffer = buffer;
    source.loop = false;
    source.connect(esgst.audioContext.destination);
    source.start(0);
  }

  function hr_getCache() {
    let cache = {
      mainButton: esgst.mainButton.outerHTML,
      inboxButton: esgst.inboxButton.outerHTML,
      timestamp: Date.now(),
      username: esgst.username
    };
    if (esgst.sg) {
      cache.createdButton = esgst.createdButton.outerHTML;
      cache.wonButton = esgst.wonButton.outerHTML;
      cache.wishlist = esgst.wishlist;
    }
    return cache;
  }

  async function hr_startRefresher(hr) {
    await hr_refreshHeaderElements(parseHtml((await request({method: `GET`, url: esgst.sg ? `/giveaways/search?type=wishlist` : `/`})).responseText));
    let cache = hr_getCache();
    setLocalValue(`hrCache`, JSON.stringify(cache));
    await hr_refreshHeader(cache, hr);
    hr.refresher = setTimeout(() => hr_continueRefresher(hr), esgst.hr_minutes * 60000);
  }

  async function hr_continueRefresher(hr) {
    let cache = JSON.parse(getLocalValue(`hrCache`));
    if (cache.username !== esgst.username || Date.now() - cache.timestamp  > esgst.hr_minutes * 60000) {
      cache.timestamp = Date.now();
      setLocalValue(`hrCache`, JSON.stringify(cache));
      await hr_refreshHeaderElements(parseHtml((await request({method: `GET`, url: esgst.sg ? `/giveaways/search?type=wishlist` : `/`})).responseText));
      cache = hr_getCache();
      setLocalValue(`hrCache`, JSON.stringify(cache));
      await hr_refreshHeader(cache, hr, true);
      hr.refresher = setTimeout(() => hr_continueRefresher(hr), esgst.hr_minutes * 60000);
    } else {
      esgst.wishlist = cache.wishlist;
      await hr_refreshHeader(cache, hr);
      setTimeout(() => hr_continueRefresher(hr), esgst.hr_minutes * 60000);
    }
  }

  async function hr_refreshHeader(cache, hr, notify) {
    await hr_refreshHeaderElements(document);
    esgst.mainButton.outerHTML = cache.mainButton;
    if (esgst.sg) {
      esgst.createdButton.outerHTML = cache.createdButton;
      esgst.wonButton.outerHTML = cache.wonButton;
    }
    esgst.inboxButton.outerHTML = cache.inboxButton;
    if (esgst.nm) {
      // refresh notification merger
      nm_getNotifications();
    }
    await hr_refreshHeaderElements(document);
    if (esgst.qiv) {
      qiv();
      if (esgst.qiv.popout && esgst.messageCount > 0 && esgst.qiv_p) {
        esgst.qiv.nextPage = 1;
        qiv_addMarkReadButton();
        qiv_scroll(false, true);
      }
    }
    if (esgst.hr) {
      hr_notifyChange(hr, notify);
    }
    if (esgst.lpv) {
      lpv_setStyle();
    } else if (esgst.pv) {
      pv_setStyle();
    }
  }

  async function hr_refreshHeaderElements(context) {
    let navigation = context.querySelector(`.nav__right-container, .header_inner_wrap nav`);
    esgst.mainButton = navigation.querySelector(`.nav__button--is-dropdown, .nav_btn[href^="/user/"]`);
    if (esgst.sg) {
      esgst.pointsContainer = esgst.mainButton.firstElementChild;
      esgst.points = parseInt(esgst.pointsContainer.textContent.replace(/,/g, ``).match(/\d+/)[0]);
      if (esgst.ttpcc && esgst.points < 400) {
        let nextRefresh = 60 - new Date().getMinutes();
        while (nextRefresh > 15) {
          nextRefresh -= 15;
        }
        esgst.pointsContainer.title = getFeatureTooltip(`ttpcc`, `${ttec_getTime(Math.round((nextRefresh + (15 * Math.floor((400 - esgst.points) / 6))) * 100) / 100)} to 400P`);
      }
      esgst.levelContainer = esgst.mainButton.lastElementChild;
      esgst.level = parseInt(esgst.levelContainer.textContent.match(/\d+/)[0]);
      esgst.createdButton = navigation.getElementsByClassName(`fa-gift`)[0];
      if (esgst.createdButton) {
        esgst.createdButton = esgst.createdButton.closest(`.nav__button-container`);
      }
      esgst.wonButton = navigation.getElementsByClassName(`fa-trophy`)[0];
      if (esgst.wonButton) {
        esgst.wonButton = esgst.wonButton.closest(`.nav__button-container`);
        let won = esgst.wonButton.getElementsByClassName(`nav__notification`)[0];
        if (won && won.textContent !== getLocalValue(`wonCount`)) {
          getWonGames(won.textContent);
        }
      }
      if (esgst.hr_g && context !== document) {
        esgst.wishlist = 0;
        esgst.wishlistNew = 0;
        let cache = JSON.parse(getLocalValue(`hrWishlistCache`, `[]`));
        let codes = [];
        let currentTime = Date.now();
        let giveaways = await giveaways_get(context, false, null, true);
        for (let i = giveaways.length - 1; i > -1; i--) {
          let giveaway = giveaways[i];
          codes.push(giveaway.code);
          if (giveaway && giveaway.level <= esgst.level && !giveaway.pinned && !giveaway.entered && (!esgst.giveaways[giveaway.code] || (!esgst.giveaways[giveaway.code].visited && !esgst.giveaways[giveaway.code].hidden)) && (!esgst.hr_w_h || giveaway.endTime - currentTime < esgst.hr_w_hours * 3600000)) {
            esgst.wishlist += 1;
            if (cache.indexOf(giveaway.code) < 0) {
              cache.push(giveaway.code);
              esgst.wishlistNew += 1;
            }
          }
        }
        for (let i = cache.length - 1; i > -1; i--) {
          if (codes.indexOf(cache[i]) < 0) {
            cache.splice(i, 1);
          }
        }
        setLocalValue(`hrWishlistCache`, JSON.stringify(cache));
        esgst.inboxButton = navigation.getElementsByClassName(`fa-envelope`)[0];
        if (esgst.inboxButton) {
          esgst.inboxButton = esgst.inboxButton.closest(`.nav__button-container, .nav_btn_container`);
          esgst.messageCountContainer = esgst.inboxButton.querySelector(`.nav__notification, .message_count`);
        }
        esgst.messageCount = esgst.messageCountContainer ? esgst.messageCountContainer.textContent : ``;
      } else {
        esgst.inboxButton = navigation.getElementsByClassName(`fa-envelope`)[0];
        if (esgst.inboxButton) {
          esgst.inboxButton = esgst.inboxButton.closest(`.nav__button-container, .nav_btn_container`);
          esgst.messageCountContainer = esgst.inboxButton.querySelector(`.nav__notification, .message_count`);
        }
        esgst.messageCount = esgst.messageCountContainer ? esgst.messageCountContainer.textContent : ``;
      }
    } else {
      esgst.inboxButton = navigation.getElementsByClassName(`fa-envelope`)[0];
      if (esgst.inboxButton) {
        esgst.inboxButton = esgst.inboxButton.closest(`.nav__button-container, .nav_btn_container`);
        esgst.messageCountContainer = esgst.inboxButton.querySelector(`.nav__notification, .message_count`);
      }
      esgst.messageCount = esgst.messageCountContainer ? esgst.messageCountContainer.textContent : ``;
    }
  }

  function hr_notifyChange(hr, notify) {
    let canvas, context, deliveredNotification, image, messageNotification, messageCount, notification, pointsNotification, title;
    messageCount = esgst.messageCount;
    if (messageCount !== hr.messageCount) {
      messageNotification = messageCount - hr.messageCount;
      if (messageNotification < 0) {
        messageNotification = 0;
      }
      hr.messageCount = messageCount;
    } else {
      messageNotification = 0;
    }
    if (messageCount > 0 && esgst.hr_m) {
      canvas = document.createElement(`canvas`);
      image = document.createElement(`img`);
      canvas.width = 16;
      canvas.height = 16;
      context = canvas.getContext(`2d`);
      image.crossOrigin = `esgst`;
      image.onload = () => {
        context.drawImage(image, 0, 0);
        context.fillStyle = `#e9202a`;
        context.fillRect(8, 6, 8, 10);
        context.fillStyle = `#fff`;
        context.font = `bold 10px Arial`;
        context.textAlign = `left`;
        if (messageCount > 9) {
          messageCount = `+`;
        }
        context.fillText(messageCount, 9, 14);
        esgst.favicon.href = canvas.toDataURL(`image/png`);
      };
      image.src = esgst.menuPath ? esgst.icon : esgst[`${esgst.name}Icon`];
    } else {
      esgst.favicon.href = esgst.menuPath ? esgst.icon : esgst[`${esgst.name}Icon`];
    }
    if (esgst.sg) {
      if (hr.points !== esgst.points) {
        hr.points = esgst.points;
        elgb_updateButtons(hr.points);
        if (esgst.points >= 400) {
          pointsNotification = true;
        }
      }
      title = ``;
      let delivered = esgst.wonButton.getElementsByClassName(`fade_infinite`)[0];
      if (delivered) {
        if (!hr.delivered) {
          deliveredNotification = true;
          hr.delivered = true;
        } else {
          deliveredNotification = false;
        }
      } else {
        hr.delivered = deliveredNotification = false;
      }
      if (esgst.hr_g && delivered) {
        title += `${esgst.hr_g_format} `;
      }
      if (esgst.hr_w && esgst.wishlist) {
        title += `${esgst.hr_w_format.replace(/#/, esgst.wishlist)} `;
      }
      if (esgst.hr_p) {
        title += `${esgst.hr_p_format.replace(/#/, esgst.points)} `;
      }
      title += esgst.originalTitle;
      if (document.title !== title) {
        document.title = title;
      }
    }
    if (notify) {
      notification = {
        msg: ``,
        inbox: false,
        wishlist: false,
        won: false
      };
      if (pointsNotification && esgst.hr_fp) {
        notification.msg += `You have ${esgst.points}P.\n\n`;
        notification.points = true;
      }
      if (messageNotification && esgst.hr_m && esgst.hr_m_n) {
        notification.msg += `You have ${messageNotification} new messages.\n\n`;
        notification.inbox = true;
      }
      if (deliveredNotification && esgst.hr_g && esgst.hr_g_n) {
        notification.msg += `You have new gifts delivered.\n\n`;
        notification.won = true;
      }
      if (esgst.wishlistNew && esgst.hr_w && esgst.hr_w_n) {
        if (esgst.hr_w_h) {
          notification.msg += `You have ${esgst.wishlistNew} new wishlist giveaways ending in ${esgst.hr_w_hours} hours.`;
        } else {
          notification.msg += `You have ${esgst.wishlistNew} new wishlist giveaways.`;
        }
        notification.wishlist = true;
      }
      if (notification.msg) {
        hr_showNotification(notification);
      }
    }
  }

  async function hr_showNotification(details) {
    console.log(details);
    let result = await Notification.requestPermission();
    if (result !== `granted`) {
      return;
    }
    if ((details.points && esgst.hr_fp_s) || (details.inbox && esgst.hr_m_n_s) || (details.wishlist && esgst.hr_w_n_s) || (details.won && esgst.hr_g_n_s)) {
      try {
        if (!esgst.audioContext) {
          esgst.audioContext = new AudioContext();
          let promises = [];
          [`hr_fp_s`, `hr_g_n_s`, `hr_m_n_s`, `hr_w_n_s`].forEach(id => {
            if (!esgst[id]) {
              promises.push(null);
              return;
            }
            promises.push(hr_createPlayer(esgst.settings[`${id}_sound`] || hr_getDefaultSound()));
          });
          [esgst.hr.pointsPlayer, esgst.hr.wonPlayer, esgst.hr.inboxPlayer, esgst.hr.wishlistPlayer] = await Promise.all(promises);
        }
        if (details.points && esgst.hr.pointsPlayer) {
          esgst.hr.pointsPlayer.play();
        }
        if (details.inbox && esgst.hr.inboxPlayer) {
          esgst.hr.inboxPlayer.play();
        }
        if (details.wishlist && esgst.hr.wishlistPlayer) {
          esgst.hr.wishlistPlayer.play();
        }
        if (details.won && esgst.hr.wonPlayer) {
          esgst.hr.wonPlayer.play();
        }
      } catch (e) {
        console.log(e);
        details.msg += `\n\nAn error happened when trying to play the sound.`;
      }
    }
    let notification = new Notification(`ESGST Notification`, {
      body: details.msg,
      icon: `https://dl.dropboxusercontent.com/s/lr3t3bxrxfxylqe/esgstIcon.ico?raw=1`,
      requireInteraction: esgst.hr_c,
      tag: details.msg
    });
    notification.onclick = () => {
      if (_USER_INFO.extension && esgst.hr_a) {
        browser.runtime.sendMessage({action: `tabs`, any: esgst.hr_a_a, inbox_sg: esgst.sg && details.inbox, inbox_st: esgst.st && details.inbox, refresh: esgst.hr_a_r, wishlist: details.wishlist, won: details.won});
      } else {
        if (details.inbox) {
          open(`/messages`);
        }
        if (details.wishlist) {
          open(`/giveaways/search?type=wishlist`);
        }
        if (details.won) {
          open(`/giveaways/won`);
        }
      }
      notification.close();
    };
  }

  // [HWLC]
  
  _MODULES.push({
    description: `
      <ul>
        <li>Adds a button (<i class="fa fa-list"></i>) to the right side of the first page heading of any trade that allows you to check the have/want list against your wishlisted/owned games, along with some filtering options.</li>
      </ul>
    `,
    id: `hwlc`,
    load: hwlc,
    name: `Have/Want List Checker`,
    st: true,
    type: `trades`
  });

  function hwlc() {
    if (!esgst.tradePath) {
      return;
    }
    let obj = {
      button: createHeadingButton({
        context: document.getElementsByClassName(`page_heading`)[0],
        id: `hwlc`,
        icons: [`fa-list`]
      })
    };
    obj.button.addEventListener(`click`, hwlc_openPopup.bind(null, obj));
  }

  function hwlc_openPopup(obj) {
    if (obj.popup) {
      obj.popup.open();
      return;
    }
    obj.popup = new Popup_v2({
      icon: `fa-list`,
      title: `Have/Want List Checker`,
      addScrollable: `left`
    });
    hwlc_addPanel(obj);
    obj.popup.open();
    setTimeout(() => hwlc_getGames(obj), 1000);
  }

  function hwlc_addPanel(obj) {
    obj.panel = obj.popup.getScrollable();
    obj.panel.classList.add(`esgst-hwlc-panel`, `markdown`);
    obj.sections = {};
    hwlc_addSection(obj, `have`, `want`);
    hwlc_addSection(obj, `want`, `have`);
  }

  function hwlc_addSection(obj, key, counterKey) {
    obj[key] = document.querySelector(`.${key}`);
    obj.panel.insertAdjacentHTML(`beforeEnd`, `
      <div class="esgst-hwlc-section">
        <h2>You ${counterKey}:</h2>
        <br>
        <textarea id="esgst-hwlc-${key}-textArea"></textarea>
        <br>
        <br>
        <h2>Matches (you ${counterKey} x they ${key}):</h2>
        <ul id="esgst-hwlc-${key}-matches">
          <i class="fa fa-circle-o-notch fa-spin"></i>
        </ul>
        <br>
        <h2>They ${key}:</h2>
        <ul id="esgst-hwlc-${key}-games">
          <i class="fa fa-circle-o-notch fa-spin"></i>
        </ul>
        <br>
        <h2>Unable to identify: <i class="fa fa-question-circle" title="You can report unidentified games in the ESGST thread so that exceptions can be added for them"></i></h2>
        <ul id="esgst-hwlc-${key}-unidentified">
          <i class="fa fa-circle-o-notch fa-spin"></i>
        </ul>
      </div>
    `);
    obj.sections[key] = {
      textArea: document.getElementById(`esgst-hwlc-${key}-textArea`),
      matches: document.getElementById(`esgst-hwlc-${key}-matches`),
      games: document.getElementById(`esgst-hwlc-${key}-games`),
      unidentified: document.getElementById(`esgst-hwlc-${key}-unidentified`)
    };
    obj.sections[key].textArea.addEventListener(`input`, hwlc_filter.bind(null, obj, key, null));
  }

  async function hwlc_getGames(obj) {
    const currentTime = Date.now();
    let cache = JSON.parse(getLocalValue(`hwlcCache`, `{"lastUpdate": 0}`));
    let json = null;
    if (currentTime - cache.lastUpdate > 604800000) {
      try {
        const response = await request({
          method: `GET`,
          url: `https://api.steampowered.com/ISteamApps/GetAppList/v2/`
        });
        cache = {
          data: response.responseText,
          lastUpdate: currentTime
        };
        setLocalValue(`hwlcCache`, JSON.stringify(cache));
      } catch (error) {
        alert(`Could not retrieve list of Steam games. Games will not be identified by name.`);
      }
    }
    json = JSON.parse(cache.data);
    obj.games = {};
    hwlc_addGames(obj, `have`, json);
    hwlc_addGames(obj, `want`, json);
  }

  async function hwlc_addGames(obj, key, json) {
    obj.games[key] = {
      apps: [],
      subs: []
    };
    const unidentified = [];
    const elements = getTextNodesIn(obj[key]);
    for (const element of elements) {
      const parent = element.parentElement;
      const striked = parent.closest(`del`);
      if (striked) {
        // Game assumed to no longer be available.
        continue;
      }
      const name = element.textContent.trim();
      const link = parent.closest(`a`);
      const url = link && link.getAttribute && link.getAttribute(`href`);
      if (url) {
        const match = url.match(/\/(app|sub)\/(\d+)/);
        if (match) {
          obj.games[key][`${match[1]}s`].push({
            id: parseInt(match[2]),
            name,
            parent
          });
          continue;
        }
      }
      if (!hwlc_tidyName(name)) {
        continue;
      }
      if (json) {
        const matches = json.applist.apps.filter(x => hwlc_formatName(x.name) === hwlc_formatName(name));
        if (matches.length) {
          obj.games[key].apps.push({
            id: matches[0].appid,
            name,
            parent
          });
          continue;
        }
      }
      if (unidentified.filter(x => x.name === name).length) {
        // Name has already been found (duplicate).
        continue;
      }
      unidentified.push({name, parent});
    }
    if (key === `want`) {
      try {
        const steamId = document.querySelector(`.author_name`).getAttribute(`href`).match(/\d+/)[0];
        const response = await request({
          method: `GET`,
          url: `http://store.steampowered.com/wishlist/profiles/${steamId}`
        });
        const responseText = response.responseText;
        const wishlistData = responseText.match(/g_rgWishlistData\s=\s(\[(.+?)\]);/);
        if (wishlistData) {
          const appInfo = responseText.match(/g_rgAppInfo\s=\s({(.+?)});/);
          const apps = appInfo ? JSON.parse(appInfo[1]) : null;
          JSON.parse(wishlistData[1]).forEach(item => {
            const id = parseInt(item.appid);
            if (apps && apps[id]) {
              obj.games[key].apps.push({
                id,
                name: apps[id].name,
                wishlisted: true
              });
            } else {
              obj.games[key].apps.push({
                id,
                name: `${id}`,
                wishlisted: true
              });
            }
          });
        }
      } catch (e) { /**/ }
    }
    for (const section in obj.sections[key]) {
      obj.sections[key][section].innerHTML = ``;
    }
    obj.games[key].apps = obj.games[key].apps.map(game => {
      if (game.wishlisted) {
        game.html = `
          <li>
            <i class="fa fa-star" title="On their wishlist"></i>
            <a href="https://store.steampowered.com/app/${game.id}">${game.name}</a>
          </li>
        `;
        return game;
      }
      if (esgst.games.apps[game.id]) {
        if (esgst.games.apps[game.id].owned) {
          game.owned = true;
          game.html = `
            <li>
              <i class="fa fa-folder" title="On your library"></i>
              <a href="https://store.steampowered.com/app/${game.id}">${game.name}</a>
            </li>
          `;
          return game;
        } else if (esgst.games.apps[game.id].wishlisted) {
          game.wishlisted = true;
          game.html = `
            <li>
              <i class="fa fa-star" title="On your wishlist"></i>
              <a href="https://store.steampowered.com/app/${game.id}">${game.name}</a>
            </li>
          `;
          return game;
        }
      }
      game.html = `
        <li>
          <a href="https://store.steampowered.com/app/${game.id}">${game.name}</a>
        </li>
      `;
      return game;
    }).sort(hwlc_sortGames);
    obj.games[key].subs = obj.games[key].subs.sort(hwlc_sortGames);
    for (const game of obj.games[key].apps) {
      obj.sections[key].games.insertAdjacentHTML(`beforeEnd`, game.html);
    }
    for (const game of obj.games[key].subs) {
      obj.sections[key].games.insertAdjacentHTML(`beforeEnd`, `
        <li>
          <i class="fa fa-suitcase" title="This is a package (packages are not checked for wishlisted/owned status)"></i>
          <a href="https://store.steampowered.com/sub/${game.id}">${game.name || game.id}</a>
        </li>
      `);
    }
    for (const game of unidentified) {
      obj.sections[key].unidentified.insertAdjacentHTML(`beforeEnd`, `
        <li>${game.name}</li>
      `);
    }
    for (const section in obj.sections[key]) {
      if (section === `textArea` || obj.sections[key][section].innerHTML) {
        continue;
      }
      obj.sections[key][section].innerHTML = `None.`;
    }
    const query = getLocalValue(`hwlc_${key}`);
    if (query) {
      obj.sections[key].textArea.value = query;
      hwlc_filter(obj, key);
    }
  }

  function hwlc_filter(obj, key) {
    obj.sections[key].matches.innerHTML = ``;
    const query = obj.sections[key].textArea.value;
    setLocalValue(`hwlc_${key}`, query);
    let found = [];
    const values = query.split(/\n/);
    for (let value of values) {
      value = value.trim().toLowerCase();
      if (!value) {
        continue;
      }
      obj.games[key].apps.filter(game => game.name.toLowerCase().match(value)).forEach(game => {
        if (found.filter(x => x.name === game.name).length) {
          return;
        }
        found.push({
          id: game.id,
          name: game.name,
          type: `app`
        });
      });
      obj.games[key].subs.filter(game => game.name.toLowerCase().match(value)).forEach(game => {
        if (found.filter(x => x.name === game.name).length) {
          return;
        }
        found.push({
          id: game.id,
          name: game.name,
          type: `sub`
        });
      });
    }
    found = found.sort(hwlc_sortGames);
    for (const game of found) {
      obj.sections[key].matches.insertAdjacentHTML(`beforeEnd`, `
        <li>
          <a href="https://store.steampowered.com/${game.type}/${game.id}">${game.name || game.id}</a>
        </li>
      `);
    }
    if (!obj.sections[key].matches.innerHTML) {
      obj.sections[key].matches.innerHTML = `None.`;
    }
  }

  function hwlc_tidyName(name) {
    return name
      .replace(/[^\w]/g, ``).toLowerCase()
      .replace(/steamkeys/, ``);
  }

  function hwlc_formatName(name) {
    return name
      .replace(/[^\w]/g, ``).toLowerCase()
      .replace(/windowsedition/, ``);
  }

  function hwlc_sortGames(a, b) {
    if (a.wishlisted && !b.wishlisted) {
      return -1;
    }
    if (!a.wishlisted && b.wishlisted) {
      return 1;
    }
    if (a.owned && !b.owned) {
      return 1;
    }
    if (!a.owned && b.owned) {
      return -1;
    }
    return a.name.localeCompare(b.name, {
      sensitivity: `base`
    });
  }

  // [LPL]

  _MODULES.push({
    description: `
      <ul>
        <li>Adds a "Last Page" link to the pagination navigation of some pages that do not have it. For example: discussion pages with 100+ pages, user pages, group pages with 100+ pages, etc...</li>
      </ul>
    `,
    id: `lpl`,
    load: lpl,
    name: `Last Page Link`,
    sg: true,
    type: `general`
  });

  function lpl() {
    if (!esgst.paginationNavigation) return;
    if (esgst.discussionPath) {
      lpl_addDiscussionLink();
    } else if (esgst.userPath) {
      lpl_addUserLink();
    } else if (esgst.groupPath) {
      lpl_addGroupLink();
    }
  }

  function lpl_getLastPage(context, main, discussion, user, userWon, group, groupUsers, groupWishlist) {
    let element, first, lastPage, pagination, paginationNavigation, paginationResults, second, third;
    pagination = context.getElementsByClassName(`pagination`)[0];
    paginationResults = context.getElementsByClassName(`pagination__results`)[0];
    paginationNavigation = context.getElementsByClassName(`pagination__navigation`)[0];
    if (paginationNavigation) {
      element = paginationNavigation.lastElementChild;
      if (element.textContent.match(/Last/)) {
        lastPage = parseInt(element.getAttribute(`data-page-number`));
      } else if ((main && esgst.discussionPath) || discussion) {
        if (pagination) {
          lastPage = Math.ceil(parseInt(pagination.firstElementChild.lastElementChild.textContent.replace(/,/g, ``)) / 25);
        } else {
          lastPage = 999999999;
        }
      } else if ((main && esgst.userPath) || user) {
        if ((main && location.pathname.match(/\/giveaways\/won/)) || userWon) {
          lastPage = Math.ceil(parseInt(context.querySelector(`.featured__table__row__right a[href*="/giveaways/won"]`).textContent.replace(/,/g, ``)) / 25);
        } else {
          lastPage = Math.ceil(parseInt(context.getElementsByClassName(`sidebar__navigation__item__count`)[0].textContent.replace(/,/g, ``)) / 25);
        }
      } else if ((main && esgst.groupPath) || group) {
        if ((main && location.pathname.match(/\/users/)) || groupUsers) {
          lastPage = Math.ceil(parseInt(context.getElementsByClassName(`sidebar__navigation__item__count`)[1].textContent.replace(/,/g, ``)) / 25);
        } else if ((main && esgst.groupWishlistPath) || groupWishlist) {
          lastPage = 999999999;
        } else {
          lastPage = Math.ceil(parseInt(context.getElementsByClassName(`sidebar__navigation__item__count`)[0].textContent.replace(/,/g, ``)) / 25);
        }
      } else {
        lastPage = 999999999;
      }
    } else {
      lastPage = 999999999;
    }
    if (lastPage === 999999999 && paginationResults) {
      first = paginationResults.firstElementChild;
      if (first) {
        second = first.nextElementSibling;
        if (second) {
          third = second.nextElementSibling;
          if (third && !third.textContent.match(/Giveaway\sFilters/)) {
            lastPage = Math.ceil(parseInt(third.textContent.replace(/,/g, ``)) / parseInt(second.textContent.replace(/,/g, ``)));
          }
        }
      }
    }
    return lastPage;
  }

  function lpl_addDiscussionLink() {
    let lastLink, url;
    url = `${location.pathname.replace(`/search`, ``)}/search?page=${esgst.lastPage}`;
    esgst.lastPageLink = `
      <a data-page-number="${esgst.lastPage}" href="${url}">
        <span>Last</span>
        <i class="fa fa-angle-double-right"></i>
      </a>
    `;
    lastLink = esgst.paginationNavigation.lastElementChild;
    if (!lastLink.classList.contains(`is-selected`) && !lastLink.textContent.match(/Last/)) {
      esgst.paginationNavigation.insertAdjacentHTML(`beforeEnd`, esgst.lastPageLink);
    }
  }

  function lpl_addUserLink() {
    let lastLink, url, username;
    username = location.pathname.match(/^\/user\/(.+?)(\/.*?)?$/)[1];
    if (location.pathname.match(/\/giveaways\/won/)) {
      url = `/user/${username}/giveaways/won/search?page=${esgst.lastPage}`;
    } else {
      url = `/user/${username}/search?page=${esgst.lastPage}`;
    }
    esgst.lastPageLink = `
      <a data-page-number="${esgst.lastPage}" href="${url}">
        <span>Last</span>
        <i class="fa fa-angle-double-right"></i>
      </a>
    `;
    lastLink = esgst.paginationNavigation.lastElementChild;
    if (esgst.currentPage !== esgst.lastPage && !lastLink.classList.contains(`is-selected`) && !lastLink.textContent.match(/Last/)) {
      esgst.paginationNavigation.insertAdjacentHTML(`beforeEnd`, esgst.lastPageLink);
    }
  }

  function lpl_addGroupLink() {
    let group, lastLink, url;
    group = location.pathname.match(/^\/group\/(.+?\/.+?)(\/.*?)?$/)[1];
    if (location.pathname.match(/\/users/)) {
      url = `/group/${group}/users/search?page=${esgst.lastPage}`;
    } else if (esgst.groupWishlistPath) {
      url = `/group/${group}/wishlist/search?page=${esgst.lastPage}`;
    } else {
      url = `/group/${group}/search?page=${esgst.lastPage}`;
    }
    esgst.lastPageLink = `
      <a data-page-number="${esgst.lastPage}" href="${url}">
        <span>Last</span>
        <i class="fa fa-angle-double-right"></i>
      </a>
    `;
    lastLink = esgst.paginationNavigation.lastElementChild;
    if (esgst.currentPage !== esgst.lastPage && !lastLink.classList.contains(`is-selected`) && !lastLink.textContent.match(/Last/)) {
      esgst.paginationNavigation.insertAdjacentHTML(`beforeEnd`, esgst.lastPageLink);
    }
  }

  // LPV

  _MODULES.push({
    conflicts: [
      {id: `pv`, name: `Points Visualizer`}
    ],
    description: `
      <ul>
        <li>Displays a green bar in the account button at the header of any page that represents your level progress.</li>
        <li>Also displays a lighter green bar, if you have any giveaways open, to estimate what your level will be when the giveaways are marked as received. If you hover over the account button, it shows the number of the estimated level.</li>
      </ul>
    `,
    id: `lpv`,
    load: lpv,
    name: `Level Progress Visualizer`,
    sg: true,
    sync: `Giveaways, Reduced CV Games and No CV Games`,
    type: `general`
  });

  function lpv() {
    if (esgst.hr) return;
    lpv_setStyle();
  }

  function lpv_setStyle() {
    const currentLevel = parseFloat(esgst.levelContainer.getAttribute(`title`));
    const currentBase = parseInt(currentLevel);
    if (currentBase === 10) {
      return;
    }
    let cache = JSON.parse(getLocalValue(`lpvCache`, `{}`));
    if (!cache.level) {
      cache = {
        difference: 0,
        level: currentLevel
      };
    }
    cache.difference += round(currentLevel - cache.level);
    cache.difference = round(cache.difference);
    cache.level = currentLevel;
    setLocalValue(`lpvCache`, JSON.stringify(cache));
    const currentPercentage = parseInt(round(currentLevel - currentBase) * 100);
    const currentProgress = parseInt(currentPercentage * 1.86); // 186px is the width of the button
    const firstBar = `${currentProgress}px`;
    const secondBar = `${Math.max(0, currentProgress - 157)}px`; // 157px is the width of the button without the arrow
    let projectedFirstBar = `0`;
    let projectedSecondBar = `0`;
    const cv = lpv_getCv();
    if (cv > 0) {
      // the formula is: current_percentage + (real_cv_to_gain / real_cv_difference),
      // where real_cv_difference is the real CV difference between the next level and the current one
      const prediction = round(currentPercentage + (round(cv) / [0.01, 25, 50, 100, 150, 250, 500, 1000, 1000, 2000][currentBase] * 100));
      const newLevel = round(Math.min(10, round(currentBase + (prediction / 100))) - cache.difference);
      const newBase = parseInt(newLevel);
      const newPercentage = parseInt(round(newLevel - newBase) * 100);
      const newProgress = parseInt(Math.min(100, newPercentage) * 1.86);
      projectedFirstBar = `${newProgress}px`;
      projectedSecondBar = `${Math.max(0, newProgress - 157)}px`;
      esgst.levelContainer.title = getFeatureTooltip(`lpv`, `${esgst.levelContainer.getAttribute(`title`)} (${newLevel})`);
    }
    if (!esgst.lpvStyle) {
      esgst.lpvStyle = insertHtml(esgst.style, `afterEnd`, `<style id="esgst-lpv-style"></style>`);
    }
    esgst.lpvStyle.innerHTML = `
      .esgst-lpv-container {
        background-image: linear-gradient(to right, var(--esgst-lpv-bar, #609f60) ${firstBar}, var(--esgst-lpv-bar-projected, rgba(96, 159, 96, 0.5)) ${firstBar}, var(--esgst-lpv-bar-projected, rgba(96, 159, 96, 0.5)) ${projectedFirstBar}, transparent ${firstBar}), var(--esgst-lpv-button, linear-gradient(#8a92a1 0px, #757e8f 8px, #4e5666 100%)) !important;
      }
      .esgst-lpv-container .nav__button--is-dropdown:hover {
        background-image: linear-gradient(to right, var(--esgst-lpv-bar-hover, #6dac6d) ${firstBar}, var(--esgst-lpv-bar-hover-projected, rgba(122, 185, 122, 0.5)) ${firstBar}, var(--esgst-lpv-bar-hover-projected, rgba(122, 185, 122, 0.5)) ${projectedFirstBar}, transparent ${firstBar}), var(--esgst-lpv-button-hover, linear-gradient(#9ba2b0 0px, #8c94a3 8px, #596070 100%)) !important;
      }
      .esgst-lpv-container .nav__button--is-dropdown-arrow:hover {
        background-image: linear-gradient(to right, var(--esgst-lpv-bar-hover, #6dac6d) ${secondBar}, var(--esgst-lpv-bar-hover-projected, rgba(122, 185, 122, 0.5)) ${secondBar}, var(--esgst-lpv-bar-hover-projected, rgba(122, 185, 122, 0.5)) ${projectedSecondBar}, transparent ${secondBar}), var(--esgst-lpv-button-hover, linear-gradient(#9ba2b0 0px, #8c94a3 8px, #596070 100%)) !important;
      }
      .esgst-lpv-container .nav__button--is-dropdown-arrow.is-selected {
        background-image: linear-gradient(to right, var(--esgst-lpv-bar, #609f60) ${secondBar}, var(--esgst-lpv-bar-projected, rgba(96, 159, 96, 0.5)) ${secondBar}, var(--esgst-lpv-bar-projected, rgba(96, 159, 96, 0.5)) ${projectedSecondBar}, transparent ${secondBar}), var(--esgst-lpv-arrow, linear-gradient(#4e525f 0px, #434857 5px, #2b2e3a 100%)) !important;
      }
      .esgst-lpv-container.is-selected .nav__button--is-dropdown {
        background-image: linear-gradient(to right, var(--esgst-lpv-bar-hover, #6dac6d) ${firstBar}, var(--esgst-lpv-bar-hover-projected, rgba(122, 185, 122, 0.5)) ${firstBar}, var(--esgst-lpv-bar-hover-projected, rgba(122, 185, 122, 0.5)) ${projectedFirstBar}, transparent ${firstBar}), var(--esgst-lpv-button-selected, linear-gradient(#d0d5de 0px, #c9cdd7 5px, #9097a6 100%)) !important;
      }
      .esgst-lpv-container.is-selected .nav__button--is-dropdown-arrow {
        background-image: linear-gradient(to right, var(--esgst-lpv-bar-hover, #6dac6d) ${secondBar}, var(--esgst-lpv-bar-hover-projected, rgba(122, 185, 122, 0.5)) ${secondBar}, var(--esgst-lpv-bar-hover-projected, rgba(122, 185, 122, 0.5)) ${projectedSecondBar}, transparent ${secondBar}), var(--esgst-lpv-button-selected, linear-gradient(#d0d5de 0px, #c9cdd7 5px, #9097a6 100%)) !important;
      }
      .esgst-lpv-container.is-selected .nav__button--is-dropdown:hover {
        background-image: linear-gradient(to right, var(--esgst-lpv-bar-selected, #7ab97a) ${firstBar}, var(--esgst-lpv-bar-selected-projected, rgba(147, 210, 147, 0.5)) ${firstBar}, var(--esgst-lpv-bar-selected-projected, rgba(147, 210, 147, 0.5)) ${projectedFirstBar}, transparent ${firstBar}), var(--esgst-lpv-button-selected-hover, linear-gradient(#f0f1f5 0px, #d1d4de 100%)) !important;
      }
      .esgst-lpv-container.is-selected .nav__button--is-dropdown-arrow:hover:not(.is-selected) {
        background-image: linear-gradient(to right, var(--esgst-lpv-bar-selected, #7ab97a) ${secondBar}, var(--esgst-lpv-bar-selected-projected, rgba(147, 210, 147, 0.5)) ${secondBar}, var(--esgst-lpv-bar-selected-projected, rgba(147, 210, 147, 0.5)) ${projectedSecondBar}, transparent ${secondBar}), var(--esgst-lpv-button-selected-hover, linear-gradient(#f0f1f5 0px, #d1d4de 100%)) !important;
      }
      .esgst-lpv-container.is-selected .nav__button--is-dropdown-arrow.is-selected {
        background-image: linear-gradient(to right, var(--esgst-lpv-bar-selected, #7ab97a) ${secondBar}, var(--esgst-lpv-bar-selected-projected, rgba(147, 210, 147, 0.5)) ${secondBar}, var(--esgst-lpv-bar-selected-projected, rgba(147, 210, 147, 0.5)) ${projectedSecondBar}, transparent ${secondBar}), var(--esgst-lpv-arrow-selected, linear-gradient(#4e525f 0px, #434857 5px, #2b2e3a 100%)) !important;
      }
    `;
    esgst.mainButton.parentElement.classList.add(`esgst-lpv-container`);
  }

  function lpv_getCv() {
    let cv = 0;
    const user = esgst.users.users[esgst.steamId];
    if (!user) {
      return cv;
    }
    const giveaways = user.giveaways;
    if (!giveaways) {
      return cv;
    }
    const currentTime = Date.now();
    for (const type of [`apps`, `subs`]) {
      const items = giveaways.sent[type];
      for (const id in items) {
        let open = 0;
        let sent = 0;
        let value = 0;
        for (const code of items[id]) {
          const giveaway = esgst.giveaways[code];
          if (!giveaway) {
            continue;
          }
          value = giveaway.points;
          if (currentTime < giveaway.endTime || !giveaway.started) {
            // giveaway is open or has not started yet
            open += giveaway.copies;
          } else {
            // giveaway is closed
            if (giveaway.entries >= 5 || (!giveaway.inviteOnly && !giveaway.group && !giveaway.whitelist)) {
              // giveaway counts for cv
              if (Array.isArray(giveaway.winners)) {
                // user is using the new database, which is more accurate
                for (const winner of giveaway.winners) {
                  if (winner.status === `Received`) {
                    sent += 1;
                  }
                }
              } else if (giveaway.winners > 0) {
                // user is using the old database, not very accurate
                sent += Math.min(giveaway.entries, giveaway.winners);
              }
            }
          }
        }
        const game = esgst.games[type][id];
        if (game) {
          if (game.noCV) {
            // game gives no cv
            value = 0;
          } else if (game.reducedCV) {
            // game gives reduced cv (15% of the value)
            value *= 0.15;
          }
        }
        if (sent > 5 || sent + open > 5) {
          // after 5 copies each next copy is worth only 90% of the previous value
          for (let i = sent - 5; i > 0; i--) {
            value *= 0.90;
          }
          for (let i = open; i > 0; i--) {
            value *= 0.90;
            cv += value;
          }
        } else {
          cv += (value * open);
        }
      }
    }
    return cv;
  }

  // [MGC]

  _MODULES.push({
    description: `
      <ul>
        <li>Adds a section 0 to the <a href="https://www.steamgifts.com/giveaways/new">new giveaway</a> page that allows you to create multiple giveaways at once.</li>
        <li>There is also a special tool to create a train (multiple giveaways linked to each other), which has the option to automatically create a discussion for the train.</li>
        <li>The icon <i class="fa fa-question-circle"></i> next to "Create Multiple Giveaways" in the section contains all of the steps that you have to follow to use the feature correctly.</li>
        <li>When you add a giveaway to the queue, a small numbered box appears at the panel below the buttons to represent that giveaway. If you hover over the box it shows the details of the giveaway.</li>
        <li>You can re-order/remove a giveaway by dragging and dropping the box.</li>
        <li>The giveaways will be created without reviewing or validating, so make sure that all of the fields were filled correctly or the creation will fail (if a train is being created, the failed giveaway will be disconnected and the previous giveaway will be connected to the next one instead).</li>
      </ul>
    `,
    id: `mgc`,
    load: mgc,
    name: `Multiple Giveaway Creator`,
    sg: true,
    type: `giveaways`
  });

  async function mgc() {
    if (esgst.newGiveawayPath) {
      mgc_addSection();
    }
    if (esgst.newDiscussionPath) {
      if ((getLocalValue(`mgcAttach_step1`) || getLocalValue(`mgcAttach_step2`))) {
        delLocalValue(`mgcAttach_step1`);
        delLocalValue(`mgcAttach_step2`);
        mgc_addCreateAndAttachButton();
      }
    } else if (esgst.editDiscussionPath) {
      if (getLocalValue(`mgcAttach_step4`)) {
        mgc_editDiscussion();
      }
    } else if (esgst.discussionPath) {
      if (getLocalValue(`mgcAttach_step2`)) {
        delLocalValue(`mgcAttach_step2`);
        setLocalValue(`mgcAttach_step3`, location.pathname.match(/\/discussion\/(.+?)\//)[1]);
        await request({data: `xsrf_token=${esgst.xsrfToken}&do=close_discussion`, method: `POST`, url: location.href});
        close();
      } else if (getLocalValue(`mgcAttach_step4`)) {
        document.querySelector(`form[action="/discussions/edit"]`).submit();
      } else if (getLocalValue(`mgcAttach_step5`)) {
        delLocalValue(`mgcAttach_step5`);
        await request({data: `xsrf_token=${esgst.xsrfToken}&do=reopen_discussion`, method: `POST`, url: location.href});
        setLocalValue(`mgcAttach_step6`, true);
        location.reload();
      } else if (getLocalValue(`mgcAttach_step6`)) {
        delLocalValue(`mgcAttach_step6`);
        new Popup(`fa-check`, `Train created with success! You can close this now.`, true).open();
      }
    }
  }

  function mgc_addSection() {
    let addButton, attachButton, createButton, createTrainDescription, createTrainOption, detach, emptyButton, exportButton, importButton, mgc, removeIcon, rows, section, shuffleButton, viewButton;
    rows = document.getElementsByClassName(`form__rows`)[0];
    if (rows) {
      mgc = {
        countries: document.querySelector(`[name="country_item_string"]`),
        gameId: document.querySelector(`[name="game_id"]`),
        gameType: document.querySelector(`[name="type"]`),
        copies: document.querySelector(`[name="copies"]`),
        keys: document.querySelector(`[name="key_string"]`),
        startTime: document.querySelector(`[name="start_time"]`),
        endTime: document.querySelector(`[name="end_time"]`),
        region: document.querySelector(`[name="region_restricted"]`),
        whoCanEnter: document.querySelector(`[name="who_can_enter"]`),
        whitelist: document.querySelector(`.form__row--who-can-enter [name="whitelist"]`),
        groups: document.querySelector(`[name="group_item_string"]`),
        level: document.querySelector(`[name="contributor_level"]`),
        description: document.querySelector(`[name="description"]`),
        timezone: new Date().getTimezoneOffset(),
        datas: [],
        values: [],
        created: [],
        countryNames: {},
        groupNames: {}
      };
      let elements = document.querySelector(`[data-input="country_item_string"]`).querySelectorAll(`[data-item-id]`);
      for (let i = 0, n = elements.length; i < n; i++) {
        let element = elements[i];
        mgc.countryNames[element.getAttribute(`data-item-id`)] = element.getAttribute(`data-name`);
      }
      elements = document.querySelector(`[data-input="group_item_string"]`).querySelectorAll(`[data-item-id]`);
      for (let i = 0, n = elements.length; i < n; i++) {
        let element = elements[i];
        mgc.groupNames[element.getAttribute(`data-item-id`)] = element.getAttribute(`data-name`);
      }
      mgc.gameName = mgc.gameId.nextElementSibling;
      let context = insertHtml(rows, `afterBegin`, `
        <div class="esgst-form-row" title="${getFeatureTooltip(`mgc`)}">
          <div class="esgst-form-heading">
            <div class="esgst-form-heading-number">0.</div>
            <div class="esgst-form-heading-text">
              Create Multiple Giveaways <i class="fa fa-question-circle esgst-clickable"></i>
            </div>
          </div>
          <div class="esgst-gm-section esgst-form-row-indent">
            <div>
              <div></div>
              <div class="esgst-hidden">
                <div></div>
              </div>
            </div>
          </div>
        </div>
      `);
      section = context.lastElementChild;
      createTooltip(context.firstElementChild.lastElementChild.lastElementChild, `
        <div class="esgst-bold">How To Use</div>
        <ol>
          <li>If you want to create a train, enable 'Create train', otherwise go to step 3.</li>
          <li>If you want to attach a discussion to the train, click 'Attach' and follow the steps.</li>
          <li>Fill the details of the giveaway (you can use Giveaway Templates for this).</li>
          <li>If you are creating a train, you must generate next/previous links by clicking 'Generate' and following the steps, otherwise go to the next step.</li>
          <li>If you want to add a counter to the giveaways, click 'Generate' and follow the steps.</li>
          <li>You can either add each giveaway at a time, by typing the game name, filling the copies/keys fields and clicking 'Add', or all giveaways at the same time, by clicking 'Import' and following the steps.</li>
          <li>If you want to play with the order of the giveaways you can use 'Shuffle' to change their order.</li>
          <li>When you have added all the giveaways and are ready to create them, click 'Create' and wait until the process is done.</li>
        </ol>
        <div>You can add certain variables to the description of the giveaways (before clicking 'Add') that will be replaced with certain details for each giveaway:</div>
        <ul>
          <li>[esgst-level] - The level of the giveaway.</li>
          <li>[esgst-name] - The name of the game being given away.</li>
          <li>[esgst-steam-id] - The Steam app/sub id of the game being given away.</li>
          <li>[esgst-steam-type] - The Steam type of the game being given away ("app" or "sub").</li>
          <li>[esgst-steam-url] - The Steam store URL of the game being given away (https://store.steampowered.com/type/id).</li>
        </ul>
      `);
      createTrainOption = section.firstElementChild;
      createTrainDescription = createTrainOption.lastElementChild;
      if (esgst.mgc_createTrain) {
        createTrainDescription.classList.remove(`esgst-hidden`);
      }
      esgst.mgc_createTrainSwitch = new ToggleSwitch(createTrainOption.firstElementChild, `mgc_createTrain`, false, `Create train.`, false, false, null, esgst.mgc_createTrain);
      esgst.mgc_createTrainSwitch.dependencies.push(createTrainDescription);
      esgst.mgc_removeLinksSwitch = new ToggleSwitch(createTrainDescription.firstElementChild, `mgc_removeLinks`, false, `Remove previous/next links from the first/last wagons.`, false, false, `Disabling this keeps the links as plain text.`, esgst.mgc_removeLinks);
      let generateButton = new ButtonSet(`green`, `grey`, `fa-gear`, `fa-circle-o-notch fa-spin`, `Generate`, `Generating...`, mgc_generateFormat);
      mgc.editButton = new ButtonSet(`green`, `grey`, `fa-edit`, `fa-circle-o-notch fa-spin`, `Edit`, `Editing...`, mgc_getValues.bind(null, true, mgc));
      mgc.editButton.set.classList.add(`esgst-hidden`);
      addButton = new ButtonSet(`green`, `grey`, `fa-plus-circle`, `fa-circle-o-notch fa-spin`, `Add`, `Adding...`, mgc_getValues.bind(null, false, mgc));
      importButton = new ButtonSet(`green`, `grey`, `fa-arrow-circle-up`, `fa-circle-o-notch fa-spin`, `Import`, `Importing...`, mgc_importGiveaways.bind(null, mgc));
      exportButton = new ButtonSet(`green`, `grey`, `fa-arrow-circle-down`, `fa-circle-o-notch fa-spin`, `Export`, `Exporting...`, mgc_exportGiveaways.bind(null, mgc));
      shuffleButton = new ButtonSet(`green`, `grey`, `fa-random`, `fa-circle-o-notch fa-spin`, `Shuffle`, `Shuffling...`, mgc_shuffleGiveaways.bind(null, mgc));
      emptyButton = new ButtonSet(`green`, `grey`, `fa-trash`, `fa-circle-o-notch fa-spin`, `Empty`, `Emptying...`, mgc_emptyGiveaways.bind(null, mgc));
      attachButton = new ButtonSet(`green`, `grey`, `fa-paperclip`, `fa-circle-o-notch fa-spin`, `Attach`, `Attaching...`, mgc_attachDiscussion.bind(null, mgc));
      esgst.mgc_createTrainSwitch.dependencies.push(attachButton.set);
      if (!esgst.mgc_createTrain) {
        attachButton.set.classList.add(`esgst-hidden`);
      }
      viewButton = new ButtonSet(`green`, `grey`, `fa-eye`, `fa-circle-o-notch fa-spin`, `View Results`, `Opening...`, mgc_viewResults.bind(null, mgc));
      createButton = new ButtonSet(`green`, `grey`, `fa-arrow-circle-right`, `fa-circle-o-notch fa-spin`, `Create`, `Creating...`, mgc_createGiveaways.bind(null, mgc, viewButton));
      viewButton.set.classList.add(`esgst-hidden`);
      section.appendChild(generateButton.set);
      section.appendChild(mgc.editButton.set);
      section.appendChild(addButton.set);
      section.appendChild(importButton.set);
      section.appendChild(exportButton.set);
      section.appendChild(shuffleButton.set);
      section.appendChild(emptyButton.set);
      section.appendChild(attachButton.set);
      section.appendChild(createButton.set);
      section.appendChild(viewButton.set);
      mgc.discussionPanel = insertHtml(section, `beforeEnd`, `
        <div class="esgst-hidden">
          <span class="esgst-bold">Discussion Attached:</span> <a></a> <i class="esgst-clickable fa fa-times" title="Detach discussion"></i>
        </div>
      `);
      detach = mgc.discussionPanel.lastElementChild;
      detach.addEventListener(`click`, mgc_detachDiscussion.bind(null, mgc));
      mgc.discussionLink = detach.previousElementSibling;
      new ToggleSwitch(mgc.discussionPanel, `mgc_bumpLast`, false, `Only insert the bump link in the last wagon.`, false, false, `If disabled, the bump link will appear on all wagons.`, esgst.mgc_bumpLast);
      mgc.giveaways = insertHtml(section, `beforeEnd`, `
        <div class="pinned-giveaways__outer-wrap">
          <div class="pinned-giveaways__inner-wrap"></div>
          <i class="fa fa-trash" title="Drag a giveaway here to remove it"></i>
          <div class="esgst-description">To edit a giveaway, click on it and a "Edit" button will appear. Then make your alterations and click "Edit".</div>
          <div class="esgst-description">Giveaways successfully created will turn green, giveaways successfully connected will be strikethrough (for train creations) and giveaways that were not successfully created will turn red.</div>
        </div>
      `).firstElementChild;
      removeIcon = mgc.giveaways.nextElementSibling;
      removeIcon.addEventListener(`dragenter`, mgc_removeGiveaway.bind(null, mgc));
      JSON.parse(getLocalValue(`mgcCache`, `[]`)).forEach(values => {
        mgc_addGiveaway(false, mgc, values);
      });
    }
  }

  function mgc_generateFormat(callback) {
    callback();
    let popup = new Popup(`fa-gear`, `Generate formats:`);
    popup.description.insertAdjacentHTML(`afterBegin`, `<div class="esgst-description">1. Generate the format you want by editing the input fields (the text outside of the blue box is what the result will look like).<br>2. Copy the text inside of the blue box (you can use the copy icon for that).<br>3. Paste it in the giveaway description (section 8 in this page), wherever you want it to appear.</div>`);
    let inputs = {};
    popup.scrollable.insertAdjacentHTML(`beforeEnd`, `<div class="esgst-bold">Next/previous links</div>`);
    inputs.previousPrefix = insertHtml(popup.scrollable, `beforeEnd`, `<input class="esgst-mgc-input" placeholder="← " type="text">`);
    inputs.previous = insertHtml(popup.scrollable, `beforeEnd`, `<input class="esgst-mgc-input" placeholder="Previous" type="text">`);
    inputs.previousSuffix = insertHtml(popup.scrollable, `beforeEnd`, `<input class="esgst-mgc-input" placeholder=" ←" type="text">`);
    inputs.separator = insertHtml(popup.scrollable, `beforeEnd`, `<input class="esgst-mgc-input" placeholder=" | " type="text">`);
    inputs.nextPrefix = insertHtml(popup.scrollable, `beforeEnd`, `<input class="esgst-mgc-input" placeholder="→ " type="text">`);
    inputs.next = insertHtml(popup.scrollable, `beforeEnd`, `<input class="esgst-mgc-input" placeholder="Next" type="text">`);
    inputs.nextSuffix = insertHtml(popup.scrollable, `beforeEnd`, `<input class="esgst-mgc-input" placeholder=" →" type="text">`);
    let output = insertHtml(popup.scrollable, `beforeEnd`, `
      <div class="esgst-mgc-preview esgst-text-left markdown">
        <div>
          <p>← <a href="#">Previous</a> ← | → <a href="#">Next</a> → </p>
        </div>
        <br>
        <pre><code>[ESGST-P]← [P]Previous[/P] ←[/ESGST-P] | [ESGST-N]→ [N]Next[/N] →[/ESGST-N]</code></pre>
        <i class="esgst-clickable fa fa-copy"></i>
      </div>
    `);
    let outputPreview = output.firstElementChild;
    let outputCopy = output.lastElementChild;
    let outputCode = outputCopy.previousElementSibling.firstElementChild;
    outputCopy.addEventListener(`click`, () => {
      copyValue(outputCopy, outputCode.textContent);
    });
    popup.scrollable.insertAdjacentHTML(`beforeEnd`, `<div class="esgst-bold">Counter</div>`);
    inputs.counter = insertHtml(popup.scrollable, `beforeEnd`, `<input class="esgst-mgc-input" placeholder=" of " type="text">`);
    let counterOutput = insertHtml(popup.scrollable, `beforeEnd`, `
      <div class="esgst-mgc-preview esgst-text-left markdown">
        <div>
          <p>1 of 10</p>
        </div>
        <br>
        <pre><code>[ESGST-C] of [/ESGST-C]</code></pre>
        <i class="esgst-clickable fa fa-copy"></i>
      </div>
    `);
    let counterOutputPreview = counterOutput.firstElementChild;
    let counterOutputCopy = counterOutput.lastElementChild;
    let counterOutputCode = counterOutputCopy.previousElementSibling.firstElementChild;
    counterOutputCopy.addEventListener(`click`, () => {
      copyValue(counterOutputCopy, counterOutputCode.textContent);
    });
    popup.scrollable.insertAdjacentHTML(`beforeEnd`, `<div class="esgst-bold">Bump link (for attached discussions)</div>`);
    inputs.bump = insertHtml(popup.scrollable, `beforeEnd`, `<input class="esgst-mgc-input" placeholder="Bump" type="text">`);
    let bumpOutput = insertHtml(popup.scrollable, `beforeEnd`, `
      <div class="esgst-mgc-preview esgst-text-left markdown">
        <div>
          <p><a href="#">Bump</a></p>
        </div>
        <br>
        <pre><code>[ESGST-B]Bump[/ESGST-B]</code></pre>
        <i class="esgst-clickable fa fa-copy"></i>
      </div>
    `);
    let bumpOutputPreview = bumpOutput.firstElementChild;
    let bumpOutputCopy = bumpOutput.lastElementChild;
    let bumpOutputCode = bumpOutputCopy.previousElementSibling.firstElementChild;
    popup.scrollable.insertAdjacentHTML(`beforeEnd`, `<div class="esgst-bold">First train wagon link (for attached discussions)</div>`);
    inputs.train = insertHtml(popup.scrollable, `beforeEnd`, `<input class="esgst-mgc-input" placeholder="Choo choo!" type="text">`);
    let trainOutput = insertHtml(popup.scrollable, `beforeEnd`, `
      <div class="esgst-mgc-preview esgst-text-left markdown">
        <div>
          <p><a href="#">Choo choo!</a></p>
        </div>
        <br>
        <pre><code>[ESGST-T]Choo choo![/ESGST-T]</code></pre>
        <i class="esgst-clickable fa fa-copy"></i>
      </div>
    `);
    let trainOutputPreview = trainOutput.firstElementChild;
    let trainOutputCopy = trainOutput.lastElementChild;
    let trainOutputCode = trainOutputCopy.previousElementSibling.firstElementChild;
    trainOutputCopy.addEventListener(`click`, () => {
      copyValue(trainOutputCopy, trainOutputCode.textContent);
    });
    for (let key in inputs) {
      let input = inputs[key];
      input.addEventListener(`input`, () => {
        if (key === `counter`) {
          counterOutputCode.textContent = `[ESGST-C]${input.value}[/ESGST-C]`;
          counterOutputPreview.innerHTML = parseMarkdown(`1${input.value}10`);
        } else if (key === `bump`) {
          bumpOutputCode.textContent = `[ESGST-B]${input.value}[/ESGST-B]`;
          bumpOutputPreview.innerHTML = parseMarkdown(`[${input.value}](#)`);
        } else if (key === `train`) {
          trainOutputCode.textContent = `[ESGST-B]${input.value}[/ESGST-B]`;
          trainOutputPreview.innerHTML = parseMarkdown(`[${input.value}](#)`);
        } else {
          let markdown = ``;
          let text = ``;
          if (inputs.previousPrefix.value || inputs.previousSuffix.value) {
            text += `[ESGST-P]${inputs.previousPrefix.value}[P]${inputs.previous.value}[/P]${inputs.previousSuffix.value}[/ESGST-P]`;
            markdown += `${inputs.previousPrefix.value}[${inputs.previous.value}](#)${inputs.previousSuffix.value}`;
          } else {
            text += `[ESGST-P]${inputs.previous.value}[/ESGST-P]`;
            markdown += `[${inputs.previous.value}](#)`;
          }
          if (inputs.separator.value) {
            text += inputs.separator.value;
            markdown += inputs.separator.value;
          }
          if (inputs.nextPrefix.value || inputs.nextSuffix.value) {
            text += `[ESGST-N]${inputs.nextPrefix.value}[N]${inputs.next.value}[/N]${inputs.nextSuffix.value}[/ESGST-N]`;
            markdown += `${inputs.nextPrefix.value}[${inputs.next.value}](#)${inputs.nextSuffix.value}`;
          } else {
            text += `[ESGST-N]${inputs.next.value}[/ESGST-N]`;
            markdown += `[${inputs.next.value}](#)`;
          }
          outputCode.textContent = text;
          outputPreview.innerHTML = parseMarkdown(markdown);
        }
        input.style.width = `${input.value.length + 75}px`;
      });
    }
    popup.open();
  }

  function mgc_getValues(edit, mgc, callback) {
    let values;
    values = {
      gameId: mgc.gameId.value,
      gameType: mgc.gameType.value,
      copies: mgc.copies.value,
      keys: mgc.keys.value
    };
    if (values.gameId && ((values.gameType === `gift` && parseInt(values.copies) > 0) || (values.gameType === `key` && values.keys))) {
      esgst.busy = true;
      values.countries = mgc.countries.value.trim();
      values.gameName = mgc.gameName.value;
      values.startTime = mgc.startTime.value;
      values.endTime = mgc.endTime.value;
      values.region = mgc.region.value;
      values.whoCanEnter = mgc.whoCanEnter.value;
      values.whitelist = mgc.whitelist.value;
      values.groups = mgc.groups.value.trim();
      values.level = mgc.level.value;
      values.description = mgc.description.value;
      values.steam = games_getInfo(document.querySelector(`[data-autocomplete-id="${values.gameId}"]`));
      if ((esgst.mgc_createTrain && mgc.description.value.match(/\[ESGST-P\]|\[ESGST-N\]/)) || !esgst.mgc_createTrain) {
        if ((mgc.discussion && mgc.description.value.match(/\[ESGST-B\]/)) || !mgc.discussion) {
          mgc_addGiveaway(edit, mgc, values);
          mgc_updateCache(mgc);
          mgc.copies.value = `1`;
          mgc.keys.value = ``;
        } else {
          createAlert(`The bump link format is missing from the description.`);
        }
      } else {
        createAlert(`The next/previous links format is missing from the description.`);
      }
    } else {
      createAlert(`You must first fill the details of the giveaway.`);
    }
    callback();
  }

  function mgc_addGiveaway(edit, mgc, values) {
    let data, details;
    details = `${values.gameName.replace(/"/g, `&quot;`)}\n`;
    if (values.gameType === `gift`) {
      details += `Gift\n${values.copies} Copies\n`;
    } else {
      details += `Keys\n${values.keys}\n`;
    }
    details += `\n${values.startTime} - ${values.endTime}\n`;
    if (values.region === `1`) {
      details += `Region Restricted\n`;
    }
    if (values.whoCanEnter === `everyone`) {
      details += `Public\n`;
    } else if (values.whoCanEnter === `invite_only`) {
      details += `Invite Only\n`;
    } else {
      if (values.whitelist === `1`) {
        details += `Whitelist\n`;
      }
      if (values.groups.trim()) {
        details += `Groups\n`;
      }
    }
    values.description = values.description
      .replace(/\[ESGST-LEVEL\]/ig, values.level)
      .replace(/\[ESGST-NAME\]/ig, values.gameName)
      .replace(/\[ESGST-STEAM-ID\]/ig, values.steam.id)
      .replace(/\[ESGST-STEAM-TYPE\]/ig, values.steam.type.slice(0, -1))
      .replace(/\[ESGST-STEAM-URL\]/ig, `http://store.steampowered.com/${values.steam.type.slice(0, -1)}/${values.steam.id}`);
    details += `Level ${values.level}\n\n${values.description}`;
    data = `xsrf_token=${esgst.xsrfToken}&next_step=3&game_id=${values.gameId}&type=${values.gameType}&copies=${values.copies}&key_string=${encodeURIComponent(values.keys)}&timezone=${mgc.timezone}&start_time=${encodeURIComponent(values.startTime)}&end_time=${encodeURIComponent(values.endTime)}&region_restricted=${values.region}&country_item_string=${encodeURIComponent(values.countries)}&who_can_enter=${values.whoCanEnter}&whitelist=${values.whitelist}&group_item_string=${encodeURIComponent(values.groups)}&contributor_level=${values.level}&description=${encodeURIComponent(values.description)}`;
    if (edit) {
      mgc.datas[mgc.editPos] = data;
      mgc.values[mgc.editPos] = values;
      mgc.giveaways.children[mgc.editPos].title = details;
      mgc.editButton.set.classList.add(`esgst-hidden`);
    } else {
      mgc.datas.push(data);
      mgc.values.push(values);
      mgc_setGiveaway(insertHtml(mgc.giveaways, `beforeEnd`, `
        <div class="esgst-gm-giveaway" draggable="true" title="${details}">${mgc.datas.length}</div>
      `), mgc);
    }
  }

  function mgc_setGiveaway(giveaway, mgc) {
    giveaway.addEventListener(`click`, mgc_setValues.bind(null, giveaway, mgc))
    giveaway.addEventListener(`dragstart`, mgc_setSource.bind(null, giveaway, mgc));
    giveaway.addEventListener(`dragenter`, mgc_getSource.bind(null, giveaway, mgc));
  }

  function mgc_setValues(giveaway, mgc) {
    let pos, values;
    pos = parseInt(giveaway.textContent) - 1;
    values = mgc.values[pos];
    mgc.countries.value = values.countries;
    mgc.gameId.value = values.gameId;
    mgc.gameType.value = values.gameType;
    mgc.copies.value = values.copies;
    mgc.keys.value = values.keys;
    mgc.gameName.value = values.gameName;
    mgc.startTime.value = values.startTime;
    mgc.endTime.value = values.endTime;
    mgc.region.value = values.region;
    mgc.whoCanEnter.value = values.whoCanEnter;
    mgc.whitelist.value = values.whitelist;
    mgc.groups.value = values.groups;
    mgc.level.value = values.level;
    mgc.description.value = values.description;
    values.edit = true;
    gts_applyTemplate(values);
    mgc.editPos = pos;
    mgc.editButton.set.classList.remove(`esgst-hidden`);
  }

  function mgc_setSource(giveaway, mgc, event) {
    mgc.source = giveaway;
    event.dataTransfer.setData(`text/plain`, ``);
  }

  function mgc_getSource(giveaway, mgc) {
    let current;
    current = mgc.source;
    do {
      current = current.previousElementSibling;
      if (current && current === giveaway) {
        mgc.giveaways.insertBefore(mgc.source, giveaway);
        mgc_updateCache(mgc);
        return;
      }
    } while (current);
    mgc.giveaways.insertBefore(mgc.source, giveaway.nextElementSibling);
    mgc_updateCache(mgc);
  }

  function mgc_importGiveaways(mgc, callback) {
    callback();
    let counter, popup, progress, progressPanel, textArea;
    popup = new Popup(`fa-arrow-up`, `Import Giveaways`, true);
    popup.popup.classList.add(`esgst-popup-large`);
    popup.description.insertAdjacentHTML(`afterBegin`, `
      <div class="esgst-description">
        Insert the keys below. <i class="fa fa-question-circle"></i>
      </div>
    `);
    createTooltip(popup.description.firstElementChild.lastElementChild, `
      <div>Before importing, make sure you have filled the details of the giveaway (start/end times, regions, who can enter, whitelist, groups, level and description) or applied a template (with ${getFeatureNumber(`gts`).number} Giveaway Templates). You can also specify separate details for each giveaway using the parameters below:</div>
      <ul>
        <li><span class="esgst-bold">[countries="..."]</span> (Replace the 3 dots with the ids of the countries that the giveaway must be restricted to, separated by a comma followed by a space. The ids must be exactly how they appear in the country selection list. For example, "BR, US". If you do not want the giveaway to be region restricted, use the id "*", for example, [countries="*"].)</li>
        <li><span class="esgst-bold">[startTime="..."]</span> (Replace the 3 dots with the date that the giveaway must start, in the format "Mon D, YYYY H:MM xm". For example, "Jan 15, 2018 12:00 am". For the names of the months, use "Jan", "Feb", "Mar", "Apr", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov" and "Dec". For single-digit days/hours, do not put a 0 at the beginning. For example, use "Jan 1" instead of "Jan 01" and "9:00 am" instead of "09:00 am".)</li>
        <li><span class="esgst-bold">[endTime="..."]</span> (Replace the 3 dots with the date that the giveaway must end, in the same format as the start time.)</li>
        <li><span class="esgst-bold">[whoCanEnter="..."]</span> (Replace the 3 dots with either: "everyone", if the giveaway must be public; "invite_only", if the giveaway must be private; or "groups", if the giveaway must be restricted to groups/whitelist.)</li>
        <li><span class="esgst-bold">[groups="..."]</span> (Replace the 3 dots with the names of the groups that the giveaway must be restricted to, separated by a comma followed by a space. The names must be exactly how they appear on the group selection list. Use "My Whitelist" to include your whitelist in the groups. For example, "My Whitelist, Playing Appreciated, S.Gifts" or "My Whitelist".)</li>
        <li><span class="esgst-bold">[level="..."]</span> (Replace the 3 dots with the level that the giveaway must be restricted to. For example, "5".)</li>
        <li><span class="esgst-bold">[description="..."]</span> (Replace the 3 dots with the description that the giveaway must have. Use "\\n" to represent a new line. You can use all of the variables explained in the "How To Use" tooltip from section 0 here. For example, "The winner will be added on Steam for the delivery.\\n\\nPlease be patient.".)</li>
      </ul>
      <div>Put each giveaway in a separate line, using one of the formats below:</div>
      <ul>
        <li>Gift giveaways for 1 copy.</li>
        <ul>
          <li><span class="esgst-bold">Game Name</span></li>
          <li><span class="esgst-bold">Game Name https://store.steampowered.com/xxx/XXXXX</span></li>
          <li><span class="esgst-bold">https://store.steampowered.com/xxx/XXXXX</span></li>
        </ul>
        <li>Gift giveaways for more than 1 copy. Replace the X with the number of copies.</li>
        <ul>
          <li><span class="esgst-bold">Game Name (X Copies)</span></li>
          <li><span class="esgst-bold">Game Name https://store.steampowered.com/xxx/XXXXX (X Copies)</span></li>
          <li><span class="esgst-bold">https://store.steampowered.com/xxx/XXXXX (X Copies)</span></li>
        </ul>
        <li>Key giveaways. Gift links are also acceptable, so instead of "XXXXX-XXXXX-XXXXX" you can have "https://www.humblebundle.com/?gift=XxXXxxXXxXxxxXxx". For a link to be recognized it must start with either "http" or "https".</li>
        <ul>
          <li><span class="esgst-bold">Game Name XXXXX-XXXXX-XXXXX</span></li>
          <li><span class="esgst-bold">Game Name https://store.steampowered.com/xxx/XXXXX XXXXX-XXXXX-XXXXX</span></li>
          <li><span class="esgst-bold">https://store.steampowered.com/xxx/XXXXX XXXXX-XXXXX-XXXXX</span></li>
          <li><span class="esgst-bold">XXXXX-XXXXX-XXXXX Game Name</span></li>
          <li><span class="esgst-bold">XXXXX-XXXXX-XXXXX Game Name https://store.steampowered.com/xxx/XXXXX</span></li>
          <li><span class="esgst-bold">XXXXX-XXXXX-XXXXX https://store.steampowered.com/xxx/XXXXX</span></li>
        </ul>
      </ul>
      <div>By using the format that includes the link to the Steam store page of the game (https://store.steampowered.com/xxx/XXXXX), you make sure that if there are multiple games with the same name there will be a 100% match. If you do not use that format and there are multiple games with the same name, a popup will appear for you to decide which game should be used.</div>
      <br>
      <div>Here's an example:</div>
      <br>
      <div class="esgst-bold">Portal</div>
      <div class="esgst-bold">Portal XXXXX-XXXXX-XXXXX</div>
      <div class="esgst-bold">YYYYY-YYYYY-YYYYY Portal</div>
      <div class="esgst-bold">Portal https://store.steampowered.com/app/400 (2 Copies)</div>
      <div class="esgst-bold">https://store.steampowered.com/app/400 ZZZZZ-ZZZZZ-ZZZZZ</div>
      <br>
      <div>This example will create the 5 following giveaways if the options "Group adjacent keys for the same game." and "Group all keys for the same game." are disabled:</div>
      <br>
      <div>1 Portal giveaway for 1 gift copy.</div>
      <div>1 Portal giveaway for 1 key (XXXXX-XXXXX-XXXXX).</div>
      <div>1 Portal giveaway for 1 key (YYYYY-YYYYY-YYYYY).</div>
      <div>1 Portal giveaway for 2 gift copies.</div>
      <div>1 Portal giveaway for 1 key (ZZZZZ-ZZZZZ-ZZZZZ).</div>
      <br>
      <div>If the option "Group adjacent keys for the same game." is enabled, however, only 4 giveaways will be created, because the keys in the 2nd and 3rd giveaways are for the same game (Portal) and are adjacent (next to each other), so they will be grouped together in the same giveaway. Note that the key in the 5th giveaway is not adjacent, because the 4th giveaway is separating it from the others. So with this option enabled the 4 following giveaways will be created:</div>
      <br>
      <div>1 Portal giveaway for 1 gift copy.</div>
      <div>1 Portal giveaway for 2 keys (XXXXX-XXXXX-XXXXX and YYYYY-YYYYY-YYYYY).</div>
      <div>1 Portal giveaway for 2 gift copies.</div>
      <div>1 Portal giveaway for 1 key (ZZZZZ-ZZZZZ-ZZZZZ).</div>
      <br>
      <div>But if the option "Group all keys for the same game." is enabled, then only 3 giveaways will be created, because every single key found for the same game will be grouped together in a single giveaway, regardless of whether or not they are next to each other. So with this option enabled the 3 following giveaways will be created:</div>
      <br>
      <div>1 Portal giveaway for 1 gift copy.</div>
      <div>1 Portal giveaway for 3 keys (XXXXX-XXXXX-XXXXX, YYYYY-YYYYY-YYYYY and ZZZZZ-ZZZZZ-ZZZZZ).</div>
      <div>1 Portal giveaway for 2 gift copies.</div>
      <br>
      <div>And here's an example using separate details for each giveaway:</div>
      <br>
      <div class="esgst-bold">Portal [countries="BR, US"] [level="5"]</div>
      <div class="esgst-bold">Portal XXXXX-XXXXX-XXXXX [whoCanEnter="groups"] [groups="Playing Appreciated"]</div>
      <div class="esgst-bold">YYYYY-YYYYY-YYYYY Portal [whoCanEnter="groups"] [groups="My Whitelist"]</div>
      <div class="esgst-bold">Portal (2 Copies) [startTime="Apr 1, 2018 9:00 am"] [endTime="Apr 11, 2018 15:00 pm"] [whoCanEnter="invite_only"]</div>
      <div class="esgst-bold">Portal ZZZZZ-ZZZZZ-ZZZZZ [level="8"] [description="Appreciation for high level users.\\n\\nEnjoy!"]</div>
      <br>
      <div>Note that any missing parameters will be copied from the details that you have filled for the giveaway in the SteamGifts page. So, for example, if you have selected Everyone for Who Can Enter, the 1st and 5th giveaways will be public, because [whoCanEnter="..."] was not specified for them, so that detail will be copied over from the SteamGifts page.</div>
      <br>
      <div>Imported giveaways will not be automatically created, you still have to review them by clicking on the 'Create' button.</div>
      <br>
    `);
    let groupKeys = new ToggleSwitch(popup.description, `mgc_groupKeys`, false, `Group adjacent keys for the same game.`, false, false, ``, esgst.mgc_groupKeys);
    let groupAllKeys = new ToggleSwitch(popup.description, `mgc_groupAllKeys`, false, `Group all keys for the same game.`, false, false, ``, esgst.mgc_groupAllKeys);
    groupKeys.exclusions.push(groupAllKeys.container);
    groupAllKeys.exclusions.push(groupKeys.container);
    if (esgst.mgc_groupKeys) {
      groupAllKeys.container.classList.add(`esgst-hidden`);
    } else if (esgst.mgc_groupAllKeys) {
      groupKeys.container.classList.add(`esgst-hidden`);
    }
    textArea = insertHtml(popup.scrollable, `beforeEnd`, `
      <textarea></textarea>
    `);
    progressPanel = insertHtml(popup.description, `beforeEnd`, `
      <div>
        <div class="esgst-progress-bar"></div>
        <div>
          <span>0</span> of <span>0</span> giveaways imported.
        </div>
      </div>
    `);
    progress = {
      bar: progressPanel.firstElementChild,
    };
    counter = progressPanel.lastElementChild;
    progress.current = counter.firstElementChild;
    progress.total = progress.current.nextElementSibling;
    popup.description.appendChild(new ButtonSet(`green`, `grey`, `fa-arrow-circle-up`, `fa-circle-o-notch fa-spin`, `Import`, `Importing...`, mgc_getGiveaways.bind(null, mgc, popup, progress, textArea)).set);
    popup.open(mgc_focusTextArea.bind(null, textArea));
    textArea.style.height = `${ innerHeight * 0.9 - (popup.popup.offsetHeight - popup.scrollable.offsetHeight) - 25}px`;
    textArea.style.overflow = `auto`;
    textArea.addEventListener(`paste`, mgc_resizeTextArea.bind(null, popup, textArea));
  }

  function mgc_resizeTextArea(popup, textArea) {
    let interval, value;
    value = textArea.value;
    interval = setInterval(() => {
      if (value !== textArea.value) {
        clearInterval(interval);
        textArea.style.height = `${ innerHeight * 0.9 - (popup.popup.offsetHeight - popup.scrollable.offsetHeight) - 25}px`;
        textArea.style.overflow = `auto`;
      }
    }, 250);
  }

  function mgc_getGiveaways(mgc, popup, progress, textArea, callback) {
    let giveaways, lines, max, n, value;
    esgst.busy = true;
    giveaways = [];
    lines = textArea.value.trim().split(/\n/);
    for (let i = 0, n = lines.length; i < n; ++i) {
      const line = lines[i].trim();
      if (line) {
        giveaways.push(line);
      }
    }
    textArea.value = `${giveaways.join(`\n`)}\n`;
    n = giveaways.length;
    if ($(progress.bar).progressbar(`instance`)) {
      max = $(progress.bar).progressbar(`option`, `max`);
      value = $(progress.bar).progressbar(`option`, `value`);
      if (value + n !== max) {
        $(progress.bar).progressbar({
          max: value + n,
          value: value
        });
        progress.total.textContent = value + n;
      }
    } else {
      $(progress.bar).progressbar({
        max: n
      });
      progress.total.textContent = n;
    }
    mgc_importGiveaway(giveaways, 0, mgc, n, popup, progress, textArea, () => {
      mgc_updateCache(mgc);
      popup.close();
    }, callback);
  }

  async function mgc_importGiveaway(giveaways, i, mgc, n, popup, progress, textArea, mainCallback, callback) {
    let copies, found, giveaway, key, keyPos, match, name, namePos, values;
    if (i < n) {
      let countries = giveaways[i].match(/\[countries="(.+?)"\]/);
      let startTime = giveaways[i].match(/\[startTime="(.+?)"\]/);
      let endTime = giveaways[i].match(/\[endTime="(.+?)"\]/);
      let whoCanEnter = giveaways[i].match(/\[whoCanEnter="(.+?)"\]/);
      let groups = giveaways[i].match(/\[groups="(.+?)"\]/);
      let level = giveaways[i].match(/\[level="(.+?)"\]/);
      let description = giveaways[i].match(/\[description="(.+?)"\]/);
      if (esgst.mgc_createTrain && !((description && description[1]) || mgc.description.value || ``).match(/\[ESGST-P\]|\[ESGST-N\]/)) {
        createAlert(`The next/previous links format is missing from the description.`);
        callback();
        return;
      }
      if (mgc.discussion && !((description && description[1]) || mgc.description.value || ``).match(/\[ESGST-B\]/)) {
        createAlert(`The bump link format is missing from the description.`);
        callback();
        return;
      }
      if (countries) {
        if (countries[1] === `*`) {
          countries = `*`;
        } else {
          let ids = countries[1].split(/,\s/);
          countries = ``;
          ids.forEach(id => {
            let element = document.querySelector(`[data-input="country_item_string"]`).querySelector(`[data-name$="${id}"]`);
            if (element) {
              countries += `${element.getAttribute(`data-item-id`)} `;
            }
          });
        }
      }
      let whitelist = ``;
      if (groups) {
        let ids = groups[1].split(/,\s/);
        groups = ``;
        ids.forEach(id => {
          if (id === `My Whitelist`) {
            whitelist = `1`;
            return;
          }
          let element = document.querySelector(`[data-input="group_item_string"]`).querySelector(`[data-name$="${id}"]`);
          if (element) {
            groups += `${element.getAttribute(`data-item-id`)} `;
          }
        });
      }
      let steamLink = giveaways[i].match(/https?:\/\/.*?store\.steampowered\.com\/(app|sub)\/(\d+)/);
      let steamInfo = null;
      if (steamLink) {
        steamInfo = {
          id: steamLink[2],
          type: `${steamLink[1]}s`
        };
      }
      giveaways[i] = giveaways[i].replace(/\[(.+?)="(.+?)"\]/g, ``).replace(/https?:\/\/.*?store\.steampowered\.com(.*?\s|.*)/, `[ESGST] `).trim();
      match = giveaways[i].match(/^(([\d\w]{5}(-[\d\w]{5}){2,}\s?|https?:\/\/.+?\s?)+)\s(.+)$/);
      if (match) {
        key = true;
        keyPos = 1;
        namePos = 4;
      } else {
        match = giveaways[i].match(/^(.+?)\s(([\d\w]{5}(-[\d\w]{5}){2,}\s?|https?:\/\/.+?\s?)+)$/);
        if (match) {
          key = true;
          keyPos = 2;
          namePos = 1;
        } else {
          match = giveaways[i].match(/^(.+?)(\s\((\d+?)\sCopies\))?$/);
          if (match) {
            key = false;
            namePos = 1;
          }
        }
      }
      if (match) {
        name = match[namePos].replace(/\[ESGST\]/, ``).trim().toLowerCase();
        values = {
          countries: (countries === `*` ? `` : (countries || mgc.countries.value || ``)).trim(),
          startTime: (startTime && startTime[1]) || mgc.startTime.value || ``,
          endTime: (endTime && endTime[1]) || mgc.endTime.value || ``,
          region: countries === `*` ? `0` : (countries ? `1` : (mgc.region.value || `0`)),
          whoCanEnter: (whoCanEnter && whoCanEnter[1]) || mgc.whoCanEnter.value || `everyone`,
          whitelist: whitelist || mgc.whitelist.value || `0`,
          groups: (groups || mgc.groups.value || ``).trim(),
          level: (level && level[1]) || mgc.level.value || `0`,
          description: description ? description[1].replace(/\\n/g, `\n`) : (mgc.description.value || ``)
        };
        if (key) {
          values.gameType = `key`;
          values.keys = match[keyPos].replace(/\s/g, `\n`);
        } else {
          values.gameType = `gift`;
          copies = match[3];
          if (copies) {
            values.copies = copies;
          } else {
            values.copies = `1`;
          }
        }
        let toRemove = [giveaways[i]];
        if ((esgst.mgc_groupKeys || esgst.mgc_groupAllKeys) && key) {
          let k = i;
          do {
            found = false;
            giveaway = giveaways[k + 1];
            if (giveaway) {
              let nextSteamLink = giveaway.match(/https?:\/\/.*?store\.steampowered\.com\/(app|sub)\/(\d+)/);
              let nextSteamInfo = null;
              if (nextSteamLink) {
                nextSteamInfo = {
                  id: nextSteamLink[2],
                  type: `${nextSteamLink[1]}s`
                };
              }
              giveaway = giveaway.replace(/\[(.+?)="(.+?)"\]/g, ``).replace(/https?:\/\/.*?store\.steampowered\.com(.*?\s|.*)/, `[ESGST] `).trim();
              match = giveaway.match(/^(([\d\w]{5}(-[\d\w]{5}){2,}\s?|https?:\/\/.+?\s?)+)\s(.+)$/);
              if (match) {
                key = true;
                keyPos = 1;
                namePos = 4;
              } else {
                match = giveaway.match(/^(.+?)\s(([\d\w]{5}(-[\d\w]{5}){2,}\s?|https?:\/\/.+?\s?)+)$/);
                if (match) {
                  key = true;
                  keyPos = 2;
                  namePos = 1;
                } else {
                  key = false;
                }
              }
              if (match && key && (match[namePos].replace(/\[ESGST\]/, ``).trim().toLowerCase() === name || (nextSteamInfo && steamInfo && nextSteamInfo.type === steamInfo.type && nextSteamInfo.id === steamInfo.id))) {
                found = true;
                values.keys += `\n${match[keyPos].replace(/\s/g, `\n`)}`;
                toRemove.push(giveaways.splice(k + 1, 1)[0]);
                k--;
                n--;
              }
            }
            k++;
          } while ((esgst.mgc_groupKeys && found) || (esgst.mgc_groupAllKeys && giveaways[k + 1]));
        }
        mgc_getGiveaway(giveaways, i + 1, toRemove, mgc, n, name, popup, progress, steamInfo, textArea, values, mainCallback, callback, await request({data: `do=autocomplete_giveaway_game&page_number=1&search_query=${encodeURIComponent((steamInfo && steamInfo.id) || name)}`, method: `POST`, url: `/ajax.php`}));
      } else {
        createAlert(`The next giveaway is not in the right format. Please correct it and click on "Import" again to continue importing.`);
        callback();
      }
    } else {
      mainCallback();
    }
  }

  function mgc_getGiveaway(giveaways, i, toRemove, mgc, n, name, popup, progress, steamInfo, textArea, values, mainCallback, callback, response) {
    let button, conflictPopup, context, element, elements, exactMatch, info, k, matches, numElements, value;
    elements = parseHtml(JSON.parse(response.responseText).html).getElementsByClassName(`table__row-outer-wrap`);
    exactMatch = null;
    matches = [];
    for (k = 0, numElements = elements.length; k < numElements; k++) {
      element = elements[k];
      if (element.getAttribute(`data-autocomplete-name`).toLowerCase() === name) {
        if (steamInfo) {
          info = games_getInfo(element);
          if (steamInfo.type === info.type && steamInfo.id === info.id) {
            exactMatch = element;
            break;
          }
        } else {
          matches.push(element);
        }
      } else if (steamInfo) {
        info = games_getInfo(element);
        if (steamInfo.type === info.type && steamInfo.id === info.id) {
          exactMatch = element;
          break;
        }
      }
    }
    if (!exactMatch && matches.length === 1) {
      exactMatch = matches[0];
    }
    if (exactMatch) {
      values.gameName = exactMatch.getAttribute(`data-autocomplete-name`);
      values.gameId = exactMatch.getAttribute(`data-autocomplete-id`);
      values.steam = games_getInfo(exactMatch);
      mgc_addGiveaway(false, mgc, values);
      value = $(progress.bar).progressbar(`option`, `value`) + toRemove.length;
      $(progress.bar).progressbar(`option`, `value`, value);
      progress.current.textContent = value;
      toRemove.forEach(line => {
        textArea.value = textArea.value.replace(`${line}\n`, ``);
      });
      setTimeout(() => mgc_importGiveaway(giveaways, i, mgc, n, popup, progress, textArea, mainCallback, callback), 0);
    } else if (matches.length > 0) {
      conflictPopup = new Popup_v2({
        icon: `fa-exclamation`,
        isTemp: true,
        title: `There are ${matches.length} matches for ${name}. Please select the correct match.`,
        addScrollable: `left`
      });
      context = conflictPopup.getScrollable();
      matches.forEach(match => {
        let element = insertHtml(context, `beforeEnd`, match.outerHTML);
        element.classList.remove(`is-clickable`);
        button = new ButtonSet_v2({color1: `green`, color2: ``, icon1: `fa-arrow-circle-right`, icon2: ``, title1: `Select`, title2: ``, callback1: () => {
          conflictPopup.close();
          values.gameName = element.getAttribute(`data-autocomplete-name`);
          values.gameId = element.getAttribute(`data-autocomplete-id`);
          values.steam = games_getInfo(element);
          mgc_addGiveaway(false, mgc, values);
          value = $(progress.bar).progressbar(`option`, `value`) + toRemove.length;
          $(progress.bar).progressbar(`option`, `value`, value);
          progress.current.textContent = value;
          toRemove.forEach(line => {
            textArea.value = textArea.value.replace(`${line}\n`, ``);
          });
          setTimeout(() => mgc_importGiveaway(giveaways, i, mgc, n, popup, progress, textArea, mainCallback, callback), 0);
        }});
        button.set.style.position = `absolute`;
        button.set.style.right = `50px`;
        element.insertBefore(button.set, element.firstElementChild);
      });
      conflictPopup.onClose = callback;
      conflictPopup.open();
    } else {
      createAlert(`${name} was not found! Please correct the title of the game and click on "Import" again to continue importing (it must be exactly like on Steam).`);
      callback();
    }
  }

  function mgc_focusTextArea(textArea) {
    textArea.focus();
  }

  function mgc_exportGiveaways(mgc, mainCallback) {
    mainCallback();
    let anchor, file, i, j, n, popup, url, values;
    popup = new Popup(`fa-arrow-down`, `Export`);
    new ToggleSwitch(popup.description, `mgc_reversePosition`, false, `Export keys in reverse position (before the name of the game).`, false, false, ``, esgst.mgc_reversePosition);
    popup.description.appendChild(new ButtonSet(`green`, ``, `fa-arrow-down`, ``, `Export`, ``, callback => {
      file = ``;
      for (i = 0, n = mgc.giveaways.children.length; i < n; ++i) {
        values = mgc.giveaways.children[i].title.split(/\n/);
        if (values[1] === `Gift`) {
          if (parseInt(values[2].match(/\d+/)[0]) > 1) {
            file += `${values[0]} (${values[2]})\r\n`;
          } else {
            file += `${values[0]}\r\n`;
          }
        } else {
          for (j = 2; values[j]; ++j) {
            if (esgst.mgc_reversePosition) {
              file += `${values[j]} ${values[0]}\r\n`;
            } else {
              file += `${values[0]} ${values[j]}\r\n`;
            }
          }
        }
      }
      downloadFile(file, `giveaways.txt`);
      callback();
    }).set);
    popup.open();
  }

  function mgc_emptyGiveaways(mgc, callback) {
    if (confirm(`Are you sure you want to empty the creator?`)) {
      delLocalValue(`mgcCache`);
      esgst.busy = false;
      mgc.datas = [];
      mgc.values = [];
      mgc.created = [];
      mgc.giveaways.innerHTML = ``;
      mgc.copies.value = `1`;
      mgc.keys.value = ``;
    }
    callback();
  }

  function mgc_createGiveaways(mgc, viewButton, callback) {
    if (!mgc.datas.length) {
      createAlert(`There are no giveaways in the queue. Click on the "Add" button to add a giveaway to the queue.`);
      callback();
      return;
    }
    let popup = new Popup(`fa-arrow-circle-right`, `ESGST will create the giveaways below. Are you sure you want to continue?`);
    let rows = insertHtml(popup.scrollable, `beforeEnd`, `
      <div class="table esgst-mgc-table">
        <div class="table__heading">
          <div class="table__column--width-small">No.</div>
          <div class="table__column--width-fill">Game</div>
          <div class="table__column--width-small">Copies/Keys</div>
          <div class="table__column--width-small">Start Time</div>
          <div class="table__column--width-small">End Time</div>
          <div class="table__column--width-small">Region Restricted</div>
          <div class="table__column--width-small">Who Can Enter</div>
          <div class="table__column--width-small">Level</div>
          <div class="table__column--width-small">Description</div>
        </div>
        <div class="table__rows"></div>
      </div>
    `).lastElementChild;
    for (let i = 0, n = mgc.giveaways.children.length; i < n; i++) {
      let values = mgc.values[parseInt(mgc.giveaways.children[i].textContent) - 1];
      let regionRestricted = `No`;
      if (values.region === `1`) {
        regionRestricted = `Yes (`;
        values.countries.split(/\s/).forEach(id => {
          console.log(id, mgc.countryNames[id]);
          regionRestricted += `${mgc.countryNames[id].match(/.+\s(.+)$/)[1]}, `;
        });
        regionRestricted = `${regionRestricted.slice(0, -2)})`;
      }
      let whoCanEnter = `Everyone`;
      if (values.whoCanEnter === `invite_only`) {
        whoCanEnter = `Invite Only`;
      } else if (values.whoCanEnter === `groups`) {
        whoCanEnter = `Groups (`;
        if (values.whitelist === `1`) {
          whoCanEnter += `Whitelist, `;
        }
        if (values.groups) {
          values.groups.split(/\s/).forEach(id => {
            whoCanEnter += `${mgc.groupNames[id]}, `;
          });
        }
        whoCanEnter = `${whoCanEnter.slice(0, -2)})`;
      }
      rows.insertAdjacentHTML(`beforeEnd`, `
        <div class="table__row-outer-wrap">
          <div class="table__row-inner-wrap">
            <div class="table__column--width-small">${i + 1}</div>
            <div class="table__column--width-fill">
            ${values.steam ? `
              <a class="table__column__secondary-link" href="https://store.steampowered.com/${values.steam.type.slice(0, -1)}/${values.steam.id}">${values.gameName}</a>
            ` : `
              <span>${values.gameName}</span>
            `}
            </div>
            <div class="table__column--width-small">${values.keys ? values.keys.replace(/\n/g, `<br>`) : `${values.copies} Copies`}</div>
            <div class="table__column--width-small">${values.startTime}</div>
            <div class="table__column--width-small">${values.endTime}</div>
            <div class="table__column--width-small">${regionRestricted}</div>
            <div class="table__column--width-small">${whoCanEnter}</div>
            <div class="table__column--width-small">${values.level}</div>
            <div class="table__column--width-small" title="${values.description.replace(/"/g, `&quot;`)}">${values.description.length > 100 ? `${values.description.slice(0, 100)}...` : values.description}</div>
          </div>
        </div>
      `);
    }
    popup.description.appendChild(new ButtonSet_v2({color1: `green`, color2: ``, icon1: `fa-check`, icon2: ``, title1: `Yes`, title2: ``, callback1: mgc_createGiveaways_2.bind(null, mgc, viewButton, popup, callback)}).set);
    popup.description.appendChild(new ButtonSet_v2({color1: `red`, color2: ``, icon1: `fa-times`, icon2: ``, title1: `No`, title2: ``, callback1: popup.close.bind(popup)}).set);
    popup.onClose = () => {
      if (popup.isOpen) {
        callback();
      }
    };
    popup.open();
  }

  function mgc_createGiveaways_2(mgc, viewButton, popup, callback) {
    popup.onClose = null;
    popup.close();
    mgc.copies.value = `1`;
    mgc.keys.value = ``;
    viewButton.set.classList.add(`esgst-hidden`);
    mgc.saveGiveaways = {};
    mgc_createGiveaway(0, mgc, mgc.giveaways.children.length, esgst.cewgd || (esgst.gc && esgst.gc_gi) || esgst.lpv || esgst.rcvc ? mgc_saveGiveaways.bind(null, mgc, mgc_completeCreation.bind(null, mgc, viewButton, callback)) : mgc_completeCreation.bind(null, mgc, viewButton, callback));
  }

  async function mgc_createGiveaway(i, mgc, n, callback) {
    if (i < n) {
      if (!mgc.giveaways.children[i].classList.contains(`success`)) {
        const j = parseInt(mgc.giveaways.children[i].textContent) - 1;
        mgc_checkCreation(i, mgc, n, callback, await request({data: mgc.datas[j].replace(/start_time=(.+?)&/, mgc_correctTime), method: `POST`, url: `/giveaways/new`}));
      } else {
        setTimeout(() => mgc_createGiveaway(i + 1, mgc, n, callback), 0);
      }
    } else if (esgst.mgc_createTrain) {
      mgc_createTrain(0, mgc, mgc.created.length, callback);
    } else {
      callback();
    }
  }

  function mgc_correctTime(fullMatch, match1) {
    const offsetTime = Date.now() + 5000;
    if ((new Date(decodeURIComponent(match1)).getTime()) < offsetTime) {
      return `start_time=${encodeURIComponent(getDate(`[MMM] [D], [YYYY] [H12]:[HMM] [XX]`, offsetTime))}&`;
    } else {
      return fullMatch;
    }
  }

  async function mgc_checkCreation(i, mgc, n, callback, response) {
    let errors, errorsTitle, giveaway, j, numErrors, responseHtml;
    giveaway = mgc.giveaways.children[i];
    if (response.finalUrl.match(/\/giveaways\/new/)) {
      if (response.responseText.match(/Error\.\sYou\salready\sposted\san\sidentical\sgiveaway\swithin\sthe\spast\s2\sminutes\.\sTo\sprevent\sdouble\sposts,\sit's\sbeen\sblocked\./)) {
        const popup = new Popup(`fa-circle-o-notch fa-spin`, `Waiting <span></span> minutes to create another identical giveaway... Please do not close this popup. If you do not want this waiting period, create a single multiple-copy giveaway for the game.`, true);
        popup.open();
        setCountdown(popup.title.firstElementChild, 120, async () => {
          popup.close();
          const j = parseInt(mgc.giveaways.children[i].textContent) - 1;
          setTimeout(async () => mgc_checkCreation(i, mgc, n, callback, await request({data: mgc.datas[j].replace(/start_time=(.+?)&/, mgc_correctTime), method: `POST`, url: `/giveaways/new`})), 0);
        });
      } else {
        giveaway.classList.add(`error`);
        errors = parseHtml(response.responseText).getElementsByClassName(`form__row__error`);
        errorsTitle = `Errors:\n`;
        for (j = 0, numErrors = errors.length; j < numErrors; ++j) {
          errorsTitle += `${errors[j].textContent}\n`;
        }
        errorsTitle += `\n`;
        giveaway.title = `${errorsTitle}${giveaway.title}`;
        setTimeout(() => mgc_createGiveaway(++i, mgc, n, callback), 0);
      }
    } else {
      giveaway.classList.add(`success`);
      responseHtml = parseHtml(response.responseText);
      mgc.created.push({
        giveaway: giveaway,
        html: buildGiveaway(responseHtml, response.finalUrl).html,
        url: response.finalUrl
      });
      if (esgst.cewgd || (esgst.gc && esgst.gc_gi) || esgst.lpv || esgst.rcvc) {
        giveaway = (await giveaways_get(responseHtml, false, response.finalUrl))[0];
        if (giveaway) {
          mgc.saveGiveaways[giveaway.code] = giveaway;
        }
        setTimeout(() => mgc_createGiveaway(++i, mgc, n, callback), 0);
      } else {
        setTimeout(() => mgc_createGiveaway(++i, mgc, n, callback), 0);
      }
    }
  }

  async function mgc_saveGiveaways(mgc, callback) {
    let user = {
      steamId: esgst.steamId,
      username: esgst.username
    };
    let ugd;
    const savedUser = await getUser(null, user);
    let giveaways = null;
    if (savedUser) {
      giveaways = savedUser.giveaways;
    }
    if (!giveaways) {
      giveaways = {
        sent: {
          apps: {},
          subs: {}
        },
        won: {
          apps: {},
          subs: {}
        },
        sentTimestamp: 0,
        wonTimestamp: 0
      };
      if (savedUser) {
        ugd = savedUser.ugd;
        if (ugd) {
          if (ugd.sent) {
            for (let key in ugd.sent.apps) {
              giveaways.sent.apps[key] = [];
              for (let i = 0, n = ugd.sent.apps[key].length; i < n; ++i) {
                mgc.saveGiveaways[ugd.sent.apps[key][i].code] = ugd.sent.apps[key][i];
                giveaways.sent.apps[key].push(ugd.sent.apps[key][i].code);
              }
            }
            for (let key in ugd.sent.subs) {
              giveaways.sent.subs[key] = [];
              for (let i = 0, n = ugd.sent.subs[key].length; i < n; ++i) {
                mgc.saveGiveaways[ugd.sent.subs[key][i].code] = ugd.sent.subs[key][i];
                giveaways.sent.subs[key].push(ugd.sent.subs[key][i].code);
              }
            }
            giveaways.sentTimestamp = ugd.sentTimestamp;
          }
          if (ugd.won) {
            for (let key in ugd.won.apps) {
              giveaways.won.apps[key] = [];
              for (let i = 0, n = ugd.won.apps[key].length; i < n; ++i) {
                mgc.saveGiveaways[ugd.won.apps[key][i].code] = ugd.won.apps[key][i];
                giveaways.won.apps[key].push(ugd.won.apps[key][i].code);
              }
            }
            for (let key in ugd.won.subs) {
              giveaways.won.subs[key] = [];
              for (let i = 0, n = ugd.won.subs[key].length; i < n; ++i) {
                mgc.saveGiveaways[ugd.won.subs[key][i].code] = ugd.won.subs[key][i];
                giveaways.won.subs[key].push(ugd.won.subs[key][i].code);
              }
            }
            giveaways.wonTimestamp = ugd.wonTimestamp;
          }
        }
      }
    }
    for (const key in mgc.saveGiveaways) {
      let giveaway = mgc.saveGiveaways[key];
      if (!giveaways.sent[giveaway.gameType][giveaway.gameSteamId]) {
        giveaways.sent[giveaway.gameType][giveaway.gameSteamId] = [];
      }
      if (giveaways.sent[giveaway.gameType][giveaway.gameSteamId].indexOf(giveaway.code) < 0) {
        giveaways.sent[giveaway.gameType][giveaway.gameSteamId].push(giveaway.code);
      }
    }
    user.values = {
      giveaways: giveaways
    };
    await lockAndSaveGiveaways(mgc.saveGiveaways);
    await saveUser(null, null, user);
    callback();
  }

  async function mgc_createTrain(i, mgc, n, callback) {
    if (i >= n || n - 1 === 0) {
      callback();
    } else {
      let responseHtml = parseHtml((await request({method: `GET`, url: mgc.created[i].url})).responseText);
      let id = responseHtml.querySelector(`[name="giveaway_id"]`).value;
      let description = responseHtml.querySelector(`[name="description"]`).value;
      let replaceCallback = null;
      if (i === 0) {
        mgc.firstWagon = mgc.created[i].url;
        replaceCallback = mgc_getNext;
      } else if (i === n - 1) {
        replaceCallback = mgc_getPrevious;
      } else {
        replaceCallback = mgc_getBoth;
      }
      description = description.replace(/\[ESGST-P\](.+?)\[\/ESGST-P\](.+?)\[ESGST-N\](.+?)\[\/ESGST-N\]/g, replaceCallback.bind(null, i, mgc, false));
      description = description.replace(/\[ESGST-P\](.+?)\[\/ESGST-P\]|\[ESGST-N\](.+?)\[\/ESGST-N\]/g, replaceCallback.bind(null, i, mgc, true));
      description = description.replace(/\[ESGST-C\](.+?)\[\/ESGST-C\]/g, mgc_getCounter.bind(null, i, n));
      if (mgc.discussion && (!esgst.mgc_bumpLast || i === n - 1)) {
        description = description.replace(/\[ESGST-B\](.+?)\[\/ESGST-B\]/g, `[$1](/discussion/${mgc.discussion}/)`);
      } else {
        description = description.replace(/\[ESGST-B\](.+?)\[\/ESGST-B\]/g, ``);
      }
      await request({data: `xsrf_token=${esgst.xsrfToken}&do=edit_giveaway_description&giveaway_id=${id}&description=${encodeURIComponent(description.trim())}`, method: `POST`, url: `/ajax.php`});
      mgc.created[i].giveaway.classList.add(`connected`);
      setTimeout(() => mgc_createTrain(i + 1, mgc, n, callback), 0);
    }
  }

  function mgc_getNext(i, mgc, single, fullMatch, match1, match2, match3) {
    let match, next, nextPref, nextSuf;
    if ((single && match2) || !single) {
      match = (single ? match2 : match3).match(/(.*?)\[N\](.+?)\[\/N\](.*?)$/);
      if (match) {
        nextPref = match[1];
        next = match[2];
        nextSuf = match[3];
      } else {
        nextPref = ``;
        next = single ? match2 : match3;
        nextSuf = ``;
      }
      if (esgst.mgc_removeLinks || single) {
        return `${nextPref}[${next}](${mgc.created[i + 1].url})${nextSuf}`;
      } else {
        return `${match1}${match2}${nextPref}[${next}](${mgc.created[i + 1].url})${nextSuf}`;
      }
    } else {
      return ``;
    }
  }

  function mgc_getPrevious(i, mgc, single, fullMatch, match1, match2, match3) {
    let match, prev, prevPref, prevSuf;
    if ((single && match1) || !single) {
      match = match1.match(/(.*?)\[P\](.+?)\[\/P\](.*?)$/);
      if (match) {
        prevPref = match[1];
        prev = match[2];
        prevSuf = match[3];
      } else {
        prevPref = ``;
        prev = match1;
        prevSuf = ``;
      }
      if (esgst.mgc_removeLinks || single) {
        return `${prevPref}[${prev}](${mgc.created[i - 1].url})${prevSuf}`;
      } else {
        return `${prevPref}[${prev}](${mgc.created[i - 1].url})${prevSuf}${match2}${match3}`;
      }
    } else {
      return ``;
    }
  }

  function mgc_getBoth(i, mgc, single, fullMatch, match1, match2, match3) {
    let match, next, nextPref, nextSuf, prev, prevPref, prevSuf;
    if (single) {
      if (match1) {
        return mgc_getPrevious(i, mgc, true, fullMatch, match1);
      } else {
        return mgc_getNext(i, mgc, true, fullMatch, null, match2);
      }
    } else {
      match = match1.match(/(.*?)\[P\](.+?)\[\/P\](.*?)$/);
      if (match) {
        prevPref = match[1];
        prev = match[2];
        prevSuf = match[3];
      } else {
        prevPref = ``;
        prev = match1;
        prevSuf = ``;
      }
      match = match3.match(/(.*?)\[N\](.+?)\[\/N\](.*?)$/);
      if (match) {
        nextPref = match[1];
        next = match[2];
        nextSuf = match[3];
      } else {
        nextPref = ``;
        next = match3;
        nextSuf = ``;
      }
      return `${prevPref}[${prev}](${mgc.created[i - 1].url})${prevSuf}${match2}${nextPref}[${next}](${mgc.created[i + 1].url})${nextSuf}`;
    }
  }

  function mgc_getCounter(i, n, fullMatch, match1) {
    return `${i + 1}${match1}${n}`;
  }

  function mgc_completeCreation(mgc, viewButton, callback) {
    if (mgc.discussion) {
      if (mgc.created.length) {
        delLocalValue(`mgcCache`);
        setLocalValue(`mgcAttach_step4`, mgc.firstWagon);
        open(`/discussion/${mgc.discussion}/`);
        viewButton.set.classList.remove(`esgst-hidden`);
      }
      callback();
    } else {
      if (mgc.created.length) {
        delLocalValue(`mgcCache`);
        viewButton.set.classList.remove(`esgst-hidden`);
      }
      callback();
    }
  }

  function mgc_shuffleGiveaways(mgc, callback) {
    if (!mgc.datas.length) {
      createAlert(`There are no giveaways in the queue. Click on the "Add" button to add a giveaway to the queue.`);
      callback();
      return;
    }
    let i;
    for (i = mgc.giveaways.children.length; i > -1; --i) {
      mgc.giveaways.appendChild(mgc.giveaways.children[Math.random() * i | 0]);
    }
    mgc_updateCache(mgc);
    callback();
  }

  function mgc_updateCache(mgc) {
    let cache, i, n;
    cache = [];
    for (i = 0, n = mgc.giveaways.children.length; i < n; ++i) {
      cache.push(mgc.values[parseInt(mgc.giveaways.children[i].textContent) - 1]);
    }
    setLocalValue(`mgcCache`, JSON.stringify(cache));
  }

  function mgc_attachDiscussion(mgc, callback) {
    let input, popup;
    callback();
    popup = new Popup(`fa-comments`, `Attach discussion:`);
    popup.description.insertAdjacentHTML(`afterBegin`, `
      <div class="esgst-description">
        <div>You can attach an existing or a new discussion. To attach an existing discussion, simply enter its code below and click "Attach Existing". To attach a new discussion, simply click "Attach New".</div>
        <br/>
        <div>Use [ESGST-B][/ESGST-B] to delimit the bump link in the description of the giveaway, for example: ### [ESGST-B]Bump[/ESGST-B]</div>
        <br/>
        <div>Use [ESGST-T][/ESGST-T] to delimit the train link in the description of the discussion (this link will lead to the first giveaway of the train), for example: ### [ESGST-T]Choo choo![/ESGST-T]</div>
        <br/>
        <div>When the discussion page opens in your browser at the end of the train creation, wait until it has completely finished altering it (you will get a popup when this happens).</div>
      </div>
    `);
    input = insertHtml(popup.description, `beforeEnd`, `<input placeholder="XXXXX" type="text"/>`);
    popup.description.appendChild(new ButtonSet(`green`, `grey`, `fa-paperclip`, `fa-circle-o-notch fa-spin`, `Attach Existing`, `Attaching...`, mgc_attachExistingDiscussion.bind(null, input, mgc, popup)).set);
    popup.description.appendChild(new ButtonSet(`green`, `grey`, `fa-paperclip`, `fa-circle-o-notch fa-spin`, `Attach New`, `Attaching...`, mgc_attachNewDiscussion.bind(null, mgc, popup)).set);
    popup.open();
  }

  function mgc_attachExistingDiscussion(input, mgc, popup, callback) {
    mgc.discussion = input.value;
    mgc.discussionPanel.classList.remove(`esgst-hidden`);
    mgc.discussionLink.href = `/discussion/${mgc.discussion}/`;
    mgc.discussionLink.textContent = mgc.discussion;
    callback();
    popup.close();
  }

  function mgc_attachNewDiscussion(mgc, popup, callback) {
    let win;
    setLocalValue(`mgcAttach_step1`, true);
    win = open(`/discussions/new`);
    setTimeout(() => mgc_checkAttached(mgc, popup, win, callback), 100);
  }

  function mgc_checkAttached(mgc, popup, win, callback) {
    if (win.closed) {
      mgc.discussion = getLocalValue(`mgcAttach_step3`);
      delLocalValue(`mgcAttach_step3`);
      mgc.discussionPanel.classList.remove(`esgst-hidden`);
      mgc.discussionLink.href = `/discussion/${mgc.discussion}/`;
      mgc.discussionLink.textContent = mgc.discussion;
      callback();
      popup.close();
    } else {
      setTimeout(() => mgc_checkAttached(mgc, popup, win, callback), 100);
    }
  }

  function mgc_addCreateAndAttachButton() {
    let rows;
    rows = document.getElementsByClassName(`form__rows`)[0];
    rows.appendChild(new ButtonSet(`green`, `grey`, `fa-check`, `fa-circle-o-notch fa-spin`, `Create & Attach`, `Creating & attaching...`, mgc_createAndAttachDiscussion.bind(null, rows)).set);
  }

  function mgc_createAndAttachDiscussion(rows) {
    setLocalValue(`mgcAttach_step2`, true);
    rows.parentElement.submit();
  }

  function mgc_editDiscussion() {
    const description = document.querySelector(`[name=description]`);
    description.value = description.value.replace(/\[ESGST-T\](.+?)\[\/ESGST-T\]/g, `[$1](${getLocalValue(`mgcAttach_step4`)})`);
    delLocalValue(`mgcAttach_step4`);
    setLocalValue(`mgcAttach_step5`, true);
    document.getElementsByClassName(`js__submit-form`)[0].click();
  }

  function mgc_detachDiscussion(mgc) {
    mgc.discussion = null;
    mgc.discussionPanel.classList.add(`esgst-hidden`);
  }

  async function mgc_viewResults(mgc, callback) {
    let html, i, n, popup;
    popup = new Popup(`fa-eye`, `Results`);
    html = ``;
    for (i = 0, n = mgc.created.length; i < n; ++i) {
      html += mgc.created[i].html;
    }
    popup.scrollable.insertAdjacentHTML(`beforeEnd`, `
      <div class="popup__keys__list">
        ${html}
      </div>
    `);
    let giveaways = await giveaways_get(popup.scrollable);
    if (esgst.mm) {
      const heading = insertHtml(popup.scrollable, `afterBegin`, `
        <div class="esgst-page-heading"></div>
      `);
      mm(heading, giveaways, `Giveaways`);
    }
    popup.open();
    callback();
  }

  function mgc_removeGiveaway(mgc) {
    if (confirm(`Are you sure you want to remove this giveaway?`)) {
      mgc.source.remove();
      mgc.source = null;
      mgc_updateCache(mgc);
    }
  }

  // [MM]

  _MODULES.push({
    description: `
      <ul>
        <li>Adds a button (<i class="fa fa-gears"></i>) to the main page heading of any page that allows you to do stuff with multiple giveaways/discussions/users/games at once.</li>
        <li>When you click on the button, a popout appears where you can select what type of item you want to manage (giveaways, discussions, users or games) and enable the manager for that type. When you do this, checkboxes are added in front of each item in the page, allowing you to select which ones you want to manage.</li>
        <li>You can:</li>
        <ul>
          <li>Search and replace something in the description of the selected giveaways.</li>
          <li>Hide the selected giveaways, if [id=gf_s] is enabled.</li>
          <li>Bookmark/unbookmark the selected giveaways, if [id=gb] is enabled.</li>
          <li>Calculate how much time you have to wait until you have enough points to enter the selected giveaways, if [id=ttec] is enabled.</li>
          <li>Export the selected giveaways to encrypted giveaways, if [id=ged] is enabled.</li>
          <li>Hide the selected discussions, if [id=df_s] is enabled.</li>
          <li>Highlight/unhighlight the selected discussions, if [id=dh] is enabled.</li>
          <li>Mark the selected discussions as visited/unvisited, if [id=gdttt] is enabled.</li>
          <li>Tag the selected users with the same tags, if [id=ut], is enabled.</li>
          <li>Check the selected users for whitelists/blacklists, if [id=wbc] is enabled.</li>
          <li>Tag the selected games with the same tags, if [id=gt], is enabled.</li>
          <li>Export the selected giveaways/discussions/users/games to links or to a custom format that you can specify.</li>
        </ul>
        <li>On SteamTrades you can only manage users.</li>
      </ul>
    `,
    id: `mm`,
    load: mm,
    name: `Multi-Manager`,
    sg: true,
    st: true,
    type: `general`
  });

  function mm(context, items, itemsKey) {
    if (!context && !esgst.mainPageHeading) return;
    let obj = {
      button: createHeadingButton({
        context,
        id: `mm`,
        icons: [`fa-gears`],
        title: `Multi-manage`
      }),
      checkboxes: {
        Giveaways: {},
        Discussions: {},
        Users: {},
        Games: {}
      },
      counters: {
        Giveaways: 0,
        Discussions: 0,
        Users: 0,
        Games: 0
      },
      counterElements: {},
      scope: context ? `popup` : `main`
    };
    esgst.mm_enable = mm_enable.bind(null, obj);
    esgst.mm_disable = mm_disable.bind(null, obj);
    obj.button.addEventListener(`click`,  mm_openPopout.bind(null, obj, items, itemsKey));
  }

  function mm_openPopout(obj, items, itemsKey) {
    if (obj.popout) return;
    obj.popout = new Popout(`esgst-mm-popout`, obj.button, 0, true);
    obj.headings = insertHtml(obj.popout.popout, `afterBegin`, `
      <div class="esgst-mm-headings"></div>
      <div class="esgst-mm-sections"></div>
    `);
    obj.sections = obj.headings.nextElementSibling;
    let activeIndex = 0;
    Object.keys(obj.checkboxes).forEach((key, i) => {
      if (!esgst.sg && key !== `Users`) return;
      let heading = insertHtml(obj.headings, `beforeEnd`, `
        <div>
          <span></span> ${key}
          <br/>
          <span class="esgst-bold">${obj.counters[key]}</span> selected
        </div>
      `);
      obj.counterElements[key] = heading.lastElementChild;
      let toggleSwitch = new ToggleSwitch(heading.firstElementChild, `mm_enable${key}`, true, ``, false, false, null, esgst[`mm_enable${key}`]);
      toggleSwitch.onEnabled = mm_enable.bind(null, obj, itemsKey === key ? items : null, key);
      toggleSwitch.onDisabled = mm_disable.bind(null, obj, itemsKey === key ? items : null, key);
      mm_setSection(obj, insertHtml(obj.sections, `beforeEnd`, `
        <div></div>
      `), itemsKey === key ? items : null, key);
      if (esgst.sg) {
        heading.addEventListener(`click`, mm_changeActiveSection.bind(null, obj, i));
      }
      if (esgst[`mm_enable${key}`]) {
        activeIndex = i;
      }
    });
    mm_changeActiveSection(obj, esgst.sg ? activeIndex : 0);
    obj.popout.open();
  }

  function mm_changeActiveSection(obj, i) {
    for (let j = obj.headings.children.length - 1; j > -1; j--) {
      obj.headings.children[j].classList.remove(`esgst-selected`);
    }
    obj.headings.children[i].classList.add(`esgst-selected`);
    for (let j = obj.sections.children.length - 1; j > -1; j--) {
      obj.sections.children[j].classList.remove(`esgst-selected`);
    }
    obj.sections.children[i].classList.add(`esgst-selected`);
  }

  function mm_enable(obj, items, key) {
    if (!items) {
      items = esgst[obj.scope + key];
    }
    items.forEach(item => {
      let checkbox = getChildByClassName(item.innerWrap, `esgst-mm-checkbox`) || getChildByClassName(item.innerWrap.parentElement, `esgst-mm-checkbox`);
      if (checkbox) return;
      checkbox = new Checkbox(insertHtml(item.innerWrap, key.match(/Giveaways|Discussions/) ? `afterBegin` : `beforeBegin`, `
        <div class="esgst-mm-checkbox"></div>
      `), false, false, {
        select: `Add item to Multi-Manager selection`,
        unselect: `Remove item from Multi-Manager selection`
      });
      checkbox.onPreEnabled = mm_selectItem.bind(null, obj, item, key, 1);
      checkbox.onPreDisabled = mm_selectItem.bind(null, obj, item, key, 0);
      let itemKey = item.type ? `${item.type}_${item.code}` : item.code;
      if (!obj.checkboxes[key][itemKey]) {
        obj.checkboxes[key][itemKey] = [];
      }
      obj.checkboxes[key][itemKey].push(checkbox);
    });
    mm_resetCounters(obj);
  }

  function mm_disable(obj, items, key) {
    obj.checkboxes[key] = {};
    if (!items) {
      items = esgst[obj.scope + key];
    }
    items.forEach(item => {
      let checkbox = getChildByClassName(item.innerWrap, `esgst-mm-checkbox`) || getChildByClassName(item.innerWrap.parentElement, `esgst-mm-checkbox`);
      if (checkbox) {
        checkbox.remove();
      }
      item.mm = 0;
    });
    mm_resetCounters(obj);
  }

  function mm_selectItem(obj, item, key, value) {
    let isNew = false;
    item.mm = value;
    obj.checkboxes[key][item.type ? `${item.type}_${item.code}` : item.code].forEach(checkbox => {
      if (value) {
        if (!checkbox.value) {
          isNew = true;
          checkbox.isBlocked = true;
          checkbox.check();
          checkbox.isBlocked = false;
        }
      } else {
        if (checkbox.value) {
          isNew = true;
          checkbox.isBlocked = true;
          checkbox.uncheck();
          checkbox.isBlocked = false;
        }
      }
    });
    if (isNew && item.outerWrap.offsetParent) {
      obj.counters[key] += (value ? 1 : -1);
      if (obj.counterElements[key]) {
        obj.counterElements[key].textContent = obj.counters[key];
      }
    }
  }

  function mm_resetCounters(obj) {
    for (let key in obj.counters) {
      obj.counters[key] = 0;
      if (obj.counterElements[key]) {
        obj.counterElements[key].textContent = 0;
      }
    }
  }

  function mm_setSection(obj, context, items, key) {
    if (!items) {
      items = esgst[`${obj.scope}${key}`];
    }
    let sections = {
      default: [
        {
          buttons: [
            {
              check: true,
              color1: `grey`, color2: `grey`,
              icon1: `fa-square`, icon2: `fa-circle-o-notch fa-spin`,
              title1: `All`, title2: ``,
              callback1: selectSwitches.bind(null, obj.checkboxes[key], `check`, null)
            },
            {
              check: true,
              color1: `grey`, color2: `grey`,
              icon1: `fa-square-o`, icon2: `fa-circle-o-notch fa-spin`,
              title1: `None`, title2: ``,
              callback1: selectSwitches.bind(null, obj.checkboxes[key], `uncheck`, null)
            },
            {
              check: true,
              color1: `grey`, color2: `grey`,
              icon1: `fa-plus-square-o`, icon2: `fa-circle-o-notch fa-spin`,
              title1: `Inverse`, title2: ``,
              callback1: selectSwitches.bind(null, obj.checkboxes[key], `toggle`, null)
            }
          ],
          name: `Select:`
        },
        {
          buttons: [],
          name: ``
        },
        {
          buttons: [
            {
              check: true,
              color1: `green`, color2: `grey`,
              icon1: `fa-globe`, icon2: `fa-circle-o-notch fa-spin`,
              title1: `Links`, title2: ``,
              callback1: mm_exportLinks.bind(null, obj, items, key)
            },
            {
              check: true,
              color1: `green`, color2: `grey`,
              icon1: `fa-pencil`, icon2: `fa-circle-o-notch fa-spin`,
              title1: `Custom`, title2: ``,
              callback1: mm_exportCustom.bind(null, obj, items, key)
            }
          ],
          name: `Export to:`
        }
      ],
      Giveaways: [
        [],
        [
          {
            check: true,
            color1: `green`, color2: ``,
            icon1: `fa-search`, icon2: ``,
            key: `searchReplace`,
            title1: `Replace`, title2: ``
          },
          {
            check: esgst.gf && esgst.gf_s,
            color1: `green`, color2: `grey`,
            icon1: `fa-eye-slash`, icon2: `fa-circle-o-notch fa-spin`,
            title1: `Hide`, title2: ``,
            callback1: mm_hideGiveaways.bind(null, obj, items)
          },
          {
            check: esgst.gb,
            color1: `green`, color2: `grey`,
            icon1: `fa-bookmark`, icon2: `fa-circle-o-notch fa-spin`,
            title1: `Bookmark`, title2: ``,
            callback1: mm_bookmarkGiveaways.bind(null, obj, items)
          },
          {
            check: esgst.gb,
            color1: `green`, color2: `grey`,
            icon1: `fa-bookmark-o`, icon2: `fa-circle-o-notch fa-spin`,
            title1: `Unbookmark`, title2: ``,
            callback1: mm_unbookmarkGiveaways.bind(null, obj, items)
          },
          {
            check: esgst.ttec,
            color1: `green`, color2: `grey`,
            icon1: `fa-clock-o`, icon2: `fa-circle-o-notch fa-spin`,
            title1: `Calculate`, title2: ``,
            callback1: mm_calculateGiveaways.bind(null, obj, items)
          }
        ],
        [
          {
            check: esgst.ged,
            color1: `green`, color2: `grey`,
            icon1: `fa-puzzle-piece`, icon2: `fa-circle-o-notch fa-spin`,
            title1: `Encrypted`, title2: ``,
            callback1: mm_exportEncryptedGiveaways.bind(null, obj, items)
          }
        ]
      ],
      Discussions: [
        [],
        [
          {
            check: esgst.df && esgst.df_s,
            color1: `green`, color2: `grey`,
            icon1: `fa-eye-slash`, icon2: `fa-circle-o-notch fa-spin`,
            title1: `Hide`, title2: ``,
            callback1: mm_hideDiscussions.bind(null, obj, items)
          },
          {
            check: esgst.dh,
            color1: `green`, color2: `grey`,
            icon1: `fa-star`, icon2: `fa-circle-o-notch fa-spin`,
            title1: `Highlight`, title2: ``,
            callback1: mm_highlightDiscussions.bind(null, obj, items)
          },
          {
            check: esgst.dh,
            color1: `green`, color2: `grey`,
            icon1: `fa-star-o`, icon2: `fa-circle-o-notch fa-spin`,
            title1: `Unhighlight`, title2: ``,
            callback1: mm_unhighlightDiscussions.bind(null, obj, items)
          },
          {
            check: esgst.gdttt,
            color1: `green`, color2: `grey`,
            icon1: `fa-check`, icon2: `fa-circle-o-notch fa-spin`,
            title1: `Visit`, title2: ``,
            callback1: mm_visitDiscussions.bind(null, obj, items)
          },
          {
            check: esgst.gdttt,
            color1: `green`, color2: `grey`,
            icon1: `fa-times`, icon2: `fa-circle-o-notch fa-spin`,
            title1: `Unvisit`, title2: ``,
            callback1: mm_unvisitDiscussions.bind(null, obj, items)
          }
        ],
        []
      ],
      Users: [
        [],
        [
          {
            check: esgst.ut,
            color1: `green`, color2: `grey`,
            icon1: `fa-tags`, icon2: `fa-circle-o-notch fa-spin`,
            title1: `Tag`, title2: ``,
            callback1: mm_openTagPopup.bind(null, obj, items, key)
          },
          {
            check: esgst.wbc,
            color1: `green`, color2: `grey`,
            icon1: `fa-question-circle`, icon2: `fa-circle-o-notch fa-spin`,
            title1: `Check WL/BL`, title2: ``,
            callback1: mm_selectWbcUsers.bind(null, obj, items)
          }
        ],
        []
      ],
      Games: [
        [],
        [
          {
            check: esgst.gt,
            color1: `green`, color2: `grey`,
            icon1: `fa-tags`, icon2: `fa-circle-o-notch fa-spin`,
            title1: `Tag`, title2: ``,
            callback1: mm_openTagPopup.bind(null, obj, items, key)
          },
          {
            check: true,
            color1: `green`, color2: `grey`,
            icon1: `fa-eye-slash`, icon2: `fa-circle-o-notch fa-spin`,
            title1: `Hide`, title2: ``,
            callback1: mm_hideGames.bind(null, obj, items)
          }
        ],
        []
      ],
    };
    sections.default.forEach((section, i) => {
      let group = insertHtml(context, `beforeEnd`, `
        <div class="esgst-button-group">
          <span>${section.name}</span>
        </div>
      `);
      let buttons = sections[key][i].concat(section.buttons);
      buttons.forEach(button => {
        if (!button.check) return;
        let element = new ButtonSet_v2(button).set;
        if (group.children.length === 4) {
          group = insertHtml(context, `beforeEnd`, `
            <div class="esgst-button-group">
              <span>${section.name}</span>
            </div>
          `);
        }
        group.appendChild(element);
        if (button.key === `searchReplace`) {
          new Process({
            button: element,
            contextHtml: `
              <div class="markdown">
                <ul></ul>
              </div>
            `,
            popup: {
              icon: `fa-search`,
              title: `Search & Replace`,
              options: [
                {
                  check: true,
                  description: `Use <a class="esgst-bold" href="https://developer.mozilla.org/en/docs/Web/JavaScript/Guide/Regular_Expressions">regular expression</a>.`,
                  id: `mm_useRegExp`,
                  tooltip: null
                }
              ],
              textInputs: [
                {
                  placeholder: `Example without regular expression: query | Example with regular expression: /query/flags`,
                  title: `Search for: `
                },
                {
                  placeholder: `Do not use regular expression here.`,
                  title: `Replace with: `
                }
              ],
              addProgress: true,
              addScrollable: true
            },
            urls: {
              arguments: [items],
              doNotTrigger: true,
              id: `mm`,
              init: mm_initUrls,
              request: {
                request: mm_getSearchReplaceUrlRequest
              },
              restart: true
            }
          });
        }
      });
    });
    createTooltip(insertHtml(context, `beforeEnd`, `
      <div class="esgst-description">
        Enter the custom format below. <i class="fa fa-question-circle"></i>
      </div>
    `).lastElementChild, `
      <div>Delimit the line to be replaced and duplicated (in case more than one items were selected) with [line][/line]. If you want the lines to be sorted in ascending order use [line-asc][/line] instead, and for descending order use [line-desc][/line]. Then build your custom format between [line] and [/line] using the templates below. Some templates are not available depending on which page you are on.</div>
      <br/>
      <div class="esgst-bold">Giveaways:</div>
      <ul>
        <li>[code] - The 5-character code of the giveaway.</li>
        <li>[comments] - The current number of comments that the giveaway has.</li>
        <li>[copies] - The number of copies being given away.</li>
        <li>[creator] - The creator of the giveaway.</li>
        <li>[end-time="$"] - When the giveaway ended/will end. Replace $ with the date templates specified at the end of this tooltip.</li>
        <li>[entries] - The current number of entries that the giveaway has.</li>
        <li>[level] - The level of the giveaway.</li>
        <li>[name] - The name of the game being given away.</li>
        <li>[points] - The number of points that the giveaway is worth.</li>
        <li>[short-url] - The short URL of the giveaway (https://www.steamgifts.com/giveaway/XXXXX/).</li>
        <li>[start-time="$"] - When the giveaway started. Replace $ with the date templates specified at the end of this tooltip.</li>
        <li>[steam-id] - The Steam app/sub id of the game being given away.</li>
        <li>[steam-type] - The Steam type of the game being given away ("app" or "sub").</li>
        <li>[steam-url] - The Steam store URL of the game being given away.</li>
        <li>[type] - The type of the giveaway ("Public", "Invite Only", "Group", "Whitelist", "Region Restricted", "Invite Only + Region Restricted", "Group + Whitelist", "Group + Region Restricted" or "Whitelist + Region Restricted").</li>
        <li>[url] - The full URL of the giveaway (https://www.steamgifts.com/giveaway/XXXXX/game-name).</li>
      </ul>
      <div class="esgst-bold">Discussions:</div>
      <ul>
        <li>[author] - The author of the discussion.</li>
        <li>[category] - The category of the discussion.</li>
        <li>[code] - The 5-character code of the discussion.</li>
        <li>[comments] - The current number of comments that the discussion has.</li>
        <li>[created-time="$"] - When the discussion was created. Replace $ with the date templates specified at the end of this tooltip.</li>
        <li>[poll] - "Yes" if the discussion has a poll and "No" otherwise.</li>
        <li>[short-url] - The short URL of the discussion (https://www.steamgifts.com/discussion/XXXXX/).</li>
        <li>[title] - The title of the discussion.</li>
        <li>[url] - The full URL of the discussion (https://www.steamgifts.com/discussion/XXXXX/title).</li>
      </ul>
      <div class="esgst-bold">Users:</div>
      <ul>
        <li>[url] - The URL of the user (https://www.steamgifts.com/user/username).</li>
        <li>[username] - The username of the user.</li>
      </ul>
      <div class="esgst-bold">Games:</div>
      <ul>
        <li>[id] - The Steam app/sub id of the game.</li>
        <li>[name] - The name of the game.</li>
        <li>[type] - The Steam type of the game ("app" or "sub").</li>
        <li>[url] - The Steam store URL of the game.</li>
      </ul>
      <div class="esgst-bold">Date Templates:</div>
      <ul>
        <li>[d] - The number of the day with no leading zeroes if it is lower than 10.</li>
        <li>[dd] - The number of the day with leading zeroes if it is lower than 10.</li>
        <li>[m] - The number of the month with no leading zeroes if it is lower than 10.</li>
        <li>[mm] - The number of the month with leading zeroes if it is lower than 10.</li>
        <li>[mmm] - The name of the month abbreviated to 3 letters ("Jan", "Feb", etc...).</li>
        <li>[mmmm] - The full name of the month.</li>
        <li>[yyyy] - The year.</li>
        <li>[h] - The number of hours with no leading zeroes if it is lower than 10, using the 24-hour clock.</li>
        <li>[hh] - The number of hours with leading zeroes if it is lower than 10, using the 24-hour clock.</li>
        <li>[h12] - The number of hours with no leading zeroes if it is lower than 10, using the 12-hour clock.</li>
        <li>[hh12] - The number of hours with leading zeroes if it is lower than 10, using the 12-hour clock.</li>
        <li>[hm] - The number of minutes with no leading zeroes if it is lower than 10.</li>
        <li>[hmm] - The number of minutes with leading zeroes if it is lower than 10.</li>
        <li>[s] - The number of seconds with no leading zeroes if it is lower than 10.</li>
        <li>[ss] - The number of seconds with leading zeroes if it is lower than 10.</li>
        <li>[xx] - "am" or "pm". Remember to use h12 or hh12 if you use this template.</li>
      </ul>
      <div>You can use any symbol except for """ to separate things in your date templates. For example: "[mmm] [d], [yyyy] [h]:[hmm]", "[yyyy]-[mm]-[dd] [hh]:[hmm]", etc...</div>
      <br/>
      <div>Here is an example that generates a table with links to giveaways sorted in ascending order:</div>
      <br/>
      <div>Game | Giveaway | Level | Points | Ends</div>
      <div>:-: | :-: | :-: | :-: | :-:</div>
      <div>[line-asc][[name]]([steam-url]) | [Enter]([short-url]) | [level] | [points] | [end-time="[mmm] [d], [yyyy]"][/line]
      <br/>
      <br/>
    `);
    obj[`textArea${key}`] = insertHtml(context, `beforeEnd`, `
      <div class="page_outer_wrap">
        <textarea></textarea>
      </div>
    `).firstElementChild;
    if (esgst.cfh) {
      cfh_addPanel(obj[`textArea${key}`]);
    }
    obj[`message${key}`] = insertHtml(context, `beforeEnd`, `
      <div class="esgst-description"></div>
    `);
    context.appendChild(new ButtonSet_v2({
      color1: `grey`, color2: `grey`,
      icon1: `fa-copy`, icon2: `fa-circle-o-notch fa-spin`,
      title1: `Copy`, title2: `Copying...`,
      callback1: mm_copyOutput.bind(null, obj, key)
    }).set);
  }

  function mm_exportLinks(obj, items, key) {
    let links = [];
    items.forEach(item => {
      if (!item.mm || (!item.outerWrap.offsetParent && !item.outerWrap.closest(`.esgst-gv-container:not(.is-hidden):not(.esgst-hidden)`))) return;
      links.push(`[${escapeMarkdown(item.name || item.title || item.code)}](https://${key === `Games` ? `store.steampowered.com/${item.type.slice(0, -1)}/${item.code}` : `${location.hostname}/${key.toLowerCase().slice(0, -1)}/${item.code}/`})`);
    });
    obj[`textArea${key}`].value = links.join(`\n`);
  }

  function mm_exportCustom(obj, items, key) {
    let match = obj[`textArea${key}`].value.match(/\[LINE(.*?)\](.+)\[\/LINE\]/i),
      links = [];
    if (!match) return;
    let sorting = match[1],
      line = match[2];
    switch (key) {
      case `Giveaways`:
        items.forEach(item => {
          if (!item.mm || (!item.outerWrap.offsetParent && !item.outerWrap.closest(`.esgst-gv-container:not(.is-hidden):not(.esgst-hidden)`))) return;
          let type = ``;
          if (item.public) {
            type += `Public`;
          } else if (item.inviteOnly) {
            type += `Invite Only`;
            if (item.regionRestricted) {
              type += `Region Restricted`;
            }
          } else if (item.group) {
            type += `Group`;
            if (item.whitelist) {
              type += `Whitelist`;
            }
            if (item.regionRestricted) {
              type += `Region Restricted`;
            }
          } else if (item.whitelist) {
            type += `Whitelist`;
            if (item.regionRestricted) {
              type += `Region Restricted`;
            }
          } else if (item.regionRestricted) {
            type += `Region Restricted`;
          }
          links.push(line
            .replace(/\[CODE\]/ig, item.code)
            .replace(/\[COMMENTS\]/ig, item.comments)
            .replace(/\[COPIES\]/ig, item.copies)
            .replace(/\[CREATOR\]/ig, item.creator)
            .replace(/\[END-TIME="(.+?)"\]/ig, mm_formatDate.bind(null, item.endTime))
            .replace(/\[ENTRIES\]/ig, item.entries)
            .replace(/\[LEVEL\]/ig, item.level)
            .replace(/\[NAME\]/ig, escapeMarkdown(item.name))
            .replace(/\[POINTS\]/ig, item.points)
            .replace(/\[SHORT-URL\]/ig, `https://www.steamgifts.com/giveaway/${item.code}/`)
            .replace(/\[START-TIME="(.+?)"\]/ig, mm_formatDate.bind(null, item.startTime))
            .replace(/\[STEAM-ID\]/ig, item.id)
            .replace(/\[STEAM-TYPE\]/ig, item.type.slice(0, -1))
            .replace(/\[STEAM-URL\]/ig, `http://store.steampowered.com/${item.type.slice(0, -1)}/${item.id}`)
            .replace(/\[TYPE\]/ig, type)
            .replace(/\[URL\]/ig, `https://www.steamgifts.com${item.url.match(/\/giveaway\/.+/)[0]}`)
          );
        });
        break;
      case `Discussions`:
        items.forEach(item => {
          if (!item.mm || (!item.outerWrap.offsetParent && !item.outerWrap.closest(`.esgst-gv-container:not(.is-hidden):not(.esgst-hidden)`))) return;
          links.push(line
            .replace(/\[AUTHOR\]/ig, item.author)
            .replace(/\[CATEGORY\]/ig, escapeMarkdown(item.category))
            .replace(/\[CODE\]/ig, item.code)
            .replace(/\[COMMENTS\]/ig, item.comments)
            .replace(/\[CREATED-TIME="(.+?)"\]/ig, mm_formatDate.bind(null, item.createdTimestamp))
            .replace(/\[POLL\]/ig, item.poll ? `Yes` : `No`)
            .replace(/\[SHORT-URL\]/ig, `https://www.steamgifts.com/discussion/${item.code}/`)
            .replace(/\[TITLE\]/ig, escapeMarkdown(item.title))
            .replace(/\[URL\]/ig, `https://www.steamgifts.com${item.url.match(/\/discussion\/.+/)[0]}`)
          );
        });
        break;
      case `Users`:
        items.forEach(item => {
          if (!item.mm || (!item.outerWrap.offsetParent && !item.outerWrap.closest(`.esgst-gv-container:not(.is-hidden):not(.esgst-hidden)`))) return;
          links.push(line
            .replace(/\[URL\]/ig, `https://${location.hostname}/user/${item.code}`)
            .replace(/\[USERNAME\]/ig, item.code)
          );
        });
        break;
      case `Games`:
        items.forEach(item => {
          if (!item.mm || (!item.outerWrap.offsetParent && !item.outerWrap.closest(`.esgst-gv-container:not(.is-hidden):not(.esgst-hidden)`))) return;
          links.push(line
            .replace(/\[ID\]/ig, item.code)
            .replace(/\[NAME\]/ig, escapeMarkdown(item.name))
            .replace(/\[TYPE\]/ig, item.type.slice(0, -1))
            .replace(/\[URL\]/ig, `https://store.steampowered.com/${item.type.slice(0, -1)}/${item.code}`)
          );
        });
        break;
      default:
        break;
    }
    if (sorting) {
      links = sortArray(links, sorting === `-desc`);
    }
    obj[`textArea${key}`].value = obj[`textArea${key}`].value.replace(/\[LINE.*?\].+\[\/LINE\]/i, links.join(`\n`));
  }

  function mm_formatDate(timestamp, match, p1) {
    return escapeMarkdown(getDate(p1, timestamp));
  }

  function mm_initUrls(obj, items) {
    items.forEach(item => {
      if (!item.mm || (!item.outerWrap.offsetParent && !item.outerWrap.closest(`.esgst-gv-container:not(.is-hidden):not(.esgst-hidden)`))) return;
      obj.items.push({
        name: item.name,
        url: `https://www.steamgifts.com/giveaway/${item.code}/`
      });
    });
    obj.perLoad = obj.items.length;
  }

  async function mm_getSearchReplaceUrlRequest(obj, details, response, responseHtml) {
    let replaceValue, searchValue;
    if (esgst.mm_useRegExp) {
      try {
        let parts = obj.popup.getTextInputValue(0).match(/^\/(.+)\/(.*)$/);
        searchValue = new RegExp(parts[1], parts[2]);
        replaceValue = obj.popup.getTextInputValue(1);
      } catch (error) {
        obj.popup.setError(`Invalid regular expression!`);
        return;
      }
    } else {
      searchValue = obj.popup.getTextInputValue(0);
      replaceValue = obj.popup.getTextInputValue(1);
    }
    let description = responseHtml.querySelector(`.page__description textarea[name=description]`),
      name = obj.items[obj.index].name,
      url = obj.items[obj.index].url;
    if (description) {
      let match = esgst.mm_useRegExp ? description.value.match(searchValue) : description.value.includes(searchValue);
      if (match) {
        let responseJson = JSON.parse((await request({data: `xsrf_token=${esgst.xsrfToken}&do=edit_giveaway_description&giveaway_id=${description.previousElementSibling.value}&description=${encodeURIComponent(description.value.replace(searchValue, replaceValue))}`, method: `POST`, url: `/ajax.php`})).responseText);
        if (responseJson.type === `success`) {
          obj.context.firstElementChild.firstElementChild.insertAdjacentHTML(`beforeEnd`, `
            <li>Found and replaced in <a href="${url}">${name}</a></li>
          `);
        } else {
          obj.context.firstElementChild.firstElementChild.insertAdjacentHTML(`beforeEnd`, `
            <li>Found, but failed to replace, in <a href="${url}"
          `);
        }
      } else {
        obj.context.firstElementChild.firstElementChild.insertAdjacentHTML(`beforeEnd`, `
          <li>Not found in <a href="${url}">${name}</a></li>
        `);
      }
    } else {
      obj.context.firstElementChild.firstElementChild.insertAdjacentHTML(`beforeEnd`, `
        <li>Not found in <a href="${url}">${name}</a></li>
      `);
    }
  }

  async function mm_hideGiveaways(obj, items) {
    let newItems = {};
    items.forEach(item => {
      if (!item.mm || (!item.outerWrap.offsetParent && !item.outerWrap.closest(`.esgst-gv-container:not(.is-hidden):not(.esgst-hidden)`))) return;
      newItems[item.code] = {
        code: item.code,
        endTime: item.endTime,
        hidden: true
      };
      if (obj.source !== `main` || !esgst.giveawayPath) {
        item.outerWrap.remove();
      }
    });
    await lockAndSaveGiveaways(newItems);
  }

  async function mm_bookmarkGiveaways(obj, items) {
    let newItems = {};
    items.forEach(item => {
      if (!item.mm || (!item.outerWrap.offsetParent && !item.outerWrap.closest(`.esgst-gv-container:not(.is-hidden):not(.esgst-hidden)`)) || !item.gbButton || item.gbButton.index !== 1) return;
      newItems[item.code] = {
        bookmarked: true,
        code: item.code,
        endTime: item.endTime,
        name: item.name,
        started: item.started
      };
      item.gbButton.change(null, 2);
    });
    await lockAndSaveGiveaways(newItems);
  }

  async function mm_unbookmarkGiveaways(obj, items) {
    let newItems = {};
    items.forEach(item => {
      if (!item.mm || (!item.outerWrap.offsetParent && !item.outerWrap.closest(`.esgst-gv-container:not(.is-hidden):not(.esgst-hidden)`)) || !item.gbButton || item.gbButton.index !== 3) return;
      newItems[item.code] = {
        bookmarked: false
      };
      item.gbButton.change(null, 0);
    });
    await lockAndSaveGiveaways(newItems);
  }

  function mm_calculateGiveaways(obj, items) {
    let points = 0;
    items.forEach(item => {
      if (!item.mm || (!item.outerWrap.offsetParent && !item.outerWrap.closest(`.esgst-gv-container:not(.is-hidden):not(.esgst-hidden)`)) || item.ended) return;
      points += item.points;
    });
    let nextRefresh = 60 - new Date().getMinutes();
    while (nextRefresh > 15) nextRefresh -= 15;
    if (points > esgst.points) {
      obj.textAreaGiveaways.value = `You will need to wait ${ttec_getTime(Math.round((nextRefresh + (15 * Math.floor((points - esgst.points) / 6))) * 100) / 100)} to enter all selected giveaways for a total of ${points}P.${points > 400 ? `\n\nSince each 400P regeneration takes about 17h, you will need to return in 17h and use all your points so more can be regenerated.` : ``}`;
    } else {
      obj.textAreaGiveaways.value = `You have enough points to enter all giveaways right now.`;
    }
  }

  function mm_exportEncryptedGiveaways(obj, items) {
    let encrypted = [];
    items.forEach(item => {
      if (!item.mm || (!item.outerWrap.offsetParent && !item.outerWrap.closest(`.esgst-gv-container:not(.is-hidden):not(.esgst-hidden)`))) return;
      encrypted.push(`[](ESGST-${ged_encryptCode(item.code)})`);
    });
    obj.textAreaGiveaways.value = encrypted.join(` `);
  }

  function mm_copyOutput(obj, key) {
    obj[`textArea${key}`].select();
    document.execCommand(`copy`);
    createFadeMessage(obj[`message${key}`], `Copied!`);
  }

  async function mm_hideDiscussions(obj, items) {
    let newItems = {};
    items.forEach(item => {
      if (!item.mm || (!item.outerWrap.offsetParent && !item.outerWrap.closest(`.esgst-gv-container:not(.is-hidden):not(.esgst-hidden)`))) return;
      let currentDate = Date.now();
      newItems[item.code] = {
        hidden: currentDate,
        lastUsed: currentDate
      };
      if (obj.source !== `main` || !esgst.discussionPath) {
        item.outerWrap.remove();
      }
    });
    await lockAndSaveDiscussions(newItems);
  }

  async function mm_highlightDiscussions(obj, items) {
    let newItems = {};
    items.forEach(item => {
      if (!item.mm || (!item.outerWrap.offsetParent && !item.outerWrap.closest(`.esgst-gv-container:not(.is-hidden):not(.esgst-hidden)`)) || !item.dhButton || item.dhButton.index !== 1) return;
      newItems[item.code] = {
        highlighted: true,
        lastUsed: Date.now()
      };
      item.dhButton.change(null, 2);
    });
    await lockAndSaveDiscussions(newItems);
  }

  async function mm_unhighlightDiscussions(obj, items) {
    let newItems = {};
    items.forEach(item => {
      if (!item.mm || (!item.outerWrap.offsetParent && !item.outerWrap.closest(`.esgst-gv-container:not(.is-hidden):not(.esgst-hidden)`)) || !item.dhButton || item.dhButton.index !== 3) return;
      newItems[item.code] = {
        highlighted: false,
        lastUsed: Date.now()
      };
      item.dhButton.change(null, 0);
    });
    await lockAndSaveDiscussions(newItems);
  }

  async function mm_visitDiscussions(obj, items) {
    let newItems = {};
    items.forEach(item => {
      if (!item.mm || (!item.outerWrap.offsetParent && !item.outerWrap.closest(`.esgst-gv-container:not(.is-hidden):not(.esgst-hidden)`)) || !item.gdtttButton || item.gdtttButton.index !== 1) return;
      newItems[item.code] = {
        visited: true,
        lastUsed: Date.now()
      };
      if (esgst.ct_s) {
        newItems[item.code].count = item.count;
      }
      item.gdtttButton.callbacks[0]();
      item.gdtttButton.change(null, 2);
    });
    await lockAndSaveDiscussions(newItems);
  }

  async function mm_unvisitDiscussions(obj, items) {
    let newItems = {};
    items.forEach(item => {
      if (!item.mm || (!item.outerWrap.offsetParent && !item.outerWrap.closest(`.esgst-gv-container:not(.is-hidden):not(.esgst-hidden)`)) || !item.gdtttButton || item.gdtttButton.index !== 3) return;
      newItems[item.code] = {
        count: 0,
        visited: false,
        lastUsed: Date.now()
      };
      item.gdtttButton.callbacks[2]();
      item.gdtttButton.change(null, 0);
    });
    await lockAndSaveDiscussions(newItems);
  }

  function mm_selectWbcUsers(obj, items) {
    if (!esgst.wbcButton) return;
    esgst.mmWbcUsers = [];
    items.forEach(item => {
      if (!item.mm || (!item.outerWrap.offsetParent && !item.outerWrap.closest(`.esgst-gv-container:not(.is-hidden):not(.esgst-hidden)`))) return;
      esgst.mmWbcUsers.push(item.code);
    });
    esgst.wbcButton.setAttribute(`data-mm`, true);
    esgst.wbcButton.click();
  }

  async function mm_openTagPopup(obj, items, key) {
    obj.tPopup = new Popup(`fa-tags`, `Tag <span>0</span> ${key}:`, true);
    obj.tPopup.description.insertAdjacentHTML(`beforeEnd`, `
      <div class="esgst-description">Drag the tags to move them.<br/><br/>When editing a tag color, it will also alter the color for all users/games with that tag (you have to refresh the page for it to take effect).<br/><br/>[*] means that there are tags that are not shared between all users/games. If you delete the [*] tag, those individual tags will be deleted.</div>
    `);
    obj.tPopup.tags = insertHtml(obj.tPopup.description, `beforeEnd`, `
      <div class="esgst-${key[0].toLowerCase()}t-tags"></div>
    `);
    obj.tPopup.input = insertHtml(obj.tPopup.description, `beforeEnd`, `
      <input type="text">
    `);
    obj.tPopup.description.insertAdjacentHTML(`beforeEnd`, `
      <div class="esgst-description">Use commas to separate tags, for example: Tag1, Tag2, ...</div>
    `);
    obj.tPopup.description.appendChild(new ButtonSet_v2({
      color1: `green`, color2: `grey`,
      icon1: `fa-check`, icon2: `fa-circle-o-notch fa-spin`,
      title1: `Save`, title2: `Saving...`,
      callback1: mm_saveTags.bind(null, obj, items, key),
      input: obj.tPopup.input
    }).set);
    obj.tPopup.open();
    obj.tIndividualTags = {};
    obj.tTags = [];
    switch (key) {
      case `Users`: {
        obj.tPopup.input.addEventListener(`input`, ut_createTags.bind(null, obj.tPopup));
        let savedUsers = JSON.parse(await getValue(`users`));
        for (let i = 0, n = items.length; i < n; i++) {
          if (!items[i].mm || !items[i].outerWrap.offsetParent) continue;
          let username = items[i].code;
          let savedUser = await getUser(savedUsers, {
            [items[i].sg ? `username` : `steamId`]: username
          });
          if (savedUser) {
            let tags = savedUser.tags;
            if (tags) {
              obj.tIndividualTags[username] = tags;
              tags.forEach(tag => {
                if (obj.tTags.indexOf(tag) < 0) {
                  obj.tTags.push(tag);
                }
              });
            } else {
              obj.tIndividualTags[username] = [];
            }
          } else {
            obj.tIndividualTags[username] = [];
          }
        }
        let hasIndividual = false;
        items.forEach(item => {
          if (!item.mm || (!item.outerWrap.offsetParent && !item.outerWrap.closest(`.esgst-gv-container:not(.is-hidden):not(.esgst-hidden)`))) return;
          let username = item.code;
          obj.tIndividualTags[username].forEach(tag => {
            items.forEach(subItem => {
              if (!subItem.mm || !subItem.outerWrap.offsetParent) return;
              let subUsername = subItem.code;
              if (subUsername === username || obj.tIndividualTags[subUsername].indexOf(tag) > -1) return;
              let index = obj.tTags.indexOf(tag);
              if (index > -1) {
                obj.tTags.splice(index, 1);
              }
              hasIndividual = true;
            });
          });
        });
        if (hasIndividual) {
          obj.tTags.push(`[*]`);
        }
        obj.tTags.forEach(tag => {
          ut_createTag(obj.tPopup, tag);
        });
        obj.tPopup.input.value = obj.tTags.join(`, `);
        break;
      }
      case `Games`: {
        obj.tPopup.input.addEventListener(`input`, gt_createTags.bind(null, obj.tPopup));
        let savedGames = JSON.parse(await getValue(`games`));
        items.forEach(item => {
          if (!item.mm || (!item.outerWrap.offsetParent && !item.outerWrap.closest(`.esgst-gv-container:not(.is-hidden):not(.esgst-hidden)`))) return;
          let savedGame = savedGames[item.type][item.code];
          let gameKey = `${item.type}_${item.code}`;
          if (savedGame) {
            let tags = savedGame.tags;
            if (tags) {
              obj.tIndividualTags[gameKey] = tags;
              tags.forEach(tag => {
                if (obj.tTags.indexOf(tag) < 0) {
                  obj.tTags.push(tag);
                }
              });
            } else {
              obj.tIndividualTags[gameKey] = [];
            }
          } else {
            obj.tIndividualTags[gameKey] = [];
          }
        });
        let hasIndividual = false;
        items.forEach(item => {
          if (!item.mm || (!item.outerWrap.offsetParent && !item.outerWrap.closest(`.esgst-gv-container:not(.is-hidden):not(.esgst-hidden)`))) return;
          obj.tIndividualTags[`${item.type}_${item.code}`].forEach(tag => {
            items.forEach(subItem => {
              if (!subItem.mm || !subItem.outerWrap.offsetParent) return;
              if (subItem.code === item.code || obj.tIndividualTags[`${subItem.type}_${subItem.code}`].indexOf(tag) > -1) return;
              let index = obj.tTags.indexOf(tag);
              if (index > -1) {
                obj.tTags.splice(index, 1);
              }
              hasIndividual = true;
            });
          });
        });
        if (hasIndividual) {
          obj.tTags.push(`[*]`);
        }
        obj.tTags.forEach(tag => {
          gt_createTag(obj.tPopup, tag);
        });
        obj.tPopup.input.value = obj.tTags.join(`, `);
        break;
      }
      default:
        break;
    }
    obj.tPopup.input.focus();
  }

  async function mm_saveTags(obj, items, key) {
    switch (key) {
      case `Users`: {
        let tags = obj.tPopup.input.value.replace(/(,\s*)+/g, formatTags);
        let users = [];
        items.forEach(item => {
          if (!item.mm || (!item.outerWrap.offsetParent && !item.outerWrap.closest(`.esgst-gv-container:not(.is-hidden):not(.esgst-hidden)`))) return;
          let username = item.code;
          obj.tTags.forEach(tag => {
            let index = obj.tIndividualTags[username].indexOf(tag);
            if (index > -1) {
              obj.tIndividualTags[username].splice(index, 1);
            }
          });
          if (obj.tIndividualTags[username].length > 0) {
            obj.tIndividualTags[username] = tags.replace(/\[\*\]/, obj.tIndividualTags[username].join(`, `)).split(/,\s/);
          } else {
            obj.tIndividualTags[username] = tags.replace(/\[\*\]|,\s\[\*\]/, ``).split(/,\s/);
          }
          for (let i = obj.tIndividualTags[username].length - 1; i > -1; i--) {
            if (!obj.tIndividualTags[username][i]) {
              obj.tIndividualTags[username].splice(i, 1);
            }
          }
          users.push({
            [item.sg ? `username` : `steamId`]: username,
            values: {
              tags: Array.from(new Set(obj.tIndividualTags[username]))
            }
          });
        });
        await saveUsers(users);
        setSetting(`ut_colors`, esgst.ut_colors);
        items.forEach(item => {
          if (!item.mm || (!item.outerWrap.offsetParent && !item.outerWrap.closest(`.esgst-gv-container:not(.is-hidden):not(.esgst-hidden)`))) return;
          ut_addTags(item.code, obj.tIndividualTags[item.code]);
        });
        break;
      }
      case `Games`: {
        let tags = obj.tPopup.input.value.replace(/(,\s*)+/g, formatTags);
        let games = {
          apps: {},
          subs: {}
        };
        items.forEach(item => {
          if (!item.mm || (!item.outerWrap.offsetParent && !item.outerWrap.closest(`.esgst-gv-container:not(.is-hidden):not(.esgst-hidden)`))) return;
          let id = item.code;
          let type = item.type;
          let gameKey = `${type}_${id}`;
          obj.tTags.forEach(tag => {
            const index = obj.tIndividualTags[gameKey].indexOf(tag);
            if (index > -1) {
              obj.tIndividualTags[gameKey].splice(index, 1);
            }
          });
          if (obj.tIndividualTags[gameKey].length > 0) {
            obj.tIndividualTags[gameKey] = tags.replace(/\[\*\]/, obj.tIndividualTags[gameKey].join(`, `)).split(/,\s/);
          } else {
            obj.tIndividualTags[gameKey] = tags.replace(/\[\*\]|,\s\[\*\]/, ``).split(/,\s/);
          }
          for (let i = obj.tIndividualTags[gameKey].length - 1; i > -1; i--) {
            if (!obj.tIndividualTags[gameKey][i]) {
              obj.tIndividualTags[gameKey].splice(i, 1);
            }
          }
          games[type][id] = {
            tags: Array.from(new Set(obj.tIndividualTags[gameKey]))
          };
        });
        await lockAndSaveGames(games);
        setSetting(`gt_colors`, esgst.gt_colors);
        items.forEach(item => {
          if (!item.mm || (!item.outerWrap.offsetParent && !item.outerWrap.closest(`.esgst-gv-container:not(.is-hidden):not(.esgst-hidden)`))) return;
          gt_addTags(null, item.code, obj.tIndividualTags[`${item.type}_${item.code}`], item.type);
        });
        break;
      }
    }
    obj.tPopup.close();
  }

  async function mm_hideGames(obj, items) {
    const newItems = {
          apps: {},
          subs: {}
        },
        notFound = [];
    for (const item of items) {
      if (!item.mm || (!item.outerWrap.offsetParent && !item.outerWrap.closest(`.esgst-gv-container:not(.is-hidden):not(.esgst-hidden)`))) continue;

      const elements = parseHtml(JSON.parse((await request({
        data: `do=autocomplete_giveaway_game&page_number=1&search_query=${encodeURIComponent(item.code)}`,
        method: `POST`,
        url: `/ajax.php`
      })).responseText).html).getElementsByClassName(`table__row-outer-wrap`);
      let found = false;
      for (let i = elements.length - 1; i > -1; i--) {
        const element = elements[i],
            info = games_getInfo(element);
        if (info && info.type === item.type && info.id === item.code) {
          await request({
            data: `xsrf_token=${esgst.xsrfToken}&do=hide_giveaways_by_game_id&game_id=${element.getAttribute(`data-autocomplete-id`)}`,
            method: `POST`,
            url: `/ajax.php`
          });
          newItems[item.type][item.code] = {
            hidden: true
          };
          found = true;
          break;
        }
      }
      if (!found) {
        notFound.push(item.name);
      }
    }
    await lockAndSaveGames(newItems);
    if (notFound.length) {
      alert(`The following games were not found and therefore not hidden: ${notFound.join(`, `)}`);
    }
  }

  // [MPP]
  
  _MODULES.push({
    description: `
      <ul>
        <li>Hides the main post of a discussion and adds a button (<i class="fa fa-home"></i>) to its main page heading that allows you to open the main post through a popup.</li>
        <li>This feature is useful if you have [id=fmph] enabled, which allows you to view the main post of a discussion from any scrolling position.</li>
      </ul>
    `,
    features: {
      mpp_r: {
        description: `
          <ul>
            <li>This option requires [id=ct] enabled to work.</li>
          </ul>
        `,
        name: `Only hide the main post if it has been marked as read.`,
        sg: true
      }
    },
    id: `mpp`,
    load: mpp,
    name: `Main Post Popup`,
    sg: true,
    type: `discussions`
  });

  function mpp() {
    if (!esgst.discussionPath) {
      return;
    }
    let button = createHeadingButton({id: `mpp`, icons: [`fa-home`], title: `Open the main post`});
    let MPPPost = document.createElement(`div`);
    MPPPost.className = `page__outer-wrap`;
    let Sibling;
    do {
      Sibling = esgst.mainPageHeading.previousElementSibling;
      if (Sibling) {
        MPPPost.insertBefore(Sibling, MPPPost.firstElementChild);
      }
    } while (Sibling);
    esgst.mainPageHeading.parentElement.insertBefore(MPPPost, esgst.mainPageHeading);
    let Hidden;
    if (esgst.mpp_r) {
      let discussion = JSON.parse(esgst.storage.discussions)[location.pathname.match(/^\/discussion\/(.+?)\//)[1]];
      if (discussion) {
        if (discussion.readComments && discussion.readComments[``]) {
          Hidden = true;
          scrollTo(0, 0);
        } else {
          Hidden = false;
        }
      } else {
        Hidden = false;
      }
    } else {
      Hidden = true;
      scrollTo(0, 0);
    }
    MPPPost.classList.add(Hidden ? `esgst-mpp-hidden` : `esgst-mpp-visible`);
    button.addEventListener(`click`, () => {
      if (!Hidden) {
        MPPPost.classList.remove(`esgst-mpp-visible`);
        MPPPost.classList.add(`esgst-mpp-hidden`);
      }
      let popup = new Popup(null, null, false, false, MPPPost);
      MPPPost.classList.add(`esgst-mpp-popup`);
      popup.open();
      popup.onClose = () => {
        MPPPost.classList.remove(`esgst-mpp-popup`);
        if (!Hidden) {
          MPPPost.classList.remove(`esgst-mpp-hidden`);
          MPPPost.classList.add(`esgst-mpp-visible`);
          MPPPost.removeAttribute(`style`);
          esgst.mainPageHeading.parentElement.insertBefore(MPPPost, esgst.mainPageHeading);
        }
      };
    });
  }

  // MPS

  _MODULES.push({
    description: `
      <ul>
        <li>Skips to the comments of a discussion if you have used the pagination navigation. For example, if you enter a discussion and use the pagination navigation to go to page 2, on page 2 the feature will skip the main post and take you directly to the comments.</li>
      </ul>
    `,
    id: `mps`,
    load: mps,
    name: `Main Post Skipper`,
    sg: true,
    type: `discussions`
  });

  function mps() {
    if (!location.hash && esgst.discussionPath && esgst.paginationNavigation && document.referrer.match(new RegExp(`/discussion/${[location.pathname.match(/^\/discussion\/(.+?)\//)[1]]}/`))) {
      goToComment(``, esgst.pagination.previousElementSibling.firstElementChild.firstElementChild, true);
    }
  }

  // [NM]

  _MODULES.push({
    // by Royalgamer06
    description: `
      <ul>
        <li>Adds a second inbox icon colored as red (<i class="fa fa-envelope esgst-red"></i>) to the header of any page that allows you to be notified about messages from SteamTrades on SteamGifts and vice-versa.</li>
        <li>This feature is compatible with [id=hr_b].</li>
      </ul>
    `,
    id: `nm`,
    load: nm,
    name: `Notification Merger`,
    sg: true,
    st: true,
    type: `general`
  });

  function nm() {
    if (esgst.hr) return;
    nm_getNotifications();
  }

  async function nm_getNotifications() {
    if (esgst.sg) {
      let notification = parseHtml((await request({method: `GET`, url: `https://www.steamtrades.com`})).responseText).getElementsByClassName(`message_count`)[0];
      if (!notification) {
        if (esgst.altInboxButton) {
          // hide the button, since there are no notifications
          esgst.altInboxButton.classList.add(`esgst-hidden`);
        }
        return;
      }
      if (esgst.altInboxButton) {
        // the button already exists, so simply unhide it and change the message count
        esgst.altInboxButton.classList.remove(`esgst-hidden`);
        esgst.altMessageCount.textContent = notification.textContent;
      } else {
        // the button does not exist yet, so add it and save it in a global variable
        esgst.altInboxButton = insertHtml(esgst.inboxButton, `afterEnd`, `
          <div class="nav__button-container nav__button-container--notification nav__button-container--active">
            <a class="nav__button" href="https://www.steamtrades.com/messages" title="${getFeatureTooltip(`nm`, `SteamTrades Messages`)}">
              <i class="fa fa-envelope esgst-nm-icon"></i>
              <div class="nav__notification">${notification.textContent}</div>
            </a>
          </div>
        `);
        esgst.altMessageCount = esgst.altInboxButton.firstElementChild.lastElementChild;
      }
    } else {
      let notification = parseHtml((await request({method: `GET`, url: `https://www.steamgifts.com`})).responseText).getElementsByClassName(`nav__notification`)[0];
      if (!notification) {
        if (esgst.altInboxButton) {
          // hide the button, since there are no notifications
          esgst.altInboxButton.classList.add(`esgst-hidden`);
        }
        return;
      }
      if (esgst.altInboxButton) {
        // the button already exists, so simply unhide it and change the message count
        esgst.altInboxButton.classList.remove(`esgst-hidden`);
        esgst.altMessageCount.textContent = notification.textContent;
      } else {
        // the button does not exist yet, so add it and save it in a global variable
        esgst.altInboxButton = insertHtml(esgst.inboxButton, `afterEnd`, `
          <div class="nav_btn_container" title="${getFeatureTooltip(`nm`)}">
            <a class="nav_btn" href="https://www.steamgifts.com/messages">
              <i class="fa fa-envelope esgst-nm-icon"></i>
              <span>Messages <span class="message_count">${notification.textContent}</span></span>
            </a>
          </div>
        `);
        esgst.altMessageCount = esgst.altInboxButton.firstElementChild.lastElementChild.lastElementChild;
      }
    }
  }

  // [NPTH]

  _MODULES.push({
    description: `
      <ul>
        <li>Allows you to navigate through a train using hotkeys.</a>
        <li>This feature is not 100% accurate, because the feature looks for a link with any variation of "previous"/"next" in the giveaway's description to make sure that it is going backward/forward, so if it does not find such a link, it will not work.</li>
        <li>It also does not work if you press the hotkey inside of an input/text area.</li>
        <li>If you press Ctrl together with the hotkey, the giveaway is open in a new tab.</li>
      </ul>
    `,
    id: `npth`,
    load: npth,
    name: `Next/Previous Train Hotkeys`,
    inputItems: [
      {
        event: `keydown`,
        id: `npth_previousKey`,
        prefix: `Enter the key you want to use for previous links: `
      },
      {
        event: `keydown`,
        id: `npth_nextKey`,
        prefix: `Enter the key you want to use for next links: `
      }
    ],
    sg: true,
    type: `giveaways`
  });

  function npth() {
    let description, element, elements, i, n, next, previous, text;
    if (esgst.giveawayCommentsPath) {
      description = document.getElementsByClassName(`page__description`)[0];
      if (description) {
        elements = description.querySelectorAll(`[href*="/giveaway/"]`);
        n = elements.length;
        for (i = 0; i < n && (!previous || !next); ++i) {
          element = elements[i];
          text = element.textContent.toLowerCase();
          if (!previous && text.match(/back|last|less|prev|<|←/)) {
            previous = element;
          } else if (!next && text.match(/forw|more|next|>|→/)) {
            next = element;
          }
        }
        if (!previous || !next) {
          if (n > 1) {
            previous = elements[0];
            next = elements[1];
          } else {
            next = elements[0];
          }
        }
        if (previous || next) {
          document.addEventListener(`keydown`, npth_loadGiveaway.bind(null, next, previous));
        }
      }
    }
  }

  function npth_loadGiveaway(next, previous, event) {
    let referrer;
    if (!event.target.closest(`input, textarea`)) {
      if (event.key === esgst.npth_previousKey) {
        if (previous) {
          if (event.ctrlKey) {
            open(previous.getAttribute(`href`));
          } else {
            location.href = previous.getAttribute(`href`);
          }
        } else {
          referrer = document.referrer;
          if (referrer.match(/\/giveaway\//) && ((next && referrer !== next.getAttribute(`href`)) || !next)) {
            if (event.ctrlKey) {
              open(referrer);
            } else {
              location.href = referrer;
            }
          } else {
            createAlert(`No previous link found.`);
          }
        }
      } else if (event.key === esgst.npth_nextKey) {
        if (next) {
          if (event.ctrlKey) {
            open(next.getAttribute(`href`));
          } else {
            location.href = next.getAttribute(`href`);
          }
        } else {
          createAlert(`No next link found.`);
        }
      }
    }
  }

  // [PNOT]

  _MODULES.push({
    description: `
      <ul>
        <li>Moves the pagination navigation of any page to the main page heading of the page.</li>
      </ul>
    `,
    id: `pnot`,
    load: pnot,
    name: `Pagination Navigation On Top`,
    sg: true,
    st: true,
    type: `general`
  });

  function pnot() {
    if (!esgst.paginationNavigation || !esgst.mainPageHeading) return;

    if (esgst.st) {
      esgst.paginationNavigation.classList.add(`page_heading_btn`);
    }
    esgst.paginationNavigation.title = getFeatureTooltip(`pnot`);
    esgst.mainPageHeading.appendChild(esgst.paginationNavigation);
  }

  // [PGB]
  
  _MODULES.push({
    description: `
      <ul>
        <li>Modifies the arrow button in the pinned giveaways box of the main page so that you are able to collapse the box again after expanding it.</li>
      </ul>
    `,
    id: `pgb`,
    load: pgb,
    name: `Pinned Giveaways Button`,
    sg: true,
    type: `giveaways`
  });

  function pgb() {
    let button = document.getElementsByClassName(`pinned-giveaways__button`)[0];
    if (!button) return;
    const container = button.previousElementSibling;
    container.classList.add(`esgst-pgb-container`);
    button.remove();
    button = insertHtml(container, `afterEnd`, `
      <div class="esgst-pgb-button">
        <i class="esgst-pgb-icon fa fa-angle-down"></i>
      </div>
    `);
    const icon = button.firstElementChild;
    button.addEventListener(`click`, pgb_toggle.bind(null, container, icon));
  }

  function pgb_toggle(container, icon) {
    container.classList.toggle(`pinned-giveaways__inner-wrap--minimized`);
    icon.classList.toggle(`fa-angle-down`);
    icon.classList.toggle(`fa-angle-up`);
  }

  // [PM]
  
  _MODULES.push({
    description: `
      <ul>
        <li>Adds a checkbox in front of a discussion categorized as "Puzzles" (in any page) that changes states (<i class="fa fa-circle-o esgst-grey"></i> by default, <i class="fa fa-times-circle esgst-red"></i> for "unsolved", <i class="fa fa-exclamation-circle esgst-orange"></i> for "in progress" and <i class="fa fa-check-circle esgst-green"></i> for "solved") and allows you to mark the puzzle as unsolved/in progress/solved.</li>
      </ul>
    `,
    features: {
      pm_a: {
        name: `Show the checkbox for all discussions, regardless of their category.`,
        sg: true
      }
    },
    id: `pm`,
    name: `Puzzle Marker`,
    sg: true,
    type: `discussions`
  });

  async function pm_change(code, status) {
    let deleteLock = await createLock(`commentLock`, 300);
    let discussions = JSON.parse(await getValue(`discussions`));
    if (!discussions[code]) {
      discussions[code] = {
        readComments: {}
      };
    }
    if (status === `off`) {
      delete discussions[code].status;
    } else {
      discussions[code].status = status;
    }
    discussions[code].lastUsed = Date.now();
    await setValue(`discussions`, JSON.stringify(discussions));
    deleteLock();
    return true;
  }

  // [PV]

  _MODULES.push({
    conflicts: [
      {id: `lpv`, name: `Level Progress Visualizer`}
    ],
    description: `
      <ul>
        <li>Displays a green bar in the account button at the header of any page that represents the amount of points that you have.</li>
      </ul>
    `,
    id: `pv`,
    load: pv,
    name: `Points Visualizer`,
    sg: true,
    type: `general`
  });

  function pv() {
    pv_setStyle();
  }

  function pv_setStyle() {
    const points = Math.min(400, esgst.points);
    const percentage = points / 400 * 100;
    const progress = parseInt(percentage * 1.86); // 186px is the width of the button
    const firstBar = `${progress}px`;
    const secondBar = `${Math.max(0, progress - 157)}px`; // 157px is the width of the button without the arrow
    if (!esgst.pvStyle) {
      esgst.pvStyle = insertHtml(esgst.style, `afterEnd`, `<style id="esgst-pv-style"></style>`);
    }
    esgst.pvStyle.innerHTML = `
      .esgst-lpv-container {
        background-image: linear-gradient(to right, var(--esgst-lpv-bar, #609f60) ${firstBar}, transparent ${firstBar}), var(--esgst-lpv-button, linear-gradient(#8a92a1 0px, #757e8f 8px, #4e5666 100%)) !important;
      }
      .esgst-lpv-container .nav__button--is-dropdown:hover {
        background-image: linear-gradient(to right, var(--esgst-lpv-bar-hover, #6dac6d) ${firstBar}, transparent ${firstBar}), var(--esgst-lpv-button-hover, linear-gradient(#9ba2b0 0px, #8c94a3 8px, #596070 100%)) !important;
      }
      .esgst-lpv-container .nav__button--is-dropdown-arrow:hover {
        background-image: linear-gradient(to right, var(--esgst-lpv-bar-hover, #6dac6d) ${secondBar}, transparent ${secondBar}), var(--esgst-lpv-button-hover, linear-gradient(#9ba2b0 0px, #8c94a3 8px, #596070 100%)) !important;
      }
      .esgst-lpv-container .nav__button--is-dropdown-arrow.is-selected {
        background-image: linear-gradient(to right, var(--esgst-lpv-bar, #609f60) ${secondBar}, transparent ${secondBar}), var(--esgst-lpv-arrow, linear-gradient(#4e525f 0px, #434857 5px, #2b2e3a 100%)) !important;
      }
      .esgst-lpv-container.is-selected .nav__button--is-dropdown {
        background-image: linear-gradient(to right, var(--esgst-lpv-bar-hover, #6dac6d) ${firstBar}, transparent ${firstBar}), var(--esgst-lpv-button-selected, linear-gradient(#d0d5de 0px, #c9cdd7 5px, #9097a6 100%)) !important;
      }
      .esgst-lpv-container.is-selected .nav__button--is-dropdown-arrow {
        background-image: linear-gradient(to right, var(--esgst-lpv-bar-hover, #6dac6d) ${secondBar}, transparent ${secondBar}), var(--esgst-lpv-button-selected, linear-gradient(#d0d5de 0px, #c9cdd7 5px, #9097a6 100%)) !important;
      }
      .esgst-lpv-container.is-selected .nav__button--is-dropdown:hover {
        background-image: linear-gradient(to right, var(--esgst-lpv-bar-selected, #7ab97a) ${firstBar}, transparent ${firstBar}), var(--esgst-lpv-button-selected-hover, linear-gradient(#f0f1f5 0px, #d1d4de 100%)) !important;
      }
      .esgst-lpv-container.is-selected .nav__button--is-dropdown-arrow:hover:not(.is-selected) {
        background-image: linear-gradient(to right, var(--esgst-lpv-bar-selected, #7ab97a) ${secondBar}, transparent ${secondBar}), var(--esgst-lpv-button-selected-hover, linear-gradient(#f0f1f5 0px, #d1d4de 100%)) !important;
      }
      .esgst-lpv-container.is-selected .nav__button--is-dropdown-arrow.is-selected {
        background-image: linear-gradient(to right, var(--esgst-lpv-bar-selected, #7ab97a) ${secondBar}, transparent ${secondBar}), var(--esgst-lpv-arrow-selected, linear-gradient(#4e525f 0px, #434857 5px, #2b2e3a 100%)) !important;
      }
    `;
    esgst.mainButton.parentElement.classList.add(`esgst-lpv-container`);
  }

  // [QGS]

  _MODULES.push({
    description: `
      <ul>
        <li>Adds a search box before the "Giveaways" box at the header of any page that allows you to quickly search for giveaways from any page.</li>
        <li>Has [id=ags] built-in.</li>
      </ul>
    `,
    features: {
      qgs_h: {
        name: `Hide the native search on the main page.`,
        sg: true
      }
    },
    id: `qgs`,
    load: qgs,
    name: `Quick Giveaway Search`,
    sg: true,
    type: `giveaways`
  });

  function qgs() {
    let container = insertHtml(document.getElementsByClassName(`nav__left-container`)[0], `afterBegin`, `
      <div class="esgst-qgs-container" title="${getFeatureTooltip(`qgs`)}">
        <input class="esgst-qgs-input" placeholder="Search..." type="text">
        <i class="fa fa-search"></i>
      </div>
    `);
    container.addEventListener(`mouseenter`, qgs_expand);
    container.addEventListener(`mouseleave`, qgs_collapse);
    container.firstElementChild.addEventListener(`keypress`, qgs_trigger);
    if (esgst.qgs_h && esgst.giveawaysPath) {
      document.getElementsByClassName(`sidebar__search-container`)[0].remove();
    }
  }

  function qgs_expand(event) {
    event.currentTarget.classList.add(`esgst-qgs-container-expanded`);
  }

  function qgs_collapse(event) {
    if (event.relatedTarget.closest(`.esgst-popout`)) return;
    event.currentTarget.classList.remove(`esgst-qgs-container-expanded`);
  }

  function qgs_trigger(event) {
    if (event.key !== `Enter`) return;
    event.preventDefault();
    location.href = `/giveaways/search?q=${encodeURIComponent(event.currentTarget.value)}`;
  }
  
  // [AGS]
  
  _MODULES.push({
    description: `
      <ul>
        <li>Adds a panel below the search field of the main page that allows you to easily search for giveaways using SteamGifts' <a href="https://www.steamgifts.com/discussion/8SzdT/">search parameters</a>.</li>
      </ul>
    `,
    id: `ags`,
    load: ags,
    name: `Advanced Giveaway Search`,
    sg: true,
    type: `giveaways`
  });

  function ags() {
    let query = ``;
    if (esgst.giveawaysPath) {
      query += `.sidebar__search-container, `;
    }
    if (esgst.qgs) {
      query += `.esgst-qgs-container, `;
    }
    if (!query) return;
    const elements = document.querySelectorAll(query.slice(0, -2));
    for (const element of elements) {
      ags_addPanel(element);
    }
  }

  function ags_addPanel(context) {
    const qgs = context.classList.contains(`esgst-qgs-container`);
    let obj = {
      qgs
    };
    context.firstElementChild.remove();
    obj.input = insertHtml(context, `afterBegin`, `
      <input class="${qgs ? `esgst-qgs-input` : `sidebar__search-input`}" placeholder="Search..." type="text">
    `);
    let icon = obj.input.nextElementSibling;
    icon.classList.add(`esgst-clickable`);
    icon.title = getFeatureTooltip(`ags`, `Use advanced search`);
    if (!qgs) {
      let match = location.search.match(/q=(.*?)(&.*?)?$/);
      if (match) {
        obj.input.value = decodeURIComponent(match[1]);
      }
    }
    if (!qgs && ((esgst.adots && esgst.adots_index === 0) || !esgst.adots)) {
      obj.panel = insertHtml(context, `afterEnd`, `
        <div class="esgst-ags-panel"></div>
      `);
    } else {
      obj.panel = new Popout(`esgst-ags-panel`, context, 100).popout;
    }
    let filterDetails = [
      {
        key: `ags_type`,
        parameter: `type`,
        name: `Type`,
        options: [
          {
            name: `All`,
            value: ``
          },
          {
            name: `Wishlist`,
            value: `wishlist`
          },
          {
            name: `Recommended`,
            value: `recommended`
          },
          {
            name: `Group`,
            value: `group`
          },
          {
            name: `New`,
            value: `new`
          }
        ],
        type: `select`
      },
      {
        maxKey: `ags_maxDate`,
        minKey: `ags_minDate`,
        maxParameter: `release_date_max`,
        minParameter: `release_date_min`,
        name: `Release Date`,
        type: `input`
      },
      {
        maxKey: `ags_maxScore`,
        minKey: `ags_minScore`,
        maxParameter: `metascore_max`,
        minParameter: `metascore_min`,
        name: `Metascore`,
        type: `input`
      },
      {
        maxKey: `ags_maxLevel`,
        minKey: `ags_minLevel`,
        maxParameter: `level_max`,
        minParameter: `level_min`,
        name: `Level`,
        type: `select`
      },
      {
        maxKey: `ags_maxEntries`,
        minKey: `ags_minEntries`,
        maxParameter: `entry_max`,
        minParameter: `entry_min`,
        name: `Entries`,
        type: `input`
      },
      {
        maxKey: `ags_maxCopies`,
        minKey: `ags_minCopies`,
        maxParameter: `copy_max`,
        minParameter: `copy_min`,
        name: `Copies`,
        type: `input`
      },
      {
        maxKey: `ags_maxPoints`,
        minKey: `ags_minPoints`,
        maxParameter: `point_max`,
        minParameter: `point_min`,
        name: `Points`,
        type: `input`
      },
      {
        key: `ags_regionRestricted`,
        name: `Region Restricted`,
        parameter: `region_restricted`,
        type: `checkbox`
      },
      {
        key: `ags_dlc`,
        name: `DLC`,
        parameter: `dlc`,
        type: `checkbox`
      },
      {
        key: `ags_app`,
        name: `App`,
        parameter: `app`,
        type: `checkbox`
      },
      {
        key: `ags_sub`,
        name: `Sub`,
        parameter: `sub`,
        type: `checkbox`
      }
    ];
    obj.filters = [];
    for (let i = 0, n = filterDetails.length; i < n; ++i) {
      ags_createFilter(obj, filterDetails[i]);
    }
    obj.input.addEventListener(`keydown`,
      triggerOnEnter.bind(null, ags_searchQuery.bind(null, obj))
    );
    icon.addEventListener(`click`, ags_searchQuery.bind(null, obj));
  }

  function ags_createFilter(obj, details) {
    if (details.key === `ags_type` && !obj.qgs) {
      return;
    }
    if (details.type === `checkbox`) {
      let element = insertHtml(obj.panel, `beforeEnd`, `
          <div class="esgst-ags-checkbox-filter">
            <span>${details.name}</span>
          </div>
        `),
        filter = new Checkbox(
          element,
          esgst[details.key]
        ).input;
      observeChange(filter, details.key, `checked`, `click`);
      obj.filters.push({
        filter: filter,
        key: `checked`,
        parameter: details.parameter
      });
    } else if (details.options) {
      let html = `
        <select>
      `;
      details.options.forEach(option => {
        html += `
          <option value="${option.value}">${option.name}</option>
        `;
      });
      html += `
        </select>
      `;
      let element = insertHtml(obj.panel, `beforeEnd`, `
          <div style="display: block;">${details.name} <div class="esgst-ags-filter">${html}</div></div>
        `),
        filter = element.firstElementChild.firstElementChild;
      filter.value = esgst[details.key];
      observeNumChange(filter, details.key);
      obj.filters.push({
        filter: filter,
        key: `value`,
        parameter: details.parameter
      });
    } else {
      let html = ``;
      if (details.type === `select`) {
        html = `
          <select>
            <option></option>
        `;
        for (let i = 0; i <= 10; ++i) {
          html += `
            <option>${i}</option>
          `;
        }
        html += `
          </select>
        `;
      } else if (details.maxKey === `ags_maxDate`) {
        html = `
          <input type="date">
        `;
      } else {
        html = `
          <input type="text">
        `;
      }
      let element = insertHtml(obj.panel, `beforeEnd`, `
        <div>${details.name} <div class="esgst-ags-filter">${html}</div><div class="esgst-ags-filter">${html}</div></div>
      `);
      let maxFilter = element.lastElementChild.lastElementChild;
      maxFilter.value = esgst[details.maxKey];
      observeNumChange(maxFilter, details.maxKey);
      let minFilter = element.firstElementChild.lastElementChild;
      minFilter.value = esgst[details.minKey];
      observeNumChange(minFilter, details.minKey);
      if (details.type === `input`) {
        maxFilter.addEventListener(`keypress`,
          triggerOnEnter.bind(null, ags_searchQuery.bind(null, obj))
        );
        minFilter.addEventListener(`keypress`,
          triggerOnEnter.bind(null, ags_searchQuery.bind(null, obj))
        );
      }
      obj.filters.push({
        filter: minFilter,
        key: `value`,
        parameter: details.minParameter
      });
      obj.filters.push({
        filter: maxFilter,
        key: `value`,
        parameter: details.maxParameter
      });
    }
  }

  function ags_searchQuery(obj) {
    let url;
    if (esgst.ags_app || esgst.ags_sub) {
      url = `https://www.steamgifts.com/giveaways/search?q=`;
    } else {
      url = `https://www.steamgifts.com/giveaways/search?q=${encodeURIComponent(obj.input.value)}`;
    }
    if (!obj.qgs) {
      let match = location.search.match(/(type=.*?)(&.*?)?$/);
      if (match) {
        url += `&${match[1]}`;
      }
    }
    for (let i = 0, n = obj.filters.length; i < n; ++i) {
      let filter = obj.filters[i],
        value = filter.filter[filter.key];
      if (value) {
        if (filter.parameter === `app`) {
          url += `&app=${obj.input.value}`;
        } else if (filter.parameter === `sub`) {
          url += `&sub=${obj.input.value}`;
        } else {
          url += `&${filter.parameter}=${value}`;
        }
      }
    }
    location.href = url;
  }

  // [SMGB]

  _MODULES.push({
    description: `
      <ul>
        <li>Turns the magnifying glass icon (<i class="fa fa-search"></i>) in the search field of any page into a button that submits the search when you click on it.</li>
      </ul>
    `,
    id: `smgb`,
    load: smgb,
    name: `Search Magnifying Glass Button`,
    sg: true,
    type: `general`
  });

  function smgb() {
    let buttons, i;
    buttons = document.querySelectorAll(`.sidebar__search-container .fa-search, .esgst-qgs-container .fa-search`);
    for (i = buttons.length - 1; i > -1; --i) {
      let button, input;
      button = buttons[i];
      input = button.previousElementSibling;
      button.classList.add(`esgst-clickable`);
      button.addEventListener(`click`, () => {
        let value = input.value.trim();
        if (value) {
          location.href = `${esgst.searchUrl.replace(/page=/, ``)}q=${value}`;
        }
      });
    }
  }

  // [RADB]

  _MODULES.push({
    description: `
      <ul>
        <li>Adds a button (<i class="fa fa-refresh"></i>) to the page heading of the active discussions (in the main page) that allows you to refresh the active discussions without having to refresh the entire page.</li>
      </ul>
    `,
    id: `radb`,
    name: `Refresh Active Discussions Button`,
    sg: true,
    type: `discussions`
  });

  function radb_addButtons() {
    let elements, i;
    elements = esgst.activeDiscussions.querySelectorAll(`.homepage_heading, .esgst-heading-button`);
    for (i = elements.length - 1; i > -1; --i) {
      insertHtml(elements[i], `beforeBegin`, `
        <div class="esgst-radb-button${esgst.oadd ? `` : ` homepage_heading`}" title="${getFeatureTooltip(`radb`, `Refresh active discussions/deals`)}">
          <i class="fa fa-refresh"></i>
        </div>
      `).addEventListener(`click`, event => {
        let icon = event.currentTarget.firstElementChild;
        icon.classList.add(`fa-spin`);
        if (esgst.oadd) {
          oadd_load(true, () => {
            icon.classList.remove(`fa-spin`);
          });
        } else {
          checkMissingDiscussions(true, () => {
            icon.classList.remove(`fa-spin`);
          });
        }
      });
    }
  }

  // [RBP]

  _MODULES.push({
    description: `
      <ul>
        <li>Adds a button (<i class="fa fa-comment"></i>) to the main page heading of any page that allows you to add comments to the page through a popup.</li>
        <li>This feature is useful if you have [id=fmph] enabled, which allows you to add comments to the page from any scrolling position.</li>
        <li>Has [id=ded] built-in.</li>
      </ul>
    `,
    id: `rbp`,
    load: rbp,
    name: `Reply Box Popup`,
    sg: true,
    st: true,
    type: `comments`
  });

  function rbp() {
    if (!esgst.replyBox) return;

    let button = createHeadingButton({id: `rbp`, icons: [`fa-comment`], title: `Add a comment`});
    let popup = new Popup(`fa-comment`, `Add a comment:`);
    popup.textArea = insertHtml(popup.scrollable, `beforeEnd`, `
      <textarea name="description"></textarea>
    `);
    popup.description.appendChild(new ButtonSet(`green`, `grey`, `fa-check`, `fa-circle-o-notch fa-spin`, `Save`, `Saving...`, Callback => {
      popup.progress.innerHTML = ``;
      saveComment(esgst.sg ? `` : document.querySelector(`[name="trade_code"]`).value, ``, popup.textArea.value, esgst.sg ? location.href.match(/(.+?)(#.+?)?$/)[1] : `/ajax.php`, popup.progress,
        Callback);
    }).set);
    popup.progress = insertHtml(popup.description, `beforeEnd`, `<div></div>`);
    button.addEventListener(`click`, popup.open.bind(popup, popup.textArea.focus.bind(popup.textArea)));
  }

  // [CFH]

  _MODULES.push({
    description: `
      <ul>
        <li>When you click on any text area (in any page) to start writing a comment, a panel is added above it that helps you use SteamGifts' <a href="https://www.steamgifts.com/about/comment-formatting">comment formatting</a>.</li>
        <li>There is a button (<i class="fa fa-paste"></i> if enabled and <i class="fa fa-paste esgst-faded"></i> if disabled) in the panel that allows the feature to automatically format links/images pasted into the text area.</li>
        <li>There are also buttons (<i class="fa fa-rotate-right"></i> to redo and <i class="fa fa-rotate-left"></i> to undo) in the panel that allow you to redo/undo any formatting added.</li>
      </ul>
    `,
    features: {
      cfh_bq: {
        description: `
          <ul>
            <li>Adds a button (<i class="fa fa-quote-left"></i>) to the panel that allows you to write text like shown below.</li>
          </ul>
          <blockquote>Blockquote</blockquote>
        `,
        name: `Blockquote`,
        sg: true,
        st: true
      },
      cfh_b: {
        description: `
          <ul>
            <li>Adds a button (B) to the panel that allows you to write text like shown below.</li>
          </ul>
          <strong>Bold</strong>
        `,
        name: `Bold`,
        sg: true,
        st: true
      },
      cfh_h1: {
        description: `
          <ul>
            <li>Adds a button (H¹) to the panel that allows you to write text like shown below.</li>
          </ul>
          <h1>Heading 1</h1>
        `,
        name: `Heading 1`,
        sg: true,
        st: true
      },
      cfh_h2: {
        description: `
          <ul>
            <li>Adds a button (H²) to the panel that allows you to write text like shown below.</li>
          </ul>
          <h2>Heading 2</h2>
        `,
        name: `Heading 2`,
        sg: true,
        st: true
      },
      cfh_h3: {
        description: `
          <ul>
            <li>Adds a button (H³) to the panel that allows you to write text like shown below.</li>
          </ul>
          <h3>Heading 3</h3>
        `,
        name: `Heading 3`,
        sg: true,
        st: true
      },
      cfh_ic: {
        description: `
          <ul>
            <li>Adds a button (<i class="fa fa-code"></i>) to the panel that allows you to write text like shown below.</li>
          </ul>
          <p>Inline <code>Code</code></p>
        `,
        name: `Inline Code`,
        sg: true,
        st: true
      },
      cfh_i: {
        description: `
          <ul>
            <li>Adds a button (I) to the panel that allows you to write text like shown below.</li>
          </ul>
          <em>Italic</em>
        `,
        name: `Italic`,
        sg: true,
        st: true
      },
      cfh_lb: {
        description: `
          <ul>
            <li>Adds a button (<i class="fa fa-minus"></i>) to the panel that allows you to write text like shown below.</li>
          </ul>
          <p>Line</p>
          <hr>
          <p>Break</p>
        `,
        name: `Line Break`,
        sg: true,
        st: true
      },
      cfh_lc: {
        description: `
          <ul>
            <li>Adds a button (<i class="fa fa-code"></i> <i class="fa fa-indent"></i>) to the panel that allows you to write text like shown below.</li>
          </ul>
          <code>Line Code</code>
        `,
        name: `Line Code`,
        sg: true,
        st: true
      },
      cfh_ol: {
        description: `
          <ul>
            <li>Adds a button (<i class="fa fa-list-ol"></i>) to the panel that allows you to write text like shown below.</li>
          </ul>
          <ol>
            <li>Ordered</li>
            <li>List</li>
          </ol>
        `,
        name: `Ordered List`,
        sg: true,
        st: true
      },
      cfh_pc: {
        description: `
          <ul>
            <li>Adds a button (<i class="fa fa-code"></i> <i class="fa fa-paragraph"></i>) to the panel that allows you to write text like shown below.</li>
          </ul>
          <pre><code>Paragraph Code</code></pre>
        `,
        name: `Paragraph Code`,
        sg: true,
        st: true
      },
      cfh_s: {
        description: `
          <ul>
            <li>Adds a button (<i class="fa fa-eye-slash"></i>) to the panel that allows you to write text like shown below.</li>
          </ul>
          <span class="spoiler">Spoiler</spoiler>
        `,
        name: `Spoiler`,
        sg: true,
        st: true
      },
      cfh_st: {
        description: `
          <ul>
            <li>Adds a button (<i class="fa fa-strikethrough"></i>) to the panel that allows you to write text like shown below.</li>
          </ul>
          <del>Strikethrough</del>
        `,
        name: `Strikethrough`,
        sg: true,
        st: true
      },
      cfh_ul: {
        description: `
          <ul>
            <li>Adds a button (<i class="fa fa-list-ul"></i>) to the panel that allows you to write text like shown below.</li>
          </ul>
          <ul>
            <li>Unordered</li>
            <li>List</li>
          </ul>
        `,
        name: `Unordered List`,
        sg: true,
        st: true
      },
      cfh_img: {
        description: `
          <ul>
            <li>Adds a button (<i class="fa fa-image"></i>) to the panel that allows you to add images to your comments with an interface where you can enter the title and the URL of the image and let ESGST format it.</li>
            <li>You can also upload images from your computer instead of using a URL. The images will be uploaded to <a href="https://imgur.com">Imgur</a>.</li>
          </li>
        `,
        name: `Image`,
        sg: true,
        st: true
      },
      cfh_l: {
        description: `
          <ul>
            <li>Adds a button (<i class="fa fa-globe"></i>) to the panel that allows you to add links to your comments with an interface where you can enter the title and the URL of the link and let ESGST format it.</li>
          </ul>
        `,
        name: `Link`,
        sg: true,
        st: true
      },
      cfh_t: {
        description: `
          <ul>
            <li>Adds a button (<i class="fa fa-table"></i>) to the panel that allows you to add tables to your comments with an interface where you can dynamically add as many rows/columns as you want, align each column however you want, enter the value for each cell and let ESGST format it.</li>
          </ul>
        `,
        name: `Table`,
        sg: true,
        st: true
      },
      cfh_e: {
        description: `
          <ul>
            <li>Adds a button (<i class="fa fa-smile-o"></i>) to the panel that allows you to add emojis to your comments by selecting them out of a huge list of emojis.</li>
          </ul>
        `,
        name: `Emoji`,
        sg: true,
        st: true
      },
      cfh_g: {
        description: `
          <ul>
            <li>Adds a button (<i class="fa fa-star"></i>) to the panel that allows you to add encrypted giveaways (see [id=ged] for more details about them) to your comments.</li>
          </ul>
        `,
        name: `Giveaway Encrypter`,
        sg: true,
        st: true
      },
      cfh_p: {
        description: `
          <ul>
            <li>Adds a button (<i class="fa fa-eye"></i>) to the panel that allows you to preview your comment before submitting it.</li>
          </ul>
        `,
        features: {
          cfh_p_a: {
            name: `Automatically preview while typing.`,
            sg: true,
            st: true
          }
        },
        name: `Preview`,
        sg: true,
        st: true
      },
      cfh_sr: {
        description: `
          <ul>
            <li>Adds a button (<i class="fa fa-floppy-o"></i>) to the panel that allows you to save replies that you frequently use so that you can reuse them later.</li>
          </ul>
        `,
        name: `Saved Replies`,
        sg: true,
        st: true
      },
      cfh_cf: {
        description: `
          <ul>
            <li>Adds a button (<i class="fa fa-question-circle"></i>) to the panel that links to SteamGifts' <a href="https://www.steamgifts.com/about/comment-formatting">comment formatting page</a>.</li>
          </ul>
        `,
        name: `Comment Formatting`,
        sg: true,
        st: true
      }
    },
    id: `cfh`,
    load: cfh,
    name: `Comment Formatting Helper`,
    sg: true,
    st: true,
    type: `comments`
  });

  async function cfh() {
    esgst.cfhEmojis = cfh_emojis();
    esgst.endlessFeatures.push(cfh_setTextAreas);
    esgst.cfh = {
      backup: [],
      history: [],
      panel: document.createElement(`div`),
      preview: document.createElement(`div`)
    };
    esgst.cfh.panel.className = `esgst-cfh-panel`;
    let items = [
      {
        id: `cfh_i`,
        icons: [`fa-italic`],
        name: `Italic`,
        prefix: `*`,
        suffix: `*`
      },
      {
        id: `cfh_b`,
        icons: [`fa-bold`],
        name: `Bold`,
        prefix: `**`,
        suffix: `**`
      },
      {
        id: `cfh_s`,
        icons: [`fa-eye-slash`],
        name: `Spoiler`,
        prefix: `~`,
        suffix: `~`
      },
      {
        id: `cfh_st`,
        icons: [`fa-strikethrough`],
        name: `Strikethrough`,
        prefix: `~~`,
        suffix: `~~`
      },
      {
        id: `cfh_h1`,
        icons: [`fa-header`],
        name: `Heading 1`,
        prefix: `# `,
        text: `1`
      },
      {
        id: `cfh_h2`,
        icons: [`fa-header`],
        name: `Heading 2`,
        prefix: `## `,
        text: `2`
      },
      {
        id: `cfh_h3`,
        icons: [`fa-header`],
        name: `Heading 3`,
        prefix: `### `,
        text: `3`
      },
      {
        id: `cfh_bq`,
        icons: [`fa-quote-left`],
        name: `Blockquote`,
        prefix: `> `
      },
      {
        id: `cfh_lb`,
        icons: [`fa-minus`],
        name: `Line Break`,
        prefix: `---`
      },
      {
        id: `cfh_ol`,
        icons: [`fa-list-ol`],
        multiline: true,
        name: `Ordered List`,
        prefix: `[n]. `
      },
      {
        id: `cfh_ul`,
        icons: [`fa-list-ul`],
        multiline: true,
        name: `Unordered List`,
        prefix: `* `
      },
      {
        id: `cfh_ic`,
        icons: [`fa-code`],
        name: `Inline Code`,
        prefix: `\``,
        suffix: `\``
      },
      {
        id: `cfh_lc`,
        icons: [`fa-code`, `fa-indent`],
        name: `Line Code`,
        prefix: `    `
      },
      {
        id: `cfh_pc`,
        icons: [`fa-code`, `fa-paragraph`],
        name: `Paragraph Code`,
        prefix: `\`\`\`\n`,
        suffix: `\n\`\`\``
      },
      {
        id: `cfh_l`,
        icons: [`fa-globe`],
        name: `Link`,
        setPopout: popout => {
          let title, url;
          popout.popout.innerHTML = `
            <div>URL: <input placeholder="http://www.example.com" type="text"/></div>
            <div>Title: <input placeholder="Cat" type="text"/></div>
            <div class="form__saving-button btn_action white">Add</div>
          `;
          url = popout.popout.firstElementChild.firstElementChild;
          title = popout.popout.firstElementChild.nextElementSibling.firstElementChild;
          popout.popout.lastElementChild.addEventListener(`click`, () => {
            cfh_formatLink(title.value, url.value);
            url.value = ``;
            title.value = ``;
            popout.close();
          });
        },
        callback: popout => {
          let title = popout.firstElementChild.nextElementSibling.firstElementChild;
          title.value = esgst.cfh.textArea.value.slice(esgst.cfh.textArea.selectionStart, esgst.cfh.textArea.selectionEnd);
          title.focus();
        }
      },
      {
        id: `cfh_img`,
        icons: [`fa-image`],
        name: `Image`,
        setPopout: popout => {
          let title, url;
          popout.popout.innerHTML = `
            <div>URL: <input placeholder="http://www.example.com/image.jpg" type="text"/> <i class="fa fa-upload esgst-clickable" title="Upload image to Imgur and use it"></i></div>
            <div>Title: <input placeholder="Cat" type="text"/></div>
            <div class="form__saving-button btn_action white">Add</div>
          `;
          url = popout.popout.firstElementChild.firstElementChild;
          let imgur = url.nextElementSibling;
          title = popout.popout.firstElementChild.nextElementSibling.firstElementChild;
          imgur.addEventListener(`click`, () => {
            multiChoice(`grey`, `fa-user-secret`, `Anonymously`, `grey`, `fa-user`, `Through Account`, `How would you like to upload?`, cfh_uploadImage.bind(null, `Client-ID e25283ef48ab9aa`, popout, url), async () => {
              await delValue(`imgurToken`);
              openSmallWindow(`https://api.imgur.com/oauth2/authorize?client_id=e25283ef48ab9aa&response_type=token`);
              cfh_checkImgur(popout, url);
            });
          });
          popout.popout.lastElementChild.addEventListener(`click`, () => {
            cfh_formatLink(title.value, url.value, true);
            url.value = ``;
            title.value = ``;
            popout.close();
          });
        },
        callback: popout => {
          let title, url;
          url = popout.firstElementChild.firstElementChild;
          title = popout.firstElementChild.nextElementSibling.firstElementChild;
          title.value = esgst.cfh.textArea.value.slice(esgst.cfh.textArea.selectionStart, esgst.cfh.textArea.selectionEnd);
          if (url.value && title.value) {
            popout.lastElementChild.click();
          } else if (url.value) {
            title.focus();
          } else {
            url.focus();
          }
        }
      },
      {
        id: `cfh_t`,
        icons: [`fa-table`],
        name: `Table`,
        setPopup: popup => {
          let context, insertColumn, insertRow, table;
          context = popup.scrollable;
          context.innerHTML = `
            <table></table>
            <div class="form__saving-button btn_action white">Insert Row</div>
            <div class="form__saving-button btn_action white">Insert Column</div>
            <div class="form__saving-button btn_action white">Add</div>
          `;
          table = context.firstElementChild;
          insertRow = table.nextElementSibling;
          insertColumn = insertRow.nextElementSibling;
          cfh_insertTableRows(4, table);
          cfh_insertTableColumns(2, table);
          insertRow.addEventListener(`click`, () => {
            cfh_insertTableRows(1, table);
          });
          insertColumn.addEventListener(`click`, () => {
            cfh_insertTableColumns(1, table);
          });
          insertColumn.nextElementSibling.addEventListener(`click`, () => {
            let end, i, j, numColumns, numRows, rows, start, value;
            rows = table.rows;
            for (i = 1, numRows = rows.length; i < numRows; ++i) {
              for (j = 1, numColumns = rows[0].cells.length; j < numColumns; ++j) {
                if (!rows[i].cells[j].firstElementChild.value) {
                  i = numRows + 1;
                  j = numColumns + 1;
                }
              }
            }
            if (i <= numRows || (i > numRows &&  confirm(`Some cells are empty. This might lead to unexpected results. Are you sure you want to continue?`))) {
              value = ``;
              for (i = 1; i < numRows; ++i) {
                value += `\n`;
                for (j = 1; j < numColumns; ++j) {
                  value += `${rows[i].cells[j].firstElementChild.value}${j < numColumns - 1 ? ` | ` : ``}`;
                }
              }
              value = value.replace(/^\n/, ``);
              start = esgst.cfh.textArea.selectionStart;
              end = esgst.cfh.textArea.selectionEnd;
              esgst.cfh.textArea.value = `${esgst.cfh.textArea.value.slice(0, start)}${value}${esgst.cfh.textArea.value.slice(end)}`;
              esgst.cfh.textArea.setSelectionRange(end + value.length, end + value.length);
              esgst.cfh.textArea.focus();
              popup.close();
            }
          });
        }
      },
      {
        id: `cfh_e`,
        icons: [`fa-smile-o`],
        name: `Emojis`,
        setPopout: async popout => {
          let emojis, popup;
          popout.popout.innerHTML = `
            <div class="esgst-cfh-emojis">${await cfh_getEmojis()}</div>
            <div class="form__saving-button btn_action white">Select Emojis</div>
          `;
          emojis = popout.popout.firstElementChild;
          draggable_set({context: emojis, id: `emojis`});
          cfh_setEmojis(emojis);
          emojis.nextElementSibling.addEventListener(`click`, async () => {
            if (popup) {
              popup.open(() => {
                popout.popout.classList.add(`esgst-hidden`)
              });
            } else {
              let emoji, emojis, filter, i;
              popup = new Popup_v2({icon: `fa-smile-o`, title: `Select emojis:`, addScrollable: true});
              filter = popup.getScrollable(`
                <input placeholder="Filter emojis..." type="text"/>
                <div class="esgst-cfh-emojis"></div>
                <div class="esgst-description">Simply click on an emoji above to add it to your selection. You can re-order emojis in your selection by dragging and dropping them. To remove an emoji from your selection, start dragging it and a trash area will appear, then drop it there.</div>
                <div class="global__image-outer-wrap page_heading_btn esgst-cfh-emojis">${await cfh_getEmojis()}</div>
              `).firstElementChild;
              emojis = filter.nextElementSibling;
              const savedEmojis = emojis.nextElementSibling.nextElementSibling;
              const obj = {
                context: savedEmojis,
                id: `emojid`
              };
              draggable_set(obj);
              for (const emoji in esgst.cfhEmojis) {
                emojis.insertAdjacentHTML(`beforeEnd`, `
                  <span data-id="${encodeURIComponent(emoji)}" title="${esgst.cfhEmojis[emoji]}">${emoji}</span>
                `);
                emojis.lastElementChild.addEventListener(`click`, event => {
                  savedEmojis.insertAdjacentHTML(`beforeEnd`, `
                    <span data-id="${encodeURIComponent(emoji)}" title="${esgst.cfhEmojis[emoji]}">${emoji}</span>
                  `);
                  draggable_set(obj);
                });
              }
              popup.onClose = () => {
                const emojArr = [];
                for (const element of savedEmojis.children) {
                  emojArr.push(decodeURIComponent(element.getAttribute(`data-id`)));
                }
                setValue(`emojis`, JSON.stringify(emojArr));
              };
              filter.addEventListener(`input`, () => {
                if (filter.value) {
                  for (i = emojis.children.length - 1; i > -1; --i) {
                    emoji = emojis.children[i];
                    if (emoji.getAttribute(`title`).toLowerCase().match(filter.value)) {
                      emoji.classList.remove(`esgst-hidden`);
                    } else {
                      emoji.classList.add(`esgst-hidden`);
                    }
                  }
                } else {
                  for (i = emojis.children.length - 1; i > -1; --i) {
                    emojis.children[i].classList.remove(`esgst-hidden`);
                  }
                }
              });
              popup.open(() => {
                popout.popout.classList.add(`esgst-hidden`)
              });
            }
          });
        },
        callback: async popout => {
          let emojis = popout.firstElementChild;
          emojis.innerHTML = await cfh_getEmojis();
          draggable_set({context: emojis, id: `emojis`});
          cfh_setEmojis(emojis);
        }
      },
      {
        id: `cfh_g`,
        icons: [`fa-star`],
        name: `Giveaway Encrypter`,
        setPopout: popout => {
          popout.popout.innerHTML = `
            Giveaway Code: <input placeholder="XXXXX" type="text"/>
            <div class="form__saving-button btn_action white">Add</div>
          `;
          let code = popout.popout.firstElementChild;
          code.nextElementSibling.addEventListener(`click`, () => {
            if (code.value.match(/^[\d\w]{5}$/)) {
              let encodedCode = ged_encryptCode(code.value);
              cfh_formatLink(``, `ESGST-${encodedCode}`);
              code.value = ``;
              popout.close();
            } else {
                alert(`Wrong format. The right format is XXXXX.`);
            }
          });
        },
        callback: popout => {
          let code = popout.firstElementChild;
          code.value = esgst.cfh.textArea.value.slice(esgst.cfh.textArea.selectionStart, esgst.cfh.textArea.selectionEnd);
          code.focus();
        }
      },
      {
        id: `cfh_sr`,
        icons: [`fa-floppy-o`],
        name: `Saved Replies`,
        setPopout: async popout => {
          let addButton, filter, i, n, replies, saveButton, savedReplies;
          esgst.cfh.deletedReplies = [];
          savedReplies = JSON.parse(await getValue(`savedReplies`, `[]`));
          popout.popout.innerHTML = `
            <div>
              <input placeholder="Filter replies..." type="text"/>
            </div>
            <div class="esgst-cfh-sr-container"></div>
            <div class="form__saving-button btn_action white">Add New Reply</div>
            <div class="form__saving-button btn_action white">Save Reply</div>
            <div class="esgst-clickable esgst-hidden">
              <i class="fa fa-rotate-left"></i>
              <span>Undo Delete</span>
            </div>
          `;
          filter = popout.popout.firstElementChild.firstElementChild;
          esgst.cfh.undoDelete = popout.popout.lastElementChild;
          saveButton = esgst.cfh.undoDelete.previousElementSibling;
          addButton = saveButton.previousElementSibling;
          replies = addButton.previousElementSibling;
          for (i = 0, n = savedReplies.length; i < n; ++i) {
            cfh_setReply(replies, savedReplies[i]);
          }
          filter.addEventListener(`input`, cfh_filterReplies.bind(null, replies));
          esgst.cfh.undoDelete.addEventListener(`click`, cfh_undoDelete);
          addButton.addEventListener(`click`, cfh_openReplyPopup.bind(null, null, null, replies, null));
          saveButton.addEventListener(`click`, () => cfh_saveReply(esgst.cfh.textArea.value, null, `Untitled`, null, null, replies, null, null));
        },
        callback: popout => {
          popout.firstElementChild.firstElementChild.focus();
        }
      }, {
        icons: [`fa-paste`],
        name: `Automatic Links / Images Paste Formatting: OFF`,
        callback: context => {
          esgst.cfh.alipf = context.firstElementChild;
          cfh_setAlipf(esgst.cfh_pasteFormatting, true);
        },
        onClick: cfh_setAlipf
      }, {
        icons: [`fa-rotate-left`],
        name: `Undo Formatting`,
        callback: context => {
          esgst.cfh.undo = context.firstElementChild;
          esgst.cfh.undo.classList.add(`esgst-faded`);
        },
        onClick: () => {
          let end, value;
          if (esgst.cfh.history.length) {
            cfh_redo(esgst.cfh.textArea, esgst.cfh.textArea.value);
            value = esgst.cfh.history.pop();
            end = esgst.cfh.textArea.selectionEnd - (esgst.cfh.textArea.value.length - value.length);
            esgst.cfh.textArea.value = value;
            esgst.cfh.textArea.setSelectionRange(end, end);
            if (!esgst.cfh.history.length) {
              esgst.cfh.undo.classList.add(`esgst-faded`);
            }
            esgst.cfh.textArea.focus();
          }
        }
      }, {
        icons: [`fa-rotate-right`],
        name: `Redo Formatting`,
        callback: context => {
          esgst.cfh.redo = context.firstElementChild;
          esgst.cfh.redo.classList.add(`esgst-faded`);
        },
        onClick: () => {
          let end, value;
          if (esgst.cfh.backup.length) {
            cfh_undo(esgst.cfh.textArea, esgst.cfh.textArea.value);
            value = esgst.cfh.backup.pop();
            end = esgst.cfh.textArea.selectionEnd + (value.length - esgst.cfh.textArea.value.length);
            esgst.cfh.textArea.value = value;
            esgst.cfh.textArea.setSelectionRange(end, end);
            if (!esgst.cfh.backup.length) {
              esgst.cfh.redo.classList.add(`esgst-faded`);
            }
            esgst.cfh.textArea.focus();
          }
        }
      }
    ];
    for (let i = 0, n = items.length; i < n; i++) {
      let item = items[i];
      if (!item.id || esgst[item.id]) {
        let button = insertHtml(esgst.cfh.panel, `beforeEnd`, `<div title="${getFeatureTooltip(item.id || `cfh`, item.name)}"></div>`);
        item.icons.forEach(icon => {
          button.insertAdjacentHTML(`beforeEnd`, `<i class="fa ${icon}"></i>`);
        });
        if (item.text) {
          button.insertAdjacentText(`beforeEnd`, item.text);
        }
        if (item.setPopout) {
          await item.setPopout(new Popout(`esgst-cfh-popout`, button, 0, true, null, item.callback));
        } else if (item.setPopup) {
          let popup;
          button.addEventListener(`click`, () => {
            if (popup) {
              popup.open();
            } else {
              popup = new Popup(`fa-table`, `Add a table:`);
              item.setPopup(popup);
              popup.open();
            }
          });
        } else {
          if (item.callback) {
            item.callback(button);
          }
          button.addEventListener(`click`, () => {
            if (item.onClick) {
              item.onClick();
            } else {
              cfh_formatItem(item.prefix, item.suffix, item.multiline);
            }
          });
        }
      }
    }
    if (esgst.cfh_cf) {
      esgst.cfh.panel.insertAdjacentHTML(`beforeEnd`, `
        <a href="/about/comment-formatting" title="${getFeatureTooltip(`cfh_cf`, `Comment Formatting`)}">
          <i class="fa fa-question-circle"></i>
        </a>
      `);
    }
    if (esgst.cfh_p && !esgst.cfh_p_a) {
      insertHtml(esgst.cfh.panel, `beforeEnd`, `
        <div title="${getFeatureTooltip(`cfh_p`, `Preview`)}">
          <i class="fa fa-eye"></i>
        </div>
      `).addEventListener(`click`, () => {
        esgst.cfh.preview.innerHTML = parseMarkdown(esgst.cfh.textArea.value);
        cfh_formatImages(esgst.cfh.preview);
      });
    }
    esgst.cfh.preview.className = `esgst-cfh-preview markdown`;
  }

  function cfh_emojis() {
    return {
      [`&#xAF&#x5C&#x5C&#x5C&#x5F&#x28&#x30C4&#x29&#x5F&#x2F&#xAF`]: ``,
      [`&#x28&#x20&#x361&#xB0&#x20&#x35C&#x296&#x20&#x361&#xB0&#x29`]: ``,
      [`&#x28&#x20&#x361&#x2299&#x20&#x35C&#x296&#x20&#x361&#x2299&#x29`]: ``,
      [`&#x28&#x30CE&#xCA0&#x76CA&#xCA0&#x29&#x30CE`]: ``,
      [`&#x28&#x256F&#xB0&#x25A1&#xB0&#xFF09&#x256F&#xFE35&#x20&#x253B&#x2501&#x253B`]: ``,
      [`&#x252C&#x2500&#x252C&#x30CE&#x28&#x20&#xBA&#x20&#x5F&#x20&#xBA&#x30CE&#x29`]: ``,
      [`&#x10DA&#x28&#xCA0&#x76CA&#xCA0&#x10DA&#x29`]: ``,
      [`&#x28&#x25D5&#x203F&#x2D&#x29&#x270C`]: ``,
      [`&#x28&#xFF61&#x25D5&#x203F&#x25D5&#xFF61&#x29`]: ``,
      [`&#x28&#x25D1&#x203F&#x25D0&#x29`]: ``,
      [`&#x25D4&#x5F&#x25D4`]: ``,
      [`&#x28&#x2022&#x203F&#x2022&#x29`]: ``,
      [`&#x28&#xCA0&#x5F&#xCA0&#x29`]: ``,
      [`&#x28&#xAC&#xFF64&#xAC&#x29`]: ``,
      [`&#x28&#x2500&#x203F&#x203F&#x2500&#x29`]: ``,
      [`&#x28&#xCA5&#xFE4F&#xCA5&#x29`]: ``,
      [`&#x28&#xCA5&#x2038&#xCA5&#x29`]: ``,
      [`&#x28&#x2310&#x25A0&#x5F&#x25A0&#x29`]: ``,
      [`&#x28&#x25B0&#x2D8&#x25E1&#x2D8&#x25B0&#x29`]: ``,
      [`&#x4E41&#x28&#x20&#x25D4&#x20&#xC6A&#x25D4&#x29&#x310F`]: ``,
      [`&#x28&#xE07&#x20&#x360&#xB0&#x20&#x35F&#x296&#x20&#x361&#xB0&#x29&#xE07`]: ``,
      [`&#x3B6&#xF3C&#x19F&#x346&#x644&#x35C&#x19F&#x346&#xF3D&#x1D98`]: ``,
      [`&#x295&#x2022&#x1D25&#x2022&#x294`]: ``,
      [`&#x28&#x20&#x35D&#xB0&#x20&#x35C&#x296&#x361&#xB0&#x29`]: ``,
      [`&#x28&#x2F&#xFF9F&#x414&#xFF9F&#x29&#x2F`]: ``,
      [`&#xB67&#xF3C&#xCA0&#x76CA&#xCA0&#xF3D&#xB68`]: ``,
      [`&#x28&#xE07&#x20&#x2022&#x300&#x5F&#x2022&#x301&#x29&#xE07`]: ``,
      [`&#x1F600`]: `Grinning Face`,
      [`&#x1F601`]: `Grinning Face With Smiling Eyes`,
      [`&#x1F602`]: `Face With Tears Of Joy`,
      [`&#x1F923`]: `Rolling On The Floor Laughing`,
      [`&#x1F603`]: `Smiling Face With Open Mouth`,
      [`&#x1F604`]: `Smiling Face With Open Mouth & Smiling Eyes`,
      [`&#x1F605`]: `Smiling Face With Open Mouth & Cold Sweat`,
      [`&#x1F606`]: `Smiling Face With Open Mouth & Closed Eyes`,
      [`&#x1F609`]: `Winking Face`,
      [`&#x1F60A`]: `Smiling Face With Smiling Eyes`,
      [`&#x1F60B`]: `Face Savouring Delicious Food`,
      [`&#x1F60E`]: `Smiling Face With Sunglasses`,
      [`&#x1F60D`]: `Smiling Face With Heart-Eyes`,
      [`&#x1F618`]: `Face Blowing A Kiss`,
      [`&#x1F617`]: `Kissing Face`,
      [`&#x1F619`]: `Kissing Face With Smiling Eyes`,
      [`&#x1F61A`]: `Kissing Face With Closed Eyes`,
      [`&#x263A`]: `Smiling Face`,
      [`&#x1F642`]: `Slightly Smiling Face`,
      [`&#x1F917`]: `Hugging Face`,
      [`&#x1F914`]: `Thinking Face`,
      [`&#x1F610`]: `Neutral Face`,
      [`&#x1F611`]: `Expressionless Face`,
      [`&#x1F636`]: `Face Without Mouth`,
      [`&#x1F644`]: `Face With Rolling Eyes`,
      [`&#x1F60F`]: `Smirking Face`,
      [`&#x1F623`]: `Persevering Face`,
      [`&#x1F625`]: `Disappointed But Relieved Face`,
      [`&#x1F62E`]: `Face With Open Mouth`,
      [`&#x1F910`]: `Zipper-Mouth Face`,
      [`&#x1F62F`]: `Hushed Face`,
      [`&#x1F62A`]: `Sleepy Face`,
      [`&#x1F62B`]: `Tired Face`,
      [`&#x1F634`]: `Sleeping Face`,
      [`&#x1F60C`]: `Relieved Face`,
      [`&#x1F913`]: `Nerd Face`,
      [`&#x1F61B`]: `Face With Stuck-Out Tongue`,
      [`&#x1F61C`]: `Face With Stuck-Out Tongue & Winking Eye`,
      [`&#x1F61D`]: `Face With Stuck-Out Tongue & Closed Eyes`,
      [`&#x1F924`]: `Drooling Face`,
      [`&#x1F612`]: `Unamused Face`,
      [`&#x1F613`]: `Face With Cold Sweat`,
      [`&#x1F614`]: `Pensive Face`,
      [`&#x1F615`]: `Confused Face`,
      [`&#x1F643`]: `Upside-Down Face`,
      [`&#x1F911`]: `Money-Mouth Face`,
      [`&#x1F632`]: `Astonished Face`,
      [`&#x2639`]: `Frowning Face`,
      [`&#x1F641`]: `Slightly Frowning Face`,
      [`&#x1F616`]: `Confounded Face`,
      [`&#x1F61E`]: `Disappointed Face`,
      [`&#x1F61F`]: `Worried Face`,
      [`&#x1F624`]: `Face With Steam From Nose`,
      [`&#x1F622`]: `Crying Face`,
      [`&#x1F62D`]: `Loudly Crying Face`,
      [`&#x1F626`]: `Frowning Face With Open Mouth`,
      [`&#x1F627`]: `Anguished Face`,
      [`&#x1F628`]: `Fearful Face`,
      [`&#x1F629`]: `Weary Face`,
      [`&#x1F62C`]: `Grimacing Face`,
      [`&#x1F630`]: `Face With Open Mouth & Cold Sweat`,
      [`&#x1F631`]: `Face Screaming In Fear`,
      [`&#x1F633`]: `Flushed Face`,
      [`&#x1F635`]: `Dizzy Face`,
      [`&#x1F621`]: `Pouting Face`,
      [`&#x1F620`]: `Angry Face`,
      [`&#x1F607`]: `Smiling Face With Halo`,
      [`&#x1F920`]: `Cowboy Hat Face`,
      [`&#x1F921`]: `Clown Face`,
      [`&#x1F925`]: `Lying Face`,
      [`&#x1F637`]: `Face With Medical Mask`,
      [`&#x1F912`]: `Face With Thermometer`,
      [`&#x1F915`]: `Face With Head-Bandage`,
      [`&#x1F922`]: `Nauseated Face`,
      [`&#x1F927`]: `Sneezing Face`,
      [`&#x1F608`]: `Smiling Face With Horns`,
      [`&#x1F47F`]: `Angry Face With Horns`,
      [`&#x1F479`]: `Ogre`,
      [`&#x1F47A`]: `Goblin`,
      [`&#x1F480`]: `Skull`,
      [`&#x2620`]: `Skull And Crossbones`,
      [`&#x1F47B`]: `Ghost`,
      [`&#x1F47D`]: `Alien`,
      [`&#x1F47E`]: `Alien Monster`,
      [`&#x1F916`]: `Robot Face`,
      [`&#x1F4A9`]: `Pile Of Poo`,
      [`&#x1F63A`]: `Smiling Cat Face With Open Mouth`,
      [`&#x1F638`]: `Grinning Cat Face With Smiling Eyes`,
      [`&#x1F639`]: `Cat Face With Tears Of Joy`,
      [`&#x1F63B`]: `Smiling Cat Face With Heart-Eyes`,
      [`&#x1F63C`]: `Cat Face With Wry Smile`,
      [`&#x1F63D`]: `Kissing Cat Face With Closed Eyes`,
      [`&#x1F640`]: `Weary Cat Face`,
      [`&#x1F63F`]: `Crying Cat Face`,
      [`&#x1F63E`]: `Pouting Cat Face`,
      [`&#x1F648`]: `See-No-Evil Monkey`,
      [`&#x1F649`]: `Hear-No-Evil Monkey`,
      [`&#x1F64A`]: `Speak-No-Evil Monkey`,
      [`&#x1F466`]: `Boy`,
      [`&#x1F466&#x1F3FB`]: `Boy: Light Skin Tone`,
      [`&#x1F466&#x1F3FC`]: `Boy: Medium-Light Skin Tone`,
      [`&#x1F466&#x1F3FD`]: `Boy: Medium Skin Tone`,
      [`&#x1F466&#x1F3FE`]: `Boy: Medium-Dark Skin Tone`,
      [`&#x1F466&#x1F3FF`]: `Boy: Dark Skin Tone`,
      [`&#x1F467`]: `Girl`,
      [`&#x1F467&#x1F3FB`]: `Girl: Light Skin Tone`,
      [`&#x1F467&#x1F3FC`]: `Girl: Medium-Light Skin Tone`,
      [`&#x1F467&#x1F3FD`]: `Girl: Medium Skin Tone`,
      [`&#x1F467&#x1F3FE`]: `Girl: Medium-Dark Skin Tone`,
      [`&#x1F467&#x1F3FF`]: `Girl: Dark Skin Tone`,
      [`&#x1F468`]: `Man`,
      [`&#x1F468&#x1F3FB`]: `Man: Light Skin Tone`,
      [`&#x1F468&#x1F3FC`]: `Man: Medium-Light Skin Tone`,
      [`&#x1F468&#x1F3FD`]: `Man: Medium Skin Tone`,
      [`&#x1F468&#x1F3FE`]: `Man: Medium-Dark Skin Tone`,
      [`&#x1F468&#x1F3FF`]: `Man: Dark Skin Tone`,
      [`&#x1F469`]: `Woman`,
      [`&#x1F469&#x1F3FB`]: `Woman: Light Skin Tone`,
      [`&#x1F469&#x1F3FC`]: `Woman: Medium-Light Skin Tone`,
      [`&#x1F469&#x1F3FD`]: `Woman: Medium Skin Tone`,
      [`&#x1F469&#x1F3FE`]: `Woman: Medium-Dark Skin Tone`,
      [`&#x1F469&#x1F3FF`]: `Woman: Dark Skin Tone`,
      [`&#x1F474`]: `Old Man`,
      [`&#x1F474&#x1F3FB`]: `Old Man: Light Skin Tone`,
      [`&#x1F474&#x1F3FC`]: `Old Man: Medium-Light Skin Tone`,
      [`&#x1F474&#x1F3FD`]: `Old Man: Medium Skin Tone`,
      [`&#x1F474&#x1F3FE`]: `Old Man: Medium-Dark Skin Tone`,
      [`&#x1F474&#x1F3FF`]: `Old Man: Dark Skin Tone`,
      [`&#x1F475`]: `Old Woman`,
      [`&#x1F475&#x1F3FB`]: `Old Woman: Light Skin Tone`,
      [`&#x1F475&#x1F3FC`]: `Old Woman: Medium-Light Skin Tone`,
      [`&#x1F475&#x1F3FD`]: `Old Woman: Medium Skin Tone`,
      [`&#x1F475&#x1F3FE`]: `Old Woman: Medium-Dark Skin Tone`,
      [`&#x1F475&#x1F3FF`]: `Old Woman: Dark Skin Tone`,
      [`&#x1F476`]: `Baby`,
      [`&#x1F476&#x1F3FB`]: `Baby: Light Skin Tone`,
      [`&#x1F476&#x1F3FC`]: `Baby: Medium-Light Skin Tone`,
      [`&#x1F476&#x1F3FD`]: `Baby: Medium Skin Tone`,
      [`&#x1F476&#x1F3FE`]: `Baby: Medium-Dark Skin Tone`,
      [`&#x1F476&#x1F3FF`]: `Baby: Dark Skin Tone`,
      [`&#x1F47C`]: `Baby Angel`,
      [`&#x1F47C&#x1F3FB`]: `Baby Angel: Light Skin Tone`,
      [`&#x1F47C&#x1F3FC`]: `Baby Angel: Medium-Light Skin Tone`,
      [`&#x1F47C&#x1F3FD`]: `Baby Angel: Medium Skin Tone`,
      [`&#x1F47C&#x1F3FE`]: `Baby Angel: Medium-Dark Skin Tone`,
      [`&#x1F47C&#x1F3FF`]: `Baby Angel: Dark Skin Tone`,
      [`&#x1F468&#x200D&#x2695&#xFE0F`]: `Man Health Worker`,
      [`&#x1F468&#x1F3FB&#x200D&#x2695&#xFE0F`]: `Man Health Worker: Light Skin Tone`,
      [`&#x1F468&#x1F3FC&#x200D&#x2695&#xFE0F`]: `Man Health Worker: Medium-Light Skin Tone`,
      [`&#x1F468&#x1F3FD&#x200D&#x2695&#xFE0F`]: `Man Health Worker: Medium Skin Tone`,
      [`&#x1F468&#x1F3FE&#x200D&#x2695&#xFE0F`]: `Man Health Worker: Medium-Dark Skin Tone`,
      [`&#x1F468&#x1F3FF&#x200D&#x2695&#xFE0F`]: `Man Health Worker: Dark Skin Tone`,
      [`&#x1F469&#x200D&#x2695&#xFE0F`]: `Woman Health Worker`,
      [`&#x1F469&#x1F3FB&#x200D&#x2695&#xFE0F`]: `Woman Health Worker: Light Skin Tone`,
      [`&#x1F469&#x1F3FC&#x200D&#x2695&#xFE0F`]: `Woman Health Worker: Medium-Light Skin Tone`,
      [`&#x1F469&#x1F3FD&#x200D&#x2695&#xFE0F`]: `Woman Health Worker: Medium Skin Tone`,
      [`&#x1F469&#x1F3FE&#x200D&#x2695&#xFE0F`]: `Woman Health Worker: Medium-Dark Skin Tone`,
      [`&#x1F469&#x1F3FF&#x200D&#x2695&#xFE0F`]: `Woman Health Worker: Dark Skin Tone`,
      [`&#x1F468&#x200D&#x1F393`]: `Man Student`,
      [`&#x1F468&#x1F3FB&#x200D&#x1F393`]: `Man Student: Light Skin Tone`,
      [`&#x1F468&#x1F3FC&#x200D&#x1F393`]: `Man Student: Medium-Light Skin Tone`,
      [`&#x1F468&#x1F3FD&#x200D&#x1F393`]: `Man Student: Medium Skin Tone`,
      [`&#x1F468&#x1F3FE&#x200D&#x1F393`]: `Man Student: Medium-Dark Skin Tone`,
      [`&#x1F468&#x1F3FF&#x200D&#x1F393`]: `Man Student: Dark Skin Tone`,
      [`&#x1F469&#x200D&#x1F393`]: `Woman Student`,
      [`&#x1F469&#x1F3FB&#x200D&#x1F393`]: `Woman Student: Light Skin Tone`,
      [`&#x1F469&#x1F3FC&#x200D&#x1F393`]: `Woman Student: Medium-Light Skin Tone`,
      [`&#x1F469&#x1F3FD&#x200D&#x1F393`]: `Woman Student: Medium Skin Tone`,
      [`&#x1F469&#x1F3FE&#x200D&#x1F393`]: `Woman Student: Medium-Dark Skin Tone`,
      [`&#x1F469&#x1F3FF&#x200D&#x1F393`]: `Woman Student: Dark Skin Tone`,
      [`&#x1F468&#x200D&#x1F3EB`]: `Man Teacher`,
      [`&#x1F468&#x1F3FB&#x200D&#x1F3EB`]: `Man Teacher: Light Skin Tone`,
      [`&#x1F468&#x1F3FC&#x200D&#x1F3EB`]: `Man Teacher: Medium-Light Skin Tone`,
      [`&#x1F468&#x1F3FD&#x200D&#x1F3EB`]: `Man Teacher: Medium Skin Tone`,
      [`&#x1F468&#x1F3FE&#x200D&#x1F3EB`]: `Man Teacher: Medium-Dark Skin Tone`,
      [`&#x1F468&#x1F3FF&#x200D&#x1F3EB`]: `Man Teacher: Dark Skin Tone`,
      [`&#x1F469&#x200D&#x1F3EB`]: `Woman Teacher`,
      [`&#x1F469&#x1F3FB&#x200D&#x1F3EB`]: `Woman Teacher: Light Skin Tone`,
      [`&#x1F469&#x1F3FC&#x200D&#x1F3EB`]: `Woman Teacher: Medium-Light Skin Tone`,
      [`&#x1F469&#x1F3FD&#x200D&#x1F3EB`]: `Woman Teacher: Medium Skin Tone`,
      [`&#x1F469&#x1F3FE&#x200D&#x1F3EB`]: `Woman Teacher: Medium-Dark Skin Tone`,
      [`&#x1F469&#x1F3FF&#x200D&#x1F3EB`]: `Woman Teacher: Dark Skin Tone`,
      [`&#x1F468&#x200D&#x2696&#xFE0F`]: `Man Judge`,
      [`&#x1F468&#x1F3FB&#x200D&#x2696&#xFE0F`]: `Man Judge: Light Skin Tone`,
      [`&#x1F468&#x1F3FC&#x200D&#x2696&#xFE0F`]: `Man Judge: Medium-Light Skin Tone`,
      [`&#x1F468&#x1F3FD&#x200D&#x2696&#xFE0F`]: `Man Judge: Medium Skin Tone`,
      [`&#x1F468&#x1F3FE&#x200D&#x2696&#xFE0F`]: `Man Judge: Medium-Dark Skin Tone`,
      [`&#x1F468&#x1F3FF&#x200D&#x2696&#xFE0F`]: `Man Judge: Dark Skin Tone`,
      [`&#x1F469&#x200D&#x2696&#xFE0F`]: `Woman Judge`,
      [`&#x1F469&#x1F3FB&#x200D&#x2696&#xFE0F`]: `Woman Judge: Light Skin Tone`,
      [`&#x1F469&#x1F3FC&#x200D&#x2696&#xFE0F`]: `Woman Judge: Medium-Light Skin Tone`,
      [`&#x1F469&#x1F3FD&#x200D&#x2696&#xFE0F`]: `Woman Judge: Medium Skin Tone`,
      [`&#x1F469&#x1F3FE&#x200D&#x2696&#xFE0F`]: `Woman Judge: Medium-Dark Skin Tone`,
      [`&#x1F469&#x1F3FF&#x200D&#x2696&#xFE0F`]: `Woman Judge: Dark Skin Tone`,
      [`&#x1F468&#x200D&#x1F33E`]: `Man Farmer`,
      [`&#x1F468&#x1F3FB&#x200D&#x1F33E`]: `Man Farmer: Light Skin Tone`,
      [`&#x1F468&#x1F3FC&#x200D&#x1F33E`]: `Man Farmer: Medium-Light Skin Tone`,
      [`&#x1F468&#x1F3FD&#x200D&#x1F33E`]: `Man Farmer: Medium Skin Tone`,
      [`&#x1F468&#x1F3FE&#x200D&#x1F33E`]: `Man Farmer: Medium-Dark Skin Tone`,
      [`&#x1F468&#x1F3FF&#x200D&#x1F33E`]: `Man Farmer: Dark Skin Tone`,
      [`&#x1F469&#x200D&#x1F33E`]: `Woman Farmer`,
      [`&#x1F469&#x1F3FB&#x200D&#x1F33E`]: `Woman Farmer: Light Skin Tone`,
      [`&#x1F469&#x1F3FC&#x200D&#x1F33E`]: `Woman Farmer: Medium-Light Skin Tone`,
      [`&#x1F469&#x1F3FD&#x200D&#x1F33E`]: `Woman Farmer: Medium Skin Tone`,
      [`&#x1F469&#x1F3FE&#x200D&#x1F33E`]: `Woman Farmer: Medium-Dark Skin Tone`,
      [`&#x1F469&#x1F3FF&#x200D&#x1F33E`]: `Woman Farmer: Dark Skin Tone`,
      [`&#x1F468&#x200D&#x1F373`]: `Man Cook`,
      [`&#x1F468&#x1F3FB&#x200D&#x1F373`]: `Man Cook: Light Skin Tone`,
      [`&#x1F468&#x1F3FC&#x200D&#x1F373`]: `Man Cook: Medium-Light Skin Tone`,
      [`&#x1F468&#x1F3FD&#x200D&#x1F373`]: `Man Cook: Medium Skin Tone`,
      [`&#x1F468&#x1F3FE&#x200D&#x1F373`]: `Man Cook: Medium-Dark Skin Tone`,
      [`&#x1F468&#x1F3FF&#x200D&#x1F373`]: `Man Cook: Dark Skin Tone`,
      [`&#x1F469&#x200D&#x1F373`]: `Woman Cook`,
      [`&#x1F469&#x1F3FB&#x200D&#x1F373`]: `Woman Cook: Light Skin Tone`,
      [`&#x1F469&#x1F3FC&#x200D&#x1F373`]: `Woman Cook: Medium-Light Skin Tone`,
      [`&#x1F469&#x1F3FD&#x200D&#x1F373`]: `Woman Cook: Medium Skin Tone`,
      [`&#x1F469&#x1F3FE&#x200D&#x1F373`]: `Woman Cook: Medium-Dark Skin Tone`,
      [`&#x1F469&#x1F3FF&#x200D&#x1F373`]: `Woman Cook: Dark Skin Tone`,
      [`&#x1F468&#x200D&#x1F527`]: `Man Mechanic`,
      [`&#x1F468&#x1F3FB&#x200D&#x1F527`]: `Man Mechanic: Light Skin Tone`,
      [`&#x1F468&#x1F3FC&#x200D&#x1F527`]: `Man Mechanic: Medium-Light Skin Tone`,
      [`&#x1F468&#x1F3FD&#x200D&#x1F527`]: `Man Mechanic: Medium Skin Tone`,
      [`&#x1F468&#x1F3FE&#x200D&#x1F527`]: `Man Mechanic: Medium-Dark Skin Tone`,
      [`&#x1F468&#x1F3FF&#x200D&#x1F527`]: `Man Mechanic: Dark Skin Tone`,
      [`&#x1F469&#x200D&#x1F527`]: `Woman Mechanic`,
      [`&#x1F469&#x1F3FB&#x200D&#x1F527`]: `Woman Mechanic: Light Skin Tone`,
      [`&#x1F469&#x1F3FC&#x200D&#x1F527`]: `Woman Mechanic: Medium-Light Skin Tone`,
      [`&#x1F469&#x1F3FD&#x200D&#x1F527`]: `Woman Mechanic: Medium Skin Tone`,
      [`&#x1F469&#x1F3FE&#x200D&#x1F527`]: `Woman Mechanic: Medium-Dark Skin Tone`,
      [`&#x1F469&#x1F3FF&#x200D&#x1F527`]: `Woman Mechanic: Dark Skin Tone`,
      [`&#x1F468&#x200D&#x1F3ED`]: `Man Factory Worker`,
      [`&#x1F468&#x1F3FB&#x200D&#x1F3ED`]: `Man Factory Worker: Light Skin Tone`,
      [`&#x1F468&#x1F3FC&#x200D&#x1F3ED`]: `Man Factory Worker: Medium-Light Skin Tone`,
      [`&#x1F468&#x1F3FD&#x200D&#x1F3ED`]: `Man Factory Worker: Medium Skin Tone`,
      [`&#x1F468&#x1F3FE&#x200D&#x1F3ED`]: `Man Factory Worker: Medium-Dark Skin Tone`,
      [`&#x1F468&#x1F3FF&#x200D&#x1F3ED`]: `Man Factory Worker: Dark Skin Tone`,
      [`&#x1F469&#x200D&#x1F3ED`]: `Woman Factory Worker`,
      [`&#x1F469&#x1F3FB&#x200D&#x1F3ED`]: `Woman Factory Worker: Light Skin Tone`,
      [`&#x1F469&#x1F3FC&#x200D&#x1F3ED`]: `Woman Factory Worker: Medium-Light Skin Tone`,
      [`&#x1F469&#x1F3FD&#x200D&#x1F3ED`]: `Woman Factory Worker: Medium Skin Tone`,
      [`&#x1F469&#x1F3FE&#x200D&#x1F3ED`]: `Woman Factory Worker: Medium-Dark Skin Tone`,
      [`&#x1F469&#x1F3FF&#x200D&#x1F3ED`]: `Woman Factory Worker: Dark Skin Tone`,
      [`&#x1F468&#x200D&#x1F4BC`]: `Man Office Worker`,
      [`&#x1F468&#x1F3FB&#x200D&#x1F4BC`]: `Man Office Worker: Light Skin Tone`,
      [`&#x1F468&#x1F3FC&#x200D&#x1F4BC`]: `Man Office Worker: Medium-Light Skin Tone`,
      [`&#x1F468&#x1F3FD&#x200D&#x1F4BC`]: `Man Office Worker: Medium Skin Tone`,
      [`&#x1F468&#x1F3FE&#x200D&#x1F4BC`]: `Man Office Worker: Medium-Dark Skin Tone`,
      [`&#x1F468&#x1F3FF&#x200D&#x1F4BC`]: `Man Office Worker: Dark Skin Tone`,
      [`&#x1F469&#x200D&#x1F4BC`]: `Woman Office Worker`,
      [`&#x1F469&#x1F3FB&#x200D&#x1F4BC`]: `Woman Office Worker: Light Skin Tone`,
      [`&#x1F469&#x1F3FC&#x200D&#x1F4BC`]: `Woman Office Worker: Medium-Light Skin Tone`,
      [`&#x1F469&#x1F3FD&#x200D&#x1F4BC`]: `Woman Office Worker: Medium Skin Tone`,
      [`&#x1F469&#x1F3FE&#x200D&#x1F4BC`]: `Woman Office Worker: Medium-Dark Skin Tone`,
      [`&#x1F469&#x1F3FF&#x200D&#x1F4BC`]: `Woman Office Worker: Dark Skin Tone`,
      [`&#x1F468&#x200D&#x1F52C`]: `Man Scientist`,
      [`&#x1F468&#x1F3FB&#x200D&#x1F52C`]: `Man Scientist: Light Skin Tone`,
      [`&#x1F468&#x1F3FC&#x200D&#x1F52C`]: `Man Scientist: Medium-Light Skin Tone`,
      [`&#x1F468&#x1F3FD&#x200D&#x1F52C`]: `Man Scientist: Medium Skin Tone`,
      [`&#x1F468&#x1F3FE&#x200D&#x1F52C`]: `Man Scientist: Medium-Dark Skin Tone`,
      [`&#x1F468&#x1F3FF&#x200D&#x1F52C`]: `Man Scientist: Dark Skin Tone`,
      [`&#x1F469&#x200D&#x1F52C`]: `Woman Scientist`,
      [`&#x1F469&#x1F3FB&#x200D&#x1F52C`]: `Woman Scientist: Light Skin Tone`,
      [`&#x1F469&#x1F3FC&#x200D&#x1F52C`]: `Woman Scientist: Medium-Light Skin Tone`,
      [`&#x1F469&#x1F3FD&#x200D&#x1F52C`]: `Woman Scientist: Medium Skin Tone`,
      [`&#x1F469&#x1F3FE&#x200D&#x1F52C`]: `Woman Scientist: Medium-Dark Skin Tone`,
      [`&#x1F469&#x1F3FF&#x200D&#x1F52C`]: `Woman Scientist: Dark Skin Tone`,
      [`&#x1F468&#x200D&#x1F4BB`]: `Man Technologist`,
      [`&#x1F468&#x1F3FB&#x200D&#x1F4BB`]: `Man Technologist: Light Skin Tone`,
      [`&#x1F468&#x1F3FC&#x200D&#x1F4BB`]: `Man Technologist: Medium-Light Skin Tone`,
      [`&#x1F468&#x1F3FD&#x200D&#x1F4BB`]: `Man Technologist: Medium Skin Tone`,
      [`&#x1F468&#x1F3FE&#x200D&#x1F4BB`]: `Man Technologist: Medium-Dark Skin Tone`,
      [`&#x1F468&#x1F3FF&#x200D&#x1F4BB`]: `Man Technologist: Dark Skin Tone`,
      [`&#x1F469&#x200D&#x1F4BB`]: `Woman Technologist`,
      [`&#x1F469&#x1F3FB&#x200D&#x1F4BB`]: `Woman Technologist: Light Skin Tone`,
      [`&#x1F469&#x1F3FC&#x200D&#x1F4BB`]: `Woman Technologist: Medium-Light Skin Tone`,
      [`&#x1F469&#x1F3FD&#x200D&#x1F4BB`]: `Woman Technologist: Medium Skin Tone`,
      [`&#x1F469&#x1F3FE&#x200D&#x1F4BB`]: `Woman Technologist: Medium-Dark Skin Tone`,
      [`&#x1F469&#x1F3FF&#x200D&#x1F4BB`]: `Woman Technologist: Dark Skin Tone`,
      [`&#x1F468&#x200D&#x1F3A4`]: `Man Singer`,
      [`&#x1F468&#x1F3FB&#x200D&#x1F3A4`]: `Man Singer: Light Skin Tone`,
      [`&#x1F468&#x1F3FC&#x200D&#x1F3A4`]: `Man Singer: Medium-Light Skin Tone`,
      [`&#x1F468&#x1F3FD&#x200D&#x1F3A4`]: `Man Singer: Medium Skin Tone`,
      [`&#x1F468&#x1F3FE&#x200D&#x1F3A4`]: `Man Singer: Medium-Dark Skin Tone`,
      [`&#x1F468&#x1F3FF&#x200D&#x1F3A4`]: `Man Singer: Dark Skin Tone`,
      [`&#x1F469&#x200D&#x1F3A4`]: `Woman Singer`,
      [`&#x1F469&#x1F3FB&#x200D&#x1F3A4`]: `Woman Singer: Light Skin Tone`,
      [`&#x1F469&#x1F3FC&#x200D&#x1F3A4`]: `Woman Singer: Medium-Light Skin Tone`,
      [`&#x1F469&#x1F3FD&#x200D&#x1F3A4`]: `Woman Singer: Medium Skin Tone`,
      [`&#x1F469&#x1F3FE&#x200D&#x1F3A4`]: `Woman Singer: Medium-Dark Skin Tone`,
      [`&#x1F469&#x1F3FF&#x200D&#x1F3A4`]: `Woman Singer: Dark Skin Tone`,
      [`&#x1F468&#x200D&#x1F3A8`]: `Man Artist`,
      [`&#x1F468&#x1F3FB&#x200D&#x1F3A8`]: `Man Artist: Light Skin Tone`,
      [`&#x1F468&#x1F3FC&#x200D&#x1F3A8`]: `Man Artist: Medium-Light Skin Tone`,
      [`&#x1F468&#x1F3FD&#x200D&#x1F3A8`]: `Man Artist: Medium Skin Tone`,
      [`&#x1F468&#x1F3FE&#x200D&#x1F3A8`]: `Man Artist: Medium-Dark Skin Tone`,
      [`&#x1F468&#x1F3FF&#x200D&#x1F3A8`]: `Man Artist: Dark Skin Tone`,
      [`&#x1F469&#x200D&#x1F3A8`]: `Woman Artist`,
      [`&#x1F469&#x1F3FB&#x200D&#x1F3A8`]: `Woman Artist: Light Skin Tone`,
      [`&#x1F469&#x1F3FC&#x200D&#x1F3A8`]: `Woman Artist: Medium-Light Skin Tone`,
      [`&#x1F469&#x1F3FD&#x200D&#x1F3A8`]: `Woman Artist: Medium Skin Tone`,
      [`&#x1F469&#x1F3FE&#x200D&#x1F3A8`]: `Woman Artist: Medium-Dark Skin Tone`,
      [`&#x1F469&#x1F3FF&#x200D&#x1F3A8`]: `Woman Artist: Dark Skin Tone`,
      [`&#x1F468&#x200D&#x2708&#xFE0F`]: `Man Pilot`,
      [`&#x1F468&#x1F3FB&#x200D&#x2708&#xFE0F`]: `Man Pilot: Light Skin Tone`,
      [`&#x1F468&#x1F3FC&#x200D&#x2708&#xFE0F`]: `Man Pilot: Medium-Light Skin Tone`,
      [`&#x1F468&#x1F3FD&#x200D&#x2708&#xFE0F`]: `Man Pilot: Medium Skin Tone`,
      [`&#x1F468&#x1F3FE&#x200D&#x2708&#xFE0F`]: `Man Pilot: Medium-Dark Skin Tone`,
      [`&#x1F468&#x1F3FF&#x200D&#x2708&#xFE0F`]: `Man Pilot: Dark Skin Tone`,
      [`&#x1F469&#x200D&#x2708&#xFE0F`]: `Woman Pilot`,
      [`&#x1F469&#x1F3FB&#x200D&#x2708&#xFE0F`]: `Woman Pilot: Light Skin Tone`,
      [`&#x1F469&#x1F3FC&#x200D&#x2708&#xFE0F`]: `Woman Pilot: Medium-Light Skin Tone`,
      [`&#x1F469&#x1F3FD&#x200D&#x2708&#xFE0F`]: `Woman Pilot: Medium Skin Tone`,
      [`&#x1F469&#x1F3FE&#x200D&#x2708&#xFE0F`]: `Woman Pilot: Medium-Dark Skin Tone`,
      [`&#x1F469&#x1F3FF&#x200D&#x2708&#xFE0F`]: `Woman Pilot: Dark Skin Tone`,
      [`&#x1F468&#x200D&#x1F680`]: `Man Astronaut`,
      [`&#x1F468&#x1F3FB&#x200D&#x1F680`]: `Man Astronaut: Light Skin Tone`,
      [`&#x1F468&#x1F3FC&#x200D&#x1F680`]: `Man Astronaut: Medium-Light Skin Tone`,
      [`&#x1F468&#x1F3FD&#x200D&#x1F680`]: `Man Astronaut: Medium Skin Tone`,
      [`&#x1F468&#x1F3FE&#x200D&#x1F680`]: `Man Astronaut: Medium-Dark Skin Tone`,
      [`&#x1F468&#x1F3FF&#x200D&#x1F680`]: `Man Astronaut: Dark Skin Tone`,
      [`&#x1F469&#x200D&#x1F680`]: `Woman Astronaut`,
      [`&#x1F469&#x1F3FB&#x200D&#x1F680`]: `Woman Astronaut: Light Skin Tone`,
      [`&#x1F469&#x1F3FC&#x200D&#x1F680`]: `Woman Astronaut: Medium-Light Skin Tone`,
      [`&#x1F469&#x1F3FD&#x200D&#x1F680`]: `Woman Astronaut: Medium Skin Tone`,
      [`&#x1F469&#x1F3FE&#x200D&#x1F680`]: `Woman Astronaut: Medium-Dark Skin Tone`,
      [`&#x1F469&#x1F3FF&#x200D&#x1F680`]: `Woman Astronaut: Dark Skin Tone`,
      [`&#x1F468&#x200D&#x1F692`]: `Man Firefighter`,
      [`&#x1F468&#x1F3FB&#x200D&#x1F692`]: `Man Firefighter: Light Skin Tone`,
      [`&#x1F468&#x1F3FC&#x200D&#x1F692`]: `Man Firefighter: Medium-Light Skin Tone`,
      [`&#x1F468&#x1F3FD&#x200D&#x1F692`]: `Man Firefighter: Medium Skin Tone`,
      [`&#x1F468&#x1F3FE&#x200D&#x1F692`]: `Man Firefighter: Medium-Dark Skin Tone`,
      [`&#x1F468&#x1F3FF&#x200D&#x1F692`]: `Man Firefighter: Dark Skin Tone`,
      [`&#x1F469&#x200D&#x1F692`]: `Woman Firefighter`,
      [`&#x1F469&#x1F3FB&#x200D&#x1F692`]: `Woman Firefighter: Light Skin Tone`,
      [`&#x1F469&#x1F3FC&#x200D&#x1F692`]: `Woman Firefighter: Medium-Light Skin Tone`,
      [`&#x1F469&#x1F3FD&#x200D&#x1F692`]: `Woman Firefighter: Medium Skin Tone`,
      [`&#x1F469&#x1F3FE&#x200D&#x1F692`]: `Woman Firefighter: Medium-Dark Skin Tone`,
      [`&#x1F469&#x1F3FF&#x200D&#x1F692`]: `Woman Firefighter: Dark Skin Tone`,
      [`&#x1F46E`]: `Police Officer`,
      [`&#x1F46E&#x1F3FB`]: `Police Officer: Light Skin Tone`,
      [`&#x1F46E&#x1F3FC`]: `Police Officer: Medium-Light Skin Tone`,
      [`&#x1F46E&#x1F3FD`]: `Police Officer: Medium Skin Tone`,
      [`&#x1F46E&#x1F3FE`]: `Police Officer: Medium-Dark Skin Tone`,
      [`&#x1F46E&#x1F3FF`]: `Police Officer: Dark Skin Tone`,
      [`&#x1F46E&#x200D&#x2642&#xFE0F`]: `Man Police Officer`,
      [`&#x1F46E&#x1F3FB&#x200D&#x2642&#xFE0F`]: `Man Police Officer: Light Skin Tone`,
      [`&#x1F46E&#x1F3FC&#x200D&#x2642&#xFE0F`]: `Man Police Officer: Medium-Light Skin Tone`,
      [`&#x1F46E&#x1F3FD&#x200D&#x2642&#xFE0F`]: `Man Police Officer: Medium Skin Tone`,
      [`&#x1F46E&#x1F3FE&#x200D&#x2642&#xFE0F`]: `Man Police Officer: Medium-Dark Skin Tone`,
      [`&#x1F46E&#x1F3FF&#x200D&#x2642&#xFE0F`]: `Man Police Officer: Dark Skin Tone`,
      [`&#x1F46E&#x200D&#x2640&#xFE0F`]: `Woman Police Officer`,
      [`&#x1F46E&#x1F3FB&#x200D&#x2640&#xFE0F`]: `Woman Police Officer: Light Skin Tone`,
      [`&#x1F46E&#x1F3FC&#x200D&#x2640&#xFE0F`]: `Woman Police Officer: Medium-Light Skin Tone`,
      [`&#x1F46E&#x1F3FD&#x200D&#x2640&#xFE0F`]: `Woman Police Officer: Medium Skin Tone`,
      [`&#x1F46E&#x1F3FE&#x200D&#x2640&#xFE0F`]: `Woman Police Officer: Medium-Dark Skin Tone`,
      [`&#x1F46E&#x1F3FF&#x200D&#x2640&#xFE0F`]: `Woman Police Officer: Dark Skin Tone`,
      [`&#x1F575`]: `Detective`,
      [`&#x1F575&#x1F3FB`]: `Detective: Light Skin Tone`,
      [`&#x1F575&#x1F3FC`]: `Detective: Medium-Light Skin Tone`,
      [`&#x1F575&#x1F3FD`]: `Detective: Medium Skin Tone`,
      [`&#x1F575&#x1F3FE`]: `Detective: Medium-Dark Skin Tone`,
      [`&#x1F575&#x1F3FF`]: `Detective: Dark Skin Tone`,
      [`&#x1F575&#xFE0F&#x200D&#x2642&#xFE0F`]: `Man Detective`,
      [`&#x1F575&#x1F3FB&#x200D&#x2642&#xFE0F`]: `Man Detective: Light Skin Tone`,
      [`&#x1F575&#x1F3FC&#x200D&#x2642&#xFE0F`]: `Man Detective: Medium-Light Skin Tone`,
      [`&#x1F575&#x1F3FD&#x200D&#x2642&#xFE0F`]: `Man Detective: Medium Skin Tone`,
      [`&#x1F575&#x1F3FE&#x200D&#x2642&#xFE0F`]: `Man Detective: Medium-Dark Skin Tone`,
      [`&#x1F575&#x1F3FF&#x200D&#x2642&#xFE0F`]: `Man Detective: Dark Skin Tone`,
      [`&#x1F575&#xFE0F&#x200D&#x2640&#xFE0F`]: `Woman Detective`,
      [`&#x1F575&#x1F3FB&#x200D&#x2640&#xFE0F`]: `Woman Detective: Light Skin Tone`,
      [`&#x1F575&#x1F3FC&#x200D&#x2640&#xFE0F`]: `Woman Detective: Medium-Light Skin Tone`,
      [`&#x1F575&#x1F3FD&#x200D&#x2640&#xFE0F`]: `Woman Detective: Medium Skin Tone`,
      [`&#x1F575&#x1F3FE&#x200D&#x2640&#xFE0F`]: `Woman Detective: Medium-Dark Skin Tone`,
      [`&#x1F575&#x1F3FF&#x200D&#x2640&#xFE0F`]: `Woman Detective: Dark Skin Tone`,
      [`&#x1F482`]: `Guard`,
      [`&#x1F482&#x1F3FB`]: `Guard: Light Skin Tone`,
      [`&#x1F482&#x1F3FC`]: `Guard: Medium-Light Skin Tone`,
      [`&#x1F482&#x1F3FD`]: `Guard: Medium Skin Tone`,
      [`&#x1F482&#x1F3FE`]: `Guard: Medium-Dark Skin Tone`,
      [`&#x1F482&#x1F3FF`]: `Guard: Dark Skin Tone`,
      [`&#x1F482&#x200D&#x2642&#xFE0F`]: `Man Guard`,
      [`&#x1F482&#x1F3FB&#x200D&#x2642&#xFE0F`]: `Man Guard: Light Skin Tone`,
      [`&#x1F482&#x1F3FC&#x200D&#x2642&#xFE0F`]: `Man Guard: Medium-Light Skin Tone`,
      [`&#x1F482&#x1F3FD&#x200D&#x2642&#xFE0F`]: `Man Guard: Medium Skin Tone`,
      [`&#x1F482&#x1F3FE&#x200D&#x2642&#xFE0F`]: `Man Guard: Medium-Dark Skin Tone`,
      [`&#x1F482&#x1F3FF&#x200D&#x2642&#xFE0F`]: `Man Guard: Dark Skin Tone`,
      [`&#x1F482&#x200D&#x2640&#xFE0F`]: `Woman Guard`,
      [`&#x1F482&#x1F3FB&#x200D&#x2640&#xFE0F`]: `Woman Guard: Light Skin Tone`,
      [`&#x1F482&#x1F3FC&#x200D&#x2640&#xFE0F`]: `Woman Guard: Medium-Light Skin Tone`,
      [`&#x1F482&#x1F3FD&#x200D&#x2640&#xFE0F`]: `Woman Guard: Medium Skin Tone`,
      [`&#x1F482&#x1F3FE&#x200D&#x2640&#xFE0F`]: `Woman Guard: Medium-Dark Skin Tone`,
      [`&#x1F482&#x1F3FF&#x200D&#x2640&#xFE0F`]: `Woman Guard: Dark Skin Tone`,
      [`&#x1F477`]: `Construction Worker`,
      [`&#x1F477&#x1F3FB`]: `Construction Worker: Light Skin Tone`,
      [`&#x1F477&#x1F3FC`]: `Construction Worker: Medium-Light Skin Tone`,
      [`&#x1F477&#x1F3FD`]: `Construction Worker: Medium Skin Tone`,
      [`&#x1F477&#x1F3FE`]: `Construction Worker: Medium-Dark Skin Tone`,
      [`&#x1F477&#x1F3FF`]: `Construction Worker: Dark Skin Tone`,
      [`&#x1F477&#x200D&#x2642&#xFE0F`]: `Man Construction Worker`,
      [`&#x1F477&#x1F3FB&#x200D&#x2642&#xFE0F`]: `Man Construction Worker: Light Skin Tone`,
      [`&#x1F477&#x1F3FC&#x200D&#x2642&#xFE0F`]: `Man Construction Worker: Medium-Light Skin Tone`,
      [`&#x1F477&#x1F3FD&#x200D&#x2642&#xFE0F`]: `Man Construction Worker: Medium Skin Tone`,
      [`&#x1F477&#x1F3FE&#x200D&#x2642&#xFE0F`]: `Man Construction Worker: Medium-Dark Skin Tone`,
      [`&#x1F477&#x1F3FF&#x200D&#x2642&#xFE0F`]: `Man Construction Worker: Dark Skin Tone`,
      [`&#x1F477&#x200D&#x2640&#xFE0F`]: `Woman Construction Worker`,
      [`&#x1F477&#x1F3FB&#x200D&#x2640&#xFE0F`]: `Woman Construction Worker: Light Skin Tone`,
      [`&#x1F477&#x1F3FC&#x200D&#x2640&#xFE0F`]: `Woman Construction Worker: Medium-Light Skin Tone`,
      [`&#x1F477&#x1F3FD&#x200D&#x2640&#xFE0F`]: `Woman Construction Worker: Medium Skin Tone`,
      [`&#x1F477&#x1F3FE&#x200D&#x2640&#xFE0F`]: `Woman Construction Worker: Medium-Dark Skin Tone`,
      [`&#x1F477&#x1F3FF&#x200D&#x2640&#xFE0F`]: `Woman Construction Worker: Dark Skin Tone`,
      [`&#x1F473`]: `Person Wearing Turban`,
      [`&#x1F473&#x1F3FB`]: `Person Wearing Turban: Light Skin Tone`,
      [`&#x1F473&#x1F3FC`]: `Person Wearing Turban: Medium-Light Skin Tone`,
      [`&#x1F473&#x1F3FD`]: `Person Wearing Turban: Medium Skin Tone`,
      [`&#x1F473&#x1F3FE`]: `Person Wearing Turban: Medium-Dark Skin Tone`,
      [`&#x1F473&#x1F3FF`]: `Person Wearing Turban: Dark Skin Tone`,
      [`&#x1F473&#x200D&#x2642&#xFE0F`]: `Man Wearing Turban`,
      [`&#x1F473&#x1F3FB&#x200D&#x2642&#xFE0F`]: `Man Wearing Turban: Light Skin Tone`,
      [`&#x1F473&#x1F3FC&#x200D&#x2642&#xFE0F`]: `Man Wearing Turban: Medium-Light Skin Tone`,
      [`&#x1F473&#x1F3FD&#x200D&#x2642&#xFE0F`]: `Man Wearing Turban: Medium Skin Tone`,
      [`&#x1F473&#x1F3FE&#x200D&#x2642&#xFE0F`]: `Man Wearing Turban: Medium-Dark Skin Tone`,
      [`&#x1F473&#x1F3FF&#x200D&#x2642&#xFE0F`]: `Man Wearing Turban: Dark Skin Tone`,
      [`&#x1F473&#x200D&#x2640&#xFE0F`]: `Woman Wearing Turban`,
      [`&#x1F473&#x1F3FB&#x200D&#x2640&#xFE0F`]: `Woman Wearing Turban: Light Skin Tone`,
      [`&#x1F473&#x1F3FC&#x200D&#x2640&#xFE0F`]: `Woman Wearing Turban: Medium-Light Skin Tone`,
      [`&#x1F473&#x1F3FD&#x200D&#x2640&#xFE0F`]: `Woman Wearing Turban: Medium Skin Tone`,
      [`&#x1F473&#x1F3FE&#x200D&#x2640&#xFE0F`]: `Woman Wearing Turban: Medium-Dark Skin Tone`,
      [`&#x1F473&#x1F3FF&#x200D&#x2640&#xFE0F`]: `Woman Wearing Turban: Dark Skin Tone`,
      [`&#x1F471`]: `Blond-Haired Person`,
      [`&#x1F471&#x1F3FB`]: `Blond-Haired Person: Light Skin Tone`,
      [`&#x1F471&#x1F3FC`]: `Blond-Haired Person: Medium-Light Skin Tone`,
      [`&#x1F471&#x1F3FD`]: `Blond-Haired Person: Medium Skin Tone`,
      [`&#x1F471&#x1F3FE`]: `Blond-Haired Person: Medium-Dark Skin Tone`,
      [`&#x1F471&#x1F3FF`]: `Blond-Haired Person: Dark Skin Tone`,
      [`&#x1F471&#x200D&#x2642&#xFE0F`]: `Blond-Haired Man`,
      [`&#x1F471&#x1F3FB&#x200D&#x2642&#xFE0F`]: `Blond-Haired Man: Light Skin Tone`,
      [`&#x1F471&#x1F3FC&#x200D&#x2642&#xFE0F`]: `Blond-Haired Man: Medium-Light Skin Tone`,
      [`&#x1F471&#x1F3FD&#x200D&#x2642&#xFE0F`]: `Blond-Haired Man: Medium Skin Tone`,
      [`&#x1F471&#x1F3FE&#x200D&#x2642&#xFE0F`]: `Blond-Haired Man: Medium-Dark Skin Tone`,
      [`&#x1F471&#x1F3FF&#x200D&#x2642&#xFE0F`]: `Blond-Haired Man: Dark Skin Tone`,
      [`&#x1F471&#x200D&#x2640&#xFE0F`]: `Blond-Haired Woman`,
      [`&#x1F471&#x1F3FB&#x200D&#x2640&#xFE0F`]: `Blond-Haired Woman: Light Skin Tone`,
      [`&#x1F471&#x1F3FC&#x200D&#x2640&#xFE0F`]: `Blond-Haired Woman: Medium-Light Skin Tone`,
      [`&#x1F471&#x1F3FD&#x200D&#x2640&#xFE0F`]: `Blond-Haired Woman: Medium Skin Tone`,
      [`&#x1F471&#x1F3FE&#x200D&#x2640&#xFE0F`]: `Blond-Haired Woman: Medium-Dark Skin Tone`,
      [`&#x1F471&#x1F3FF&#x200D&#x2640&#xFE0F`]: `Blond-Haired Woman: Dark Skin Tone`,
      [`&#x1F385`]: `Santa Claus`,
      [`&#x1F385&#x1F3FB`]: `Santa Claus: Light Skin Tone`,
      [`&#x1F385&#x1F3FC`]: `Santa Claus: Medium-Light Skin Tone`,
      [`&#x1F385&#x1F3FD`]: `Santa Claus: Medium Skin Tone`,
      [`&#x1F385&#x1F3FE`]: `Santa Claus: Medium-Dark Skin Tone`,
      [`&#x1F385&#x1F3FF`]: `Santa Claus: Dark Skin Tone`,
      [`&#x1F936`]: `Mrs. Claus`,
      [`&#x1F936&#x1F3FB`]: `Mrs. Claus: Light Skin Tone`,
      [`&#x1F936&#x1F3FC`]: `Mrs. Claus: Medium-Light Skin Tone`,
      [`&#x1F936&#x1F3FD`]: `Mrs. Claus: Medium Skin Tone`,
      [`&#x1F936&#x1F3FE`]: `Mrs. Claus: Medium-Dark Skin Tone`,
      [`&#x1F936&#x1F3FF`]: `Mrs. Claus: Dark Skin Tone`,
      [`&#x1F478`]: `Princess`,
      [`&#x1F478&#x1F3FB`]: `Princess: Light Skin Tone`,
      [`&#x1F478&#x1F3FC`]: `Princess: Medium-Light Skin Tone`,
      [`&#x1F478&#x1F3FD`]: `Princess: Medium Skin Tone`,
      [`&#x1F478&#x1F3FE`]: `Princess: Medium-Dark Skin Tone`,
      [`&#x1F478&#x1F3FF`]: `Princess: Dark Skin Tone`,
      [`&#x1F934`]: `Prince`,
      [`&#x1F934&#x1F3FB`]: `Prince: Light Skin Tone`,
      [`&#x1F934&#x1F3FC`]: `Prince: Medium-Light Skin Tone`,
      [`&#x1F934&#x1F3FD`]: `Prince: Medium Skin Tone`,
      [`&#x1F934&#x1F3FE`]: `Prince: Medium-Dark Skin Tone`,
      [`&#x1F934&#x1F3FF`]: `Prince: Dark Skin Tone`,
      [`&#x1F470`]: `Bride With Veil`,
      [`&#x1F470&#x1F3FB`]: `Bride With Veil: Light Skin Tone`,
      [`&#x1F470&#x1F3FC`]: `Bride With Veil: Medium-Light Skin Tone`,
      [`&#x1F470&#x1F3FD`]: `Bride With Veil: Medium Skin Tone`,
      [`&#x1F470&#x1F3FE`]: `Bride With Veil: Medium-Dark Skin Tone`,
      [`&#x1F470&#x1F3FF`]: `Bride With Veil: Dark Skin Tone`,
      [`&#x1F935`]: `Man In Tuxedo`,
      [`&#x1F935&#x1F3FB`]: `Man In Tuxedo: Light Skin Tone`,
      [`&#x1F935&#x1F3FC`]: `Man In Tuxedo: Medium-Light Skin Tone`,
      [`&#x1F935&#x1F3FD`]: `Man In Tuxedo: Medium Skin Tone`,
      [`&#x1F935&#x1F3FE`]: `Man In Tuxedo: Medium-Dark Skin Tone`,
      [`&#x1F935&#x1F3FF`]: `Man In Tuxedo: Dark Skin Tone`,
      [`&#x1F930`]: `Pregnant Woman`,
      [`&#x1F930&#x1F3FB`]: `Pregnant Woman: Light Skin Tone`,
      [`&#x1F930&#x1F3FC`]: `Pregnant Woman: Medium-Light Skin Tone`,
      [`&#x1F930&#x1F3FD`]: `Pregnant Woman: Medium Skin Tone`,
      [`&#x1F930&#x1F3FE`]: `Pregnant Woman: Medium-Dark Skin Tone`,
      [`&#x1F930&#x1F3FF`]: `Pregnant Woman: Dark Skin Tone`,
      [`&#x1F472`]: `Man With Chinese Cap`,
      [`&#x1F472&#x1F3FB`]: `Man With Chinese Cap: Light Skin Tone`,
      [`&#x1F472&#x1F3FC`]: `Man With Chinese Cap: Medium-Light Skin Tone`,
      [`&#x1F472&#x1F3FD`]: `Man With Chinese Cap: Medium Skin Tone`,
      [`&#x1F472&#x1F3FE`]: `Man With Chinese Cap: Medium-Dark Skin Tone`,
      [`&#x1F472&#x1F3FF`]: `Man With Chinese Cap: Dark Skin Tone`,
      [`&#x1F64D`]: `Person Frowning`,
      [`&#x1F64D&#x1F3FB`]: `Person Frowning: Light Skin Tone`,
      [`&#x1F64D&#x1F3FC`]: `Person Frowning: Medium-Light Skin Tone`,
      [`&#x1F64D&#x1F3FD`]: `Person Frowning: Medium Skin Tone`,
      [`&#x1F64D&#x1F3FE`]: `Person Frowning: Medium-Dark Skin Tone`,
      [`&#x1F64D&#x1F3FF`]: `Person Frowning: Dark Skin Tone`,
      [`&#x1F64D&#x200D&#x2642&#xFE0F`]: `Man Frowning`,
      [`&#x1F64D&#x1F3FB&#x200D&#x2642&#xFE0F`]: `Man Frowning: Light Skin Tone`,
      [`&#x1F64D&#x1F3FC&#x200D&#x2642&#xFE0F`]: `Man Frowning: Medium-Light Skin Tone`,
      [`&#x1F64D&#x1F3FD&#x200D&#x2642&#xFE0F`]: `Man Frowning: Medium Skin Tone`,
      [`&#x1F64D&#x1F3FE&#x200D&#x2642&#xFE0F`]: `Man Frowning: Medium-Dark Skin Tone`,
      [`&#x1F64D&#x1F3FF&#x200D&#x2642&#xFE0F`]: `Man Frowning: Dark Skin Tone`,
      [`&#x1F64D&#x200D&#x2640&#xFE0F`]: `Woman Frowning`,
      [`&#x1F64D&#x1F3FB&#x200D&#x2640&#xFE0F`]: `Woman Frowning: Light Skin Tone`,
      [`&#x1F64D&#x1F3FC&#x200D&#x2640&#xFE0F`]: `Woman Frowning: Medium-Light Skin Tone`,
      [`&#x1F64D&#x1F3FD&#x200D&#x2640&#xFE0F`]: `Woman Frowning: Medium Skin Tone`,
      [`&#x1F64D&#x1F3FE&#x200D&#x2640&#xFE0F`]: `Woman Frowning: Medium-Dark Skin Tone`,
      [`&#x1F64D&#x1F3FF&#x200D&#x2640&#xFE0F`]: `Woman Frowning: Dark Skin Tone`,
      [`&#x1F64E`]: `Person Pouting`,
      [`&#x1F64E&#x1F3FB`]: `Person Pouting: Light Skin Tone`,
      [`&#x1F64E&#x1F3FC`]: `Person Pouting: Medium-Light Skin Tone`,
      [`&#x1F64E&#x1F3FD`]: `Person Pouting: Medium Skin Tone`,
      [`&#x1F64E&#x1F3FE`]: `Person Pouting: Medium-Dark Skin Tone`,
      [`&#x1F64E&#x1F3FF`]: `Person Pouting: Dark Skin Tone`,
      [`&#x1F64E&#x200D&#x2642&#xFE0F`]: `Man Pouting`,
      [`&#x1F64E&#x1F3FB&#x200D&#x2642&#xFE0F`]: `Man Pouting: Light Skin Tone`,
      [`&#x1F64E&#x1F3FC&#x200D&#x2642&#xFE0F`]: `Man Pouting: Medium-Light Skin Tone`,
      [`&#x1F64E&#x1F3FD&#x200D&#x2642&#xFE0F`]: `Man Pouting: Medium Skin Tone`,
      [`&#x1F64E&#x1F3FE&#x200D&#x2642&#xFE0F`]: `Man Pouting: Medium-Dark Skin Tone`,
      [`&#x1F64E&#x1F3FF&#x200D&#x2642&#xFE0F`]: `Man Pouting: Dark Skin Tone`,
      [`&#x1F64E&#x200D&#x2640&#xFE0F`]: `Woman Pouting`,
      [`&#x1F64E&#x1F3FB&#x200D&#x2640&#xFE0F`]: `Woman Pouting: Light Skin Tone`,
      [`&#x1F64E&#x1F3FC&#x200D&#x2640&#xFE0F`]: `Woman Pouting: Medium-Light Skin Tone`,
      [`&#x1F64E&#x1F3FD&#x200D&#x2640&#xFE0F`]: `Woman Pouting: Medium Skin Tone`,
      [`&#x1F64E&#x1F3FE&#x200D&#x2640&#xFE0F`]: `Woman Pouting: Medium-Dark Skin Tone`,
      [`&#x1F64E&#x1F3FF&#x200D&#x2640&#xFE0F`]: `Woman Pouting: Dark Skin Tone`,
      [`&#x1F645`]: `Person Gesturing NO`,
      [`&#x1F645&#x1F3FB`]: `Person Gesturing NO: Light Skin Tone`,
      [`&#x1F645&#x1F3FC`]: `Person Gesturing NO: Medium-Light Skin Tone`,
      [`&#x1F645&#x1F3FD`]: `Person Gesturing NO: Medium Skin Tone`,
      [`&#x1F645&#x1F3FE`]: `Person Gesturing NO: Medium-Dark Skin Tone`,
      [`&#x1F645&#x1F3FF`]: `Person Gesturing NO: Dark Skin Tone`,
      [`&#x1F645&#x200D&#x2642&#xFE0F`]: `Man Gesturing NO`,
      [`&#x1F645&#x1F3FB&#x200D&#x2642&#xFE0F`]: `Man Gesturing NO: Light Skin Tone`,
      [`&#x1F645&#x1F3FC&#x200D&#x2642&#xFE0F`]: `Man Gesturing NO: Medium-Light Skin Tone`,
      [`&#x1F645&#x1F3FD&#x200D&#x2642&#xFE0F`]: `Man Gesturing NO: Medium Skin Tone`,
      [`&#x1F645&#x1F3FE&#x200D&#x2642&#xFE0F`]: `Man Gesturing NO: Medium-Dark Skin Tone`,
      [`&#x1F645&#x1F3FF&#x200D&#x2642&#xFE0F`]: `Man Gesturing NO: Dark Skin Tone`,
      [`&#x1F645&#x200D&#x2640&#xFE0F`]: `Woman Gesturing NO`,
      [`&#x1F645&#x1F3FB&#x200D&#x2640&#xFE0F`]: `Woman Gesturing NO: Light Skin Tone`,
      [`&#x1F645&#x1F3FC&#x200D&#x2640&#xFE0F`]: `Woman Gesturing NO: Medium-Light Skin Tone`,
      [`&#x1F645&#x1F3FD&#x200D&#x2640&#xFE0F`]: `Woman Gesturing NO: Medium Skin Tone`,
      [`&#x1F645&#x1F3FE&#x200D&#x2640&#xFE0F`]: `Woman Gesturing NO: Medium-Dark Skin Tone`,
      [`&#x1F645&#x1F3FF&#x200D&#x2640&#xFE0F`]: `Woman Gesturing NO: Dark Skin Tone`,
      [`&#x1F646`]: `Person Gesturing OK`,
      [`&#x1F646&#x1F3FB`]: `Person Gesturing OK: Light Skin Tone`,
      [`&#x1F646&#x1F3FC`]: `Person Gesturing OK: Medium-Light Skin Tone`,
      [`&#x1F646&#x1F3FD`]: `Person Gesturing OK: Medium Skin Tone`,
      [`&#x1F646&#x1F3FE`]: `Person Gesturing OK: Medium-Dark Skin Tone`,
      [`&#x1F646&#x1F3FF`]: `Person Gesturing OK: Dark Skin Tone`,
      [`&#x1F646&#x200D&#x2642&#xFE0F`]: `Man Gesturing OK`,
      [`&#x1F646&#x1F3FB&#x200D&#x2642&#xFE0F`]: `Man Gesturing OK: Light Skin Tone`,
      [`&#x1F646&#x1F3FC&#x200D&#x2642&#xFE0F`]: `Man Gesturing OK: Medium-Light Skin Tone`,
      [`&#x1F646&#x1F3FD&#x200D&#x2642&#xFE0F`]: `Man Gesturing OK: Medium Skin Tone`,
      [`&#x1F646&#x1F3FE&#x200D&#x2642&#xFE0F`]: `Man Gesturing OK: Medium-Dark Skin Tone`,
      [`&#x1F646&#x1F3FF&#x200D&#x2642&#xFE0F`]: `Man Gesturing OK: Dark Skin Tone`,
      [`&#x1F646&#x200D&#x2640&#xFE0F`]: `Woman Gesturing OK`,
      [`&#x1F646&#x1F3FB&#x200D&#x2640&#xFE0F`]: `Woman Gesturing OK: Light Skin Tone`,
      [`&#x1F646&#x1F3FC&#x200D&#x2640&#xFE0F`]: `Woman Gesturing OK: Medium-Light Skin Tone`,
      [`&#x1F646&#x1F3FD&#x200D&#x2640&#xFE0F`]: `Woman Gesturing OK: Medium Skin Tone`,
      [`&#x1F646&#x1F3FE&#x200D&#x2640&#xFE0F`]: `Woman Gesturing OK: Medium-Dark Skin Tone`,
      [`&#x1F646&#x1F3FF&#x200D&#x2640&#xFE0F`]: `Woman Gesturing OK: Dark Skin Tone`,
      [`&#x1F481`]: `Person Tipping Hand`,
      [`&#x1F481&#x1F3FB`]: `Person Tipping Hand: Light Skin Tone`,
      [`&#x1F481&#x1F3FC`]: `Person Tipping Hand: Medium-Light Skin Tone`,
      [`&#x1F481&#x1F3FD`]: `Person Tipping Hand: Medium Skin Tone`,
      [`&#x1F481&#x1F3FE`]: `Person Tipping Hand: Medium-Dark Skin Tone`,
      [`&#x1F481&#x1F3FF`]: `Person Tipping Hand: Dark Skin Tone`,
      [`&#x1F481&#x200D&#x2642&#xFE0F`]: `Man Tipping Hand`,
      [`&#x1F481&#x1F3FB&#x200D&#x2642&#xFE0F`]: `Man Tipping Hand: Light Skin Tone`,
      [`&#x1F481&#x1F3FC&#x200D&#x2642&#xFE0F`]: `Man Tipping Hand: Medium-Light Skin Tone`,
      [`&#x1F481&#x1F3FD&#x200D&#x2642&#xFE0F`]: `Man Tipping Hand: Medium Skin Tone`,
      [`&#x1F481&#x1F3FE&#x200D&#x2642&#xFE0F`]: `Man Tipping Hand: Medium-Dark Skin Tone`,
      [`&#x1F481&#x1F3FF&#x200D&#x2642&#xFE0F`]: `Man Tipping Hand: Dark Skin Tone`,
      [`&#x1F481&#x200D&#x2640&#xFE0F`]: `Woman Tipping Hand`,
      [`&#x1F481&#x1F3FB&#x200D&#x2640&#xFE0F`]: `Woman Tipping Hand: Light Skin Tone`,
      [`&#x1F481&#x1F3FC&#x200D&#x2640&#xFE0F`]: `Woman Tipping Hand: Medium-Light Skin Tone`,
      [`&#x1F481&#x1F3FD&#x200D&#x2640&#xFE0F`]: `Woman Tipping Hand: Medium Skin Tone`,
      [`&#x1F481&#x1F3FE&#x200D&#x2640&#xFE0F`]: `Woman Tipping Hand: Medium-Dark Skin Tone`,
      [`&#x1F481&#x1F3FF&#x200D&#x2640&#xFE0F`]: `Woman Tipping Hand: Dark Skin Tone`,
      [`&#x1F64B`]: `Person Raising Hand`,
      [`&#x1F64B&#x1F3FB`]: `Person Raising Hand: Light Skin Tone`,
      [`&#x1F64B&#x1F3FC`]: `Person Raising Hand: Medium-Light Skin Tone`,
      [`&#x1F64B&#x1F3FD`]: `Person Raising Hand: Medium Skin Tone`,
      [`&#x1F64B&#x1F3FE`]: `Person Raising Hand: Medium-Dark Skin Tone`,
      [`&#x1F64B&#x1F3FF`]: `Person Raising Hand: Dark Skin Tone`,
      [`&#x1F64B&#x200D&#x2642&#xFE0F`]: `Man Raising Hand`,
      [`&#x1F64B&#x1F3FB&#x200D&#x2642&#xFE0F`]: `Man Raising Hand: Light Skin Tone`,
      [`&#x1F64B&#x1F3FC&#x200D&#x2642&#xFE0F`]: `Man Raising Hand: Medium-Light Skin Tone`,
      [`&#x1F64B&#x1F3FD&#x200D&#x2642&#xFE0F`]: `Man Raising Hand: Medium Skin Tone`,
      [`&#x1F64B&#x1F3FE&#x200D&#x2642&#xFE0F`]: `Man Raising Hand: Medium-Dark Skin Tone`,
      [`&#x1F64B&#x1F3FF&#x200D&#x2642&#xFE0F`]: `Man Raising Hand: Dark Skin Tone`,
      [`&#x1F64B&#x200D&#x2640&#xFE0F`]: `Woman Raising Hand`,
      [`&#x1F64B&#x1F3FB&#x200D&#x2640&#xFE0F`]: `Woman Raising Hand: Light Skin Tone`,
      [`&#x1F64B&#x1F3FC&#x200D&#x2640&#xFE0F`]: `Woman Raising Hand: Medium-Light Skin Tone`,
      [`&#x1F64B&#x1F3FD&#x200D&#x2640&#xFE0F`]: `Woman Raising Hand: Medium Skin Tone`,
      [`&#x1F64B&#x1F3FE&#x200D&#x2640&#xFE0F`]: `Woman Raising Hand: Medium-Dark Skin Tone`,
      [`&#x1F64B&#x1F3FF&#x200D&#x2640&#xFE0F`]: `Woman Raising Hand: Dark Skin Tone`,
      [`&#x1F647`]: `Person Bowing`,
      [`&#x1F647&#x1F3FB`]: `Person Bowing: Light Skin Tone`,
      [`&#x1F647&#x1F3FC`]: `Person Bowing: Medium-Light Skin Tone`,
      [`&#x1F647&#x1F3FD`]: `Person Bowing: Medium Skin Tone`,
      [`&#x1F647&#x1F3FE`]: `Person Bowing: Medium-Dark Skin Tone`,
      [`&#x1F647&#x1F3FF`]: `Person Bowing: Dark Skin Tone`,
      [`&#x1F647&#x200D&#x2642&#xFE0F`]: `Man Bowing`,
      [`&#x1F647&#x1F3FB&#x200D&#x2642&#xFE0F`]: `Man Bowing: Light Skin Tone`,
      [`&#x1F647&#x1F3FC&#x200D&#x2642&#xFE0F`]: `Man Bowing: Medium-Light Skin Tone`,
      [`&#x1F647&#x1F3FD&#x200D&#x2642&#xFE0F`]: `Man Bowing: Medium Skin Tone`,
      [`&#x1F647&#x1F3FE&#x200D&#x2642&#xFE0F`]: `Man Bowing: Medium-Dark Skin Tone`,
      [`&#x1F647&#x1F3FF&#x200D&#x2642&#xFE0F`]: `Man Bowing: Dark Skin Tone`,
      [`&#x1F647&#x200D&#x2640&#xFE0F`]: `Woman Bowing`,
      [`&#x1F647&#x1F3FB&#x200D&#x2640&#xFE0F`]: `Woman Bowing: Light Skin Tone`,
      [`&#x1F647&#x1F3FC&#x200D&#x2640&#xFE0F`]: `Woman Bowing: Medium-Light Skin Tone`,
      [`&#x1F647&#x1F3FD&#x200D&#x2640&#xFE0F`]: `Woman Bowing: Medium Skin Tone`,
      [`&#x1F647&#x1F3FE&#x200D&#x2640&#xFE0F`]: `Woman Bowing: Medium-Dark Skin Tone`,
      [`&#x1F647&#x1F3FF&#x200D&#x2640&#xFE0F`]: `Woman Bowing: Dark Skin Tone`,
      [`&#x1F926`]: `Person Facepalming`,
      [`&#x1F926&#x1F3FB`]: `Person Facepalming: Light Skin Tone`,
      [`&#x1F926&#x1F3FC`]: `Person Facepalming: Medium-Light Skin Tone`,
      [`&#x1F926&#x1F3FD`]: `Person Facepalming: Medium Skin Tone`,
      [`&#x1F926&#x1F3FE`]: `Person Facepalming: Medium-Dark Skin Tone`,
      [`&#x1F926&#x1F3FF`]: `Person Facepalming: Dark Skin Tone`,
      [`&#x1F926&#x200D&#x2642&#xFE0F`]: `Man Facepalming`,
      [`&#x1F926&#x1F3FB&#x200D&#x2642&#xFE0F`]: `Man Facepalming: Light Skin Tone`,
      [`&#x1F926&#x1F3FC&#x200D&#x2642&#xFE0F`]: `Man Facepalming: Medium-Light Skin Tone`,
      [`&#x1F926&#x1F3FD&#x200D&#x2642&#xFE0F`]: `Man Facepalming: Medium Skin Tone`,
      [`&#x1F926&#x1F3FE&#x200D&#x2642&#xFE0F`]: `Man Facepalming: Medium-Dark Skin Tone`,
      [`&#x1F926&#x1F3FF&#x200D&#x2642&#xFE0F`]: `Man Facepalming: Dark Skin Tone`,
      [`&#x1F926&#x200D&#x2640&#xFE0F`]: `Woman Facepalming`,
      [`&#x1F926&#x1F3FB&#x200D&#x2640&#xFE0F`]: `Woman Facepalming: Light Skin Tone`,
      [`&#x1F926&#x1F3FC&#x200D&#x2640&#xFE0F`]: `Woman Facepalming: Medium-Light Skin Tone`,
      [`&#x1F926&#x1F3FD&#x200D&#x2640&#xFE0F`]: `Woman Facepalming: Medium Skin Tone`,
      [`&#x1F926&#x1F3FE&#x200D&#x2640&#xFE0F`]: `Woman Facepalming: Medium-Dark Skin Tone`,
      [`&#x1F926&#x1F3FF&#x200D&#x2640&#xFE0F`]: `Woman Facepalming: Dark Skin Tone`,
      [`&#x1F937`]: `Person Shrugging`,
      [`&#x1F937&#x1F3FB`]: `Person Shrugging: Light Skin Tone`,
      [`&#x1F937&#x1F3FC`]: `Person Shrugging: Medium-Light Skin Tone`,
      [`&#x1F937&#x1F3FD`]: `Person Shrugging: Medium Skin Tone`,
      [`&#x1F937&#x1F3FE`]: `Person Shrugging: Medium-Dark Skin Tone`,
      [`&#x1F937&#x1F3FF`]: `Person Shrugging: Dark Skin Tone`,
      [`&#x1F937&#x200D&#x2642&#xFE0F`]: `Man Shrugging`,
      [`&#x1F937&#x1F3FB&#x200D&#x2642&#xFE0F`]: `Man Shrugging: Light Skin Tone`,
      [`&#x1F937&#x1F3FC&#x200D&#x2642&#xFE0F`]: `Man Shrugging: Medium-Light Skin Tone`,
      [`&#x1F937&#x1F3FD&#x200D&#x2642&#xFE0F`]: `Man Shrugging: Medium Skin Tone`,
      [`&#x1F937&#x1F3FE&#x200D&#x2642&#xFE0F`]: `Man Shrugging: Medium-Dark Skin Tone`,
      [`&#x1F937&#x1F3FF&#x200D&#x2642&#xFE0F`]: `Man Shrugging: Dark Skin Tone`,
      [`&#x1F937&#x200D&#x2640&#xFE0F`]: `Woman Shrugging`,
      [`&#x1F937&#x1F3FB&#x200D&#x2640&#xFE0F`]: `Woman Shrugging: Light Skin Tone`,
      [`&#x1F937&#x1F3FC&#x200D&#x2640&#xFE0F`]: `Woman Shrugging: Medium-Light Skin Tone`,
      [`&#x1F937&#x1F3FD&#x200D&#x2640&#xFE0F`]: `Woman Shrugging: Medium Skin Tone`,
      [`&#x1F937&#x1F3FE&#x200D&#x2640&#xFE0F`]: `Woman Shrugging: Medium-Dark Skin Tone`,
      [`&#x1F937&#x1F3FF&#x200D&#x2640&#xFE0F`]: `Woman Shrugging: Dark Skin Tone`,
      [`&#x1F486`]: `Person Getting Massage`,
      [`&#x1F486&#x1F3FB`]: `Person Getting Massage: Light Skin Tone`,
      [`&#x1F486&#x1F3FC`]: `Person Getting Massage: Medium-Light Skin Tone`,
      [`&#x1F486&#x1F3FD`]: `Person Getting Massage: Medium Skin Tone`,
      [`&#x1F486&#x1F3FE`]: `Person Getting Massage: Medium-Dark Skin Tone`,
      [`&#x1F486&#x1F3FF`]: `Person Getting Massage: Dark Skin Tone`,
      [`&#x1F486&#x200D&#x2642&#xFE0F`]: `Man Getting Massage`,
      [`&#x1F486&#x1F3FB&#x200D&#x2642&#xFE0F`]: `Man Getting Massage: Light Skin Tone`,
      [`&#x1F486&#x1F3FC&#x200D&#x2642&#xFE0F`]: `Man Getting Massage: Medium-Light Skin Tone`,
      [`&#x1F486&#x1F3FD&#x200D&#x2642&#xFE0F`]: `Man Getting Massage: Medium Skin Tone`,
      [`&#x1F486&#x1F3FE&#x200D&#x2642&#xFE0F`]: `Man Getting Massage: Medium-Dark Skin Tone`,
      [`&#x1F486&#x1F3FF&#x200D&#x2642&#xFE0F`]: `Man Getting Massage: Dark Skin Tone`,
      [`&#x1F486&#x200D&#x2640&#xFE0F`]: `Woman Getting Massage`,
      [`&#x1F486&#x1F3FB&#x200D&#x2640&#xFE0F`]: `Woman Getting Massage: Light Skin Tone`,
      [`&#x1F486&#x1F3FC&#x200D&#x2640&#xFE0F`]: `Woman Getting Massage: Medium-Light Skin Tone`,
      [`&#x1F486&#x1F3FD&#x200D&#x2640&#xFE0F`]: `Woman Getting Massage: Medium Skin Tone`,
      [`&#x1F486&#x1F3FE&#x200D&#x2640&#xFE0F`]: `Woman Getting Massage: Medium-Dark Skin Tone`,
      [`&#x1F486&#x1F3FF&#x200D&#x2640&#xFE0F`]: `Woman Getting Massage: Dark Skin Tone`,
      [`&#x1F487`]: `Person Getting Haircut`,
      [`&#x1F487&#x1F3FB`]: `Person Getting Haircut: Light Skin Tone`,
      [`&#x1F487&#x1F3FC`]: `Person Getting Haircut: Medium-Light Skin Tone`,
      [`&#x1F487&#x1F3FD`]: `Person Getting Haircut: Medium Skin Tone`,
      [`&#x1F487&#x1F3FE`]: `Person Getting Haircut: Medium-Dark Skin Tone`,
      [`&#x1F487&#x1F3FF`]: `Person Getting Haircut: Dark Skin Tone`,
      [`&#x1F487&#x200D&#x2642&#xFE0F`]: `Man Getting Haircut`,
      [`&#x1F487&#x1F3FB&#x200D&#x2642&#xFE0F`]: `Man Getting Haircut: Light Skin Tone`,
      [`&#x1F487&#x1F3FC&#x200D&#x2642&#xFE0F`]: `Man Getting Haircut: Medium-Light Skin Tone`,
      [`&#x1F487&#x1F3FD&#x200D&#x2642&#xFE0F`]: `Man Getting Haircut: Medium Skin Tone`,
      [`&#x1F487&#x1F3FE&#x200D&#x2642&#xFE0F`]: `Man Getting Haircut: Medium-Dark Skin Tone`,
      [`&#x1F487&#x1F3FF&#x200D&#x2642&#xFE0F`]: `Man Getting Haircut: Dark Skin Tone`,
      [`&#x1F487&#x200D&#x2640&#xFE0F`]: `Woman Getting Haircut`,
      [`&#x1F487&#x1F3FB&#x200D&#x2640&#xFE0F`]: `Woman Getting Haircut: Light Skin Tone`,
      [`&#x1F487&#x1F3FC&#x200D&#x2640&#xFE0F`]: `Woman Getting Haircut: Medium-Light Skin Tone`,
      [`&#x1F487&#x1F3FD&#x200D&#x2640&#xFE0F`]: `Woman Getting Haircut: Medium Skin Tone`,
      [`&#x1F487&#x1F3FE&#x200D&#x2640&#xFE0F`]: `Woman Getting Haircut: Medium-Dark Skin Tone`,
      [`&#x1F487&#x1F3FF&#x200D&#x2640&#xFE0F`]: `Woman Getting Haircut: Dark Skin Tone`,
      [`&#x1F6B6`]: `Person Walking`,
      [`&#x1F6B6&#x1F3FB`]: `Person Walking: Light Skin Tone`,
      [`&#x1F6B6&#x1F3FC`]: `Person Walking: Medium-Light Skin Tone`,
      [`&#x1F6B6&#x1F3FD`]: `Person Walking: Medium Skin Tone`,
      [`&#x1F6B6&#x1F3FE`]: `Person Walking: Medium-Dark Skin Tone`,
      [`&#x1F6B6&#x1F3FF`]: `Person Walking: Dark Skin Tone`,
      [`&#x1F6B6&#x200D&#x2642&#xFE0F`]: `Man Walking`,
      [`&#x1F6B6&#x1F3FB&#x200D&#x2642&#xFE0F`]: `Man Walking: Light Skin Tone`,
      [`&#x1F6B6&#x1F3FC&#x200D&#x2642&#xFE0F`]: `Man Walking: Medium-Light Skin Tone`,
      [`&#x1F6B6&#x1F3FD&#x200D&#x2642&#xFE0F`]: `Man Walking: Medium Skin Tone`,
      [`&#x1F6B6&#x1F3FE&#x200D&#x2642&#xFE0F`]: `Man Walking: Medium-Dark Skin Tone`,
      [`&#x1F6B6&#x1F3FF&#x200D&#x2642&#xFE0F`]: `Man Walking: Dark Skin Tone`,
      [`&#x1F6B6&#x200D&#x2640&#xFE0F`]: `Woman Walking`,
      [`&#x1F6B6&#x1F3FB&#x200D&#x2640&#xFE0F`]: `Woman Walking: Light Skin Tone`,
      [`&#x1F6B6&#x1F3FC&#x200D&#x2640&#xFE0F`]: `Woman Walking: Medium-Light Skin Tone`,
      [`&#x1F6B6&#x1F3FD&#x200D&#x2640&#xFE0F`]: `Woman Walking: Medium Skin Tone`,
      [`&#x1F6B6&#x1F3FE&#x200D&#x2640&#xFE0F`]: `Woman Walking: Medium-Dark Skin Tone`,
      [`&#x1F6B6&#x1F3FF&#x200D&#x2640&#xFE0F`]: `Woman Walking: Dark Skin Tone`,
      [`&#x1F3C3`]: `Person Running`,
      [`&#x1F3C3&#x1F3FB`]: `Person Running: Light Skin Tone`,
      [`&#x1F3C3&#x1F3FC`]: `Person Running: Medium-Light Skin Tone`,
      [`&#x1F3C3&#x1F3FD`]: `Person Running: Medium Skin Tone`,
      [`&#x1F3C3&#x1F3FE`]: `Person Running: Medium-Dark Skin Tone`,
      [`&#x1F3C3&#x1F3FF`]: `Person Running: Dark Skin Tone`,
      [`&#x1F3C3&#x200D&#x2642&#xFE0F`]: `Man Running`,
      [`&#x1F3C3&#x1F3FB&#x200D&#x2642&#xFE0F`]: `Man Running: Light Skin Tone`,
      [`&#x1F3C3&#x1F3FC&#x200D&#x2642&#xFE0F`]: `Man Running: Medium-Light Skin Tone`,
      [`&#x1F3C3&#x1F3FD&#x200D&#x2642&#xFE0F`]: `Man Running: Medium Skin Tone`,
      [`&#x1F3C3&#x1F3FE&#x200D&#x2642&#xFE0F`]: `Man Running: Medium-Dark Skin Tone`,
      [`&#x1F3C3&#x1F3FF&#x200D&#x2642&#xFE0F`]: `Man Running: Dark Skin Tone`,
      [`&#x1F3C3&#x200D&#x2640&#xFE0F`]: `Woman Running`,
      [`&#x1F3C3&#x1F3FB&#x200D&#x2640&#xFE0F`]: `Woman Running: Light Skin Tone`,
      [`&#x1F3C3&#x1F3FC&#x200D&#x2640&#xFE0F`]: `Woman Running: Medium-Light Skin Tone`,
      [`&#x1F3C3&#x1F3FD&#x200D&#x2640&#xFE0F`]: `Woman Running: Medium Skin Tone`,
      [`&#x1F3C3&#x1F3FE&#x200D&#x2640&#xFE0F`]: `Woman Running: Medium-Dark Skin Tone`,
      [`&#x1F3C3&#x1F3FF&#x200D&#x2640&#xFE0F`]: `Woman Running: Dark Skin Tone`,
      [`&#x1F483`]: `Woman Dancing`,
      [`&#x1F483&#x1F3FB`]: `Woman Dancing: Light Skin Tone`,
      [`&#x1F483&#x1F3FC`]: `Woman Dancing: Medium-Light Skin Tone`,
      [`&#x1F483&#x1F3FD`]: `Woman Dancing: Medium Skin Tone`,
      [`&#x1F483&#x1F3FE`]: `Woman Dancing: Medium-Dark Skin Tone`,
      [`&#x1F483&#x1F3FF`]: `Woman Dancing: Dark Skin Tone`,
      [`&#x1F57A`]: `Man Dancing`,
      [`&#x1F57A&#x1F3FB`]: `Man Dancing: Light Skin Tone`,
      [`&#x1F57A&#x1F3FC`]: `Man Dancing: Medium-Light Skin Tone`,
      [`&#x1F57A&#x1F3FD`]: `Man Dancing: Medium Skin Tone`,
      [`&#x1F57A&#x1F3FE`]: `Man Dancing: Medium-Dark Skin Tone`,
      [`&#x1F57A&#x1F3FF`]: `Man Dancing: Dark Skin Tone`,
      [`&#x1F46F`]: `People With Bunny Ears Partying`,
      [`&#x1F46F&#x200D&#x2642&#xFE0F`]: `Men With Bunny Ears Partying`,
      [`&#x1F46F&#x200D&#x2640&#xFE0F`]: `Women With Bunny Ears Partying`,
      [`&#x1F574`]: `Man In Business Suit Levitating`,
      [`&#x1F574&#x1F3FB`]: `Man In Business Suit Levitating: Light Skin Tone`,
      [`&#x1F574&#x1F3FC`]: `Man In Business Suit Levitating: Medium-Light Skin Tone`,
      [`&#x1F574&#x1F3FD`]: `Man In Business Suit Levitating: Medium Skin Tone`,
      [`&#x1F574&#x1F3FE`]: `Man In Business Suit Levitating: Medium-Dark Skin Tone`,
      [`&#x1F574&#x1F3FF`]: `Man In Business Suit Levitating: Dark Skin Tone`,
      [`&#x1F5E3`]: `Speaking Head`,
      [`&#x1F464`]: `Bust In Silhouette`,
      [`&#x1F465`]: `Busts In Silhouette`,
      [`&#x1F93A`]: `Person Fencing`,
      [`&#x1F3C7`]: `Horse Racing`,
      [`&#x1F3C7&#x1F3FB`]: `Horse Racing: Light Skin Tone`,
      [`&#x1F3C7&#x1F3FC`]: `Horse Racing: Medium-Light Skin Tone`,
      [`&#x1F3C7&#x1F3FD`]: `Horse Racing: Medium Skin Tone`,
      [`&#x1F3C7&#x1F3FE`]: `Horse Racing: Medium-Dark Skin Tone`,
      [`&#x1F3C7&#x1F3FF`]: `Horse Racing: Dark Skin Tone`,
      [`&#x26F7`]: `Skier`,
      [`&#x1F3C2`]: `Snowboarder`,
      [`&#x1F3C2&#x1F3FB`]: `Snowboarder: Light Skin Tone`,
      [`&#x1F3C2&#x1F3FC`]: `Snowboarder: Medium-Light Skin Tone`,
      [`&#x1F3C2&#x1F3FD`]: `Snowboarder: Medium Skin Tone`,
      [`&#x1F3C2&#x1F3FE`]: `Snowboarder: Medium-Dark Skin Tone`,
      [`&#x1F3C2&#x1F3FF`]: `Snowboarder: Dark Skin Tone`,
      [`&#x1F3CC`]: `Person Golfing`,
      [`&#x1F3CC&#x1F3FB`]: `Person Golfing: Light Skin Tone`,
      [`&#x1F3CC&#x1F3FC`]: `Person Golfing: Medium-Light Skin Tone`,
      [`&#x1F3CC&#x1F3FD`]: `Person Golfing: Medium Skin Tone`,
      [`&#x1F3CC&#x1F3FE`]: `Person Golfing: Medium-Dark Skin Tone`,
      [`&#x1F3CC&#x1F3FF`]: `Person Golfing: Dark Skin Tone`,
      [`&#x1F3CC&#xFE0F&#x200D&#x2642&#xFE0F`]: `Man Golfing`,
      [`&#x1F3CC&#x1F3FB&#x200D&#x2642&#xFE0F`]: `Man Golfing: Light Skin Tone`,
      [`&#x1F3CC&#x1F3FC&#x200D&#x2642&#xFE0F`]: `Man Golfing: Medium-Light Skin Tone`,
      [`&#x1F3CC&#x1F3FD&#x200D&#x2642&#xFE0F`]: `Man Golfing: Medium Skin Tone`,
      [`&#x1F3CC&#x1F3FE&#x200D&#x2642&#xFE0F`]: `Man Golfing: Medium-Dark Skin Tone`,
      [`&#x1F3CC&#x1F3FF&#x200D&#x2642&#xFE0F`]: `Man Golfing: Dark Skin Tone`,
      [`&#x1F3CC&#xFE0F&#x200D&#x2640&#xFE0F`]: `Woman Golfing`,
      [`&#x1F3CC&#x1F3FB&#x200D&#x2640&#xFE0F`]: `Woman Golfing: Light Skin Tone`,
      [`&#x1F3CC&#x1F3FC&#x200D&#x2640&#xFE0F`]: `Woman Golfing: Medium-Light Skin Tone`,
      [`&#x1F3CC&#x1F3FD&#x200D&#x2640&#xFE0F`]: `Woman Golfing: Medium Skin Tone`,
      [`&#x1F3CC&#x1F3FE&#x200D&#x2640&#xFE0F`]: `Woman Golfing: Medium-Dark Skin Tone`,
      [`&#x1F3CC&#x1F3FF&#x200D&#x2640&#xFE0F`]: `Woman Golfing: Dark Skin Tone`,
      [`&#x1F3C4`]: `Person Surfing`,
      [`&#x1F3C4&#x1F3FB`]: `Person Surfing: Light Skin Tone`,
      [`&#x1F3C4&#x1F3FC`]: `Person Surfing: Medium-Light Skin Tone`,
      [`&#x1F3C4&#x1F3FD`]: `Person Surfing: Medium Skin Tone`,
      [`&#x1F3C4&#x1F3FE`]: `Person Surfing: Medium-Dark Skin Tone`,
      [`&#x1F3C4&#x1F3FF`]: `Person Surfing: Dark Skin Tone`,
      [`&#x1F3C4&#x200D&#x2642&#xFE0F`]: `Man Surfing`,
      [`&#x1F3C4&#x1F3FB&#x200D&#x2642&#xFE0F`]: `Man Surfing: Light Skin Tone`,
      [`&#x1F3C4&#x1F3FC&#x200D&#x2642&#xFE0F`]: `Man Surfing: Medium-Light Skin Tone`,
      [`&#x1F3C4&#x1F3FD&#x200D&#x2642&#xFE0F`]: `Man Surfing: Medium Skin Tone`,
      [`&#x1F3C4&#x1F3FE&#x200D&#x2642&#xFE0F`]: `Man Surfing: Medium-Dark Skin Tone`,
      [`&#x1F3C4&#x1F3FF&#x200D&#x2642&#xFE0F`]: `Man Surfing: Dark Skin Tone`,
      [`&#x1F3C4&#x200D&#x2640&#xFE0F`]: `Woman Surfing`,
      [`&#x1F3C4&#x1F3FB&#x200D&#x2640&#xFE0F`]: `Woman Surfing: Light Skin Tone`,
      [`&#x1F3C4&#x1F3FC&#x200D&#x2640&#xFE0F`]: `Woman Surfing: Medium-Light Skin Tone`,
      [`&#x1F3C4&#x1F3FD&#x200D&#x2640&#xFE0F`]: `Woman Surfing: Medium Skin Tone`,
      [`&#x1F3C4&#x1F3FE&#x200D&#x2640&#xFE0F`]: `Woman Surfing: Medium-Dark Skin Tone`,
      [`&#x1F3C4&#x1F3FF&#x200D&#x2640&#xFE0F`]: `Woman Surfing: Dark Skin Tone`,
      [`&#x1F6A3`]: `Person Rowing Boat`,
      [`&#x1F6A3&#x1F3FB`]: `Person Rowing Boat: Light Skin Tone`,
      [`&#x1F6A3&#x1F3FC`]: `Person Rowing Boat: Medium-Light Skin Tone`,
      [`&#x1F6A3&#x1F3FD`]: `Person Rowing Boat: Medium Skin Tone`,
      [`&#x1F6A3&#x1F3FE`]: `Person Rowing Boat: Medium-Dark Skin Tone`,
      [`&#x1F6A3&#x1F3FF`]: `Person Rowing Boat: Dark Skin Tone`,
      [`&#x1F6A3&#x200D&#x2642&#xFE0F`]: `Man Rowing Boat`,
      [`&#x1F6A3&#x1F3FB&#x200D&#x2642&#xFE0F`]: `Man Rowing Boat: Light Skin Tone`,
      [`&#x1F6A3&#x1F3FC&#x200D&#x2642&#xFE0F`]: `Man Rowing Boat: Medium-Light Skin Tone`,
      [`&#x1F6A3&#x1F3FD&#x200D&#x2642&#xFE0F`]: `Man Rowing Boat: Medium Skin Tone`,
      [`&#x1F6A3&#x1F3FE&#x200D&#x2642&#xFE0F`]: `Man Rowing Boat: Medium-Dark Skin Tone`,
      [`&#x1F6A3&#x1F3FF&#x200D&#x2642&#xFE0F`]: `Man Rowing Boat: Dark Skin Tone`,
      [`&#x1F6A3&#x200D&#x2640&#xFE0F`]: `Woman Rowing Boat`,
      [`&#x1F6A3&#x1F3FB&#x200D&#x2640&#xFE0F`]: `Woman Rowing Boat: Light Skin Tone`,
      [`&#x1F6A3&#x1F3FC&#x200D&#x2640&#xFE0F`]: `Woman Rowing Boat: Medium-Light Skin Tone`,
      [`&#x1F6A3&#x1F3FD&#x200D&#x2640&#xFE0F`]: `Woman Rowing Boat: Medium Skin Tone`,
      [`&#x1F6A3&#x1F3FE&#x200D&#x2640&#xFE0F`]: `Woman Rowing Boat: Medium-Dark Skin Tone`,
      [`&#x1F6A3&#x1F3FF&#x200D&#x2640&#xFE0F`]: `Woman Rowing Boat: Dark Skin Tone`,
      [`&#x1F3CA`]: `Person Swimming`,
      [`&#x1F3CA&#x1F3FB`]: `Person Swimming: Light Skin Tone`,
      [`&#x1F3CA&#x1F3FC`]: `Person Swimming: Medium-Light Skin Tone`,
      [`&#x1F3CA&#x1F3FD`]: `Person Swimming: Medium Skin Tone`,
      [`&#x1F3CA&#x1F3FE`]: `Person Swimming: Medium-Dark Skin Tone`,
      [`&#x1F3CA&#x1F3FF`]: `Person Swimming: Dark Skin Tone`,
      [`&#x1F3CA&#x200D&#x2642&#xFE0F`]: `Man Swimming`,
      [`&#x1F3CA&#x1F3FB&#x200D&#x2642&#xFE0F`]: `Man Swimming: Light Skin Tone`,
      [`&#x1F3CA&#x1F3FC&#x200D&#x2642&#xFE0F`]: `Man Swimming: Medium-Light Skin Tone`,
      [`&#x1F3CA&#x1F3FD&#x200D&#x2642&#xFE0F`]: `Man Swimming: Medium Skin Tone`,
      [`&#x1F3CA&#x1F3FE&#x200D&#x2642&#xFE0F`]: `Man Swimming: Medium-Dark Skin Tone`,
      [`&#x1F3CA&#x1F3FF&#x200D&#x2642&#xFE0F`]: `Man Swimming: Dark Skin Tone`,
      [`&#x1F3CA&#x200D&#x2640&#xFE0F`]: `Woman Swimming`,
      [`&#x1F3CA&#x1F3FB&#x200D&#x2640&#xFE0F`]: `Woman Swimming: Light Skin Tone`,
      [`&#x1F3CA&#x1F3FC&#x200D&#x2640&#xFE0F`]: `Woman Swimming: Medium-Light Skin Tone`,
      [`&#x1F3CA&#x1F3FD&#x200D&#x2640&#xFE0F`]: `Woman Swimming: Medium Skin Tone`,
      [`&#x1F3CA&#x1F3FE&#x200D&#x2640&#xFE0F`]: `Woman Swimming: Medium-Dark Skin Tone`,
      [`&#x1F3CA&#x1F3FF&#x200D&#x2640&#xFE0F`]: `Woman Swimming: Dark Skin Tone`,
      [`&#x26F9`]: `Person Bouncing Ball`,
      [`&#x26F9&#x1F3FB`]: `Person Bouncing Ball: Light Skin Tone`,
      [`&#x26F9&#x1F3FC`]: `Person Bouncing Ball: Medium-Light Skin Tone`,
      [`&#x26F9&#x1F3FD`]: `Person Bouncing Ball: Medium Skin Tone`,
      [`&#x26F9&#x1F3FE`]: `Person Bouncing Ball: Medium-Dark Skin Tone`,
      [`&#x26F9&#x1F3FF`]: `Person Bouncing Ball: Dark Skin Tone`,
      [`&#x26F9&#xFE0F&#x200D&#x2642&#xFE0F`]: `Man Bouncing Ball`,
      [`&#x26F9&#x1F3FB&#x200D&#x2642&#xFE0F`]: `Man Bouncing Ball: Light Skin Tone`,
      [`&#x26F9&#x1F3FC&#x200D&#x2642&#xFE0F`]: `Man Bouncing Ball: Medium-Light Skin Tone`,
      [`&#x26F9&#x1F3FD&#x200D&#x2642&#xFE0F`]: `Man Bouncing Ball: Medium Skin Tone`,
      [`&#x26F9&#x1F3FE&#x200D&#x2642&#xFE0F`]: `Man Bouncing Ball: Medium-Dark Skin Tone`,
      [`&#x26F9&#x1F3FF&#x200D&#x2642&#xFE0F`]: `Man Bouncing Ball: Dark Skin Tone`,
      [`&#x26F9&#xFE0F&#x200D&#x2640&#xFE0F`]: `Woman Bouncing Ball`,
      [`&#x26F9&#x1F3FB&#x200D&#x2640&#xFE0F`]: `Woman Bouncing Ball: Light Skin Tone`,
      [`&#x26F9&#x1F3FC&#x200D&#x2640&#xFE0F`]: `Woman Bouncing Ball: Medium-Light Skin Tone`,
      [`&#x26F9&#x1F3FD&#x200D&#x2640&#xFE0F`]: `Woman Bouncing Ball: Medium Skin Tone`,
      [`&#x26F9&#x1F3FE&#x200D&#x2640&#xFE0F`]: `Woman Bouncing Ball: Medium-Dark Skin Tone`,
      [`&#x26F9&#x1F3FF&#x200D&#x2640&#xFE0F`]: `Woman Bouncing Ball: Dark Skin Tone`,
      [`&#x1F3CB`]: `Person Lifting Weights`,
      [`&#x1F3CB&#x1F3FB`]: `Person Lifting Weights: Light Skin Tone`,
      [`&#x1F3CB&#x1F3FC`]: `Person Lifting Weights: Medium-Light Skin Tone`,
      [`&#x1F3CB&#x1F3FD`]: `Person Lifting Weights: Medium Skin Tone`,
      [`&#x1F3CB&#x1F3FE`]: `Person Lifting Weights: Medium-Dark Skin Tone`,
      [`&#x1F3CB&#x1F3FF`]: `Person Lifting Weights: Dark Skin Tone`,
      [`&#x1F3CB&#xFE0F&#x200D&#x2642&#xFE0F`]: `Man Lifting Weights`,
      [`&#x1F3CB&#x1F3FB&#x200D&#x2642&#xFE0F`]: `Man Lifting Weights: Light Skin Tone`,
      [`&#x1F3CB&#x1F3FC&#x200D&#x2642&#xFE0F`]: `Man Lifting Weights: Medium-Light Skin Tone`,
      [`&#x1F3CB&#x1F3FD&#x200D&#x2642&#xFE0F`]: `Man Lifting Weights: Medium Skin Tone`,
      [`&#x1F3CB&#x1F3FE&#x200D&#x2642&#xFE0F`]: `Man Lifting Weights: Medium-Dark Skin Tone`,
      [`&#x1F3CB&#x1F3FF&#x200D&#x2642&#xFE0F`]: `Man Lifting Weights: Dark Skin Tone`,
      [`&#x1F3CB&#xFE0F&#x200D&#x2640&#xFE0F`]: `Woman Lifting Weights`,
      [`&#x1F3CB&#x1F3FB&#x200D&#x2640&#xFE0F`]: `Woman Lifting Weights: Light Skin Tone`,
      [`&#x1F3CB&#x1F3FC&#x200D&#x2640&#xFE0F`]: `Woman Lifting Weights: Medium-Light Skin Tone`,
      [`&#x1F3CB&#x1F3FD&#x200D&#x2640&#xFE0F`]: `Woman Lifting Weights: Medium Skin Tone`,
      [`&#x1F3CB&#x1F3FE&#x200D&#x2640&#xFE0F`]: `Woman Lifting Weights: Medium-Dark Skin Tone`,
      [`&#x1F3CB&#x1F3FF&#x200D&#x2640&#xFE0F`]: `Woman Lifting Weights: Dark Skin Tone`,
      [`&#x1F6B4`]: `Person Biking`,
      [`&#x1F6B4&#x1F3FB`]: `Person Biking: Light Skin Tone`,
      [`&#x1F6B4&#x1F3FC`]: `Person Biking: Medium-Light Skin Tone`,
      [`&#x1F6B4&#x1F3FD`]: `Person Biking: Medium Skin Tone`,
      [`&#x1F6B4&#x1F3FE`]: `Person Biking: Medium-Dark Skin Tone`,
      [`&#x1F6B4&#x1F3FF`]: `Person Biking: Dark Skin Tone`,
      [`&#x1F6B4&#x200D&#x2642&#xFE0F`]: `Man Biking`,
      [`&#x1F6B4&#x1F3FB&#x200D&#x2642&#xFE0F`]: `Man Biking: Light Skin Tone`,
      [`&#x1F6B4&#x1F3FC&#x200D&#x2642&#xFE0F`]: `Man Biking: Medium-Light Skin Tone`,
      [`&#x1F6B4&#x1F3FD&#x200D&#x2642&#xFE0F`]: `Man Biking: Medium Skin Tone`,
      [`&#x1F6B4&#x1F3FE&#x200D&#x2642&#xFE0F`]: `Man Biking: Medium-Dark Skin Tone`,
      [`&#x1F6B4&#x1F3FF&#x200D&#x2642&#xFE0F`]: `Man Biking: Dark Skin Tone`,
      [`&#x1F6B4&#x200D&#x2640&#xFE0F`]: `Woman Biking`,
      [`&#x1F6B4&#x1F3FB&#x200D&#x2640&#xFE0F`]: `Woman Biking: Light Skin Tone`,
      [`&#x1F6B4&#x1F3FC&#x200D&#x2640&#xFE0F`]: `Woman Biking: Medium-Light Skin Tone`,
      [`&#x1F6B4&#x1F3FD&#x200D&#x2640&#xFE0F`]: `Woman Biking: Medium Skin Tone`,
      [`&#x1F6B4&#x1F3FE&#x200D&#x2640&#xFE0F`]: `Woman Biking: Medium-Dark Skin Tone`,
      [`&#x1F6B4&#x1F3FF&#x200D&#x2640&#xFE0F`]: `Woman Biking: Dark Skin Tone`,
      [`&#x1F6B5`]: `Person Mountain Biking`,
      [`&#x1F6B5&#x1F3FB`]: `Person Mountain Biking: Light Skin Tone`,
      [`&#x1F6B5&#x1F3FC`]: `Person Mountain Biking: Medium-Light Skin Tone`,
      [`&#x1F6B5&#x1F3FD`]: `Person Mountain Biking: Medium Skin Tone`,
      [`&#x1F6B5&#x1F3FE`]: `Person Mountain Biking: Medium-Dark Skin Tone`,
      [`&#x1F6B5&#x1F3FF`]: `Person Mountain Biking: Dark Skin Tone`,
      [`&#x1F6B5&#x200D&#x2642&#xFE0F`]: `Man Mountain Biking`,
      [`&#x1F6B5&#x1F3FB&#x200D&#x2642&#xFE0F`]: `Man Mountain Biking: Light Skin Tone`,
      [`&#x1F6B5&#x1F3FC&#x200D&#x2642&#xFE0F`]: `Man Mountain Biking: Medium-Light Skin Tone`,
      [`&#x1F6B5&#x1F3FD&#x200D&#x2642&#xFE0F`]: `Man Mountain Biking: Medium Skin Tone`,
      [`&#x1F6B5&#x1F3FE&#x200D&#x2642&#xFE0F`]: `Man Mountain Biking: Medium-Dark Skin Tone`,
      [`&#x1F6B5&#x1F3FF&#x200D&#x2642&#xFE0F`]: `Man Mountain Biking: Dark Skin Tone`,
      [`&#x1F6B5&#x200D&#x2640&#xFE0F`]: `Woman Mountain Biking`,
      [`&#x1F6B5&#x1F3FB&#x200D&#x2640&#xFE0F`]: `Woman Mountain Biking: Light Skin Tone`,
      [`&#x1F6B5&#x1F3FC&#x200D&#x2640&#xFE0F`]: `Woman Mountain Biking: Medium-Light Skin Tone`,
      [`&#x1F6B5&#x1F3FD&#x200D&#x2640&#xFE0F`]: `Woman Mountain Biking: Medium Skin Tone`,
      [`&#x1F6B5&#x1F3FE&#x200D&#x2640&#xFE0F`]: `Woman Mountain Biking: Medium-Dark Skin Tone`,
      [`&#x1F6B5&#x1F3FF&#x200D&#x2640&#xFE0F`]: `Woman Mountain Biking: Dark Skin Tone`,
      [`&#x1F3CE`]: `Racing Car`,
      [`&#x1F3CD`]: `Motorcycle`,
      [`&#x1F938`]: `Person Cartwheeling`,
      [`&#x1F938&#x1F3FB`]: `Person Cartwheeling: Light Skin Tone`,
      [`&#x1F938&#x1F3FC`]: `Person Cartwheeling: Medium-Light Skin Tone`,
      [`&#x1F938&#x1F3FD`]: `Person Cartwheeling: Medium Skin Tone`,
      [`&#x1F938&#x1F3FE`]: `Person Cartwheeling: Medium-Dark Skin Tone`,
      [`&#x1F938&#x1F3FF`]: `Person Cartwheeling: Dark Skin Tone`,
      [`&#x1F938&#x200D&#x2642&#xFE0F`]: `Man Cartwheeling`,
      [`&#x1F938&#x1F3FB&#x200D&#x2642&#xFE0F`]: `Man Cartwheeling: Light Skin Tone`,
      [`&#x1F938&#x1F3FC&#x200D&#x2642&#xFE0F`]: `Man Cartwheeling: Medium-Light Skin Tone`,
      [`&#x1F938&#x1F3FD&#x200D&#x2642&#xFE0F`]: `Man Cartwheeling: Medium Skin Tone`,
      [`&#x1F938&#x1F3FE&#x200D&#x2642&#xFE0F`]: `Man Cartwheeling: Medium-Dark Skin Tone`,
      [`&#x1F938&#x1F3FF&#x200D&#x2642&#xFE0F`]: `Man Cartwheeling: Dark Skin Tone`,
      [`&#x1F938&#x200D&#x2640&#xFE0F`]: `Woman Cartwheeling`,
      [`&#x1F938&#x1F3FB&#x200D&#x2640&#xFE0F`]: `Woman Cartwheeling: Light Skin Tone`,
      [`&#x1F938&#x1F3FC&#x200D&#x2640&#xFE0F`]: `Woman Cartwheeling: Medium-Light Skin Tone`,
      [`&#x1F938&#x1F3FD&#x200D&#x2640&#xFE0F`]: `Woman Cartwheeling: Medium Skin Tone`,
      [`&#x1F938&#x1F3FE&#x200D&#x2640&#xFE0F`]: `Woman Cartwheeling: Medium-Dark Skin Tone`,
      [`&#x1F938&#x1F3FF&#x200D&#x2640&#xFE0F`]: `Woman Cartwheeling: Dark Skin Tone`,
      [`&#x1F93C`]: `People Wrestling`,
      [`&#x1F93C&#x200D&#x2642&#xFE0F`]: `Men Wrestling`,
      [`&#x1F93C&#x200D&#x2640&#xFE0F`]: `Women Wrestling`,
      [`&#x1F93D`]: `Person Playing Water Polo`,
      [`&#x1F93D&#x1F3FB`]: `Person Playing Water Polo: Light Skin Tone`,
      [`&#x1F93D&#x1F3FC`]: `Person Playing Water Polo: Medium-Light Skin Tone`,
      [`&#x1F93D&#x1F3FD`]: `Person Playing Water Polo: Medium Skin Tone`,
      [`&#x1F93D&#x1F3FE`]: `Person Playing Water Polo: Medium-Dark Skin Tone`,
      [`&#x1F93D&#x1F3FF`]: `Person Playing Water Polo: Dark Skin Tone`,
      [`&#x1F93D&#x200D&#x2642&#xFE0F`]: `Man Playing Water Polo`,
      [`&#x1F93D&#x1F3FB&#x200D&#x2642&#xFE0F`]: `Man Playing Water Polo: Light Skin Tone`,
      [`&#x1F93D&#x1F3FC&#x200D&#x2642&#xFE0F`]: `Man Playing Water Polo: Medium-Light Skin Tone`,
      [`&#x1F93D&#x1F3FD&#x200D&#x2642&#xFE0F`]: `Man Playing Water Polo: Medium Skin Tone`,
      [`&#x1F93D&#x1F3FE&#x200D&#x2642&#xFE0F`]: `Man Playing Water Polo: Medium-Dark Skin Tone`,
      [`&#x1F93D&#x1F3FF&#x200D&#x2642&#xFE0F`]: `Man Playing Water Polo: Dark Skin Tone`,
      [`&#x1F93D&#x200D&#x2640&#xFE0F`]: `Woman Playing Water Polo`,
      [`&#x1F93D&#x1F3FB&#x200D&#x2640&#xFE0F`]: `Woman Playing Water Polo: Light Skin Tone`,
      [`&#x1F93D&#x1F3FC&#x200D&#x2640&#xFE0F`]: `Woman Playing Water Polo: Medium-Light Skin Tone`,
      [`&#x1F93D&#x1F3FD&#x200D&#x2640&#xFE0F`]: `Woman Playing Water Polo: Medium Skin Tone`,
      [`&#x1F93D&#x1F3FE&#x200D&#x2640&#xFE0F`]: `Woman Playing Water Polo: Medium-Dark Skin Tone`,
      [`&#x1F93D&#x1F3FF&#x200D&#x2640&#xFE0F`]: `Woman Playing Water Polo: Dark Skin Tone`,
      [`&#x1F93E`]: `Person Playing Handball`,
      [`&#x1F93E&#x1F3FB`]: `Person Playing Handball: Light Skin Tone`,
      [`&#x1F93E&#x1F3FC`]: `Person Playing Handball: Medium-Light Skin Tone`,
      [`&#x1F93E&#x1F3FD`]: `Person Playing Handball: Medium Skin Tone`,
      [`&#x1F93E&#x1F3FE`]: `Person Playing Handball: Medium-Dark Skin Tone`,
      [`&#x1F93E&#x1F3FF`]: `Person Playing Handball: Dark Skin Tone`,
      [`&#x1F93E&#x200D&#x2642&#xFE0F`]: `Man Playing Handball`,
      [`&#x1F93E&#x1F3FB&#x200D&#x2642&#xFE0F`]: `Man Playing Handball: Light Skin Tone`,
      [`&#x1F93E&#x1F3FC&#x200D&#x2642&#xFE0F`]: `Man Playing Handball: Medium-Light Skin Tone`,
      [`&#x1F93E&#x1F3FD&#x200D&#x2642&#xFE0F`]: `Man Playing Handball: Medium Skin Tone`,
      [`&#x1F93E&#x1F3FE&#x200D&#x2642&#xFE0F`]: `Man Playing Handball: Medium-Dark Skin Tone`,
      [`&#x1F93E&#x1F3FF&#x200D&#x2642&#xFE0F`]: `Man Playing Handball: Dark Skin Tone`,
      [`&#x1F93E&#x200D&#x2640&#xFE0F`]: `Woman Playing Handball`,
      [`&#x1F93E&#x1F3FB&#x200D&#x2640&#xFE0F`]: `Woman Playing Handball: Light Skin Tone`,
      [`&#x1F93E&#x1F3FC&#x200D&#x2640&#xFE0F`]: `Woman Playing Handball: Medium-Light Skin Tone`,
      [`&#x1F93E&#x1F3FD&#x200D&#x2640&#xFE0F`]: `Woman Playing Handball: Medium Skin Tone`,
      [`&#x1F93E&#x1F3FE&#x200D&#x2640&#xFE0F`]: `Woman Playing Handball: Medium-Dark Skin Tone`,
      [`&#x1F93E&#x1F3FF&#x200D&#x2640&#xFE0F`]: `Woman Playing Handball: Dark Skin Tone`,
      [`&#x1F939`]: `Person Juggling`,
      [`&#x1F939&#x1F3FB`]: `Person Juggling: Light Skin Tone`,
      [`&#x1F939&#x1F3FC`]: `Person Juggling: Medium-Light Skin Tone`,
      [`&#x1F939&#x1F3FD`]: `Person Juggling: Medium Skin Tone`,
      [`&#x1F939&#x1F3FE`]: `Person Juggling: Medium-Dark Skin Tone`,
      [`&#x1F939&#x1F3FF`]: `Person Juggling: Dark Skin Tone`,
      [`&#x1F939&#x200D&#x2642&#xFE0F`]: `Man Juggling`,
      [`&#x1F939&#x1F3FB&#x200D&#x2642&#xFE0F`]: `Man Juggling: Light Skin Tone`,
      [`&#x1F939&#x1F3FC&#x200D&#x2642&#xFE0F`]: `Man Juggling: Medium-Light Skin Tone`,
      [`&#x1F939&#x1F3FD&#x200D&#x2642&#xFE0F`]: `Man Juggling: Medium Skin Tone`,
      [`&#x1F939&#x1F3FE&#x200D&#x2642&#xFE0F`]: `Man Juggling: Medium-Dark Skin Tone`,
      [`&#x1F939&#x1F3FF&#x200D&#x2642&#xFE0F`]: `Man Juggling: Dark Skin Tone`,
      [`&#x1F939&#x200D&#x2640&#xFE0F`]: `Woman Juggling`,
      [`&#x1F939&#x1F3FB&#x200D&#x2640&#xFE0F`]: `Woman Juggling: Light Skin Tone`,
      [`&#x1F939&#x1F3FC&#x200D&#x2640&#xFE0F`]: `Woman Juggling: Medium-Light Skin Tone`,
      [`&#x1F939&#x1F3FD&#x200D&#x2640&#xFE0F`]: `Woman Juggling: Medium Skin Tone`,
      [`&#x1F939&#x1F3FE&#x200D&#x2640&#xFE0F`]: `Woman Juggling: Medium-Dark Skin Tone`,
      [`&#x1F939&#x1F3FF&#x200D&#x2640&#xFE0F`]: `Woman Juggling: Dark Skin Tone`,
      [`&#x1F46B`]: `Man And Woman Holding Hands`,
      [`&#x1F46C`]: `Two Men Holding Hands`,
      [`&#x1F46D`]: `Two Women Holding Hands`,
      [`&#x1F48F`]: `Kiss`,
      [`&#x1F469&#x200D&#x2764&#xFE0F&#x200D&#x1F48B&#x200D&#x1F468`]: `Kiss: Woman, Man`,
      [`&#x1F468&#x200D&#x2764&#xFE0F&#x200D&#x1F48B&#x200D&#x1F468`]: `Kiss: Man, Man`,
      [`&#x1F469&#x200D&#x2764&#xFE0F&#x200D&#x1F48B&#x200D&#x1F469`]: `Kiss: Woman, Woman`,
      [`&#x1F491`]: `Couple With Heart`,
      [`&#x1F469&#x200D&#x2764&#xFE0F&#x200D&#x1F468`]: `Couple With Heart: Woman, Man`,
      [`&#x1F468&#x200D&#x2764&#xFE0F&#x200D&#x1F468`]: `Couple With Heart: Man, Man`,
      [`&#x1F469&#x200D&#x2764&#xFE0F&#x200D&#x1F469`]: `Couple With Heart: Woman, Woman`,
      [`&#x1F46A`]: `Family`,
      [`&#x1F468&#x200D&#x1F469&#x200D&#x1F466`]: `Family: Man, Woman, Boy`,
      [`&#x1F468&#x200D&#x1F469&#x200D&#x1F467`]: `Family: Man, Woman, Girl`,
      [`&#x1F468&#x200D&#x1F469&#x200D&#x1F467&#x200D&#x1F466`]: `Family: Man, Woman, Girl, Boy`,
      [`&#x1F468&#x200D&#x1F469&#x200D&#x1F466&#x200D&#x1F466`]: `Family: Man, Woman, Boy, Boy`,
      [`&#x1F468&#x200D&#x1F469&#x200D&#x1F467&#x200D&#x1F467`]: `Family: Man, Woman, Girl, Girl`,
      [`&#x1F468&#x200D&#x1F468&#x200D&#x1F466`]: `Family: Man, Man, Boy`,
      [`&#x1F468&#x200D&#x1F468&#x200D&#x1F467`]: `Family: Man, Man, Girl`,
      [`&#x1F468&#x200D&#x1F468&#x200D&#x1F467&#x200D&#x1F466`]: `Family: Man, Man, Girl, Boy`,
      [`&#x1F468&#x200D&#x1F468&#x200D&#x1F466&#x200D&#x1F466`]: `Family: Man, Man, Boy, Boy`,
      [`&#x1F468&#x200D&#x1F468&#x200D&#x1F467&#x200D&#x1F467`]: `Family: Man, Man, Girl, Girl`,
      [`&#x1F469&#x200D&#x1F469&#x200D&#x1F466`]: `Family: Woman, Woman, Boy`,
      [`&#x1F469&#x200D&#x1F469&#x200D&#x1F467`]: `Family: Woman, Woman, Girl`,
      [`&#x1F469&#x200D&#x1F469&#x200D&#x1F467&#x200D&#x1F466`]: `Family: Woman, Woman, Girl, Boy`,
      [`&#x1F469&#x200D&#x1F469&#x200D&#x1F466&#x200D&#x1F466`]: `Family: Woman, Woman, Boy, Boy`,
      [`&#x1F469&#x200D&#x1F469&#x200D&#x1F467&#x200D&#x1F467`]: `Family: Woman, Woman, Girl, Girl`,
      [`&#x1F468&#x200D&#x1F466`]: `Family: Man, Boy`,
      [`&#x1F468&#x200D&#x1F466&#x200D&#x1F466`]: `Family: Man, Boy, Boy`,
      [`&#x1F468&#x200D&#x1F467`]: `Family: Man, Girl`,
      [`&#x1F468&#x200D&#x1F467&#x200D&#x1F466`]: `Family: Man, Girl, Boy`,
      [`&#x1F468&#x200D&#x1F467&#x200D&#x1F467`]: `Family: Man, Girl, Girl`,
      [`&#x1F469&#x200D&#x1F466`]: `Family: Woman, Boy`,
      [`&#x1F469&#x200D&#x1F466&#x200D&#x1F466`]: `Family: Woman, Boy, Boy`,
      [`&#x1F469&#x200D&#x1F467`]: `Family: Woman, Girl`,
      [`&#x1F469&#x200D&#x1F467&#x200D&#x1F466`]: `Family: Woman, Girl, Boy`,
      [`&#x1F469&#x200D&#x1F467&#x200D&#x1F467`]: `Family: Woman, Girl, Girl`,
      [`&#x1F3FB`]: `Light Skin Tone`,
      [`&#x1F3FC`]: `Medium-Light Skin Tone`,
      [`&#x1F3FD`]: `Medium Skin Tone`,
      [`&#x1F3FE`]: `Medium-Dark Skin Tone`,
      [`&#x1F3FF`]: `Dark Skin Tone`,
      [`&#x1F4AA`]: `Flexed Biceps`,
      [`&#x1F4AA&#x1F3FB`]: `Flexed Biceps: Light Skin Tone`,
      [`&#x1F4AA&#x1F3FC`]: `Flexed Biceps: Medium-Light Skin Tone`,
      [`&#x1F4AA&#x1F3FD`]: `Flexed Biceps: Medium Skin Tone`,
      [`&#x1F4AA&#x1F3FE`]: `Flexed Biceps: Medium-Dark Skin Tone`,
      [`&#x1F4AA&#x1F3FF`]: `Flexed Biceps: Dark Skin Tone`,
      [`&#x1F933`]: `Selfie`,
      [`&#x1F933&#x1F3FB`]: `Selfie: Light Skin Tone`,
      [`&#x1F933&#x1F3FC`]: `Selfie: Medium-Light Skin Tone`,
      [`&#x1F933&#x1F3FD`]: `Selfie: Medium Skin Tone`,
      [`&#x1F933&#x1F3FE`]: `Selfie: Medium-Dark Skin Tone`,
      [`&#x1F933&#x1F3FF`]: `Selfie: Dark Skin Tone`,
      [`&#x1F448`]: `Backhand Index Pointing Left`,
      [`&#x1F448&#x1F3FB`]: `Backhand Index Pointing Left: Light Skin Tone`,
      [`&#x1F448&#x1F3FC`]: `Backhand Index Pointing Left: Medium-Light Skin Tone`,
      [`&#x1F448&#x1F3FD`]: `Backhand Index Pointing Left: Medium Skin Tone`,
      [`&#x1F448&#x1F3FE`]: `Backhand Index Pointing Left: Medium-Dark Skin Tone`,
      [`&#x1F448&#x1F3FF`]: `Backhand Index Pointing Left: Dark Skin Tone`,
      [`&#x1F449`]: `Backhand Index Pointing Right`,
      [`&#x1F449&#x1F3FB`]: `Backhand Index Pointing Right: Light Skin Tone`,
      [`&#x1F449&#x1F3FC`]: `Backhand Index Pointing Right: Medium-Light Skin Tone`,
      [`&#x1F449&#x1F3FD`]: `Backhand Index Pointing Right: Medium Skin Tone`,
      [`&#x1F449&#x1F3FE`]: `Backhand Index Pointing Right: Medium-Dark Skin Tone`,
      [`&#x1F449&#x1F3FF`]: `Backhand Index Pointing Right: Dark Skin Tone`,
      [`&#x261D`]: `Index Pointing Up`,
      [`&#x261D&#x1F3FB`]: `Index Pointing Up: Light Skin Tone`,
      [`&#x261D&#x1F3FC`]: `Index Pointing Up: Medium-Light Skin Tone`,
      [`&#x261D&#x1F3FD`]: `Index Pointing Up: Medium Skin Tone`,
      [`&#x261D&#x1F3FE`]: `Index Pointing Up: Medium-Dark Skin Tone`,
      [`&#x261D&#x1F3FF`]: `Index Pointing Up: Dark Skin Tone`,
      [`&#x1F446`]: `Backhand Index Pointing Up`,
      [`&#x1F446&#x1F3FB`]: `Backhand Index Pointing Up: Light Skin Tone`,
      [`&#x1F446&#x1F3FC`]: `Backhand Index Pointing Up: Medium-Light Skin Tone`,
      [`&#x1F446&#x1F3FD`]: `Backhand Index Pointing Up: Medium Skin Tone`,
      [`&#x1F446&#x1F3FE`]: `Backhand Index Pointing Up: Medium-Dark Skin Tone`,
      [`&#x1F446&#x1F3FF`]: `Backhand Index Pointing Up: Dark Skin Tone`,
      [`&#x1F595`]: `Middle Finger`,
      [`&#x1F595&#x1F3FB`]: `Middle Finger: Light Skin Tone`,
      [`&#x1F595&#x1F3FC`]: `Middle Finger: Medium-Light Skin Tone`,
      [`&#x1F595&#x1F3FD`]: `Middle Finger: Medium Skin Tone`,
      [`&#x1F595&#x1F3FE`]: `Middle Finger: Medium-Dark Skin Tone`,
      [`&#x1F595&#x1F3FF`]: `Middle Finger: Dark Skin Tone`,
      [`&#x1F447`]: `Backhand Index Pointing Down`,
      [`&#x1F447&#x1F3FB`]: `Backhand Index Pointing Down: Light Skin Tone`,
      [`&#x1F447&#x1F3FC`]: `Backhand Index Pointing Down: Medium-Light Skin Tone`,
      [`&#x1F447&#x1F3FD`]: `Backhand Index Pointing Down: Medium Skin Tone`,
      [`&#x1F447&#x1F3FE`]: `Backhand Index Pointing Down: Medium-Dark Skin Tone`,
      [`&#x1F447&#x1F3FF`]: `Backhand Index Pointing Down: Dark Skin Tone`,
      [`&#x270C`]: `Victory Hand`,
      [`&#x270C&#x1F3FB`]: `Victory Hand: Light Skin Tone`,
      [`&#x270C&#x1F3FC`]: `Victory Hand: Medium-Light Skin Tone`,
      [`&#x270C&#x1F3FD`]: `Victory Hand: Medium Skin Tone`,
      [`&#x270C&#x1F3FE`]: `Victory Hand: Medium-Dark Skin Tone`,
      [`&#x270C&#x1F3FF`]: `Victory Hand: Dark Skin Tone`,
      [`&#x1F91E`]: `Crossed Fingers`,
      [`&#x1F91E&#x1F3FB`]: `Crossed Fingers: Light Skin Tone`,
      [`&#x1F91E&#x1F3FC`]: `Crossed Fingers: Medium-Light Skin Tone`,
      [`&#x1F91E&#x1F3FD`]: `Crossed Fingers: Medium Skin Tone`,
      [`&#x1F91E&#x1F3FE`]: `Crossed Fingers: Medium-Dark Skin Tone`,
      [`&#x1F91E&#x1F3FF`]: `Crossed Fingers: Dark Skin Tone`,
      [`&#x1F596`]: `Vulcan Salute`,
      [`&#x1F596&#x1F3FB`]: `Vulcan Salute: Light Skin Tone`,
      [`&#x1F596&#x1F3FC`]: `Vulcan Salute: Medium-Light Skin Tone`,
      [`&#x1F596&#x1F3FD`]: `Vulcan Salute: Medium Skin Tone`,
      [`&#x1F596&#x1F3FE`]: `Vulcan Salute: Medium-Dark Skin Tone`,
      [`&#x1F596&#x1F3FF`]: `Vulcan Salute: Dark Skin Tone`,
      [`&#x1F918`]: `Sign Of The Horns`,
      [`&#x1F918&#x1F3FB`]: `Sign Of The Horns: Light Skin Tone`,
      [`&#x1F918&#x1F3FC`]: `Sign Of The Horns: Medium-Light Skin Tone`,
      [`&#x1F918&#x1F3FD`]: `Sign Of The Horns: Medium Skin Tone`,
      [`&#x1F918&#x1F3FE`]: `Sign Of The Horns: Medium-Dark Skin Tone`,
      [`&#x1F918&#x1F3FF`]: `Sign Of The Horns: Dark Skin Tone`,
      [`&#x1F919`]: `Call Me Hand`,
      [`&#x1F919&#x1F3FB`]: `Call Me Hand: Light Skin Tone`,
      [`&#x1F919&#x1F3FC`]: `Call Me Hand: Medium-Light Skin Tone`,
      [`&#x1F919&#x1F3FD`]: `Call Me Hand: Medium Skin Tone`,
      [`&#x1F919&#x1F3FE`]: `Call Me Hand: Medium-Dark Skin Tone`,
      [`&#x1F919&#x1F3FF`]: `Call Me Hand: Dark Skin Tone`,
      [`&#x1F590`]: `Raised Hand With Fingers Splayed`,
      [`&#x1F590&#x1F3FB`]: `Raised Hand With Fingers Splayed: Light Skin Tone`,
      [`&#x1F590&#x1F3FC`]: `Raised Hand With Fingers Splayed: Medium-Light Skin Tone`,
      [`&#x1F590&#x1F3FD`]: `Raised Hand With Fingers Splayed: Medium Skin Tone`,
      [`&#x1F590&#x1F3FE`]: `Raised Hand With Fingers Splayed: Medium-Dark Skin Tone`,
      [`&#x1F590&#x1F3FF`]: `Raised Hand With Fingers Splayed: Dark Skin Tone`,
      [`&#x270B`]: `Raised Hand`,
      [`&#x270B&#x1F3FB`]: `Raised Hand: Light Skin Tone`,
      [`&#x270B&#x1F3FC`]: `Raised Hand: Medium-Light Skin Tone`,
      [`&#x270B&#x1F3FD`]: `Raised Hand: Medium Skin Tone`,
      [`&#x270B&#x1F3FE`]: `Raised Hand: Medium-Dark Skin Tone`,
      [`&#x270B&#x1F3FF`]: `Raised Hand: Dark Skin Tone`,
      [`&#x1F44C`]: `OK Hand`,
      [`&#x1F44C&#x1F3FB`]: `OK Hand: Light Skin Tone`,
      [`&#x1F44C&#x1F3FC`]: `OK Hand: Medium-Light Skin Tone`,
      [`&#x1F44C&#x1F3FD`]: `OK Hand: Medium Skin Tone`,
      [`&#x1F44C&#x1F3FE`]: `OK Hand: Medium-Dark Skin Tone`,
      [`&#x1F44C&#x1F3FF`]: `OK Hand: Dark Skin Tone`,
      [`&#x1F44D`]: `Thumbs Up`,
      [`&#x1F44D&#x1F3FB`]: `Thumbs Up: Light Skin Tone`,
      [`&#x1F44D&#x1F3FC`]: `Thumbs Up: Medium-Light Skin Tone`,
      [`&#x1F44D&#x1F3FD`]: `Thumbs Up: Medium Skin Tone`,
      [`&#x1F44D&#x1F3FE`]: `Thumbs Up: Medium-Dark Skin Tone`,
      [`&#x1F44D&#x1F3FF`]: `Thumbs Up: Dark Skin Tone`,
      [`&#x1F44E`]: `Thumbs Down`,
      [`&#x1F44E&#x1F3FB`]: `Thumbs Down: Light Skin Tone`,
      [`&#x1F44E&#x1F3FC`]: `Thumbs Down: Medium-Light Skin Tone`,
      [`&#x1F44E&#x1F3FD`]: `Thumbs Down: Medium Skin Tone`,
      [`&#x1F44E&#x1F3FE`]: `Thumbs Down: Medium-Dark Skin Tone`,
      [`&#x1F44E&#x1F3FF`]: `Thumbs Down: Dark Skin Tone`,
      [`&#x270A`]: `Raised Fist`,
      [`&#x270A&#x1F3FB`]: `Raised Fist: Light Skin Tone`,
      [`&#x270A&#x1F3FC`]: `Raised Fist: Medium-Light Skin Tone`,
      [`&#x270A&#x1F3FD`]: `Raised Fist: Medium Skin Tone`,
      [`&#x270A&#x1F3FE`]: `Raised Fist: Medium-Dark Skin Tone`,
      [`&#x270A&#x1F3FF`]: `Raised Fist: Dark Skin Tone`,
      [`&#x1F44A`]: `Oncoming Fist`,
      [`&#x1F44A&#x1F3FB`]: `Oncoming Fist: Light Skin Tone`,
      [`&#x1F44A&#x1F3FC`]: `Oncoming Fist: Medium-Light Skin Tone`,
      [`&#x1F44A&#x1F3FD`]: `Oncoming Fist: Medium Skin Tone`,
      [`&#x1F44A&#x1F3FE`]: `Oncoming Fist: Medium-Dark Skin Tone`,
      [`&#x1F44A&#x1F3FF`]: `Oncoming Fist: Dark Skin Tone`,
      [`&#x1F91B`]: `Left-Facing Fist`,
      [`&#x1F91B&#x1F3FB`]: `Left-Facing Fist: Light Skin Tone`,
      [`&#x1F91B&#x1F3FC`]: `Left-Facing Fist: Medium-Light Skin Tone`,
      [`&#x1F91B&#x1F3FD`]: `Left-Facing Fist: Medium Skin Tone`,
      [`&#x1F91B&#x1F3FE`]: `Left-Facing Fist: Medium-Dark Skin Tone`,
      [`&#x1F91B&#x1F3FF`]: `Left-Facing Fist: Dark Skin Tone`,
      [`&#x1F91C`]: `Right-Facing Fist`,
      [`&#x1F91C&#x1F3FB`]: `Right-Facing Fist: Light Skin Tone`,
      [`&#x1F91C&#x1F3FC`]: `Right-Facing Fist: Medium-Light Skin Tone`,
      [`&#x1F91C&#x1F3FD`]: `Right-Facing Fist: Medium Skin Tone`,
      [`&#x1F91C&#x1F3FE`]: `Right-Facing Fist: Medium-Dark Skin Tone`,
      [`&#x1F91C&#x1F3FF`]: `Right-Facing Fist: Dark Skin Tone`,
      [`&#x1F91A`]: `Raised Back Of Hand`,
      [`&#x1F91A&#x1F3FB`]: `Raised Back Of Hand: Light Skin Tone`,
      [`&#x1F91A&#x1F3FC`]: `Raised Back Of Hand: Medium-Light Skin Tone`,
      [`&#x1F91A&#x1F3FD`]: `Raised Back Of Hand: Medium Skin Tone`,
      [`&#x1F91A&#x1F3FE`]: `Raised Back Of Hand: Medium-Dark Skin Tone`,
      [`&#x1F91A&#x1F3FF`]: `Raised Back Of Hand: Dark Skin Tone`,
      [`&#x1F44B`]: `Waving Hand`,
      [`&#x1F44B&#x1F3FB`]: `Waving Hand: Light Skin Tone`,
      [`&#x1F44B&#x1F3FC`]: `Waving Hand: Medium-Light Skin Tone`,
      [`&#x1F44B&#x1F3FD`]: `Waving Hand: Medium Skin Tone`,
      [`&#x1F44B&#x1F3FE`]: `Waving Hand: Medium-Dark Skin Tone`,
      [`&#x1F44B&#x1F3FF`]: `Waving Hand: Dark Skin Tone`,
      [`&#x1F44F`]: `Clapping Hands`,
      [`&#x1F44F&#x1F3FB`]: `Clapping Hands: Light Skin Tone`,
      [`&#x1F44F&#x1F3FC`]: `Clapping Hands: Medium-Light Skin Tone`,
      [`&#x1F44F&#x1F3FD`]: `Clapping Hands: Medium Skin Tone`,
      [`&#x1F44F&#x1F3FE`]: `Clapping Hands: Medium-Dark Skin Tone`,
      [`&#x1F44F&#x1F3FF`]: `Clapping Hands: Dark Skin Tone`,
      [`&#x270D`]: `Writing Hand`,
      [`&#x270D&#x1F3FB`]: `Writing Hand: Light Skin Tone`,
      [`&#x270D&#x1F3FC`]: `Writing Hand: Medium-Light Skin Tone`,
      [`&#x270D&#x1F3FD`]: `Writing Hand: Medium Skin Tone`,
      [`&#x270D&#x1F3FE`]: `Writing Hand: Medium-Dark Skin Tone`,
      [`&#x270D&#x1F3FF`]: `Writing Hand: Dark Skin Tone`,
      [`&#x1F450`]: `Open Hands`,
      [`&#x1F450&#x1F3FB`]: `Open Hands: Light Skin Tone`,
      [`&#x1F450&#x1F3FC`]: `Open Hands: Medium-Light Skin Tone`,
      [`&#x1F450&#x1F3FD`]: `Open Hands: Medium Skin Tone`,
      [`&#x1F450&#x1F3FE`]: `Open Hands: Medium-Dark Skin Tone`,
      [`&#x1F450&#x1F3FF`]: `Open Hands: Dark Skin Tone`,
      [`&#x1F64C`]: `Raising Hands`,
      [`&#x1F64C&#x1F3FB`]: `Raising Hands: Light Skin Tone`,
      [`&#x1F64C&#x1F3FC`]: `Raising Hands: Medium-Light Skin Tone`,
      [`&#x1F64C&#x1F3FD`]: `Raising Hands: Medium Skin Tone`,
      [`&#x1F64C&#x1F3FE`]: `Raising Hands: Medium-Dark Skin Tone`,
      [`&#x1F64C&#x1F3FF`]: `Raising Hands: Dark Skin Tone`,
      [`&#x1F64F`]: `Folded Hands`,
      [`&#x1F64F&#x1F3FB`]: `Folded Hands: Light Skin Tone`,
      [`&#x1F64F&#x1F3FC`]: `Folded Hands: Medium-Light Skin Tone`,
      [`&#x1F64F&#x1F3FD`]: `Folded Hands: Medium Skin Tone`,
      [`&#x1F64F&#x1F3FE`]: `Folded Hands: Medium-Dark Skin Tone`,
      [`&#x1F64F&#x1F3FF`]: `Folded Hands: Dark Skin Tone`,
      [`&#x1F91D`]: `Handshake`,
      [`&#x1F485`]: `Nail Polish`,
      [`&#x1F485&#x1F3FB`]: `Nail Polish: Light Skin Tone`,
      [`&#x1F485&#x1F3FC`]: `Nail Polish: Medium-Light Skin Tone`,
      [`&#x1F485&#x1F3FD`]: `Nail Polish: Medium Skin Tone`,
      [`&#x1F485&#x1F3FE`]: `Nail Polish: Medium-Dark Skin Tone`,
      [`&#x1F485&#x1F3FF`]: `Nail Polish: Dark Skin Tone`,
      [`&#x1F442`]: `Ear`,
      [`&#x1F442&#x1F3FB`]: `Ear: Light Skin Tone`,
      [`&#x1F442&#x1F3FC`]: `Ear: Medium-Light Skin Tone`,
      [`&#x1F442&#x1F3FD`]: `Ear: Medium Skin Tone`,
      [`&#x1F442&#x1F3FE`]: `Ear: Medium-Dark Skin Tone`,
      [`&#x1F442&#x1F3FF`]: `Ear: Dark Skin Tone`,
      [`&#x1F443`]: `Nose`,
      [`&#x1F443&#x1F3FB`]: `Nose: Light Skin Tone`,
      [`&#x1F443&#x1F3FC`]: `Nose: Medium-Light Skin Tone`,
      [`&#x1F443&#x1F3FD`]: `Nose: Medium Skin Tone`,
      [`&#x1F443&#x1F3FE`]: `Nose: Medium-Dark Skin Tone`,
      [`&#x1F443&#x1F3FF`]: `Nose: Dark Skin Tone`,
      [`&#x1F463`]: `Footprints`,
      [`&#x1F440`]: `Eyes`,
      [`&#x1F441`]: `Eye`,
      [`&#x1F441&#xFE0F&#x200D&#x1F5E8&#xFE0F`]: `Eye In Speech Bubble`,
      [`&#x1F445`]: `Tongue`,
      [`&#x1F444`]: `Mouth`,
      [`&#x1F48B`]: `Kiss Mark`,
      [`&#x1F498`]: `Heart With Arrow`,
      [`&#x2764`]: `Red Heart`,
      [`&#x1F493`]: `Beating Heart`,
      [`&#x1F494`]: `Broken Heart`,
      [`&#x1F495`]: `Two Hearts`,
      [`&#x1F496`]: `Sparkling Heart`,
      [`&#x1F497`]: `Growing Heart`,
      [`&#x1F499`]: `Blue Heart`,
      [`&#x1F49A`]: `Green Heart`,
      [`&#x1F49B`]: `Yellow Heart`,
      [`&#x1F49C`]: `Purple Heart`,
      [`&#x1F5A4`]: `Black Heart`,
      [`&#x1F49D`]: `Heart With Ribbon`,
      [`&#x1F49E`]: `Revolving Hearts`,
      [`&#x1F49F`]: `Heart Decoration`,
      [`&#x2763`]: `Heavy Heart Exclamation`,
      [`&#x1F48C`]: `Love Letter`,
      [`&#x1F4A4`]: `Zzz`,
      [`&#x1F4A2`]: `Anger Symbol`,
      [`&#x1F4A3`]: `Bomb`,
      [`&#x1F4A5`]: `Collision`,
      [`&#x1F4A6`]: `Sweat Droplets`,
      [`&#x1F4A8`]: `Dashing Away`,
      [`&#x1F4AB`]: `Dizzy`,
      [`&#x1F4AC`]: `Speech Balloon`,
      [`&#x1F5E8`]: `Left Speech Bubble`,
      [`&#x1F5EF`]: `Right Anger Bubble`,
      [`&#x1F4AD`]: `Thought Balloon`,
      [`&#x1F573`]: `Hole`,
      [`&#x1F453`]: `Glasses`,
      [`&#x1F576`]: `Sunglasses`,
      [`&#x1F454`]: `Necktie`,
      [`&#x1F455`]: `T-Shirt`,
      [`&#x1F456`]: `Jeans`,
      [`&#x1F457`]: `Dress`,
      [`&#x1F458`]: `Kimono`,
      [`&#x1F459`]: `Bikini`,
      [`&#x1F45A`]: `Woman’s Clothes`,
      [`&#x1F45B`]: `Purse`,
      [`&#x1F45C`]: `Handbag`,
      [`&#x1F45D`]: `Clutch Bag`,
      [`&#x1F6CD`]: `Shopping Bags`,
      [`&#x1F392`]: `School Backpack`,
      [`&#x1F45E`]: `Man’s Shoe`,
      [`&#x1F45F`]: `Running Shoe`,
      [`&#x1F460`]: `High-Heeled Shoe`,
      [`&#x1F461`]: `Woman’s Sandal`,
      [`&#x1F462`]: `Woman’s Boot`,
      [`&#x1F451`]: `Crown`,
      [`&#x1F452`]: `Woman’s Hat`,
      [`&#x1F3A9`]: `Top Hat`,
      [`&#x1F393`]: `Graduation Cap`,
      [`&#x26D1`]: `Rescue Worker’s Helmet`,
      [`&#x1F4FF`]: `Prayer Beads`,
      [`&#x1F484`]: `Lipstick`,
      [`&#x1F48D`]: `Ring`,
      [`&#x1F48E`]: `Gem Stone`,
      [`&#x1F435`]: `Monkey Face`,
      [`&#x1F412`]: `Monkey`,
      [`&#x1F98D`]: `Gorilla`,
      [`&#x1F436`]: `Dog Face`,
      [`&#x1F415`]: `Dog`,
      [`&#x1F429`]: `Poodle`,
      [`&#x1F43A`]: `Wolf Face`,
      [`&#x1F98A`]: `Fox Face`,
      [`&#x1F431`]: `Cat Face`,
      [`&#x1F408`]: `Cat`,
      [`&#x1F981`]: `Lion Face`,
      [`&#x1F42F`]: `Tiger Face`,
      [`&#x1F405`]: `Tiger`,
      [`&#x1F406`]: `Leopard`,
      [`&#x1F434`]: `Horse Face`,
      [`&#x1F40E`]: `Horse`,
      [`&#x1F98C`]: `Deer`,
      [`&#x1F984`]: `Unicorn Face`,
      [`&#x1F42E`]: `Cow Face`,
      [`&#x1F402`]: `Ox`,
      [`&#x1F403`]: `Water Buffalo`,
      [`&#x1F404`]: `Cow`,
      [`&#x1F437`]: `Pig Face`,
      [`&#x1F416`]: `Pig`,
      [`&#x1F417`]: `Boar`,
      [`&#x1F43D`]: `Pig Nose`,
      [`&#x1F40F`]: `Ram`,
      [`&#x1F411`]: `Sheep`,
      [`&#x1F410`]: `Goat`,
      [`&#x1F42A`]: `Camel`,
      [`&#x1F42B`]: `Two-Hump Camel`,
      [`&#x1F418`]: `Elephant`,
      [`&#x1F98F`]: `Rhinoceros`,
      [`&#x1F42D`]: `Mouse Face`,
      [`&#x1F401`]: `Mouse`,
      [`&#x1F400`]: `Rat`,
      [`&#x1F439`]: `Hamster Face`,
      [`&#x1F430`]: `Rabbit Face`,
      [`&#x1F407`]: `Rabbit`,
      [`&#x1F43F`]: `Chipmunk`,
      [`&#x1F987`]: `Bat`,
      [`&#x1F43B`]: `Bear Face`,
      [`&#x1F428`]: `Koala`,
      [`&#x1F43C`]: `Panda Face`,
      [`&#x1F43E`]: `Paw Prints`,
      [`&#x1F983`]: `Turkey`,
      [`&#x1F414`]: `Chicken`,
      [`&#x1F413`]: `Rooster`,
      [`&#x1F423`]: `Hatching Chick`,
      [`&#x1F424`]: `Baby Chick`,
      [`&#x1F425`]: `Front-Facing Baby Chick`,
      [`&#x1F426`]: `Bird`,
      [`&#x1F427`]: `Penguin`,
      [`&#x1F54A`]: `Dove`,
      [`&#x1F985`]: `Eagle`,
      [`&#x1F986`]: `Duck`,
      [`&#x1F989`]: `Owl`,
      [`&#x1F438`]: `Frog Face`,
      [`&#x1F40A`]: `Crocodile`,
      [`&#x1F422`]: `Turtle`,
      [`&#x1F98E`]: `Lizard`,
      [`&#x1F40D`]: `Snake`,
      [`&#x1F432`]: `Dragon Face`,
      [`&#x1F409`]: `Dragon`,
      [`&#x1F433`]: `Spouting Whale`,
      [`&#x1F40B`]: `Whale`,
      [`&#x1F42C`]: `Dolphin`,
      [`&#x1F41F`]: `Fish`,
      [`&#x1F420`]: `Tropical Fish`,
      [`&#x1F421`]: `Blowfish`,
      [`&#x1F988`]: `Shark`,
      [`&#x1F419`]: `Octopus`,
      [`&#x1F41A`]: `Spiral Shell`,
      [`&#x1F980`]: `Crab`,
      [`&#x1F990`]: `Shrimp`,
      [`&#x1F991`]: `Squid`,
      [`&#x1F98B`]: `Butterfly`,
      [`&#x1F40C`]: `Snail`,
      [`&#x1F41B`]: `Bug`,
      [`&#x1F41C`]: `Ant`,
      [`&#x1F41D`]: `Honeybee`,
      [`&#x1F41E`]: `Lady Beetle`,
      [`&#x1F577`]: `Spider`,
      [`&#x1F578`]: `Spider Web`,
      [`&#x1F982`]: `Scorpion`,
      [`&#x1F490`]: `Bouquet`,
      [`&#x1F338`]: `Cherry Blossom`,
      [`&#x1F4AE`]: `White Flower`,
      [`&#x1F3F5`]: `Rosette`,
      [`&#x1F339`]: `Rose`,
      [`&#x1F940`]: `Wilted Flower`,
      [`&#x1F33A`]: `Hibiscus`,
      [`&#x1F33B`]: `Sunflower`,
      [`&#x1F33C`]: `Blossom`,
      [`&#x1F337`]: `Tulip`,
      [`&#x1F331`]: `Seedling`,
      [`&#x1F332`]: `Evergreen Tree`,
      [`&#x1F333`]: `Deciduous Tree`,
      [`&#x1F334`]: `Palm Tree`,
      [`&#x1F335`]: `Cactus`,
      [`&#x1F33E`]: `Sheaf Of Rice`,
      [`&#x1F33F`]: `Herb`,
      [`&#x2618`]: `Shamrock`,
      [`&#x1F340`]: `Four Leaf Clover`,
      [`&#x1F341`]: `Maple Leaf`,
      [`&#x1F342`]: `Fallen Leaf`,
      [`&#x1F343`]: `Leaf Fluttering In Wind`,
      [`&#x1F347`]: `Grapes`,
      [`&#x1F348`]: `Melon`,
      [`&#x1F349`]: `Watermelon`,
      [`&#x1F34A`]: `Tangerine`,
      [`&#x1F34B`]: `Lemon`,
      [`&#x1F34C`]: `Banana`,
      [`&#x1F34D`]: `Pineapple`,
      [`&#x1F34E`]: `Red Apple`,
      [`&#x1F34F`]: `Green Apple`,
      [`&#x1F350`]: `Pear`,
      [`&#x1F351`]: `Peach`,
      [`&#x1F352`]: `Cherries`,
      [`&#x1F353`]: `Strawberry`,
      [`&#x1F95D`]: `Kiwi Fruit`,
      [`&#x1F345`]: `Tomato`,
      [`&#x1F951`]: `Avocado`,
      [`&#x1F346`]: `Eggplant`,
      [`&#x1F954`]: `Potato`,
      [`&#x1F955`]: `Carrot`,
      [`&#x1F33D`]: `Ear Of Corn`,
      [`&#x1F336`]: `Hot Pepper`,
      [`&#x1F952`]: `Cucumber`,
      [`&#x1F344`]: `Mushroom`,
      [`&#x1F95C`]: `Peanuts`,
      [`&#x1F330`]: `Chestnut`,
      [`&#x1F35E`]: `Bread`,
      [`&#x1F950`]: `Croissant`,
      [`&#x1F956`]: `Baguette Bread`,
      [`&#x1F95E`]: `Pancakes`,
      [`&#x1F9C0`]: `Cheese Wedge`,
      [`&#x1F356`]: `Meat On Bone`,
      [`&#x1F357`]: `Poultry Leg`,
      [`&#x1F953`]: `Bacon`,
      [`&#x1F354`]: `Hamburger`,
      [`&#x1F35F`]: `French Fries`,
      [`&#x1F355`]: `Pizza`,
      [`&#x1F32D`]: `Hot Dog`,
      [`&#x1F32E`]: `Taco`,
      [`&#x1F32F`]: `Burrito`,
      [`&#x1F959`]: `Stuffed Flatbread`,
      [`&#x1F95A`]: `Egg`,
      [`&#x1F373`]: `Cooking`,
      [`&#x1F958`]: `Shallow Pan Of Food`,
      [`&#x1F372`]: `Pot Of Food`,
      [`&#x1F957`]: `Green Salad`,
      [`&#x1F37F`]: `Popcorn`,
      [`&#x1F371`]: `Bento Box`,
      [`&#x1F358`]: `Rice Cracker`,
      [`&#x1F359`]: `Rice Ball`,
      [`&#x1F35A`]: `Cooked Rice`,
      [`&#x1F35B`]: `Curry Rice`,
      [`&#x1F35C`]: `Steaming Bowl`,
      [`&#x1F35D`]: `Spaghetti`,
      [`&#x1F360`]: `Roasted Sweet Potato`,
      [`&#x1F362`]: `Oden`,
      [`&#x1F363`]: `Sushi`,
      [`&#x1F364`]: `Fried Shrimp`,
      [`&#x1F365`]: `Fish Cake With Swirl`,
      [`&#x1F361`]: `Dango`,
      [`&#x1F366`]: `Soft Ice Cream`,
      [`&#x1F367`]: `Shaved Ice`,
      [`&#x1F368`]: `Ice Cream`,
      [`&#x1F369`]: `Doughnut`,
      [`&#x1F36A`]: `Cookie`,
      [`&#x1F382`]: `Birthday Cake`,
      [`&#x1F370`]: `Shortcake`,
      [`&#x1F36B`]: `Chocolate Bar`,
      [`&#x1F36C`]: `Candy`,
      [`&#x1F36D`]: `Lollipop`,
      [`&#x1F36E`]: `Custard`,
      [`&#x1F36F`]: `Honey Pot`,
      [`&#x1F37C`]: `Baby Bottle`,
      [`&#x1F95B`]: `Glass Of Milk`,
      [`&#x2615`]: `Hot Beverage`,
      [`&#x1F375`]: `Teacup Without Handle`,
      [`&#x1F376`]: `Sake`,
      [`&#x1F37E`]: `Bottle With Popping Cork`,
      [`&#x1F377`]: `Wine Glass`,
      [`&#x1F378`]: `Cocktail Glass`,
      [`&#x1F379`]: `Tropical Drink`,
      [`&#x1F37A`]: `Beer Mug`,
      [`&#x1F37B`]: `Clinking Beer Mugs`,
      [`&#x1F942`]: `Clinking Glasses`,
      [`&#x1F943`]: `Tumbler Glass`,
      [`&#x1F37D`]: `Fork And Knife With Plate`,
      [`&#x1F374`]: `Fork And Knife`,
      [`&#x1F944`]: `Spoon`,
      [`&#x1F52A`]: `Kitchen Knife`,
      [`&#x1F3FA`]: `Amphora`,
      [`&#x1F30D`]: `Globe Showing Europe-Africa`,
      [`&#x1F30E`]: `Globe Showing Americas`,
      [`&#x1F30F`]: `Globe Showing Asia-Australia`,
      [`&#x1F310`]: `Globe With Meridians`,
      [`&#x1F5FA`]: `World Map`,
      [`&#x1F5FE`]: `Map Of Japan`,
      [`&#x1F3D4`]: `Snow-Capped Mountain`,
      [`&#x26F0`]: `Mountain`,
      [`&#x1F30B`]: `Volcano`,
      [`&#x1F5FB`]: `Mount Fuji`,
      [`&#x1F3D5`]: `Camping`,
      [`&#x1F3D6`]: `Beach With Umbrella`,
      [`&#x1F3DC`]: `Desert`,
      [`&#x1F3DD`]: `Desert Island`,
      [`&#x1F3DE`]: `National Park`,
      [`&#x1F3DF`]: `Stadium`,
      [`&#x1F3DB`]: `Classical Building`,
      [`&#x1F3D7`]: `Building Construction`,
      [`&#x1F3D8`]: `House`,
      [`&#x1F3D9`]: `Cityscape`,
      [`&#x1F3DA`]: `Derelict House`,
      [`&#x1F3E0`]: `House`,
      [`&#x1F3E1`]: `House With Garden`,
      [`&#x1F3E2`]: `Office Building`,
      [`&#x1F3E3`]: `Japanese Post Office`,
      [`&#x1F3E4`]: `Post Office`,
      [`&#x1F3E5`]: `Hospital`,
      [`&#x1F3E6`]: `Bank`,
      [`&#x1F3E8`]: `Hotel`,
      [`&#x1F3E9`]: `Love Hotel`,
      [`&#x1F3EA`]: `Convenience Store`,
      [`&#x1F3EB`]: `School`,
      [`&#x1F3EC`]: `Department Store`,
      [`&#x1F3ED`]: `Factory`,
      [`&#x1F3EF`]: `Japanese Castle`,
      [`&#x1F3F0`]: `Castle`,
      [`&#x1F492`]: `Wedding`,
      [`&#x1F5FC`]: `Tokyo Tower`,
      [`&#x1F5FD`]: `Statue Of Liberty`,
      [`&#x26EA`]: `Church`,
      [`&#x1F54C`]: `Mosque`,
      [`&#x1F54D`]: `Synagogue`,
      [`&#x26E9`]: `Shinto Shrine`,
      [`&#x1F54B`]: `Kaaba`,
      [`&#x26F2`]: `Fountain`,
      [`&#x26FA`]: `Tent`,
      [`&#x1F301`]: `Foggy`,
      [`&#x1F303`]: `Night With Stars`,
      [`&#x1F304`]: `Sunrise Over Mountains`,
      [`&#x1F305`]: `Sunrise`,
      [`&#x1F306`]: `Cityscape At Dusk`,
      [`&#x1F307`]: `Sunset`,
      [`&#x1F309`]: `Bridge At Night`,
      [`&#x2668`]: `Hot Springs`,
      [`&#x1F30C`]: `Milky Way`,
      [`&#x1F3A0`]: `Carousel Horse`,
      [`&#x1F3A1`]: `Ferris Wheel`,
      [`&#x1F3A2`]: `Roller Coaster`,
      [`&#x1F488`]: `Barber Pole`,
      [`&#x1F3AA`]: `Circus Tent`,
      [`&#x1F3AD`]: `Performing Arts`,
      [`&#x1F5BC`]: `Framed Picture`,
      [`&#x1F3A8`]: `Artist Palette`,
      [`&#x1F3B0`]: `Slot Machine`,
      [`&#x1F682`]: `Locomotive`,
      [`&#x1F683`]: `Railway Car`,
      [`&#x1F684`]: `High-Speed Train`,
      [`&#x1F685`]: `High-Speed Train With Bullet Nose`,
      [`&#x1F686`]: `Train`,
      [`&#x1F687`]: `Metro`,
      [`&#x1F688`]: `Light Rail`,
      [`&#x1F689`]: `Station`,
      [`&#x1F68A`]: `Tram`,
      [`&#x1F69D`]: `Monorail`,
      [`&#x1F69E`]: `Mountain Railway`,
      [`&#x1F68B`]: `Tram Car`,
      [`&#x1F68C`]: `Bus`,
      [`&#x1F68D`]: `Oncoming Bus`,
      [`&#x1F68E`]: `Trolleybus`,
      [`&#x1F690`]: `Minibus`,
      [`&#x1F691`]: `Ambulance`,
      [`&#x1F692`]: `Fire Engine`,
      [`&#x1F693`]: `Police Car`,
      [`&#x1F694`]: `Oncoming Police Car`,
      [`&#x1F695`]: `Taxi`,
      [`&#x1F696`]: `Oncoming Taxi`,
      [`&#x1F697`]: `Automobile`,
      [`&#x1F698`]: `Oncoming Automobile`,
      [`&#x1F699`]: `Sport Utility Vehicle`,
      [`&#x1F69A`]: `Delivery Truck`,
      [`&#x1F69B`]: `Articulated Lorry`,
      [`&#x1F69C`]: `Tractor`,
      [`&#x1F6B2`]: `Bicycle`,
      [`&#x1F6F4`]: `Kick Scooter`,
      [`&#x1F6F5`]: `Motor Scooter`,
      [`&#x1F68F`]: `Bus Stop`,
      [`&#x1F6E3`]: `Motorway`,
      [`&#x1F6E4`]: `Railway Track`,
      [`&#x26FD`]: `Fuel Pump`,
      [`&#x1F6A8`]: `Police Car Light`,
      [`&#x1F6A5`]: `Horizontal Traffic Light`,
      [`&#x1F6A6`]: `Vertical Traffic Light`,
      [`&#x1F6A7`]: `Construction`,
      [`&#x1F6D1`]: `Stop Sign`,
      [`&#x2693`]: `Anchor`,
      [`&#x26F5`]: `Sailboat`,
      [`&#x1F6F6`]: `Canoe`,
      [`&#x1F6A4`]: `Speedboat`,
      [`&#x1F6F3`]: `Passenger Ship`,
      [`&#x26F4`]: `Ferry`,
      [`&#x1F6E5`]: `Motor Boat`,
      [`&#x1F6A2`]: `Ship`,
      [`&#x2708`]: `Airplane`,
      [`&#x1F6E9`]: `Small Airplane`,
      [`&#x1F6EB`]: `Airplane Departure`,
      [`&#x1F6EC`]: `Airplane Arrival`,
      [`&#x1F4BA`]: `Seat`,
      [`&#x1F681`]: `Helicopter`,
      [`&#x1F69F`]: `Suspension Railway`,
      [`&#x1F6A0`]: `Mountain Cableway`,
      [`&#x1F6A1`]: `Aerial Tramway`,
      [`&#x1F680`]: `Rocket`,
      [`&#x1F6F0`]: `Satellite`,
      [`&#x1F6CE`]: `Bellhop Bell`,
      [`&#x1F6AA`]: `Door`,
      [`&#x1F6CC`]: `Person In Bed`,
      [`&#x1F6CC&#x1F3FB`]: `Person In Bed: Light Skin Tone`,
      [`&#x1F6CC&#x1F3FC`]: `Person In Bed: Medium-Light Skin Tone`,
      [`&#x1F6CC&#x1F3FD`]: `Person In Bed: Medium Skin Tone`,
      [`&#x1F6CC&#x1F3FE`]: `Person In Bed: Medium-Dark Skin Tone`,
      [`&#x1F6CC&#x1F3FF`]: `Person In Bed: Dark Skin Tone`,
      [`&#x1F6CF`]: `Bed`,
      [`&#x1F6CB`]: `Couch And Lamp`,
      [`&#x1F6BD`]: `Toilet`,
      [`&#x1F6BF`]: `Shower`,
      [`&#x1F6C0`]: `Person Taking Bath`,
      [`&#x1F6C0&#x1F3FB`]: `Person Taking Bath: Light Skin Tone`,
      [`&#x1F6C0&#x1F3FC`]: `Person Taking Bath: Medium-Light Skin Tone`,
      [`&#x1F6C0&#x1F3FD`]: `Person Taking Bath: Medium Skin Tone`,
      [`&#x1F6C0&#x1F3FE`]: `Person Taking Bath: Medium-Dark Skin Tone`,
      [`&#x1F6C0&#x1F3FF`]: `Person Taking Bath: Dark Skin Tone`,
      [`&#x1F6C1`]: `Bathtub`,
      [`&#x231B`]: `Hourglass`,
      [`&#x23F3`]: `Hourglass With Flowing Sand`,
      [`&#x231A`]: `Watch`,
      [`&#x23F0`]: `Alarm Clock`,
      [`&#x23F1`]: `Stopwatch`,
      [`&#x23F2`]: `Timer Clock`,
      [`&#x1F570`]: `Mantelpiece Clock`,
      [`&#x1F55B`]: `Twelve O’clock`,
      [`&#x1F567`]: `Twelve-Thirty`,
      [`&#x1F550`]: `One O’clock`,
      [`&#x1F55C`]: `One-Thirty`,
      [`&#x1F551`]: `Two O’clock`,
      [`&#x1F55D`]: `Two-Thirty`,
      [`&#x1F552`]: `Three O’clock`,
      [`&#x1F55E`]: `Three-Thirty`,
      [`&#x1F553`]: `Four O’clock`,
      [`&#x1F55F`]: `Four-Thirty`,
      [`&#x1F554`]: `Five O’clock`,
      [`&#x1F560`]: `Five-Thirty`,
      [`&#x1F555`]: `Six O’clock`,
      [`&#x1F561`]: `Six-Thirty`,
      [`&#x1F556`]: `Seven O’clock`,
      [`&#x1F562`]: `Seven-Thirty`,
      [`&#x1F557`]: `Eight O’clock`,
      [`&#x1F563`]: `Eight-Thirty`,
      [`&#x1F558`]: `Nine O’clock`,
      [`&#x1F564`]: `Nine-Thirty`,
      [`&#x1F559`]: `Ten O’clock`,
      [`&#x1F565`]: `Ten-Thirty`,
      [`&#x1F55A`]: `Eleven O’clock`,
      [`&#x1F566`]: `Eleven-Thirty`,
      [`&#x1F311`]: `New Moon`,
      [`&#x1F312`]: `Waxing Crescent Moon`,
      [`&#x1F313`]: `First Quarter Moon`,
      [`&#x1F314`]: `Waxing Gibbous Moon`,
      [`&#x1F315`]: `Full Moon`,
      [`&#x1F316`]: `Waning Gibbous Moon`,
      [`&#x1F317`]: `Last Quarter Moon`,
      [`&#x1F318`]: `Waning Crescent Moon`,
      [`&#x1F319`]: `Crescent Moon`,
      [`&#x1F31A`]: `New Moon Face`,
      [`&#x1F31B`]: `First Quarter Moon With Face`,
      [`&#x1F31C`]: `Last Quarter Moon With Face`,
      [`&#x1F321`]: `Thermometer`,
      [`&#x2600`]: `Sun`,
      [`&#x1F31D`]: `Full Moon With Face`,
      [`&#x1F31E`]: `Sun With Face`,
      [`&#x2B50`]: `White Medium Star`,
      [`&#x1F31F`]: `Glowing Star`,
      [`&#x1F320`]: `Shooting Star`,
      [`&#x2601`]: `Cloud`,
      [`&#x26C5`]: `Sun Behind Cloud`,
      [`&#x26C8`]: `Cloud With Lightning And Rain`,
      [`&#x1F324`]: `Sun Behind Small Cloud`,
      [`&#x1F325`]: `Sun Behind Large Cloud`,
      [`&#x1F326`]: `Sun Behind Rain Cloud`,
      [`&#x1F327`]: `Cloud With Rain`,
      [`&#x1F328`]: `Cloud With Snow`,
      [`&#x1F329`]: `Cloud With Lightning`,
      [`&#x1F32A`]: `Tornado`,
      [`&#x1F32B`]: `Fog`,
      [`&#x1F32C`]: `Wind Face`,
      [`&#x1F300`]: `Cyclone`,
      [`&#x1F308`]: `Rainbow`,
      [`&#x1F302`]: `Closed Umbrella`,
      [`&#x2602`]: `Umbrella`,
      [`&#x2614`]: `Umbrella With Rain Drops`,
      [`&#x26F1`]: `Umbrella On Ground`,
      [`&#x26A1`]: `High Voltage`,
      [`&#x2744`]: `Snowflake`,
      [`&#x2603`]: `Snowman`,
      [`&#x26C4`]: `Snowman Without Snow`,
      [`&#x2604`]: `Comet`,
      [`&#x1F525`]: `Fire`,
      [`&#x1F4A7`]: `Droplet`,
      [`&#x1F30A`]: `Water Wave`,
      [`&#x1F383`]: `Jack-O-Lantern`,
      [`&#x1F384`]: `Christmas Tree`,
      [`&#x1F386`]: `Fireworks`,
      [`&#x1F387`]: `Sparkler`,
      [`&#x2728`]: `Sparkles`,
      [`&#x1F388`]: `Balloon`,
      [`&#x1F389`]: `Party Popper`,
      [`&#x1F38A`]: `Confetti Ball`,
      [`&#x1F38B`]: `Tanabata Tree`,
      [`&#x1F38D`]: `Pine Decoration`,
      [`&#x1F38E`]: `Japanese Dolls`,
      [`&#x1F38F`]: `Carp Streamer`,
      [`&#x1F390`]: `Wind Chime`,
      [`&#x1F391`]: `Moon Viewing Ceremony`,
      [`&#x1F380`]: `Ribbon`,
      [`&#x1F381`]: `Wrapped Gift`,
      [`&#x1F397`]: `Reminder Ribbon`,
      [`&#x1F39F`]: `Admission Tickets`,
      [`&#x1F3AB`]: `Ticket`,
      [`&#x1F396`]: `Military Medal`,
      [`&#x1F3C6`]: `Trophy`,
      [`&#x1F3C5`]: `Sports Medal`,
      [`&#x1F947`]: `1st Place Medal`,
      [`&#x1F948`]: `2nd Place Medal`,
      [`&#x1F949`]: `3rd Place Medal`,
      [`&#x26BD`]: `Soccer Ball`,
      [`&#x26BE`]: `Baseball`,
      [`&#x1F3C0`]: `Basketball`,
      [`&#x1F3D0`]: `Volleyball`,
      [`&#x1F3C8`]: `American Football`,
      [`&#x1F3C9`]: `Rugby Football`,
      [`&#x1F3BE`]: `Tennis`,
      [`&#x1F3B1`]: `Pool 8 Ball`,
      [`&#x1F3B3`]: `Bowling`,
      [`&#x1F3CF`]: `Cricket`,
      [`&#x1F3D1`]: `Field Hockey`,
      [`&#x1F3D2`]: `Ice Hockey`,
      [`&#x1F3D3`]: `Ping Pong`,
      [`&#x1F3F8`]: `Badminton`,
      [`&#x1F94A`]: `Boxing Glove`,
      [`&#x1F94B`]: `Martial Arts Uniform`,
      [`&#x1F945`]: `Goal Net`,
      [`&#x1F3AF`]: `Direct Hit`,
      [`&#x26F3`]: `Flag In Hole`,
      [`&#x26F8`]: `Ice Skate`,
      [`&#x1F3A3`]: `Fishing Pole`,
      [`&#x1F3BD`]: `Running Shirt`,
      [`&#x1F3BF`]: `Skis`,
      [`&#x1F3AE`]: `Video Game`,
      [`&#x1F579`]: `Joystick`,
      [`&#x1F3B2`]: `Game Die`,
      [`&#x2660`]: `Spade Suit`,
      [`&#x2665`]: `Heart Suit`,
      [`&#x2666`]: `Diamond Suit`,
      [`&#x2663`]: `Club Suit`,
      [`&#x1F0CF`]: `Joker`,
      [`&#x1F004`]: `Mahjong Red Dragon`,
      [`&#x1F3B4`]: `Flower Playing Cards`,
      [`&#x1F507`]: `Muted Speaker`,
      [`&#x1F508`]: `Speaker Low Volume`,
      [`&#x1F509`]: `Speaker Medium Volume`,
      [`&#x1F50A`]: `Speaker High Volume`,
      [`&#x1F4E2`]: `Loudspeaker`,
      [`&#x1F4E3`]: `Megaphone`,
      [`&#x1F4EF`]: `Postal Horn`,
      [`&#x1F514`]: `Bell`,
      [`&#x1F515`]: `Bell With Slash`,
      [`&#x1F3BC`]: `Musical Score`,
      [`&#x1F3B5`]: `Musical Note`,
      [`&#x1F3B6`]: `Musical Notes`,
      [`&#x1F399`]: `Studio Microphone`,
      [`&#x1F39A`]: `Level Slider`,
      [`&#x1F39B`]: `Control Knobs`,
      [`&#x1F3A4`]: `Microphone`,
      [`&#x1F3A7`]: `Headphone`,
      [`&#x1F4FB`]: `Radio`,
      [`&#x1F3B7`]: `Saxophone`,
      [`&#x1F3B8`]: `Guitar`,
      [`&#x1F3B9`]: `Musical Keyboard`,
      [`&#x1F3BA`]: `Trumpet`,
      [`&#x1F3BB`]: `Violin`,
      [`&#x1F941`]: `Drum`,
      [`&#x1F4F1`]: `Mobile Phone`,
      [`&#x1F4F2`]: `Mobile Phone With Arrow`,
      [`&#x260E`]: `Telephone`,
      [`&#x1F4DE`]: `Telephone Receiver`,
      [`&#x1F4DF`]: `Pager`,
      [`&#x1F4E0`]: `Fax Machine`,
      [`&#x1F50B`]: `Battery`,
      [`&#x1F50C`]: `Electric Plug`,
      [`&#x1F4BB`]: `Laptop Computer`,
      [`&#x1F5A5`]: `Desktop Computer`,
      [`&#x1F5A8`]: `Printer`,
      [`&#x2328`]: `Keyboard`,
      [`&#x1F5B1`]: `Computer Mouse`,
      [`&#x1F5B2`]: `Trackball`,
      [`&#x1F4BD`]: `Computer Disk`,
      [`&#x1F4BE`]: `Floppy Disk`,
      [`&#x1F4BF`]: `Optical Disk`,
      [`&#x1F4C0`]: `Dvd`,
      [`&#x1F3A5`]: `Movie Camera`,
      [`&#x1F39E`]: `Film Frames`,
      [`&#x1F4FD`]: `Film Projector`,
      [`&#x1F3AC`]: `Clapper Board`,
      [`&#x1F4FA`]: `Television`,
      [`&#x1F4F7`]: `Camera`,
      [`&#x1F4F8`]: `Camera With Flash`,
      [`&#x1F4F9`]: `Video Camera`,
      [`&#x1F4FC`]: `Videocassette`,
      [`&#x1F50D`]: `Left-Pointing Magnifying Glass`,
      [`&#x1F50E`]: `Right-Pointing Magnifying Glass`,
      [`&#x1F52C`]: `Microscope`,
      [`&#x1F52D`]: `Telescope`,
      [`&#x1F4E1`]: `Satellite Antenna`,
      [`&#x1F56F`]: `Candle`,
      [`&#x1F4A1`]: `Light Bulb`,
      [`&#x1F526`]: `Flashlight`,
      [`&#x1F3EE`]: `Red Paper Lantern`,
      [`&#x1F4D4`]: `Notebook With Decorative Cover`,
      [`&#x1F4D5`]: `Closed Book`,
      [`&#x1F4D6`]: `Open Book`,
      [`&#x1F4D7`]: `Green Book`,
      [`&#x1F4D8`]: `Blue Book`,
      [`&#x1F4D9`]: `Orange Book`,
      [`&#x1F4DA`]: `Books`,
      [`&#x1F4D3`]: `Notebook`,
      [`&#x1F4D2`]: `Ledger`,
      [`&#x1F4C3`]: `Page With Curl`,
      [`&#x1F4DC`]: `Scroll`,
      [`&#x1F4C4`]: `Page Facing Up`,
      [`&#x1F4F0`]: `Newspaper`,
      [`&#x1F5DE`]: `Rolled-Up Newspaper`,
      [`&#x1F4D1`]: `Bookmark Tabs`,
      [`&#x1F516`]: `Bookmark`,
      [`&#x1F3F7`]: `Label`,
      [`&#x1F4B0`]: `Money Bag`,
      [`&#x1F4B4`]: `Yen Banknote`,
      [`&#x1F4B5`]: `Dollar Banknote`,
      [`&#x1F4B6`]: `Euro Banknote`,
      [`&#x1F4B7`]: `Pound Banknote`,
      [`&#x1F4B8`]: `Money With Wings`,
      [`&#x1F4B3`]: `Credit Card`,
      [`&#x1F4B9`]: `Chart Increasing With Yen`,
      [`&#x1F4B1`]: `Currency Exchange`,
      [`&#x1F4B2`]: `Heavy Dollar Sign`,
      [`&#x2709`]: `Envelope`,
      [`&#x1F4E7`]: `E-Mail`,
      [`&#x1F4E8`]: `Incoming Envelope`,
      [`&#x1F4E9`]: `Envelope With Arrow`,
      [`&#x1F4E4`]: `Outbox Tray`,
      [`&#x1F4E5`]: `Inbox Tray`,
      [`&#x1F4E6`]: `Package`,
      [`&#x1F4EB`]: `Closed Mailbox With Raised Flag`,
      [`&#x1F4EA`]: `Closed Mailbox With Lowered Flag`,
      [`&#x1F4EC`]: `Open Mailbox With Raised Flag`,
      [`&#x1F4ED`]: `Open Mailbox With Lowered Flag`,
      [`&#x1F4EE`]: `Postbox`,
      [`&#x1F5F3`]: `Ballot Box With Ballot`,
      [`&#x270F`]: `Pencil`,
      [`&#x2712`]: `Black Nib`,
      [`&#x1F58B`]: `Fountain Pen`,
      [`&#x1F58A`]: `Pen`,
      [`&#x1F58C`]: `Paintbrush`,
      [`&#x1F58D`]: `Crayon`,
      [`&#x1F4DD`]: `Memo`,
      [`&#x1F4BC`]: `Briefcase`,
      [`&#x1F4C1`]: `File Folder`,
      [`&#x1F4C2`]: `Open File Folder`,
      [`&#x1F5C2`]: `Card Index Dividers`,
      [`&#x1F4C5`]: `Calendar`,
      [`&#x1F4C6`]: `Tear-Off Calendar`,
      [`&#x1F5D2`]: `Spiral Notepad`,
      [`&#x1F5D3`]: `Spiral Calendar`,
      [`&#x1F4C7`]: `Card Index`,
      [`&#x1F4C8`]: `Chart Increasing`,
      [`&#x1F4C9`]: `Chart Decreasing`,
      [`&#x1F4CA`]: `Bar Chart`,
      [`&#x1F4CB`]: `Clipboard`,
      [`&#x1F4CC`]: `Pushpin`,
      [`&#x1F4CD`]: `Round Pushpin`,
      [`&#x1F4CE`]: `Paperclip`,
      [`&#x1F587`]: `Linked Paperclips`,
      [`&#x1F4CF`]: `Straight Ruler`,
      [`&#x1F4D0`]: `Triangular Ruler`,
      [`&#x2702`]: `Scissors`,
      [`&#x1F5C3`]: `Card File Box`,
      [`&#x1F5C4`]: `File Cabinet`,
      [`&#x1F5D1`]: `Wastebasket`,
      [`&#x1F512`]: `Locked`,
      [`&#x1F513`]: `Unlocked`,
      [`&#x1F50F`]: `Locked With Pen`,
      [`&#x1F510`]: `Locked With Key`,
      [`&#x1F511`]: `Key`,
      [`&#x1F5DD`]: `Old Key`,
      [`&#x1F528`]: `Hammer`,
      [`&#x26CF`]: `Pick`,
      [`&#x2692`]: `Hammer And Pick`,
      [`&#x1F6E0`]: `Hammer And Wrench`,
      [`&#x1F5E1`]: `Dagger`,
      [`&#x2694`]: `Crossed Swords`,
      [`&#x1F52B`]: `Pistol`,
      [`&#x1F3F9`]: `Bow And Arrow`,
      [`&#x1F6E1`]: `Shield`,
      [`&#x1F527`]: `Wrench`,
      [`&#x1F529`]: `Nut And Bolt`,
      [`&#x2699`]: `Gear`,
      [`&#x1F5DC`]: `Clamp`,
      [`&#x2697`]: `Alembic`,
      [`&#x2696`]: `Balance Scale`,
      [`&#x1F517`]: `Link`,
      [`&#x26D3`]: `Chains`,
      [`&#x1F489`]: `Syringe`,
      [`&#x1F48A`]: `Pill`,
      [`&#x1F6AC`]: `Cigarette`,
      [`&#x26B0`]: `Coffin`,
      [`&#x26B1`]: `Funeral Urn`,
      [`&#x1F5FF`]: `Moai`,
      [`&#x1F6E2`]: `Oil Drum`,
      [`&#x1F52E`]: `Crystal Ball`,
      [`&#x1F6D2`]: `Shopping Cart`,
      [`&#x1F3E7`]: `ATM Sign`,
      [`&#x1F6AE`]: `Litter In Bin Sign`,
      [`&#x1F6B0`]: `Potable Water`,
      [`&#x267F`]: `Wheelchair Symbol`,
      [`&#x1F6B9`]: `Men’s Room`,
      [`&#x1F6BA`]: `Women’s Room`,
      [`&#x1F6BB`]: `Restroom`,
      [`&#x1F6BC`]: `Baby Symbol`,
      [`&#x1F6BE`]: `Water Closet`,
      [`&#x1F6C2`]: `Passport Control`,
      [`&#x1F6C3`]: `Customs`,
      [`&#x1F6C4`]: `Baggage Claim`,
      [`&#x1F6C5`]: `Left Luggage`,
      [`&#x26A0`]: `Warning`,
      [`&#x1F6B8`]: `Children Crossing`,
      [`&#x26D4`]: `No Entry`,
      [`&#x1F6AB`]: `Prohibited`,
      [`&#x1F6B3`]: `No Bicycles`,
      [`&#x1F6AD`]: `No Smoking`,
      [`&#x1F6AF`]: `No Littering`,
      [`&#x1F6B1`]: `Non-Potable Water`,
      [`&#x1F6B7`]: `No Pedestrians`,
      [`&#x1F4F5`]: `No Mobile Phones`,
      [`&#x1F51E`]: `No One Under Eighteen`,
      [`&#x2622`]: `Radioactive`,
      [`&#x2623`]: `Biohazard`,
      [`&#x2B06`]: `Up Arrow`,
      [`&#x2197`]: `Up-Right Arrow`,
      [`&#x27A1`]: `Right Arrow`,
      [`&#x2198`]: `Down-Right Arrow`,
      [`&#x2B07`]: `Down Arrow`,
      [`&#x2199`]: `Down-Left Arrow`,
      [`&#x2B05`]: `Left Arrow`,
      [`&#x2196`]: `Up-Left Arrow`,
      [`&#x2195`]: `Up-Down Arrow`,
      [`&#x2194`]: `Left-Right Arrow`,
      [`&#x21A9`]: `Right Arrow Curving Left`,
      [`&#x21AA`]: `Left Arrow Curving Right`,
      [`&#x2934`]: `Right Arrow Curving Up`,
      [`&#x2935`]: `Right Arrow Curving Down`,
      [`&#x1F503`]: `Clockwise Vertical Arrows`,
      [`&#x1F504`]: `Anticlockwise Arrows Button`,
      [`&#x1F519`]: `BACK Arrow`,
      [`&#x1F51A`]: `END Arrow`,
      [`&#x1F51B`]: `ON! Arrow`,
      [`&#x1F51C`]: `SOON Arrow`,
      [`&#x1F51D`]: `TOP Arrow`,
      [`&#x1F6D0`]: `Place Of Worship`,
      [`&#x269B`]: `Atom Symbol`,
      [`&#x1F549`]: `Om`,
      [`&#x2721`]: `Star Of David`,
      [`&#x2638`]: `Wheel Of Dharma`,
      [`&#x262F`]: `Yin Yang`,
      [`&#x271D`]: `Latin Cross`,
      [`&#x2626`]: `Orthodox Cross`,
      [`&#x262A`]: `Star And Crescent`,
      [`&#x262E`]: `Peace Symbol`,
      [`&#x1F54E`]: `Menorah`,
      [`&#x1F52F`]: `Dotted Six-Pointed Star`,
      [`&#x2648`]: `Aries`,
      [`&#x2649`]: `Taurus`,
      [`&#x264A`]: `Gemini`,
      [`&#x264B`]: `Cancer`,
      [`&#x264C`]: `Leo`,
      [`&#x264D`]: `Virgo`,
      [`&#x264E`]: `Libra`,
      [`&#x264F`]: `Scorpius`,
      [`&#x2650`]: `Sagittarius`,
      [`&#x2651`]: `Capricorn`,
      [`&#x2652`]: `Aquarius`,
      [`&#x2653`]: `Pisces`,
      [`&#x26CE`]: `Ophiuchus`,
      [`&#x1F500`]: `Shuffle Tracks Button`,
      [`&#x1F501`]: `Repeat Button`,
      [`&#x1F502`]: `Repeat Single Button`,
      [`&#x25B6`]: `Play Button`,
      [`&#x23E9`]: `Fast-Forward Button`,
      [`&#x23ED`]: `Next Track Button`,
      [`&#x23EF`]: `Play Or Pause Button`,
      [`&#x25C0`]: `Reverse Button`,
      [`&#x23EA`]: `Fast Reverse Button`,
      [`&#x23EE`]: `Last Track Button`,
      [`&#x1F53C`]: `Up Button`,
      [`&#x23EB`]: `Fast Up Button`,
      [`&#x1F53D`]: `Down Button`,
      [`&#x23EC`]: `Fast Down Button`,
      [`&#x23F8`]: `Pause Button`,
      [`&#x23F9`]: `Stop Button`,
      [`&#x23FA`]: `Record Button`,
      [`&#x23CF`]: `Eject Button`,
      [`&#x1F3A6`]: `Cinema`,
      [`&#x1F505`]: `Dim Button`,
      [`&#x1F506`]: `Bright Button`,
      [`&#x1F4F6`]: `Antenna Bars`,
      [`&#x1F4F3`]: `Vibration Mode`,
      [`&#x1F4F4`]: `Mobile Phone Off`,
      [`&#x267B`]: `Recycling Symbol`,
      [`&#x1F4DB`]: `Name Badge`,
      [`&#x269C`]: `Fleur-De-Lis`,
      [`&#x1F530`]: `Japanese Symbol For Beginner`,
      [`&#x1F531`]: `Trident Emblem`,
      [`&#x2B55`]: `Heavy Large Circle`,
      [`&#x2705`]: `White Heavy Check Mark`,
      [`&#x2611`]: `Ballot Box With Check`,
      [`&#x2714`]: `Heavy Check Mark`,
      [`&#x2716`]: `Heavy Multiplication X`,
      [`&#x274C`]: `Cross Mark`,
      [`&#x274E`]: `Cross Mark Button`,
      [`&#x2795`]: `Heavy Plus Sign`,
      [`&#x2640`]: `Female Sign`,
      [`&#x2642`]: `Male Sign`,
      [`&#x2695`]: `Medical Symbol`,
      [`&#x2796`]: `Heavy Minus Sign`,
      [`&#x2797`]: `Heavy Division Sign`,
      [`&#x27B0`]: `Curly Loop`,
      [`&#x27BF`]: `Double Curly Loop`,
      [`&#x303D`]: `Part Alternation Mark`,
      [`&#x2733`]: `Eight-Spoked Asterisk`,
      [`&#x2734`]: `Eight-Pointed Star`,
      [`&#x2747`]: `Sparkle`,
      [`&#x203C`]: `Double Exclamation Mark`,
      [`&#x2049`]: `Exclamation Question Mark`,
      [`&#x2753`]: `Question Mark`,
      [`&#x2754`]: `White Question Mark`,
      [`&#x2755`]: `White Exclamation Mark`,
      [`&#x2757`]: `Exclamation Mark`,
      [`&#x3030`]: `Wavy Dash`,
      [`&#x00A9`]: `Copyright`,
      [`&#x00AE`]: `Registered`,
      [`&#x2122`]: `Trade Mark`,
      [`&#x0023&#xFE0F&#x20E3`]: `Keycap: #`,
      [`&#x002A&#xFE0F&#x20E3`]: `Keycap: *`,
      [`&#x0030&#xFE0F&#x20E3`]: `Keycap: 0`,
      [`&#x0031&#xFE0F&#x20E3`]: `Keycap: 1`,
      [`&#x0032&#xFE0F&#x20E3`]: `Keycap: 2`,
      [`&#x0033&#xFE0F&#x20E3`]: `Keycap: 3`,
      [`&#x0034&#xFE0F&#x20E3`]: `Keycap: 4`,
      [`&#x0035&#xFE0F&#x20E3`]: `Keycap: 5`,
      [`&#x0036&#xFE0F&#x20E3`]: `Keycap: 6`,
      [`&#x0037&#xFE0F&#x20E3`]: `Keycap: 7`,
      [`&#x0038&#xFE0F&#x20E3`]: `Keycap: 8`,
      [`&#x0039&#xFE0F&#x20E3`]: `Keycap: 9`,
      [`&#x1F51F`]: `Keycap 10`,
      [`&#x1F4AF`]: `Hundred Points`,
      [`&#x1F520`]: `Input Latin Uppercase`,
      [`&#x1F521`]: `Input Latin Lowercase`,
      [`&#x1F522`]: `Input Numbers`,
      [`&#x1F523`]: `Input Symbols`,
      [`&#x1F524`]: `Input Latin Letters`,
      [`&#x1F170`]: `A Button (blood Type)`,
      [`&#x1F18E`]: `AB Button (blood Type)`,
      [`&#x1F171`]: `B Button (blood Type)`,
      [`&#x1F191`]: `CL Button`,
      [`&#x1F192`]: `COOL Button`,
      [`&#x1F193`]: `FREE Button`,
      [`&#x2139`]: `Information`,
      [`&#x1F194`]: `ID Button`,
      [`&#x24C2`]: `Circled M`,
      [`&#x1F195`]: `NEW Button`,
      [`&#x1F196`]: `NG Button`,
      [`&#x1F17E`]: `O Button (blood Type)`,
      [`&#x1F197`]: `OK Button`,
      [`&#x1F17F`]: `P Button`,
      [`&#x1F198`]: `SOS Button`,
      [`&#x1F199`]: `UP! Button`,
      [`&#x1F19A`]: `VS Button`,
      [`&#x1F201`]: `Japanese “here” Button`,
      [`&#x1F202`]: `Japanese “service Charge” Button`,
      [`&#x1F237`]: `Japanese “monthly Amount” Button`,
      [`&#x1F236`]: `Japanese “not Free Of Charge” Button`,
      [`&#x1F22F`]: `Japanese “reserved” Button`,
      [`&#x1F250`]: `Japanese “bargain” Button`,
      [`&#x1F239`]: `Japanese “discount” Button`,
      [`&#x1F21A`]: `Japanese “free Of Charge” Button`,
      [`&#x1F232`]: `Japanese “prohibited” Button`,
      [`&#x1F251`]: `Japanese “acceptable” Button`,
      [`&#x1F238`]: `Japanese “application” Button`,
      [`&#x1F234`]: `Japanese “passing Grade” Button`,
      [`&#x1F233`]: `Japanese “vacancy” Button`,
      [`&#x3297`]: `Japanese “congratulations” Button`,
      [`&#x3299`]: `Japanese “secret” Button`,
      [`&#x1F23A`]: `Japanese “open For Business” Button`,
      [`&#x1F235`]: `Japanese “no Vacancy” Button`,
      [`&#x25AA`]: `Black Small Square`,
      [`&#x25AB`]: `White Small Square`,
      [`&#x25FB`]: `White Medium Square`,
      [`&#x25FC`]: `Black Medium Square`,
      [`&#x25FD`]: `White Medium-Small Square`,
      [`&#x25FE`]: `Black Medium-Small Square`,
      [`&#x2B1B`]: `Black Large Square`,
      [`&#x2B1C`]: `White Large Square`,
      [`&#x1F536`]: `Large Orange Diamond`,
      [`&#x1F537`]: `Large Blue Diamond`,
      [`&#x1F538`]: `Small Orange Diamond`,
      [`&#x1F539`]: `Small Blue Diamond`,
      [`&#x1F53A`]: `Red Triangle Pointed Up`,
      [`&#x1F53B`]: `Red Triangle Pointed Down`,
      [`&#x1F4A0`]: `Diamond With A Dot`,
      [`&#x1F518`]: `Radio Button`,
      [`&#x1F532`]: `Black Square Button`,
      [`&#x1F533`]: `White Square Button`,
      [`&#x26AA`]: `White Circle`,
      [`&#x26AB`]: `Black Circle`,
      [`&#x1F534`]: `Red Circle`,
      [`&#x1F535`]: `Blue Circle`,
      [`&#x1F3C1`]: `Chequered Flag`,
      [`&#x1F6A9`]: `Triangular Flag`,
      [`&#x1F38C`]: `Crossed Flags`,
      [`&#x1F3F4`]: `Black Flag`,
      [`&#x1F3F3`]: `White Flag`,
      [`&#x1F3F3&#xFE0F&#x200D&#x1F308`]: `Rainbow Flag`,
      [`&#x1F1E6&#x1F1E8`]: `Ascension Island`,
      [`&#x1F1E6&#x1F1E9`]: `Andorra`,
      [`&#x1F1E6&#x1F1EA`]: `United Arab Emirates`,
      [`&#x1F1E6&#x1F1EB`]: `Afghanistan`,
      [`&#x1F1E6&#x1F1EC`]: `Antigua & Barbuda`,
      [`&#x1F1E6&#x1F1EE`]: `Anguilla`,
      [`&#x1F1E6&#x1F1F1`]: `Albania`,
      [`&#x1F1E6&#x1F1F2`]: `Armenia`,
      [`&#x1F1E6&#x1F1F4`]: `Angola`,
      [`&#x1F1E6&#x1F1F6`]: `Antarctica`,
      [`&#x1F1E6&#x1F1F7`]: `Argentina`,
      [`&#x1F1E6&#x1F1F8`]: `American Samoa`,
      [`&#x1F1E6&#x1F1F9`]: `Austria`,
      [`&#x1F1E6&#x1F1FA`]: `Australia`,
      [`&#x1F1E6&#x1F1FC`]: `Aruba`,
      [`&#x1F1E6&#x1F1FD`]: `Åland Islands`,
      [`&#x1F1E6&#x1F1FF`]: `Azerbaijan`,
      [`&#x1F1E7&#x1F1E6`]: `Bosnia & Herzegovina`,
      [`&#x1F1E7&#x1F1E7`]: `Barbados`,
      [`&#x1F1E7&#x1F1E9`]: `Bangladesh`,
      [`&#x1F1E7&#x1F1EA`]: `Belgium`,
      [`&#x1F1E7&#x1F1EB`]: `Burkina Faso`,
      [`&#x1F1E7&#x1F1EC`]: `Bulgaria`,
      [`&#x1F1E7&#x1F1ED`]: `Bahrain`,
      [`&#x1F1E7&#x1F1EE`]: `Burundi`,
      [`&#x1F1E7&#x1F1EF`]: `Benin`,
      [`&#x1F1E7&#x1F1F1`]: `St. Barthélemy`,
      [`&#x1F1E7&#x1F1F2`]: `Bermuda`,
      [`&#x1F1E7&#x1F1F3`]: `Brunei`,
      [`&#x1F1E7&#x1F1F4`]: `Bolivia`,
      [`&#x1F1E7&#x1F1F6`]: `Caribbean Netherlands`,
      [`&#x1F1E7&#x1F1F7`]: `Brazil`,
      [`&#x1F1E7&#x1F1F8`]: `Bahamas`,
      [`&#x1F1E7&#x1F1F9`]: `Bhutan`,
      [`&#x1F1E7&#x1F1FB`]: `Bouvet Island`,
      [`&#x1F1E7&#x1F1FC`]: `Botswana`,
      [`&#x1F1E7&#x1F1FE`]: `Belarus`,
      [`&#x1F1E7&#x1F1FF`]: `Belize`,
      [`&#x1F1E8&#x1F1E6`]: `Canada`,
      [`&#x1F1E8&#x1F1E8`]: `Cocos (Keeling) Islands`,
      [`&#x1F1E8&#x1F1E9`]: `Congo - Kinshasa`,
      [`&#x1F1E8&#x1F1EB`]: `Central African Republic`,
      [`&#x1F1E8&#x1F1EC`]: `Congo - Brazzaville`,
      [`&#x1F1E8&#x1F1ED`]: `Switzerland`,
      [`&#x1F1E8&#x1F1EE`]: `Côte D’Ivoire`,
      [`&#x1F1E8&#x1F1F0`]: `Cook Islands`,
      [`&#x1F1E8&#x1F1F1`]: `Chile`,
      [`&#x1F1E8&#x1F1F2`]: `Cameroon`,
      [`&#x1F1E8&#x1F1F3`]: `China`,
      [`&#x1F1E8&#x1F1F4`]: `Colombia`,
      [`&#x1F1E8&#x1F1F5`]: `Clipperton Island`,
      [`&#x1F1E8&#x1F1F7`]: `Costa Rica`,
      [`&#x1F1E8&#x1F1FA`]: `Cuba`,
      [`&#x1F1E8&#x1F1FB`]: `Cape Verde`,
      [`&#x1F1E8&#x1F1FC`]: `Curaçao`,
      [`&#x1F1E8&#x1F1FD`]: `Christmas Island`,
      [`&#x1F1E8&#x1F1FE`]: `Cyprus`,
      [`&#x1F1E8&#x1F1FF`]: `Czech Republic`,
      [`&#x1F1E9&#x1F1EA`]: `Germany`,
      [`&#x1F1E9&#x1F1EC`]: `Diego Garcia`,
      [`&#x1F1E9&#x1F1EF`]: `Djibouti`,
      [`&#x1F1E9&#x1F1F0`]: `Denmark`,
      [`&#x1F1E9&#x1F1F2`]: `Dominica`,
      [`&#x1F1E9&#x1F1F4`]: `Dominican Republic`,
      [`&#x1F1E9&#x1F1FF`]: `Algeria`,
      [`&#x1F1EA&#x1F1E6`]: `Ceuta & Melilla`,
      [`&#x1F1EA&#x1F1E8`]: `Ecuador`,
      [`&#x1F1EA&#x1F1EA`]: `Estonia`,
      [`&#x1F1EA&#x1F1EC`]: `Egypt`,
      [`&#x1F1EA&#x1F1ED`]: `Western Sahara`,
      [`&#x1F1EA&#x1F1F7`]: `Eritrea`,
      [`&#x1F1EA&#x1F1F8`]: `Spain`,
      [`&#x1F1EA&#x1F1F9`]: `Ethiopia`,
      [`&#x1F1EA&#x1F1FA`]: `European Union`,
      [`&#x1F1EB&#x1F1EE`]: `Finland`,
      [`&#x1F1EB&#x1F1EF`]: `Fiji`,
      [`&#x1F1EB&#x1F1F0`]: `Falkland Islands`,
      [`&#x1F1EB&#x1F1F2`]: `Micronesia`,
      [`&#x1F1EB&#x1F1F4`]: `Faroe Islands`,
      [`&#x1F1EB&#x1F1F7`]: `France`,
      [`&#x1F1EC&#x1F1E6`]: `Gabon`,
      [`&#x1F1EC&#x1F1E7`]: `United Kingdom`,
      [`&#x1F1EC&#x1F1E9`]: `Grenada`,
      [`&#x1F1EC&#x1F1EA`]: `Georgia`,
      [`&#x1F1EC&#x1F1EB`]: `French Guiana`,
      [`&#x1F1EC&#x1F1EC`]: `Guernsey`,
      [`&#x1F1EC&#x1F1ED`]: `Ghana`,
      [`&#x1F1EC&#x1F1EE`]: `Gibraltar`,
      [`&#x1F1EC&#x1F1F1`]: `Greenland`,
      [`&#x1F1EC&#x1F1F2`]: `Gambia`,
      [`&#x1F1EC&#x1F1F3`]: `Guinea`,
      [`&#x1F1EC&#x1F1F5`]: `Guadeloupe`,
      [`&#x1F1EC&#x1F1F6`]: `Equatorial Guinea`,
      [`&#x1F1EC&#x1F1F7`]: `Greece`,
      [`&#x1F1EC&#x1F1F8`]: `South Georgia & South Sandwich Islands`,
      [`&#x1F1EC&#x1F1F9`]: `Guatemala`,
      [`&#x1F1EC&#x1F1FA`]: `Guam`,
      [`&#x1F1EC&#x1F1FC`]: `Guinea-Bissau`,
      [`&#x1F1EC&#x1F1FE`]: `Guyana`,
      [`&#x1F1ED&#x1F1F0`]: `Hong Kong SAR China`,
      [`&#x1F1ED&#x1F1F2`]: `Heard & McDonald Islands`,
      [`&#x1F1ED&#x1F1F3`]: `Honduras`,
      [`&#x1F1ED&#x1F1F7`]: `Croatia`,
      [`&#x1F1ED&#x1F1F9`]: `Haiti`,
      [`&#x1F1ED&#x1F1FA`]: `Hungary`,
      [`&#x1F1EE&#x1F1E8`]: `Canary Islands`,
      [`&#x1F1EE&#x1F1E9`]: `Indonesia`,
      [`&#x1F1EE&#x1F1EA`]: `Ireland`,
      [`&#x1F1EE&#x1F1F1`]: `Israel`,
      [`&#x1F1EE&#x1F1F2`]: `Isle Of Man`,
      [`&#x1F1EE&#x1F1F3`]: `India`,
      [`&#x1F1EE&#x1F1F4`]: `British Indian Ocean Territory`,
      [`&#x1F1EE&#x1F1F6`]: `Iraq`,
      [`&#x1F1EE&#x1F1F7`]: `Iran`,
      [`&#x1F1EE&#x1F1F8`]: `Iceland`,
      [`&#x1F1EE&#x1F1F9`]: `Italy`,
      [`&#x1F1EF&#x1F1EA`]: `Jersey`,
      [`&#x1F1EF&#x1F1F2`]: `Jamaica`,
      [`&#x1F1EF&#x1F1F4`]: `Jordan`,
      [`&#x1F1EF&#x1F1F5`]: `Japan`,
      [`&#x1F1F0&#x1F1EA`]: `Kenya`,
      [`&#x1F1F0&#x1F1EC`]: `Kyrgyzstan`,
      [`&#x1F1F0&#x1F1ED`]: `Cambodia`,
      [`&#x1F1F0&#x1F1EE`]: `Kiribati`,
      [`&#x1F1F0&#x1F1F2`]: `Comoros`,
      [`&#x1F1F0&#x1F1F3`]: `St. Kitts & Nevis`,
      [`&#x1F1F0&#x1F1F5`]: `North Korea`,
      [`&#x1F1F0&#x1F1F7`]: `South Korea`,
      [`&#x1F1F0&#x1F1FC`]: `Kuwait`,
      [`&#x1F1F0&#x1F1FE`]: `Cayman Islands`,
      [`&#x1F1F0&#x1F1FF`]: `Kazakhstan`,
      [`&#x1F1F1&#x1F1E6`]: `Laos`,
      [`&#x1F1F1&#x1F1E7`]: `Lebanon`,
      [`&#x1F1F1&#x1F1E8`]: `St. Lucia`,
      [`&#x1F1F1&#x1F1EE`]: `Liechtenstein`,
      [`&#x1F1F1&#x1F1F0`]: `Sri Lanka`,
      [`&#x1F1F1&#x1F1F7`]: `Liberia`,
      [`&#x1F1F1&#x1F1F8`]: `Lesotho`,
      [`&#x1F1F1&#x1F1F9`]: `Lithuania`,
      [`&#x1F1F1&#x1F1FA`]: `Luxembourg`,
      [`&#x1F1F1&#x1F1FB`]: `Latvia`,
      [`&#x1F1F1&#x1F1FE`]: `Libya`,
      [`&#x1F1F2&#x1F1E6`]: `Morocco`,
      [`&#x1F1F2&#x1F1E8`]: `Monaco`,
      [`&#x1F1F2&#x1F1E9`]: `Moldova`,
      [`&#x1F1F2&#x1F1EA`]: `Montenegro`,
      [`&#x1F1F2&#x1F1EB`]: `St. Martin`,
      [`&#x1F1F2&#x1F1EC`]: `Madagascar`,
      [`&#x1F1F2&#x1F1ED`]: `Marshall Islands`,
      [`&#x1F1F2&#x1F1F0`]: `Macedonia`,
      [`&#x1F1F2&#x1F1F1`]: `Mali`,
      [`&#x1F1F2&#x1F1F2`]: `Myanmar (Burma)`,
      [`&#x1F1F2&#x1F1F3`]: `Mongolia`,
      [`&#x1F1F2&#x1F1F4`]: `Macau SAR China`,
      [`&#x1F1F2&#x1F1F5`]: `Northern Mariana Islands`,
      [`&#x1F1F2&#x1F1F6`]: `Martinique`,
      [`&#x1F1F2&#x1F1F7`]: `Mauritania`,
      [`&#x1F1F2&#x1F1F8`]: `Montserrat`,
      [`&#x1F1F2&#x1F1F9`]: `Malta`,
      [`&#x1F1F2&#x1F1FA`]: `Mauritius`,
      [`&#x1F1F2&#x1F1FB`]: `Maldives`,
      [`&#x1F1F2&#x1F1FC`]: `Malawi`,
      [`&#x1F1F2&#x1F1FD`]: `Mexico`,
      [`&#x1F1F2&#x1F1FE`]: `Malaysia`,
      [`&#x1F1F2&#x1F1FF`]: `Mozambique`,
      [`&#x1F1F3&#x1F1E6`]: `Namibia`,
      [`&#x1F1F3&#x1F1E8`]: `New Caledonia`,
      [`&#x1F1F3&#x1F1EA`]: `Niger`,
      [`&#x1F1F3&#x1F1EB`]: `Norfolk Island`,
      [`&#x1F1F3&#x1F1EC`]: `Nigeria`,
      [`&#x1F1F3&#x1F1EE`]: `Nicaragua`,
      [`&#x1F1F3&#x1F1F1`]: `Netherlands`,
      [`&#x1F1F3&#x1F1F4`]: `Norway`,
      [`&#x1F1F3&#x1F1F5`]: `Nepal`,
      [`&#x1F1F3&#x1F1F7`]: `Nauru`,
      [`&#x1F1F3&#x1F1FA`]: `Niue`,
      [`&#x1F1F3&#x1F1FF`]: `New Zealand`,
      [`&#x1F1F4&#x1F1F2`]: `Oman`,
      [`&#x1F1F5&#x1F1E6`]: `Panama`,
      [`&#x1F1F5&#x1F1EA`]: `Peru`,
      [`&#x1F1F5&#x1F1EB`]: `French Polynesia`,
      [`&#x1F1F5&#x1F1EC`]: `Papua New Guinea`,
      [`&#x1F1F5&#x1F1ED`]: `Philippines`,
      [`&#x1F1F5&#x1F1F0`]: `Pakistan`,
      [`&#x1F1F5&#x1F1F1`]: `Poland`,
      [`&#x1F1F5&#x1F1F2`]: `St. Pierre & Miquelon`,
      [`&#x1F1F5&#x1F1F3`]: `Pitcairn Islands`,
      [`&#x1F1F5&#x1F1F7`]: `Puerto Rico`,
      [`&#x1F1F5&#x1F1F8`]: `Palestinian Territories`,
      [`&#x1F1F5&#x1F1F9`]: `Portugal`,
      [`&#x1F1F5&#x1F1FC`]: `Palau`,
      [`&#x1F1F5&#x1F1FE`]: `Paraguay`,
      [`&#x1F1F6&#x1F1E6`]: `Qatar`,
      [`&#x1F1F7&#x1F1EA`]: `Réunion`,
      [`&#x1F1F7&#x1F1F4`]: `Romania`,
      [`&#x1F1F7&#x1F1F8`]: `Serbia`,
      [`&#x1F1F7&#x1F1FA`]: `Russia`,
      [`&#x1F1F7&#x1F1FC`]: `Rwanda`,
      [`&#x1F1F8&#x1F1E6`]: `Saudi Arabia`,
      [`&#x1F1F8&#x1F1E7`]: `Solomon Islands`,
      [`&#x1F1F8&#x1F1E8`]: `Seychelles`,
      [`&#x1F1F8&#x1F1E9`]: `Sudan`,
      [`&#x1F1F8&#x1F1EA`]: `Sweden`,
      [`&#x1F1F8&#x1F1EC`]: `Singapore`,
      [`&#x1F1F8&#x1F1ED`]: `St. Helena`,
      [`&#x1F1F8&#x1F1EE`]: `Slovenia`,
      [`&#x1F1F8&#x1F1EF`]: `Svalbard & Jan Mayen`,
      [`&#x1F1F8&#x1F1F0`]: `Slovakia`,
      [`&#x1F1F8&#x1F1F1`]: `Sierra Leone`,
      [`&#x1F1F8&#x1F1F2`]: `San Marino`,
      [`&#x1F1F8&#x1F1F3`]: `Senegal`,
      [`&#x1F1F8&#x1F1F4`]: `Somalia`,
      [`&#x1F1F8&#x1F1F7`]: `Suriname`,
      [`&#x1F1F8&#x1F1F8`]: `South Sudan`,
      [`&#x1F1F8&#x1F1F9`]: `São Tomé & Príncipe`,
      [`&#x1F1F8&#x1F1FB`]: `El Salvador`,
      [`&#x1F1F8&#x1F1FD`]: `Sint Maarten`,
      [`&#x1F1F8&#x1F1FE`]: `Syria`,
      [`&#x1F1F8&#x1F1FF`]: `Swaziland`,
      [`&#x1F1F9&#x1F1E6`]: `Tristan Da Cunha`,
      [`&#x1F1F9&#x1F1E8`]: `Turks & Caicos Islands`,
      [`&#x1F1F9&#x1F1E9`]: `Chad`,
      [`&#x1F1F9&#x1F1EB`]: `French Southern Territories`,
      [`&#x1F1F9&#x1F1EC`]: `Togo`,
      [`&#x1F1F9&#x1F1ED`]: `Thailand`,
      [`&#x1F1F9&#x1F1EF`]: `Tajikistan`,
      [`&#x1F1F9&#x1F1F0`]: `Tokelau`,
      [`&#x1F1F9&#x1F1F1`]: `Timor-Leste`,
      [`&#x1F1F9&#x1F1F2`]: `Turkmenistan`,
      [`&#x1F1F9&#x1F1F3`]: `Tunisia`,
      [`&#x1F1F9&#x1F1F4`]: `Tonga`,
      [`&#x1F1F9&#x1F1F7`]: `Turkey`,
      [`&#x1F1F9&#x1F1F9`]: `Trinidad & Tobago`,
      [`&#x1F1F9&#x1F1FB`]: `Tuvalu`,
      [`&#x1F1F9&#x1F1FC`]: `Taiwan`,
      [`&#x1F1F9&#x1F1FF`]: `Tanzania`,
      [`&#x1F1FA&#x1F1E6`]: `Ukraine`,
      [`&#x1F1FA&#x1F1EC`]: `Uganda`,
      [`&#x1F1FA&#x1F1F2`]: `U.S. Outlying Islands`,
      [`&#x1F1FA&#x1F1F3`]: `United Nations`,
      [`&#x1F1FA&#x1F1F8`]: `United States`,
      [`&#x1F1FA&#x1F1FE`]: `Uruguay`,
      [`&#x1F1FA&#x1F1FF`]: `Uzbekistan`,
      [`&#x1F1FB&#x1F1E6`]: `Vatican City`,
      [`&#x1F1FB&#x1F1E8`]: `St. Vincent & Grenadines`,
      [`&#x1F1FB&#x1F1EA`]: `Venezuela`,
      [`&#x1F1FB&#x1F1EC`]: `British Virgin Islands`,
      [`&#x1F1FB&#x1F1EE`]: `U.S. Virgin Islands`,
      [`&#x1F1FB&#x1F1F3`]: `Vietnam`,
      [`&#x1F1FB&#x1F1FA`]: `Vanuatu`,
      [`&#x1F1FC&#x1F1EB`]: `Wallis & Futuna`,
      [`&#x1F1FC&#x1F1F8`]: `Samoa`,
      [`&#x1F1FD&#x1F1F0`]: `Kosovo`,
      [`&#x1F1FE&#x1F1EA`]: `Yemen`,
      [`&#x1F1FE&#x1F1F9`]: `Mayotte`,
      [`&#x1F1FF&#x1F1E6`]: `South Africa`,
      [`&#x1F1FF&#x1F1F2`]: `Zambia`
    };
  }

  async function cfh_getEmojis() {
    return JSON.parse(await getValue(`emojis`, `[]`)).map(
      emoji => `
        <span data-id="${encodeURIComponent(emoji)}" title="${esgst.cfhEmojis[emoji]}">${emoji}</span>
      `
    ).join(``);
  }

  function cfh_setTextAreas(context, main, source, endless) {
    const elements = context.querySelectorAll(`${endless ? `.esgst-es-page-${endless} textarea[name*="description"], .esgst-es-page-${endless}textarea[name*="description"]` : `textarea[name*="description"]`}`);
    for (let i = elements.length - 1; i > -1; --i) {
      elements[i].onfocus = cfh_addPanel.bind(null, elements[i]);
    }
  }

  function cfh_addPanel(textArea) {
    if (textArea === esgst.cfh.textArea) return;

    const isNotMain = textArea.closest(`.esgst-popup, .esgst-popout`);
    if (isNotMain) {
      esgst.cfh.panel.style.top = `0px`;
    } else {
      esgst.cfh.panel.style.top = `${esgst.commentsTop}px`;
    }

    textArea.parentElement.insertBefore(esgst.cfh.panel, textArea);
    textArea.onfocus = cfh_addPanel.bind(null, textArea);
    textArea.onpaste = event => {
      if (esgst.cfh_pasteFormatting) {
        let clipboard, value;
        clipboard = event.clipboardData.getData(`text/plain`);
        if (clipboard.match(/^https?:/)) {
          event.preventDefault();
          value = textArea.value;
          cfh_undo(textArea, `${value.slice(0, textArea.selectionStart)}${clipboard}${value.slice(textArea.selectionEnd)}`);
          cfh_formatLink(``, clipboard, clipboard.match(/\.(jpg|jpeg|gif|bmp|png)/), true);
        }
      }
    };
    textArea.onkeydown = event => {
      if (event.key === `Backspace` && esgst.cfh.recent) {
        event.preventDefault();
        esgst.cfh.undo.click();
      }
      esgst.cfh.recent = false;
      if (!event.ctrlKey) {
        return;
      }
      if (event.key === `y` && (esgst.cfh.backup.length || esgst.cfh.history.length)) {
        event.preventDefault();
        esgst.cfh.redo.click();
      } else if (event.key === `z` && esgst.cfh.history.length) {
        event.preventDefault();
        esgst.cfh.undo.click();
      }
    };
    if (esgst.cfh_p) {
      esgst.cfh.preview.innerHTML = ``;
      textArea.parentElement.insertBefore(esgst.cfh.preview, textArea.nextElementSibling);
      if (esgst.cfh_p_a) {
        textArea.oninput = () => {
          esgst.cfh.preview.innerHTML = parseMarkdown(textArea.value);
          cfh_formatImages(esgst.cfh.preview);
        };
      }
    }
    esgst.cfh.textArea = textArea;
  }

  function cfh_undo(textArea, value) {
    esgst.cfh.history.push(value);
    esgst.cfh.undo.classList.remove(`esgst-faded`);
  }

  function cfh_redo(textArea, value) {
    esgst.cfh.backup.push(value);
    esgst.cfh.redo.classList.remove(`esgst-faded`);
  }

  function cfh_formatItem(prefix = ``, suffix = ``, multiline) {
    let end, n, range, start, text, value;
    value = esgst.cfh.textArea.value;
    cfh_undo(esgst.cfh.textArea, value);
    start = esgst.cfh.textArea.selectionStart;
    end = esgst.cfh.textArea.selectionEnd;
    text = value.slice(start, end);
    range = text.length;
    if (multiline) {
      n = 0;
      text = text.replace(/^|\n/g, match => {
        return `${match}${prefix.replace(/\[n\]/, ++n)}`;
      });
    } else {
      text = `${prefix}${text}${suffix}`;
    }
    range += range > 0 ? start + text.length - range : start + text.length - range - suffix.length;
    esgst.cfh.textArea.value = `${value.slice(0, start)}${text}${value.slice(end)}`;
    esgst.cfh.textArea.setSelectionRange(range, range);
    esgst.cfh.textArea.focus();
    if (esgst.cfh_p && esgst.cfh_p_a) {
      esgst.cfh.preview.innerHTML = parseMarkdown(esgst.cfh.textArea.value);
      cfh_formatImages(esgst.cfh.preview);
    }
  }

  function cfh_formatLink(title, url, isImage, isPaste) {
    let end, start, value;
    if (isPaste) {
      esgst.cfh.recent = true;
    } else {
      cfh_undo(esgst.cfh.textArea, esgst.cfh.textArea.value);
    }
    start = esgst.cfh.textArea.selectionStart;
    end = esgst.cfh.textArea.selectionEnd;
    value = isImage ? `![${title}](${url})` : `[${title}](${url})`;
    esgst.cfh.textArea.value = `${esgst.cfh.textArea.value.slice(0, start)}${value}${esgst.cfh.textArea.value.slice(end)}`;
    if (title) {
      esgst.cfh.textArea.setSelectionRange(end + value.length, end + value.length);
    } else {
      esgst.cfh.textArea.setSelectionRange(end + value.indexOf(`[`) + 1, end + value.indexOf(`[`) + 1);
    }
    esgst.cfh.textArea.focus();
    if (esgst.cfh_p && esgst.cfh_p_a) {
      esgst.cfh.preview.innerHTML = parseMarkdown(esgst.cfh.textArea.value);
      cfh_formatImages(esgst.cfh.preview);
    }
  }

  async function cfh_checkImgur(popout, url) {
    let value = await getValue(`imgurToken`);
    if (value) {
      cfh_uploadImage(`Bearer ${value}`, popout, url);
    } else {
      setTimeout(() => cfh_checkImgur(popout, url), 250);
    }
  }

  function cfh_uploadImage(authorization, popout, url) {
    let input, popup, warning;
    popup = new Popup(`fa-upload`, `Upload Image`, true);
    input = insertHtml(popup.description, `beforeEnd`, `<input type="file"/>`);
    warning = insertHtml(popup.description, `beforeEnd`, `<div class="esgst-description esgst-warning"></div>`);
    popup.description.appendChild(new ButtonSet(`green`, `grey`, `fa-upload`, `fa-circle-o-notch fa-spin`, `Upload`, `Uploading...`, callback => {
      let file = input.files[0];
      if (file) {
        if (file.type.match(/^image/)) {
          if (file.size / 1024 / 1024 <= 10) {
            let reader = new FileReader();
            reader.readAsDataURL(file);
            reader.onload = cfh_readImgur.bind(null, authorization, popout, popup, reader, url, warning, callback);
          } else {
            createFadeMessage(warning, `Image is larger than 10 MB!`);
            callback();
          }
        } else {
          createFadeMessage(warning, `File is not an image!`);
          callback();
        }
      } else {
        createFadeMessage(warning, `No file was loaded!`);
        callback();
      }
    }).set);
    if (esgst.cfh_img_remember) {
      popup.description.appendChild(new ButtonSet_v2({color1: `grey`, color2: `grey`, icon1: `fa-rotate-left`, icon2: `fa-circle-o-notch fa-spin`, title1: `Reset`, title2: `Resetting...`, callback1: async () => {
        await setSetting(`cfh_img_remember`, false);
        esgst.cfh_img_remember = false;
        popup.close();
      }}).set);
    }
    popup.open();
  }

  async function cfh_readImgur(authorization, popout, popup, reader, url, warning, callback) {
    let responseJson = JSON.parse((await request({data: `image=${encodeURIComponent(reader.result.match(/base64,(.+)/)[1])}`, headers: {authorization}, method: `POST`, url: `https://api.imgur.com/3/image`})).responseText);
    if (responseJson.success) {
      callback();
      popup.close();
      url.value = responseJson.data.link;
      popout.open();
    } else {
      createFadeMessage(warning, `Could not upload image!`);
      callback();
    }
  }

  function cfh_insertTableRows(rows, table) {
    let deleteRow, i, j, n, row;
    while (rows > 0) {
      n = table.rows.length;
      row = table.insertRow(n);
      for (i = 0, j = table.rows[0].cells.length - 1; i < j; ++i) {
        row.insertCell(0).innerHTML = `<input placeholder="Value" type="text"/>`;
      }
      deleteRow = row.insertCell(0);
      if (n > 2) {
        deleteRow.innerHTML = `
          <a>
            <i class="fa fa-times-circle" title="Delete row"></i>
          </a>
        `;
        deleteRow.firstElementChild.addEventListener(`click`, () => {
          if (table.rows.length > 4) {
            deleteRow.remove();
            row.remove();
          } else {
              alert(`A table must have a least one row and two columns.`);
          }
        });
      }
      --rows;
    }
  }

  function cfh_insertTableColumns(columns, table) {
    let column, deleteColumn, i, j, n, rows;
    while (columns > 0) {
      rows = table.rows;
      n = rows[0].cells.length;
      for (i = 3, j = rows.length; i < j; ++i) {
        rows[i].insertCell(n).innerHTML = `<input placeholder="Value" type="text"/>`;
      }
      rows[2].insertCell(n).innerHTML = `
        <select>
          <option value=":-">Left</option>
          <option value=":-:">Center</option>
          <option value="-:">Right</option>
        </select>
      `;
      column = rows[1].insertCell(n);
      column.innerHTML = `<input placeholder="Header" type="text"/>`;
      deleteColumn = rows[0].insertCell(n);
      deleteColumn.innerHTML = `
        <a>
          <i class="fa fa-times-circle" title="Delete column"></i>
        </a>
      `;
      deleteColumn.firstElementChild.addEventListener(`click`, () => {
        rows = table.rows;
        n = rows[1].cells.length;
        if (n > 3) {
          do {
            --n;
          } while (rows[1].cells[n] !== column);
          for (i = 0, j = rows.length; i < j; ++i) {
            rows[i].deleteCell(n);
          }
        } else {
            alert(`A table must have at least one row and two columns.`);
        }
      });
      --columns;
    }
  }

  function cfh_setEmojis(emojis) {
    let emoji, i;
    for (i = emojis.children.length - 1; i > -1; --i) {
      emoji = emojis.children[i];
      emoji.addEventListener(`click`, cfh_formatItem.bind(null, emoji.textContent, ``));
    }
  }

  function cfh_setReply(replies, savedReply) {
    let editButton, description, name, replaceButton, reply, summary;
    reply = insertHtml(replies, `beforeEnd`, `
      <div class="esgst-cfh-sr-box" draggable="true">
        <div class="esgst-cfh-sr-summary">
          <div class="esgst-cfh-sr-name">${savedReply.name}</div>
          <div class="esgst-cfh-sr-description">${savedReply.description}</div>
        </div>
        <div class="esgst-cfh-sr-controls">
          <i class="esgst-clickable fa fa-retweet" title="Replace description with current reply"></i>
          <i class="esgst-clickable fa fa-edit" title="Edit reply"></i>
          <i class="esgst-clickable fa fa-trash" title="Delete reply"></i>
          <i class="fa fa-question-circle" title="Drag the reply to move it"></i>
        </div>
      </div>
    `);
    summary = reply.firstElementChild;
    name = summary.firstElementChild;
    description = name.nextElementSibling;
    replaceButton = summary.nextElementSibling.firstElementChild;
    editButton = replaceButton.nextElementSibling;
    reply.addEventListener(`dragstart`, cfh_setSource.bind(null, description, name, reply));
    reply.addEventListener(`dragenter`, cfh_getSource.bind(null, reply, replies));
    reply.addEventListener(`dragend`, cfh_saveSource);
    summary.addEventListener(`click`, () => {
      cfh_undo(esgst.cfh.textArea, esgst.cfh.textArea.value);
      let end, i, matches, n, value;
      end = esgst.cfh.textArea.selectionEnd;
      value = savedReply.description;
      matches = value.match(/\[ESGST-R\][\s\S]+?\[\/ESGST-R\]/g);
      if (matches) {
        n = matches.length;
        i = Math.floor(Math.random() * n);
        value = matches[i].match(/\[ESGST-R\]([\s\S]+?)\[\/ESGST-R\]/)[1];
      }
      esgst.cfh.textArea.value = `${esgst.cfh.textArea.value.slice(0, esgst.cfh.textArea.selectionStart)}${value}${esgst.cfh.textArea.value.slice(end)}`;
      esgst.cfh.textArea.setSelectionRange(end + value.length, end + value.length);
      esgst.cfh.textArea.focus();
    });
    editButton.addEventListener(`click`, cfh_openReplyPopup.bind(null, savedReply.description, savedReply.name, replies, summary));
    replaceButton.addEventListener(`click`, () => cfh_saveReply(savedReply.description, esgst.cfh.textArea, savedReply.name, null, null, replies, summary, null));
    editButton.nextElementSibling.addEventListener(`click`, async () => {
      let savedReplies = JSON.parse(await getValue(`savedReplies`, `[]`));
      let i;
      for (i = savedReplies.length - 1; i > -1 && (savedReplies[i].name !== name.textContent || savedReplies[i].description !== description.textContent); i--);
      if (i > -1) {
        savedReplies.splice(i, 1);
        setValue(`savedReplies`, JSON.stringify(savedReplies));
        reply.classList.add(`esgst-hidden`);
        esgst.cfh.deletedReplies.push({
          reply: reply,
          savedReply: savedReply
        });
        esgst.cfh.undoDelete.classList.remove(`esgst-hidden`);
      }
    });
  }

  async function cfh_setSource(description, name, reply, event) {
    let i, savedReplies;
    event.dataTransfer.setData(`text/plain`, ``);
    esgst.cfh.source = reply;
    savedReplies = JSON.parse(await getValue(`savedReplies`, `[]`));
    for (i = savedReplies.length - 1; i > -1 && (savedReplies[i].name !== name.textContent || savedReplies[i].description !== description.textContent); --i);
    if (i > -1) {
      esgst.cfh.sourceIndex = i;
    }
  }

  function cfh_getSource(reply, replies) {
    let current, i;
    current = esgst.cfh.source;
    i = 0;
    do {
      current = current.previousElementSibling;
      if (current && current === reply) {
        esgst.cfh.sourceNewIndex = i;
        replies.insertBefore(esgst.cfh.source, reply);
        return;
      }
      ++i;
    } while (current);
    esgst.cfh.sourceNewIndex = i - 1;
    replies.insertBefore(esgst.cfh.source, reply.nextElementSibling);
  }

  async function cfh_saveSource() {
    let savedReplies = JSON.parse(await getValue(`savedReplies`, `[]`));
    savedReplies.splice(esgst.cfh.sourceNewIndex, 0, savedReplies.splice(esgst.cfh.sourceIndex, 1)[0]);
    setValue(`savedReplies`, JSON.stringify(savedReplies));
  }

  function cfh_openReplyPopup(description, name, replies, summary) {
    let descriptionArea, nameArea, panel, popup;
    popup = new Popup(`fa-floppy-o`, summary ? `Edit reply:` : `Save new reply:`, true);
    popup.scrollable.insertAdjacentHTML(`beforeEnd`, `
      <div class="esgst-description">
        You can save a defined list of replies to be picked at random when using it. To do so, enclose each option with <span class="esgst-bold">[ESGST-R][/ESGST-R]</span>. For example, a defined list that renders a random "thank you" comment when using it would look like this:<br/><br/>
        [ESGST-R]Thanks![/ESGST-R]<br/>
        [ESGST-R]Thank you![/ESGST-R]<br/>
        [ESGST-R]Thank you so much!<br/><br/>
        Can't wait to play this game![/ESGST-R]
      </div>
    `);
    panel = insertHtml(popup.scrollable, `beforeEnd`, `
      <div>
        <div>
          <div>Name:</div>
          <input type="text" value="${name || ``}"/>
        </div>
        <div>
          <div>Description:</div>
          <textarea>${description || ``}</textarea>
        </div>
      </div>
    `);
    nameArea = panel.firstElementChild;
    descriptionArea = nameArea.nextElementSibling;
    nameArea = nameArea.lastElementChild;
    descriptionArea = descriptionArea.lastElementChild;
    if (esgst.cfh) {
      cfh_addPanel(descriptionArea);
    }
    popup.description.appendChild(new ButtonSet(`green`, `grey`, `fa-check`, `fa-circle-o-notch fa-spin`, `Save`, `Saving...`, cfh_saveReply.bind(null, description, descriptionArea, name, nameArea, popup, replies, summary)).set);
    popup.open();
  }

  async function cfh_saveReply(description, descriptionArea, name, nameArea, popup, replies, summary, callback) {
    let [descVal, nameVal] = [descriptionArea ? descriptionArea.value.trim() : description, nameArea ? nameArea.value.trim() : name];
    if (descVal && nameVal) {
      let savedReplies = JSON.parse(await getValue(`savedReplies`, `[]`));
      let savedReply = {
        description: descVal,
        name: nameVal
      };
      if (summary) {
        let i;
        for (i = savedReplies.length - 1; i > -1 && (savedReplies[i].name !== name || savedReplies[i].description !== description); i--);
        if (i > -1) {
          savedReplies[i] = savedReply;
          summary.firstElementChild.textContent = nameVal;
          summary.lastElementChild.textContent = descVal;
        }
      } else {
        savedReplies.push(savedReply);
        cfh_setReply(replies, savedReply);
      }
      await setValue(`savedReplies`, JSON.stringify(savedReplies));
      if (callback) {
        callback();
        popup.close();
      }
    } else if (callback) {
      callback();
      createAlert(`Both fields are required.`);
    }
  }

  function cfh_filterReplies(replies, event) {
    let i, reply, value;
    value = event.currentTarget.value;
    for (i = replies.children.length - 1; i > -1; --i) {
      reply = replies.children[i];
      if (reply.textContent.toLowerCase().match(value.toLowerCase())) {
        reply.classList.remove(`esgst-hidden`);
      } else {
        reply.classList.add(`esgst-hidden`);
      }
    }
  }

  async function cfh_undoDelete() {
    let deleted, saved;
    deleted = esgst.cfh.deletedReplies.pop();
    deleted.reply.classList.remove(`esgst-hidden`);
    deleted.reply.parentElement.appendChild(deleted.reply);
    saved = JSON.parse(await getValue(`savedReplies`, `[]`));
    saved.push(deleted.savedReply);
    setValue(`savedReplies`, JSON.stringify(saved));
    if (esgst.cfh.deletedReplies.length === 0) {
      esgst.cfh.undoDelete.classList.add(`esgst-hidden`);
    }
  }

  function cfh_setAlipf(value, firstTime) {
    if (typeof value === `undefined`) {
      value = esgst.cfh_pasteFormatting ? false : true;
    }
    if (!firstTime) {
      setSetting(`cfh_pasteFormatting`, value);
    }
    esgst.cfh_pasteFormatting = value;
    if (value) {
      esgst.cfh.alipf.title = getFeatureTooltip(`cfh`, `Automatic Links / Images Paste Formatting: ON`);
      esgst.cfh.alipf.classList.remove(`esgst-faded`);
    } else {
      esgst.cfh.alipf.title = getFeatureTooltip(`cfh`, `Automatic Links / Images Paste Formatting: OFF`);
      esgst.cfh.alipf.classList.add(`esgst-faded`);
    }
    if (esgst.cfh.textArea) {
      esgst.cfh.textArea.focus();
    }
  }

  function cfh_formatImages(context) {
    let i, images, n;
    images = context.getElementsByTagName(`img`);
    for (i = 0, n = images.length; i < n; ++i) {
      const image = images[0];
      context.appendChild(image);
      image.classList.add(`is-hidden`, `is_hidden`);
      image.outerHTML = `
        <div>
          <div class="${esgst.sg ? `comment__toggle-attached` : `view_attached`}">View attached image.</div>
          <a href="${image.getAttribute(`src`)}" rel="nofollow noreferrer" target="_blank">
            ${image.outerHTML}
          </a>
        </div>
      `;
    }
  }

  // [RCVC]

  _MODULES.push({
    decription: `
      <ul>
        <li>Adds a "Real CV" row containing how much real CV you should get for a giveaway to the table of the review giveaway page (the page where you can confirm the creation of a giveaway).</li>
      </ul>
    `,
    id: `rcvc`,
    load: rcvc,
    name: `Real CV Calculator`,
    sg: true,
    sync: `Giveaways, Reduced CV Games and No CV Games`,
    type: `giveaways`
  });

  async function rcvc() {
    if (esgst.newGiveawayPath) {
      let table = document.getElementsByClassName(`table--summary`)[0], button;
      if (table) {
        let game = await getValue(`rcvcGame`);
        if (game) {
          let type = game.type;
          let id = game.id;
          let i, n;
          let headings = document.getElementsByClassName(`featured__heading__small`);
          let copies = headings.length > 1 ? parseInt(headings[0].textContent.match(/\d+/)[0]) : 1;
          try {
            let responseJson = JSON.parse((await request({method: `GET`, url: `http://store.steampowered.com/api/${type === `apps` ? `appdetails?appids` : `packagedetails?packageids`}=${id}&cc=us&filters=price,price_overview`})).responseText)[id].data;
            let value = Math.ceil((responseJson.price_overview || responseJson.price).initial / 100);
            let games, user;
            games = JSON.parse(await getValue(`games`));
            if (games[type][id]) {
              if (games[type][id].noCV) {
                value = 0;
              } else if (games[type][id].reducedCV) {
                value *= 0.15;
              }
            }
            user = {
              Username: esgst.username,
              SteamID64: esgst.steamId
            };
            let users = JSON.parse(await getValue(`users`));
            let savedUser = users.users[user.SteamID64];
            let sent = 0;
            let currentDate = Date.now();
            if (savedUser && savedUser.giveaways && savedUser.giveaways.sent && savedUser.giveaways.sent[type][id]) {
              let giveaways = savedUser.giveaways.sent[type][id];
              for (i = 0, n = giveaways.length; i < n; ++i) {
                let giveaway = esgst.giveaways[giveaways[i]];
                if (giveaway) {
                  if (giveaway.entries >= 5 || (!giveaway.inviteOnly && !giveaway.group && !giveaway.whitelist)) {
                    if (Array.isArray(giveaway.winners)) {
                      if (giveaway.winners.length > 0) {
                        giveaway.winners.forEach(winner => {
                          if (winner.status === `Received`) {
                            sent += 1;
                          }
                        });
                      } else if (currentDate < giveaway.endTime) {
                        sent += giveaway.copies;
                      }
                    } else if (giveaway.winners > 0) {
                      sent += Math.min(giveaway.entries, giveaway.winners);
                    }
                  } else if (currentDate < giveaway.endTime) {
                    sent += giveaway.copies;
                  }
                }
              }
              if (sent > 5) {
                for (i = 0, n = sent - 5; i < n; ++i) {
                  value *= 0.90;
                }
              }
            }
            let cv;
            if (copies > 1) {
              let total = copies + sent;
              if (total > 5) {
                n = total - 5;
                cv = (copies - n) * value;
                for (i = 0; i < n; ++i) {
                  value *= 0.90;
                  cv += value;
                }
              } else {
                cv = value * copies;
              }
            } else if ((sent + 1) > 5) {
              cv = value * 0.90;
            } else {
              cv = value;
            }
            cv = Math.round(cv * 100) / 100;
            let html = `
              <div class="table__row-outer-wrap">
                <div class="table__row-inner-wrap">
                  <div class="table__column--width-medium table__column--align-top">
                    <span class="esgst-bold">Real CV</span>
                  </div>
                  <div class="table__column--width-fill">You should get ~$${cv} real CV for this giveaway.</div>
                </div>
              </div>
            `;
            table.insertAdjacentHTML(`beforeEnd`, html);
          } catch (e) { /**/ }
          button = document.getElementsByClassName(`js__submit-form`)[0];
          button.addEventListener(`click`, () => {
            delValue(`rcvcGame`);
          });
        }
      } else {
        button = document.getElementsByClassName(`js__submit-form`)[0];
        let input = document.querySelector(`[name="game_id"]`);
        button.addEventListener(`click`, () => {
          let selectedId = input.value;
          let selected = document.querySelector(`[data-autocomplete-id="${selectedId}"]`);
          let info = games_getInfo(selected);
          setValue(`rcvcGame`, {
            type: info.type,
            id: info.id
          });
        });
      }
    }
  }

  // [SGAC]

  _MODULES.push({
    description: `
      <ul>
        <li>Adds a button (<i class="fa fa-thumb-stack"></i> if the country is stickied and <i class="fa fa-thumb-stack esgst-faded"></i> if it is not) next to each country in the <a href="https://www.steamgifts.com/giveaways/new">new giveaway</a> page that allows you to sticky the country so that it appears at the top of the country list when creating a giveaway for quick use.</li>
      </ul>
    `,
    id: `sgac`,
    load: sgac,
    name: `Stickied Giveaway Countries`,
    sg: true,
    type: `giveaways`
  });

  function sgac() {
    if (!esgst.newGiveawayPath) return;
    let rows = document.getElementsByClassName(`form__rows`)[0];
    if (!rows) return;
    let container, context, elements, i, id, n, separator, stickiedCountries;
    stickiedCountries = JSON.parse(esgst.storage.stickiedCountries);
    container = document.querySelector(`.form_list[data-input="country_item_string"]`);
    separator = container.firstElementChild;
    elements = container.children;
    for (i = 0, n = elements.length; i < n; ++i) {
      context = elements[i];
      id = context.getAttribute(`data-item-id`);
      if (stickiedCountries.indexOf(id) >= 0) {
        if (context === separator) {
          separator = separator.nextElementSibling;
        }
        container.insertBefore(context, separator);
      }
      new Button(context, `afterBegin`, {
        callbacks: [sgac_stickyCountry.bind(null, container, context, id, separator), null, sgac_unstickyCountry.bind(null, container, context, id, separator), null],
        className: `esgst-sgac-button`,
        icons: [`fa-thumb-tack esgst-clickable esgst-faded`, `fa-circle-o-notch fa-spin`, `fa-thumb-tack esgst-clickable`, `fa-circle-o-notch fa-spin`],
        id: `sgac`,
        index: stickiedCountries.indexOf(id) >= 0 ? 2 : 0,
        titles: [`Sticky country`, `Stickying...`, `Unsticky country`, `Unstickying...`]
      });
    }
  }

  async function sgac_stickyCountry(container, context, id, separator, event) {
    event.stopPropagation();
    if (container) {
      if (context === separator) {
        separator = separator.nextElementSibling;
      }
      container.insertBefore(context, separator);
    }
    let stickiedCountries = JSON.parse(await getValue(`stickiedCountries`, `[]`));
    if (stickiedCountries.indexOf(id) < 0) {
      stickiedCountries.push(id);
      await setValue(`stickiedCountries`, JSON.stringify(stickiedCountries));
    }
    return true;
  }

  async function sgac_unstickyCountry(container, context, id, separator, event) {
    event.stopPropagation();
    if (container) {
      container.insertBefore(context, separator);
      separator = separator.previousElementSibling;
    }
    let stickiedCountries = JSON.parse(await getValue(`stickiedCountries`, `[]`));
    let index = stickiedCountries.indexOf(id);
    if (index >= 0) {
      stickiedCountries.splice(index, 1);
      await setValue(`stickiedCountries`, JSON.stringify(stickiedCountries));
    }
    return true;
  }

  // [SK]
  
  _MODULES.push({
    description: `
      <ul>
        <li>Allows you to perform many different tasks by pressing certain keys.</li>
      </ul>
    `,
    features: {
      sk_cp: {
        inputItems: `sk_closePopups`,
        name: `Close all currently opened popups.`,
        sg: true,
        st: true
      },
      sk_sb: {
        inputItems: `sk_searchBox`,
        name: `Focus on the search box.`,
        sg: true,
        st: true
      },
      sk_fp: {
        inputItems: `sk_firstPage`,
        name: `Go to the first page.`,
        sg: true,
        st: true
      },
      sk_pp: {
        inputItems: `sk_previousPage`,
        name: `Go to the previous page.`,
        sg: true,
        st: true
      },
      sk_np: {
        inputItems: `sk_nextPage`,
        name: `Go to the next page.`,
        sg: true,
        st: true
      },
      sk_lp: {
        inputItems: `sk_lastPage`,
        name: `Go to the last page.`,
        sg: true,
        st: true
      },
      sk_tf: {
        inputItems: `sk_toggleFilters`,
        name: `Toggle the giveaway filters.`,
        sg: true
      },
      sk_hg: {
        inputItems: `sk_hideGame`,
        name: `Hide the game when inside of a giveaway.`,
        sg: true
      },
      sk_hga: {
        inputItems: `sk_hideGiveaway`,
        name: `Hide the giveaway when inside of a giveaway.`,
        sg: true
      },
      sk_ge: {
        inputItems: `sk_giveawayEntry`,
        name: `Enter/leave the giveaway when inside of a giveaway.`,
        sg: true
      },
      sk_c: {
        inputItems: `sk_creator`,
        name: `Insert the username of the creator of the giveaway/discussion/trade to the current reply box.`,
        sg: true,
        st: true
      },
      sk_rb: {
        inputItems: `sk_replyBox`,
        name: `Focus on the reply box.`,
        sg: true,
        st: true
      },
      sk_ru: {
        inputItems: `sk_replyUser`,
        name: `Insert the username of the user to whom you are replying to the current reply box.`,
        sg: true,
        st: true
      },
      sk_sr: {
        inputItems: `sk_submitReply`,
        name: `Submit the current reply.`,
        sg: true,
        st: true
      }
    },
    id: `sk`,
    load: sk,
    name: `Shortcut Keys`,
    sg: true,
    st: true,
    type: `general`
  });

  function sk() {
    let methods = {};
    if (esgst.sk_cp) {
      methods[esgst.sk_closePopups] = event => {
        if (!event.target.tagName.match(/^(INPUT|TEXTAREA)$/)) {
          let buttons = document.querySelectorAll(`.b-close, .esgst-popup-close`), i;
          for (i = buttons.length - 1; i > -1; --i) {
            buttons[i].click();
          }
          event.preventDefault();
        }
      };
    }
    if (esgst.sk_sb) {
      methods[esgst.sk_searchBox] = event => {
        if (!event.target.tagName.match(/^(INPUT|TEXTAREA)$/)) {
          let search = document.getElementsByClassName(`sidebar__search-input`)[0];
          if (search) {
            search.focus();
            event.preventDefault();
          }
        }
      };
    }
    if (esgst.sk_fp) {
      methods[esgst.sk_firstPage] = event => {
        if (!event.target.tagName.match(/^(INPUT|TEXTAREA)$/) && esgst.paginationNavigation && esgst.currentPage > 1) {
          location.href = `${esgst.searchUrl}1`;
          event.preventDefault();
        }
      };
    }
    if (esgst.sk_pp) {
      methods[esgst.sk_previousPage] = event => {
        if (!event.target.tagName.match(/^(INPUT|TEXTAREA)$/) && esgst.paginationNavigation && esgst.currentPage > 1) {
          location.href = `${esgst.searchUrl}${esgst.currentPage - 1}`;
          event.preventDefault();
        }
      };
    }
    if (esgst.sk_np) {
      methods[esgst.sk_nextPage] = event => {
        if (!event.target.tagName.match(/^(INPUT|TEXTAREA)$/) && esgst.paginationNavigation && esgst.currentPage < esgst.lastPage) {
          location.href = `${esgst.searchUrl}${esgst.currentPage + 1}`;
          event.preventDefault();
        }
      };
    }
    if (esgst.sk_lp) {
      methods[esgst.sk_lastPage] = event => {
        if (!event.target.tagName.match(/^(INPUT|TEXTAREA)$/) && esgst.paginationNavigation && esgst.currentPage < esgst.lastPage && esgst.lastPage !== 999999999) {
          location.href = `${esgst.searchUrl}${esgst.lastPage}`;
          event.preventDefault();
        }
      };
    }
    if (esgst.sk_tf) {
      methods[esgst.sk_toggleFilters] = event => {
        if (!event.target.tagName.match(/^(INPUT|TEXTAREA)$/)) {
          let toggle = document.querySelector(`.esgst-gf-toggle-switch`);
          if (toggle) {
            toggle.click();
            event.preventDefault();
          }
        }
      };
    }
    if (esgst.sk_hg) {
      methods[esgst.sk_hideGame] = event => {
        if (!event.target.tagName.match(/^(INPUT|TEXTAREA)$/) && esgst.giveawayPath) {
          let button = (document.getElementsByClassName(`popup--hide-games`)[0].style.display && document.getElementsByClassName(`popup--hide-games`)[0].style.display !== `none` && document.getElementsByClassName(`js__submit-hide-games`)[0]) || document.querySelector(`.esgst-ochgb, .giveaway__hide, .featured__giveaway__hide`);
          if (button) {
            (button.classList.contains(`esgst-ochgb`) ? button.firstElementChild : button).click();
            event.preventDefault();
          }
        }
      };
    }
    if (esgst.sk_hga) {
      methods[esgst.sk_hideGiveaway] = event => {
        if (!event.target.tagName.match(/^(INPUT|TEXTAREA)$/) && esgst.giveawayPath) {
          let button = document.querySelector(`.esgst-gf-hide-button, .esgst-gf-unhide-button`);
          if (button) {
            button.firstElementChild.click();
            event.preventDefault();
          }
        }
      };
    }
    if (esgst.sk_ge) {
      methods[esgst.sk_giveawayEntry] = event => {
        if (!event.target.tagName.match(/^(INPUT|TEXTAREA)$/) && esgst.enterGiveawayButton) {
          if (esgst.enterGiveawayButton.classList.contains(`is-hidden`)) {
            esgst.leaveGiveawayButton.click();
          } else {
            esgst.enterGiveawayButton.click();
          }
          event.preventDefault();
        }
      };
    }
    if (esgst.sk_c) {
      methods[esgst.sk_creator] = event => {
        if (event.target.tagName.match(/^(INPUT|TEXTAREA)$/)) {
          let text = event.target.value;
          let end = event.target.selectionEnd;
          let creator = document.querySelector(`.featured__column--width-fill.text-right a, .comment__username, .author_name`);
          if (creator) {
            creator = creator.textContent;
            let range = end + creator.length;
            event.target.value = `${text.slice(0, event.target.selectionStart)}${creator}${text.slice(end)}`;
            event.target.setSelectionRange(range, range);
            event.target.focus();
            event.preventDefault();
          }
        }
      };
    }
    if (esgst.sk_rb) {
      methods[esgst.sk_replyBox] = event => {
        if (!event.target.tagName.match(/^(INPUT|TEXTAREA)$/) && esgst.replyBox) {
          esgst.replyBox.getElementsByTagName(`textarea`)[0].focus();
          event.preventDefault();
        }
      };
    }
    if (esgst.sk_ru) {
      methods[esgst.sk_replyUser] = event => {
        if (event.target.tagName === `TEXTAREA`) {
          let text = event.target.value;
          let end = event.target.selectionEnd;
          let user = event.target.closest(`.comment__children, .comment_children`);
          user = (user && user.closest(`.comment, .comment_outer`).querySelector(`.comment__username, .author_name`)) || document.querySelector(`.featured__column--width-fill.text-right a, .comment__username, .author_name`);
          if (user) {
            user = user.textContent;
            let range = end + user.length;
            event.target.value = `${text.slice(0, event.target.selectionStart)}${user}${text.slice(end)}`;
            event.target.setSelectionRange(range, range);
            event.target.focus();
            event.preventDefault();
          }
        }
      };
    }
    if (esgst.sk_sr) {
      methods[esgst.sk_submitReply] = event => {
        if (event.target.tagName === `TEXTAREA`) {
          let reply = event.target.closest(`.comment, .reply_form, .esgst-popup`);
          if (reply) {
            let button = reply.querySelector(`.esgst-button-set >:first-child, .js_submit`);
            if (button) {
              button.click();
              event.preventDefault();
            }
          }
        }
      };
    }
    if (Object.keys(methods).length > 0) {
      document.addEventListener(`keydown`, event => {
        event.stopPropagation();
        let value = ``;
        if (event.ctrlKey) {
          value += `ctrlKey + `;
        } else if (event.shiftKey) {
          value += `shiftKey + `;
        } else if (event.altKey) {
          value += `altKey + `;
        }
        value += event.key.toLowerCase();
        if (methods[value]) {
          methods[value](event);
        }
      });
    }
  }

  // [SKS]
  
  _MODULES.push({
    description: `
      <ul>
        <li>Adds a button (<i class="fa fa-key"></i> <i class="fa fa-search"></i>) to the main page heading of your <a href="https://www.steamgifts.com/giveaways/created">created</a> page that allows you to search for a key or a set of keys in all of keys that you have ever sent.</li>
        <li>There is also an option to export all of the keys that you have ever sent to a text file.</li>
      </ul>
    `,
    id: `sks`,
    load: sks,
    name: `Sent Key Searcher`,
    sg: true,
    type: `giveaways`
  });

  function sks() {
    if (!esgst.createdPath) return;
    let button = createHeadingButton({id: `sks`, icons: [`fa-key`, `fa-search`], title: `Search keys`});
    button.addEventListener(`click`, sks_openPopup.bind(null, {button}));
  }

  function sks_openPopup(sks) {
    if (sks.popup) {
      sks.popup.open();
      return;
    }
    sks.popup = new Popup(`fa-key`, `Search for keys:`);
    sks.textArea = insertHtml(sks.popup.scrollable, `beforeEnd`, `
      <div class="esgst-description">Insert the keys below, one per line.</div>
      <textarea></textarea>
    `);
    new ToggleSwitch(sks.popup.description, `sks_exportKeys`, false, `Export all keys ever sent.`, false, false, `This will search all your giveaways and export a file with all keys ever sent. You don't need to enter any keys if this option is enabled.`, esgst.sks_exportKeys);
    let searchCurrent = new ToggleSwitch(sks.popup.description, `sks_searchCurrent`, false, `Only search the current page.`, false, false, null, esgst.sks_searchCurrent);
    let minDate = new ToggleSwitch(sks.popup.description, `sks_limitDate`, false, `Limit search by date, from <input class="esgst-switch-input esgst-switch-input-large" type="date" value="${esgst.sks_minDate}"> to <input class="esgst-switch-input esgst-switch-input-large" type="date" value="${esgst.sks_maxDate}">.`, false, false, null, esgst.sks_limitDate).name.firstElementChild;
    let maxDate = minDate.nextElementSibling;
    let limitPages = new ToggleSwitch(sks.popup.description, `sks_limitPages`, false, `Limit search by pages, from <input class="esgst-switch-input" min="1" type="number" value="${esgst.sks_minPage}"> to <input class="esgst-switch-input" min="1" type="number" value="${esgst.sks_maxPage}">.`, false, false, null, esgst.sks_limitPages);
    let minPage = limitPages.name.firstElementChild;
    let maxPage = minPage.nextElementSibling;
    searchCurrent.exclusions.push(limitPages.container);
    limitPages.exclusions.push(searchCurrent.container);
    if (esgst.sks_searchCurrent) {
      limitPages.container.classList.add(`esgst-hidden`);
    } else if (esgst.sks_limitPages) {
      searchCurrent.container.classList.add(`esgst-hidden`);
    }
    observeChange(minDate, `sks_minDate`);
    observeChange(maxDate, `sks_maxDate`);
    observeNumChange(minPage, `sks_minPage`);
    observeNumChange(maxPage, `sks_maxPage`);
    sks.results = insertHtml(sks.popup.scrollable, `beforeEnd`, `<div></div>`);
    sks.popup.description.appendChild(new ButtonSet_v2({color1: `green`, color2: `grey`, icon1: `fa-search`, icon2: `fa-times`, title1: `Search`, title2: `Cancel`, callback1: sks_searchGiveaways.bind(null, sks), callback2: sks_cancelSearch.bind(null, sks)}).set);
    sks.progress = insertHtml(sks.popup.description, `beforeEnd`, `<div></div>`);
    sks.overallProgress = insertHtml(sks.popup.description, `beforeEnd`, `<div></div>`);
    sks.popup.open();
  }

  async function sks_searchGiveaways(sks) {
    // initialize stuff
    sks.button.classList.add(`esgst-busy`);
    sks.canceled = false;
    sks.count = 0;
    sks.giveaways = {};
    sks.allKeys = [];
    sks.keys = [];
    sks.progress.innerHTML = ``;
    sks.overallProgress.innerHTML = ``;
    sks.results.innerHTML = ``;
    let keys = sks.textArea.value.trim().split(/\n/);
    let n = keys.length;
    if (!esgst.sks_exportKeys && n < 1) {
      return;
    }
    for (let i = 0; i < n; i++) {
      let key = keys[i].trim();
      if (key) {
        sks.keys.push(key);
        sks.count += 1;
      }
    }
    sks.textArea.value = sks.keys.join(`\n`);

    // search keys
    let [nextPage, maxPage] = esgst.sks_limitPages ? [esgst.sks_minPage, esgst.sks_maxPage + 1] : (esgst.sks_searchCurrent ? [esgst.currentPage, esgst.currentPage + 1] : [esgst.currentPage, null]);
    let [minDate, maxDate] = esgst.sks_limitDate ? [new Date(esgst.sks_minDate).getTime() - 1, new Date(esgst.sks_maxDate).getTime() + 1] : [null, null];
    let pagination = null;
    let skipped = false;
    let stopped = false;
    do {
      let context = null;
      skipped = false;
      if (nextPage === esgst.currentPage) {
        context = document;
        sks.lastPage = lpl_getLastPage(context);
        sks.lastPage = maxPage ? ` of ${maxPage - 1}` : (sks.lastPage === 999999999 ? `` : ` of ${sks.lastPage}`);
      } else if (document.getElementsByClassName(`esgst-es-page-${nextPage}`)[0]) {
        skipped = true;
        continue;
      } else {
        context = parseHtml((await request({method: `GET`, url: `/giveaways/created/search?page=${nextPage}`})).responseText);
        if (!sks.lastPage) {
          sks.lastPage = lpl_getLastPage(context);
          sks.lastPage = maxPage ? ` of ${maxPage - 1}` : (sks.lastPage === 999999999 ? `` : ` of ${sks.lastPage}`);
        }
      }
      sks.overallProgress.innerHTML = `
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <span>Searching for ${sks.count} keys (page ${nextPage}${sks.lastPage})...</span>
      `;
      let elements = context.getElementsByClassName(`trigger-popup--keys`);
      for (let i = 0, n = elements.length; !sks.canceled && i < n; i++) {
        sks.progress.innerHTML = `
          <i class="fa fa-circle-o-notch fa-spin"></i>
          <span>Retrieving keys (${i + 1} of ${n})...</span>
        `;
        let element = elements[i];
        let endDate = parseInt(element.closest(`.table__row-inner-wrap`).querySelector(`[data-timestamp]`).getAttribute(`data-timestamp`)) * 1e3;
        if (minDate && maxDate) {
          if (endDate > maxDate) {
            skipped = true;
            continue;
          }
          if (endDate < minDate) {
            stopped = true;
            continue;
          }
        }
        let giveaway = {
          active: Date.now() < endDate,
          code: element.parentElement.querySelector(`[name=code]`).value,
          name: element.getAttribute(`data-name`)
        };
        let heading = parseHtml(JSON.parse((await request({data: `xsrf_token=${esgst.xsrfToken}&do=popup_keys&code=${giveaway.code}`, method: `POST`, url: `/ajax.php`})).responseText).html).getElementsByClassName(`popup__keys__heading`)[0];
        if (!heading || (heading.textContent !== `Assigned` && !giveaway.active)) {
          continue;
        }
        let keys = heading.nextElementSibling.nextElementSibling.children;
        for (let j = keys.length - 1; !sks.canceled && j > -1; j--) {
          let key = keys[j].textContent;
          if (sks.keys.indexOf(key) > -1) {
            sks.giveaways[key] = giveaway;
            sks.count -= 1;
          }
          if (esgst.sks_exportKeys) {
            sks.allKeys.push(`${giveaway.active ? `[UNASSIGNED] ` : ``}${key} ${giveaway.name} https://www.steamgifts.com/giveaway/${giveaway.code}/`);
          }
        }
      }
      nextPage += 1;
      pagination = (sks.count > 0 || esgst.sks_exportKeys) ? context.getElementsByClassName(`pagination__navigation`)[0] : null;
    } while (!sks.canceled && !stopped && (!maxPage || nextPage < maxPage) && (skipped || (pagination && !pagination.lastElementChild.classList.contains(`is-selected`))));

    if (sks.canceled) {
      // search has been canceled
      return;
    }

    // finish the search
    let found = [];
    let notFound = [];
    for (let i = 0, n = sks.keys.length; i < n; i++) {
      let key = sks.keys[i];
      let giveaway = sks.giveaways[key];
      if (giveaway) {
        found.push(`<li>${giveaway.active ? `[UNASSIGNED] ` : ``}${key} (<a href="/giveaway/${giveaway.code}/">${giveaway.name}</a>)</li>`);
      } else {
        notFound.push(`<li>${key}</li>`);
      }
    }
    [
      {array: found, name: `Found`},
      {array: notFound, name: `Did not find`}
    ].forEach(item => {
      let n = item.array.length;
      if (n < 1) {
        return;
      }
      sks.results.insertAdjacentHTML(`beforeEnd`, `
        <div class="markdown">
          <div>
            <span class="esgst-bold">${item.name} ${n} keys:</span>
          </div>
          <ul>
            ${item.array.join(``)}
          </ul>
        </div>
      `);
    });
    if (esgst.sks_exportKeys) {
      downloadFile(sks.allKeys.join(`\r\n`), `esgst_sks_keys_${new Date().toISOString()}.txt`);
    }
    sks.progress.innerHTML = ``;
    sks.overallProgress.innerHTML = ``;
    sks.button.classList.remove(`esgst-busy`);
  }

  function sks_cancelSearch(sks) {
    sks.canceled = true;
    sks.button.classList.remove(`esgst-busy`);
    sks.progress.innerHTML = ``;
    sks.overallProgress.innerHTML = ``;
  }

  // [STBB]

  _MODULES.push({
    description: `
      <ul>
        <li>Adds a button (<i class="fa fa-chevron-down"></i>) either to the bottom right corner, the main page heading or the footer (you can decide where) of any page that takes you to the bottom of the page.</li>
      </ul>
    `,
    id: `stbb`,
    load: stbb,
    name: `Scroll To Bottom Button`,
    options: {
      title: `Show in:`,
      values: [`Bottom Right Corner`, `Main Page Heading`, `Footer`]
    },
    sg: true,
    st: true,
    type: `general`
  });

  function stbb() {
    let button;
    switch (esgst.stbb_index) {
      case 0:
        button = insertHtml(document.body, `beforeEnd`, `
          <div class="esgst-stbb-button esgst-stbb-button-fixed" title="${getFeatureTooltip(`stbb`, `Scroll to bottom`)}">
            <i class="fa fa-chevron-down"></i>
          </div>
        `);
        addEventListener(`scroll`, () => {
          if (document.documentElement.offsetHeight -  innerHeight >=  scrollY + 100) {
            button.classList.remove(`esgst-hidden`);
          } else {
            button.classList.add(`esgst-hidden`);
          }
        });
        break;
      case 1:
        button = createHeadingButton({id: `stbb`, icons: [`fa-chevron-down`], title: `Scroll to bottom`});
        button.classList.add(`esgst-stbb-button`);
        break;
      case 2:
        button = insertHtml(esgst.footer.firstElementChild.lastElementChild, `beforeEnd`, `
          <${esgst.sg ? `div` : `li`} class="esgst-stbb-button" title="${getFeatureTooltip(`stbb`, `Scroll to bottom`)}">
            <i class="fa fa-chevron-down"></i>
          </${esgst.sg ? `div` : `li`}>
        `);
        break;
    }
    button.addEventListener(`click`, () => animateScroll(document.documentElement.offsetHeight, () => {
      if (esgst.es && esgst.es.paginations) {
        es_changePagination(esgst.es, esgst.es.reverseScrolling ? 1 : esgst.es.paginations.length);
      }
    }));
  }

  // [STTB]

  _MODULES.push({
    description: `
      <ul>
        <li>Adds a button (<i class="fa fa-chevron-up"></i>) either to the bottom right corner, the main page heading or the footer (you can decide where) of any page that takes you to the top of the page.</li>
      </ul>
    `,
    id: `sttb`,
    load: sttb,
    name: `Scroll To Top Button`,
    options: {
      title: `Show in:`,
      values: [`Bottom Right Corner`, `Main Page Heading`, `Footer`]
    },
    sg: true,
    st: true,
    type: `general`
  });

  function sttb() {
    let button;
    switch (esgst.sttb_index) {
      case 0:
        button = insertHtml(document.body, `beforeEnd`, `
          <div class="esgst-sttb-button esgst-sttb-button-fixed" title="${getFeatureTooltip(`sttb`, `Scroll to top`)}">
            <i class="fa fa-chevron-up"></i>
          </div>
        `);
        button.classList.add(`esgst-hidden`);
        addEventListener(`scroll`, () => {
          if (scrollY > 100) {
            button.classList.remove(`esgst-hidden`);
          } else {
            button.classList.add(`esgst-hidden`);
          }
        });
        break;
      case 1:
        button = createHeadingButton({id: `sttb`, icons: [`fa-chevron-up`], title: `Scroll to top`});
        button.classList.add(`esgst-sttb-button`);
        break;
      case 2:
        button = insertHtml(esgst.footer.firstElementChild.lastElementChild, `beforeEnd`, `
          <${esgst.sg ? `div` : `li`} class="esgst-sttb-button" title="${getFeatureTooltip(`sttb`, `Scroll to top`)}">
            <i class="fa fa-chevron-up"></i>
          </${esgst.sg ? `div` : `li`}>
        `);
        break;
    }
    button.addEventListener(`click`, animateScroll.bind(null, 0, () => {
      if (esgst.es && esgst.es.paginations) {
        es_changePagination(esgst.es, esgst.es.reverseScrolling ? esgst.es.paginations.length : 1);
      }
    }));
  }

  // [TB]

  _MODULES.push({
    description: `
      <ul>
        <li>Adds a button (<i class="fa fa-chevron-circle-up"></i>) to the main page heading of your <a href="https://www.steamtrades.com/trades/search?user=your-steam-id">created trades</a> page that allows you to bump all of your open trades at once.</li>
      </ul>
    `,
    features: {
      tb_a: {
        description: `
          <ul>
            <li>Automatically bumps all of your trades every hour.</li>
            <li>Requires either SteamGifts or SteamTrades to be open, depending on where you have this option enabled.</li>
          </ul>
        `,
        name: `Auto bump every hour.`,
        sg: true,
        st: true
      }
    },
    id: `tb`,
    load: tb,
    name: `Trade Bumper`,
    sg: true,
    st: true,
    type: `trades`
  });

  function tb() {
    if (location.href.match(new RegExp(`\\/trades\\/search\\?user=${esgst.steamId}`))) {
      let button = createHeadingButton({id: `tb`, icons: [`fa-chevron-circle-up`], title: `Bump trades`});
      button.addEventListener(`click`, tb_getTrades.bind(null, button, document));
      if (esgst.tb_a) {
        tb_setAutoBump(button);
      }
    } else if (esgst.tb_a) {
      tb_setAutoBump();
    }
  }

  function tb_getTrades(button, context, callback) {
    let elements, n;
    if (button) {
      button.innerHTML = `
        <i class="fa fa-circle-o-notch fa-spin"></i>
      `;
    }
    elements = context.querySelectorAll(`.row_inner_wrap:not(.is_faded)`);
    n = elements.length;
    if (n > 0) {
      tb_bumpTrades(button, elements, 0, n, callback);
    } else if (button) {
      button.innerHTML = `
        <i class="fa fa-chevron-circle-up"></i>
      `;
    }
  }

  async function tb_bumpTrades(button, elements, i, n, callback) {
    if (i < n) {
      await request({data: `xsrf_token=${esgst.xsrfToken}&do=trade_bump&code=${elements[i].querySelector(`[href*="/trade/"]`).getAttribute(`href`).match(/\/trade\/(.+?)\//)[1]}`, method: `POST`, url: `https://www.steamtrades.com/ajax.php`});
      tb_bumpTrades(button, elements, ++i, n, callback);
    } else {
      if (button) {
        button.innerHTML = `
          <i class="fa fa-chevron-circle-up"></i>
        `;
      }
      if (callback) {
        callback();
      } else {
        location.reload();
      }
    }
  }

  async function tb_setAutoBump(button) {
    let currentTime = Date.now();
    let dif = currentTime - (await getValue(`lastBump`, 0));
    if (dif > 3600000) {
      await setValue(`lastBump`, currentTime);
      tb_autoBumpTrades(button);
    } else {
      setTimeout(() => tb_setAutoBump(button), 3600000 - dif);
    }
  }

  async function tb_autoBumpTrades(button) {
    if (location.href.match(new RegExp(`\\/trades\\/search\\?user=${esgst.steamId}`))) {
      tb_getTrades(button, document);
    } else {
      tb_getTrades(null, parseHtml((await request({method: `GET`, queue: true, url: `https://www.steamtrades.com/trades/search?user=${esgst.steamId}`})).responseText), setTimeout.bind(null, tb_setAutoBump, 3900000, button));
    }
  }

  // [TTPCC]
  
  _MODULES.push({
    description: `
      <ul>
        <li>If you have less than 400P and you hover over the number of points at the header of any page, it shows how much time you have to wait until you have 400P.</li>
      </ul>
    `,
    id: `ttpcc`,
    name: `Time To Point Cap Calculator`,
    sg: true,
    type: `general`
  });

  // [UGS]

  _MODULES.push({
    description: `
      <ul>
        <li>Adds a button (<i class="fa fa-gift"></i> <i class="fa fa-send"></i>) to the main page heading of your <a href="https://www.steamgifts.com/giveaways/created">created</a> page that allows you to send all of your unsent gifts at once.</li>
        <li>You can limit which gifts are sent based on whether or not the winner has any not activated/multiple wins (using <a href="https://www.sgtools.info/">SGTools</a>), whether or not the winner is still a member of the group and has a certain gift difference for group giveaways, and whether or not the winner is on your whitelist/blacklist.</li>
      </ul>
    `,
    id: `ugs`,
    load: ugs,
    name: `Unsent Gift Sender`,
    sg: true,
    type: `giveaways`
  });

  function ugs() {
    if (esgst.createdPath) {
      let button = createHeadingButton({id: `ugs`, icons: [`fa-gift`, `fa-send`], title: `Send unsent gifts`});
      button.addEventListener(`click`, ugs_openPopup.bind(null, {button}));
    } else if (esgst.newTicketPath) {
      document.getElementsByClassName(`form__submit-button`)[0].addEventListener(`click`, ugs_saveReroll.bind(null, document.querySelector(`[name="category_id"]`), document.querySelector(`[name="reroll_winner_id"]`)));
    }
  }

  async function ugs_saveReroll(category, winner) {
    let rerolls;
    if (category.value === `1`) {
      const id = winner.value;
      if (id) {
        rerolls = JSON.parse(await getValue(`rerolls`));
        if (rerolls.indexOf(id) < 0) {
          rerolls.push(id);
          setValue(`rerolls`, JSON.stringify(rerolls));
        }
      }
    }
  }

  function ugs_openPopup(ugs) {
    let checkMemberSwitch, checkDifferenceSwitch;
    if (!ugs.popup) {
      ugs.popup = new Popup(`fa-gift`, `Send unsent gifts:`);
      new ToggleSwitch(ugs.popup.description, `ugs_checkRules`, false, `Do not send if the winner has any not activated/multiple wins.`, false, false, `The winners will be checked in real time.`, esgst.ugs_checkRules);
      checkMemberSwitch = new ToggleSwitch(ugs.popup.description, `ugs_checkMember`, false, `Do not send if the winner is no longer a member of at least one of the groups for group giveaways.`, false, false, `The winners will be checked in real time.`, esgst.ugs_checkMember);
      checkDifferenceSwitch = new ToggleSwitch(ugs.popup.description, `ugs_checkDifference`, false, `Do not send if the winner has a gift difference lower than <input class="esgst-ugs-difference" step="0.1" type="number" value="${esgst.ugs_difference}"/>.`, false, false, `The winners will be checked in real time.`, esgst.ugs_checkDifference);
      new ToggleSwitch(ugs.popup.description, `ugs_checkWhitelist`, false, `Do not send if the winner is not on your whitelist.`, false, false, `You must sync your whitelist through the settings menu. Whitelisted winners get a pass for broken rules, so if this option is enabled and the winner is whitelisted, the gift will be sent regardless of whether or not the first option is enabled.`, esgst.ugs_checkWhitelist);
      new ToggleSwitch(ugs.popup.description, `ugs_checkBlacklist`, false, `Do not send if the winner on your blacklist.`, false, false, `You must sync your blacklist through the settings menu. If the winner is blacklisted, but is a member of one of the groups, the gift will be sent anyway.`, esgst.ugs_checkBlacklist);
      if (!esgst.ugs_checkMember) {
        checkDifferenceSwitch.container.classList.add(`esgst-hidden`);
      }
      observeNumChange(checkDifferenceSwitch.name.firstElementChild, `ugs_setDifference`);
      checkMemberSwitch.dependencies.push(checkDifferenceSwitch.container);
      ugs.results = insertHtml(ugs.popup.scrollable, `beforeEnd`, `
        <div class="esgst-hidden markdown">
          <ul>
            <li>
              <span class="esgst-bold">Successfully sent gifts to <span>0</span> winners:</span> <span></span>
            </li>
            <li>
              <span class="esgst-bold">Failed to send gifts to <span>0</span> winners (check the tooltips to find out the cause of the failures):</span> <span></span>
            </li>
          </ul>
        </div>
      `);
      ugs.sent = ugs.results.firstElementChild.firstElementChild;
      ugs.sentCount = ugs.sent.firstElementChild.firstElementChild;
      ugs.sentGifts = ugs.sent.lastElementChild;
      ugs.unsent = ugs.sent.nextElementSibling;
      ugs.unsentCount = ugs.unsent.firstElementChild.firstElementChild;
      ugs.unsentGifts = ugs.unsent.lastElementChild;
      ugs.popup.description.appendChild(new ButtonSet_v2({color1: `green`, color2: `red`, icon1: `fa-send`, icon2: `fa-times-circle`, title1: `Send`, title2: `Cancel`, callback1: ugs_start.bind(null, ugs), callback2: ugs_cancel.bind(null, ugs)}).set);
      ugs.progress = insertHtml(ugs.popup.description, `beforeEnd`, `<div></div>`);
      ugs.overallProgress = insertHtml(ugs.popup.description, `beforeEnd`, `<div></div>`);
      ugs.popup.description.appendChild(ugs.popup.scrollable);
    }
    ugs.popup.open();
  }

  async function ugs_start(ugs) {
    // initialize/reset stuff
    ugs.isCanceled = false;
    ugs.giveaways = [];
    ugs.groups = {};
    ugs.button.classList.add(`esgst-busy`);
    ugs.results.classList.add(`esgst-hidden`);
    ugs.sent.classList.add(`esgst-hidden`);
    ugs.unsent.classList.add(`esgst-hidden`);
    ugs.sentGifts.innerHTML = ugs.unsentGifts.innerHTML = ``;
    ugs.sentCount.textContent = ugs.unsentCount.textContent = `0`;
    ugs.progress.innerHTML = ugs.overallProgress.textContent = ``;

    let unsent = esgst.createdButton.getElementsByClassName(`nav__notification`)[0];
    if (!unsent) {
      // there are no unsent giveaways
      ugs.button.classList.remove(`esgst-busy`);
      ugs.progress.innerHTML = `You do not have any unsent gifts.`;
      return;
    }

    // retrieve unsent giveaways
    ugs.count = parseInt(unsent.textContent);
    let giveaways = [];
    let nextPage = 1;
    let pagination = null;
    let skipped = false;
    do {
      let context = null;
      skipped = false;
      if (nextPage === esgst.currentPage) {
        context = document;
      } else if (document.getElementsByClassName(`esgst-es-page-${nextPage}}`)[0]) {
        // page has been loaded with endless scrolling, so its giveaways were already retrieved when the context was the document
        skipped = true;
        continue;
      } else {
        context = parseHtml((await request({method: `GET`, url: `/giveaways/created/search?page=${nextPage}`})).responseText);
      }
      if (nextPage === 1) {
        ugs.lastPage = lpl_getLastPage(context);
        ugs.lastPage = ugs.lastPage === 999999999 ? `` : ` of ${ugs.lastPage}`;
      }
      ugs.progress.innerHTML = `
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <span>Searching for unsent gifts (page ${nextPage}${ugs.lastPage})...</span>
      `;
      ugs.continue = false;
      let elements = context.getElementsByClassName(`table__row-outer-wrap`);
      for (let i = 0, n = elements.length; i < n; i++) {
        let element = elements[i];
        let unsent = element.getElementsByClassName(`fa icon-red fa-warning`)[0];
        if (unsent) {
          let heading = element.getElementsByClassName(`table__column__heading`)[0];
          let url = heading.getAttribute(`href`);
          giveaways.push({
            code: url.match(/\/giveaway\/(.+?)\//)[1],
            context: unsent,
            name: heading.firstChild.textContent.trim().match(/(.+?)(\s\(.+\sCopies\))?$/)[1],
            url: url
          });
          ugs.continue = true;
          ugs.count -= 1;
        }
      }
      pagination = context.getElementsByClassName(`pagination__navigation`)[0];
      nextPage += 1;
    } while (!ugs.isCanceled && (ugs.count > 0 || ugs.continue) && (skipped || (pagination && !pagination.lastElementChild.classList.contains(`is-selected`))));

    // retrieve the winners/groups of each giveaway
    for (let i = 0, n = giveaways.length; !ugs.isCanceled && i < n; i++) {
      ugs.overallProgress.textContent = `${i} of ${n} giveaways checked...`;
      let giveaway = giveaways[i];
      ugs.giveaways[giveaway.code] = {
        code: giveaway.code,
        context: giveaway.context,
        name: giveaway.name,
        url: giveaway.url,
        winners: []
      };

      // retrieve the winners of the giveaway
      let nextPage = 1;
      let pagination = null;
      do {
        let context = parseHtml((await request({method: `GET`, url: `${giveaway.url}/winners/search?page=${nextPage}`})).responseText);
        if (nextPage === 1) {
          ugs.lastWinnersPage = lpl_getLastPage(context);
          ugs.lastWinnersPage = ugs.lastWinnersPage === 999999999 ? `` : ` of ${ugs.lastWinnersPage}`;
        }
        ugs.progress.innerHTML = `
          <i class="fa fa-circle-o-notch fa-spin"></i>
          <span>Retrieving winners (page ${nextPage}${ugs.lastWinnersPage})...</span>
        `;
        let elements = context.getElementsByClassName(`table__row-outer-wrap`);
        for (let i = 0, n = elements.length; i < n; i++) {
          let element = elements[i];
          if (element.querySelector(`.table__gift-not-sent:not(.is-hidden)`)) {
            ugs.giveaways[giveaway.code].winners.push({
              username: element.getElementsByClassName(`table__column__heading`)[0].textContent,
              values: {},
              winnerId: element.querySelector(`[name="winner_id"]`).value
            });
            ugs.count -= 1;
          }
        }
        if (!ugs.giveaways[giveaway.code].group) {
          ugs.giveaways[giveaway.code].group = context.getElementsByClassName(`featured__column--group`)[0];
        }
        if (!ugs.giveaways[giveaway.code].whitelist) {
          ugs.giveaways[giveaway.code].whitelist = context.getElementsByClassName(`featured__column--whitelist`)[0];
        }
        pagination = context.getElementsByClassName(`pagination__navigation`)[0];
        nextPage += 1;
      } while (!ugs.isCanceled && pagination && !pagination.lastElementChild.classList.contains(`is-selected`));

      // retrieve the groups of the giveaway
      if (esgst.ugs_checkMember && ugs.giveaways[giveaway.code].group) {
        ugs.giveaways[giveaway.code].groups = [];
        let nextPage = 1;
        let pagination = null;
        do {
          let context = parseHtml((await request({method: `GET`, url: `${giveaway.url}/groups/search?page=${nextPage}`})).responseText);
          if (nextPage === 1) {
            ugs.lastGroupsPage = lpl_getLastPage(context);
            ugs.lastGroupsPage = ugs.lastGroupsPage === 999999999 ? `` : ` of ${ugs.lastGroupsPage}`;
          }
          ugs.progress.innerHTML = `
            <i class="fa fa-circle-o-notch fa-spin"></i>
            <span>Retrieving groups (page ${nextPage}${ugs.lastGroupsPage})...</span>
          `;
          let elements = context.getElementsByClassName(`table__row-outer-wrap`);
          for (let i = 0, n = elements.length; i < n; i++) {
            let element = elements[i];
            let heading = element.getElementsByClassName(`table__column__heading`)[0];
            let match = heading.getAttribute(`href`).match(/\/group\/(.+?)\/(.+)/);
            ugs.giveaways[giveaway.code].groups.push({
              avatar: element.getElementsByClassName(`table_image_avatar`)[0].style.backgroundImage.match(/\/avatars\/(.+)_medium/)[1],
              code: match[1],
              name: heading.textContent,
              urlName: match[2]
            });
          }
          pagination = context.getElementsByClassName(`pagination__navigation`)[0];
          nextPage += 1;
        } while (!ugs.isCanceled && pagination && !pagination.lastElementChild.classList.contains(`is-selected`));
      }
    }

    if (ugs.isCanceled) {
      // process canceled
      return;
    }

    let codes = Object.keys(ugs.giveaways);
    let n = codes.length;
    if (n > 0) {
      // send gifts
      ugs.rerolls = JSON.parse(esgst.storage.rerolls);
      ugs.sentWinners = {};
      ugs.winners = {};
      ugs.results.classList.remove(`esgst-hidden`);
      for (let i = 0; !ugs.isCanceled && i < n; i++) {
        ugs.overallProgress.textContent = `${i} of ${n} giveaways checked...`;
        let giveaway = ugs.giveaways[codes[i]];
        for (let j = 0, numWinners = giveaway.winners.length; j < numWinners; j++) {
          let winner = giveaway.winners[j];
          let savedUser = await getUser(esgst.users, winner);

          // check order:
          // 1. check if the winner is being rerolled
          // 2. check if the winner has not activated/multiple wins
          // 3. if passed and it's a group giveaway, check if the winner is still a group member, otherwise go to 3
          // 4. check if the winner is whitelisted, which would give them a pass for not activated/multiple wins
          // 5. finally check if the winner is blacklisted

          if (ugs.rerolls.indexOf(winner.winnerId) > -1) {
            // winner is being rerolled, cannot send gift
            winner.error = `${winner.username} is currently being rerolled.`;
          } else {
            if (esgst.ugs_checkRules) {
              // check if winner has not activated/multiple wins
              ugs.progress.innerHTML = `
                <i class="fa fa-circle-o-notch fa-spin"></i>
                <span>Checking if ${winner.username} has not activated/multiple wins...</span>
              `;
              winner.values.namwc = {
                lastCheck: Date.now(),
                results: {}
              };
              await namwc_checkNotActivated(ugs, winner);
              await namwc_checkMultiple(ugs, winner);
              let notActivated = Array.isArray(winner.values.namwc.results.notActivated) ? winner.values.namwc.results.notActivated.length : winner.values.namwc.results.notActivated;
              let multiple = Array.isArray(winner.values.namwc.results.multiple) ? winner.values.namwc.results.multiple.length : winner.values.namwc.results.multiple;
              if (notActivated && multiple) {
                winner.error = `${winner.username} has ${notActivated} not activated wins and ${multiple} multiple wins.`;
              } else if (notActivated) {
                winner.error = `${winner.username} has ${notActivated} not activated wins.`;
              } else if (multiple) {
                winner.error = `${winner.username} has ${multiple} multiple wins.`;
              }
            }

            if (esgst.ugs_checkMember && giveaway.group && !winner.error) {
              // check if winner is still a group member
              ugs.progress.innerHTML = `
                <i class="fa fa-circle-o-notch fa-spin"></i>
                <span>Checking if ${winner.username} is a member of one of the groups...</span>
              `;
              await getSteamId(null, false, esgst.users, winner);
              let member = false;
              for (let k = 0, numGroups = giveaway.groups.length; k < numGroups; k++) {
                let group = giveaway.groups[k];
                let code = group.code;
                if (!ugs.groups[code]) {
                  // retrieve group members and store them in case another giveaway has the same group
                  let l;
                  for (l = esgst.groups.length - 1; l > -1 && esgst.groups[l].code !== code; l--);
                  if (l < 0) {
                    esgst.groups.push({
                      avatar: group.avatar,
                      code: code,
                      name: group.name
                    });
                    l = esgst.groups.length - 1;
                  }
                  if (!esgst.groups[l].steamId) {
                    esgst.groups[l].steamId = parseHtml((await request({method: `GET`, url: `/group/${code}/`})).responseText).getElementsByClassName(`sidebar__shortcut-inner-wrap`)[0].firstElementChild.getAttribute(`href`).match(/\d+/)[0];
                  }
                  ugs.groups[code] = (await request({method: `GET`, url: `http://steamcommunity.com/gid/${esgst.groups[l].steamId}/memberslistxml?xml=1`})).responseText.match(/<steamID64>.+?<\/steamID64>/g);
                  for (l = ugs.groups[code].length - 1; l > -1; l--) {
                    ugs.groups[code][l] = ugs.groups[code][l].match(/<steamID64>(.+?)<\/steamID64>/)[1];
                  }
                }

                if (ugs.groups[code].indexOf(winner.steamId) < 0) {
                  // winner is not a member of this group, continue to check the next group
                  continue;
                }

                if (!esgst.ugs_checkDifference) {
                  // no need to check gift difference, gift can be sent
                  member = true;
                  break;
                }

                // check winner's gift difference
                ugs.progress.innerHTML = `
                  <i class="fa fa-circle-o-notch fa-spin"></i>
                  <span>Checking if ${winner.username} has a gift difference higher than the one set...</span>
                `;
                let element = parseHtml((await request({method: `GET`, url: `/group/${code}/${group.urlName}/users/search?q=${winner.username}`})).responseText).getElementsByClassName(`table__row-outer-wrap`)[0];
                if (element && element.getElementsByClassName(`table__column__heading`)[0].textContent === winner.username) {
                  let difference = parseFloat(element.getElementsByClassName(`table__column--width-small`)[2].textContent);
                  if (difference >= esgst.ugs_difference) {
                    member = true;
                    break;
                  }
                  winner.error = `${winner.username} has a ${difference} gift difference.`;
                  break;
                }
              }
              if (!winner.error && !member) {
                winner.error = `${winner.username} is not a member of one of the groups.`;
              }
            }

            if (esgst.ugs_checkWhitelist) {
              // check if winner is whitelisted
              winner.error = savedUser && savedUser.whitelisted ? null : `${winner.username} is not whitelisted.`;
            }

            if (esgst.ugs_checkBlacklist && savedUser && savedUser.blacklisted && !winner.error) {
              // check if winner is blacklisted
              winner.error = `${winner.username} is blacklisted.`;
            }
          }

          // send gift to the winner or not, based on the previous checks
          if (!ugs.winners[winner.username]) {
            ugs.winners[winner.username] = [];
          }
          if (ugs.winners[winner.username].indexOf(giveaway.name) < 0) {
            if (winner.error) {
              ugs.unsent.classList.remove(`esgst-hidden`);
              ugs.unsentCount.textContent = parseInt(ugs.unsentCount.textContent) + 1;
              ugs.unsentGifts.insertAdjacentHTML(`beforeEnd`, `
                <span>
                  <a href="/user/${winner.username}">${winner.username}</a> (<a href="${giveaway.url}/winners">${giveaway.name}</a>)
                  <i class="fa fa-question-circle" title="${winner.error}"></i>
                </span>
              `);
            } else if (!ugs.isCanceled) {
              await request({data: `xsrf_token=${esgst.xsrfToken}&do=sent_feedback&action=1&winner_id=${winner.winnerId}`, method: `POST`, url: `/ajax.php`});
              if (!ugs.sentWinners[giveaway.code]) {
                ugs.sentWinners[giveaway.code] = [];
              }
              ugs.sent.classList.remove(`esgst-hidden`);
              ugs.sentWinners[giveaway.code].push(winner.username);
              ugs.sentCount.textContent = parseInt(ugs.sentCount.textContent) + 1;
              ugs.sentGifts.insertAdjacentHTML(`beforeEnd`, `
                <span>
                  <a href="/user/${winner.username}">${winner.username}</a> (<a href="${giveaway.url}/winners">${giveaway.name}</a>)
                </span>
              `);
              ugs.winners[winner.username].push(giveaway.name);
              if (document.body.contains(giveaway.context)) {
                giveaway.context.className = `fa fa-check-circle icon-green`;
                giveaway.context.nextElementSibling.textContent = `Sent`;
              }
            }
          } else {
            // exact same game has already been sent to this winner, meaning they won multiple copies of the same game, so extra gifts cannot be sent
            ugs.unsent.classList.remove(`esgst-hidden`);
            ugs.unsentCount.textContent = parseInt(ugs.unsentCount.textContent) + 1;
            ugs.unsentGifts.insertAdjacentHTML(`beforeEnd`, `
              <span>
                <a href="/user/${winner.username}">${winner.username}</a> (<a href="${giveaway.url}/winners">${giveaway.name}</a>)
                <i class="fa fa-question-circle" title="${winner.username} already won ${giveaway.name} from another giveaway of yours"></i>
              </span>
            `);
          }
        }
      }

      // finalize process
      let winners = JSON.parse(await getValue(`winners`, `{}`));
      for (let key in ugs.sentWinners) {
        if (!winners[key]) {
          winners[key] = [];
        }
        for (let i = 0, n = ugs.sentWinners[key].length; i < n; i++) {
          winners[key].push(ugs.sentWinners[key][i]);
        }
      }
      let savedUsers = [];
      for (let key in ugs.giveaways) {
        for (let i = 0, n = ugs.giveaways[key].winners.length; i < n; i++) {
          savedUsers.push(ugs.giveaways[key].winners[i]);
        }
      }
      ugs.progress.innerHTML = `
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <span>Saving data...</span>
      `;
      ugs.overallProgress.textContent = ``;
      await Promise.all([setValue(`winners`, JSON.stringify(winners)), saveUsers(savedUsers), setValue(`groups`, JSON.stringify(esgst.groups))]);
      ugs.button.classList.remove(`esgst-busy`);
      ugs.progress.innerHTML = ``;
    } else {
      // there are no unsent gifts
      ugs.button.classList.remove(`esgst-busy`);
      ugs.progress.innerHTML = `You do not have any unsent gifts.`;
    }
  }

  function ugs_cancel(ugs) {
    ugs.isCanceled = true;
    ugs.button.classList.remove(`esgst-busy`);
    ugs.progress.innerHTML = ``;
    ugs.overallProgress.textContent = ``;
  }
  
  // [UST]

  _MODULES.push({
    description: `
      <ul>
        <li>When checking a user with [id=namwc], that feature will also check if the user has already served suspensions for any infractions found so that you do not need to report them again.</li>
        <li>It is impossible to retrieve that information automatically, so the database (which is kept globally in a Google Sheet) needs to be maintained by ESGST users. For that, this feature adds 2 identical buttons (<i class="fa fa-paper-plane"></i>) to the main page heading of 2 different locations:</li>
        <ul>
          <li>Your <a href="https://www.steamgifts.com/support/tickets">tickets</a> page, which allows you to send multiple tickets to the database at once. The feature adds a checkbox in front of each ticket that belongs to one of the accepted categories so that you can select the tickets that you want to send. There are shortcuts that can help you select them:</li>
          <ul>
            <li>Clicking on an unchecked checkbox with the Ctrl key pressed will select all of the tickets.</li>
            <li>Clicking on a checked checkbox with the Ctrl key pressed will unselect all of the tickets.</li>
            <li>Clicking on any checkbox with the Alt key pressed will toggle all of the tickets (any tickets that were unselected will be selected and any tickets that were selected will be unselected).</li>
          </ul>
          <li>A ticket you created, which allows you to send that single ticket to the database.</li>
        </ul>
        <li>You can only send tickets that belong to one of the accepted categories to the database:</li>
        <ul>
          <li>Request New Winner > Did Not Activate Previous Wins This Month</li>
          <li>Request New Winner > Other</li>
          <li>User Report > Multiple Wins for the Same Game</li>
          <li>User Report > Not Activating Won Gift</li>
        </ul>
        <li>When you send a ticket, the HTML containing all of the ticket's information (including any comments) is sent to the database, and the ticket is requested before being sent, which prevents users from tampering with the HTML.</li>
        <li>After you send a ticket you will no longer have the option to send it again, to prevent duplicate entries.</li>
      </ul>
    `,
    id: `ust`,
    load: ust,
    name: `User Suspension Tracker`,
    sg: true,
    st: true,
    type: `users`
  });

  function ust() {
    if (esgst.ticketsPath) {
      esgst.ustButton = createHeadingButton({id: `ust`, icons: [`fa-paper-plane`], title: `Send selected tickets to the User Suspension Tracker database`});
      esgst.ustButton.addEventListener(`click`, ust_sendAll);
    } else if (esgst.ticketPath && document.getElementsByClassName(`table__column--width-fill`)[1].textContent.trim().match(/Did\sNot\sActivate\sPrevious\sWins\sThis\sMonth|Other|Multiple\sWins\sfor\sthe\sSame\sGame|Not\sActivating\sWon\sGift/)) {
      let code, tickets;
      code = location.pathname.match(/\/ticket\/(.+?)\//)[1];
      tickets = JSON.parse(esgst.storage.tickets);
      if (!tickets[code] || !tickets[code].sent) {
        esgst.ustButton = insertHtml(document.getElementsByClassName(`page__heading`)[0].lastElementChild, `beforeBegin`, `
          <div class="esgst-heading-button" title="${getFeatureTooltip(`ust`, `Send ticket to the User Suspension Tracker database`)}">
            <i class="fa fa-paper-plane"></i>
          </div>
        `);
        esgst.ustButton.addEventListener(`click`, ust_send);
      }
    }
  }

  async function ust_sendAll() {
    esgst.ustButton.removeEventListener(`click`, ust_sendAll);
    esgst.ustButton.innerHTML =  `<i class="fa fa-circle-o-notch fa-spin"></i>`;
    let n = Object.keys(esgst.ustCheckboxes).length;
    let numError = 0;
    let promises = [];
    let obj = {
      data: ``
    };
    for (let code in esgst.ustCheckboxes) {
      promises.push(ust_check(code, obj));
    }
    await Promise.all(promises);
    let error = JSON.parse((await request({data: obj.data.slice(0, -1), method: `POST`, url: `https://script.google.com/macros/s/AKfycbwdKNormCJs-hEKV0GVwawgWj1a26oVtPylgmxOOvNk1Gf17A/exec`})).responseText).error;
    let tickets = JSON.parse(await getValue(`tickets`));
    for (let code in esgst.ustCheckboxes) {
      if (error.indexOf(code) < 0) {
        if (!tickets[code]) {
          tickets[code] = {
            readComments: {}
          };
        }
        tickets[code].sent = 1;
        esgst.numUstTickets -= 1;
        esgst.ustCheckboxes[code].remove();
        delete esgst.ustCheckboxes[code];
      } else {
        numError += 1;
      }
    }
    await setValue(`tickets`, JSON.stringify(tickets));
    if (n === esgst.numUstTickets) {
      esgst.ustButton.remove();
    } else {
      esgst.ustButton.innerHTML = `<i class="fa fa-paper-plane"></i>`;
      esgst.ustButton.addEventListener(`click`, ust_sendAll);
    }
    esgst.ustCheckboxes = [];
    new Popup(``, `${n - numError} out of ${n} tickets sent! They will be analyzed and, if accepted, added to the database in 48 hours at most.${numError > 0 ? ` Try sending the tickets that failed again later.` : ``}`, true).open();
  }

  async function ust_check(code, obj) {
    let responseHtml = parseHtml((await request({method: `GET`, url: `/support/ticket/${code}/`})).responseText);
    if (responseHtml.getElementsByClassName(`table__column--width-fill`)[1].textContent.trim().match(/Did\sNot\sActivate\sPrevious\sWins\sThis\sMonth|Other|Multiple\sWins\sfor\sthe\sSame\sGame|Not\sActivating\sWon\sGift/)) {
      obj.data += `${code}=${encodeURIComponent(responseHtml.getElementsByClassName(`sidebar`)[0].nextElementSibling.innerHTML.replace(/\n|\r|\r\n|\s{2,}/g, ``).trim())}&`;
    }
  }

  async function ust_send() {
    let code = location.href.match(/\/ticket\/(.+?)\//)[1];
    esgst.ustButton.removeEventListener(`click`, ust_send);
    esgst.ustButton.innerHTML =  `<i class="fa fa-circle-o-notch fa-spin"></i>`;
    let error = JSON.parse(
      (await request({
        data: `${code}=${encodeURIComponent(parseHtml(
          (await request({method: `GET`, url: location.href})).responseText
        ).getElementsByClassName(`sidebar`)[0].nextElementSibling.innerHTML.replace(/\n|\r|\r\n|\s{2,}/g, ``).trim())}`,
        method: `POST`,
        url: `https://script.google.com/macros/s/AKfycbwdKNormCJs-hEKV0GVwawgWj1a26oVtPylgmxOOvNk1Gf17A/exec`
      })
    ).responseText).error;
    if (error.length === 0) {
      let tickets = JSON.parse(await getValue(`tickets`));
      if (!tickets[code]) {
        tickets[code] = {
          readComments: {}
        };
      }
      tickets[code].sent = 1;
      await setValue(`tickets`, JSON.stringify(tickets));
      esgst.ustButton.remove();
      new Popup(``, `Ticket sent! It will be analyzed and, if accepted, added to the database in 48 hours at most.`, true).open();
    } else {
      esgst.ustButton.innerHTML = `<i class="fa fa-paper-plane"></i>`;
      esgst.ustButton.addEventListener(`click`, ust_send);
      new Popup(``, `An error ocurred. Please try again later.`, true).open();
    }
  }

  function ust_addCheckbox(code, context) {
    if (!context.getElementsByClassName(`esgst-ust-checkbox`)[0]) {
      context.classList.add(`esgst-relative`);
      let checkbox = new Checkbox(context);
      checkbox.checkbox.classList.add(`esgst-ust-checkbox`);
      esgst.ustTickets[code] = checkbox;
      checkbox.onEnabled = event => {
        if (event) {
          if (event.ctrlKey) {
            for (let code in esgst.ustTickets) {
              esgst.ustTickets[code].check();
            }
          } else if (event.altKey) {
            checkbox.toggle();
            for (let code in esgst.ustTickets) {
              esgst.ustTickets[code].toggle();
            }
          }
        }
        esgst.ustCheckboxes[code] = checkbox.checkbox;
      };
      checkbox.onDisabled = event => {
        if (event) {
          if (event.ctrlKey) {
            for (let code in esgst.ustTickets) {
              esgst.ustTickets[code].uncheck();
            }
          } else if (event.altKey) {
            checkbox.toggle();
            for (let code in esgst.ustTickets) {
              esgst.ustTickets[code].toggle();
            }
          }
        }
        delete esgst.ustCheckboxes[code];
      };
      esgst.numUstTickets += 1;
    }
  }
  
  // [WBC]

  _MODULES.push({
    description: `
      <ul>
        <li>Adds a button (<i class="fa fa-heart"></i> <i class="fa fa-ban"></i> <i class="fa fa-question-circle"></i>) to the main page heading of any page that allows you to check which users in the page have whitelisted/blacklisted you.</li>
        <li>That information is retrieved by searching for whitelist giveaways in the user's <a href="https://www.steamgifts.com/user/cg">profile</a> page and checking if you can access them. If no whitelist giveaways are found, the feature searches for group + whitelist giveaways instead and checks if you can access them using the groups that you are a member of to determine whether you can access them for being a group member or for being in the user's whitelist.</li>
        <li>There are many options that allow you to narrow down the check: you can select which users to check, check only if the user has blacklisted you (which is faster than checking if they have whitelisted you because it does not need to find a whitelist giveaway), how many pages to check, whether or not to check again users that were already checked and whether or not to skip users that the feature is taking too long to find whitelist giveaways from.</li>
        <li>There are also options to return whitelists/blacklists, which means that if a user that has whitelisted/blacklisted you is found, they will be whitelisted/blacklisted back.</li>
        <li>Adds a button (<i class="fa fa-heart"></i> <i class="fa fa-ban"></i> <i class="fa fa-gear"></i>) to the page heading of this menu that allows you to view/update all of the users that have been checked.</li>
        <li>Results are cached for 24 hours, so if you check the same user again within that timeframe, their status will not change, unless you check them with the option to clear the cache enabled.</li>
      </ul>
    `,
    features: {
      wbc_h: {
        description: `
          <ul>
            <li>Adds an icon (<i class="fa fa-check esgst-whitelist"></i> if the user has whitelisted you and <i class="fa fa-times esgst-blacklist"></i> if they have blacklisted you) next to a checked user's username (in any page).</li>
            <li>If you hover over the icon, it shows the date when they were checked for the last time.</li>
          </ul>
        `,
        name: `Highlight checked users.`,
        sg: true,
        st: true
      },
      wbc_n: {
        description: `
          <ul>
            <li>If you have [id=un] enabled, a note will be saved for a user if they were whitelisted/blacklisted back.</li>
          </ul>
        `,
        name: `Save automatic notes when returning whitelists/blacklists.`,
        sg: true
      },
      wbc_hb: {
        description: `
          <ul>
            <li>With this option enabled, the feature will not tell you if a user has blacklisted you (in fact, the name of the feature will change to Whitelist Checker for you). If the feature finds a user that has blacklisted you, it will tell you that it could not determine their status.</li>
          </ul>
        `,
        name: `Hide blacklist information.`,
        sg: true
      }
    },
    id: `wbc`,
    load: wbc,
    name: `Whitelist/Blacklist Checker`,
    sg: true,
    sync: `Steam Groups`,
    type: `users`
  });

  function wbc() {
    if (!esgst.mainPageHeading) return;
    let [icons, title] = !esgst.wbc_hb ? [[`fa-heart`, `fa-ban`, `fa-question-circle`], `Check for whitelists/blacklists`] : [[`fa-heart`, `fa-question-circle`], `Check for whitelists`];
    esgst.wbcButton = createHeadingButton({id: `wbc`, icons, title});
    wbc_addButton(true, esgst.wbcButton);
  }

  function wbc_addButton(Context, WBCButton) {
    let checkAllSwitch, checkPagesSwitch, checkSingleSwitch, popup, skip, WBC;
    WBC = {
      Update: (Context ? false : true),
      B: !esgst.wbc_hb,
      Username: esgst.username
    };
    popup = new Popup(WBC.Update ? `fa-cog` : `fa-question`, WBC.Update ? `Manage Whitelist/Blacklist Checker caches:` : `Check for whitelists${WBC.B ? `/blacklists` : ``}:`);
    if (location.pathname.match(new RegExp(`^/user/(?!${WBC.Username})`))) {
      WBC.User = {
        Username: document.getElementsByClassName(`featured__heading__medium`)[0].textContent,
        ID: document.querySelector(`[name="child_user_id"]`).value,
        SteamID64: document.querySelector(`a[href*="/profiles/"]`).href.match(/\d+/)[0],
      };
    }
    popup.Options = insertHtml(popup.description, `beforeEnd`, `<div></div>`);
    if (WBC.User) {
      checkSingleSwitch = new ToggleSwitch(popup.Options, `wbc_checkSingle`, false, `Only check ${WBC.User ? WBC.User.Username : `current user`}.`, false, false, `If disabled, all users in the current page will be checked.`, esgst.wbc_checkSingle);
    }
    let feat = getFeatureNumber(`mm`);
    let checkSelectedSwitch = new ToggleSwitch(popup.Options, `wbc_checkSelected`, false, `Only check selected.`, false, false, `Use ${feat.number} ${feat.name} to select the users that you want to check. Then click the button 'Check WL/BL' in the Multi-Manager popout and you will be redirected here.`, esgst.wbc_checkSelected);
    if (WBC.B) {
      new ToggleSwitch(popup.Options, `wbc_checkBlacklist`, false, `Only check blacklist.`, false, false, `If enabled, a blacklist-only check will be performed (faster).`, esgst.wbc_checkBlacklist);
    }
    if (!WBC.Update && !location.pathname.match(/^\/(discussions|users|archive)/)) {
      checkAllSwitch = new ToggleSwitch(popup.Options, `wbc_checkAll`, false, `Check all pages.`, false, false, `If disabled, only the current page will be checked.`, esgst.wbc_checkAll);
      checkPagesSwitch = new ToggleSwitch(popup.Options, `wbc_checkPages`, false, `Check only pages from <input class="esgst-switch-input" min="1" type="number" value="${esgst.wbc_minPage}"> to <input class="esgst-switch-input" min="1" type="number" value="${esgst.wbc_maxPage}">.`, false, false, null, esgst.wbc_checkPages);
      let minPage = checkPagesSwitch.name.firstElementChild;
      let maxPage = minPage.nextElementSibling;
      let lastPage = lpl_getLastPage(document, true);
      if (lastPage !== 999999999) {
        maxPage.setAttribute(`max`, lastPage);
      }
      observeNumChange(minPage, `wbc_minPage`);
      observeNumChange(maxPage, `wbc_maxPage`);
    }
    new ToggleSwitch(popup.Options, `wbc_returnWhitelists`, false, `Return whitelists.`, false, false, `If enabled, everyone who has whitelisted you will be whitelisted back.`, esgst.wbc_returnWhitelists);
    if (WBC.B) {
      new ToggleSwitch(popup.Options, `wbc_returnBlacklists`, false, `Return blacklists.`, false, false, `If enabled, everyone who has blacklisted you will be blacklisted back.`, esgst.wbc_returnBlacklists);
    }
    new ToggleSwitch(popup.Options, `wbc_checkNew`, false, `Only check users who have not whitelisted ${WBC.B ? `/blacklisted` : ``} you.`, false, false, `If enabled, everyone who has whitelisted ${WBC.B ? `/blacklisted` : ``} you will be ignored (might lead to outdated data if someone who had whitelisted ${WBC.B ? `/blacklisted` : ``} you in the past removed you from those lists).`, esgst.wbc_checkNew);
    observeNumChange(new ToggleSwitch(popup.Options, `wbc_skipUsers`, false, `Skip users after <input class="esgst-ugs-difference" type="number" value="${esgst.wbc_pages}"/> pages.`, false, false, `If enabled, when a user check passes the number of pages specified, the user will be skipped.`, esgst.wbc_skipUsers).name.firstElementChild, `wbc_pages`);
    new ToggleSwitch(popup.Options, `wbc_clearCache`, false, `Clear caches.`, false, false, `If enabled, the caches of all checked users will be cleared (slower).`, esgst.wbc_clearCache);
    if (checkSingleSwitch || checkAllSwitch || checkPagesSwitch) {
      if (checkSingleSwitch) {
        if (checkAllSwitch) {
          checkSingleSwitch.exclusions.push(checkAllSwitch.container);
        }
        if (checkPagesSwitch) {
          checkSingleSwitch.exclusions.push(checkPagesSwitch.container);
        }
        checkSingleSwitch.exclusions.push(checkSelectedSwitch.container);
        checkSelectedSwitch.exclusions.push(checkSingleSwitch.container);
        if (esgst.wbc_checkSingle) {
          if (checkAllSwitch) {
            checkAllSwitch.container.classList.add(`esgst-hidden`);
          }
          if (checkPagesSwitch) {
            checkPagesSwitch.container.classList.add(`esgst-hidden`);
          }
          checkSelectedSwitch.container.classList.add(`esgst-hidden`);
        } else if (esgst.wbc_checkSelected) {
          checkSingleSwitch.container.classList.add(`esgst-hidden`);
        }
      }
      if (checkAllSwitch) {
        if (checkSingleSwitch) {
          checkAllSwitch.exclusions.push(checkSingleSwitch.container);
        }
        if (checkPagesSwitch) {
          checkAllSwitch.exclusions.push(checkPagesSwitch.container);
        }
        checkSelectedSwitch.exclusions.push(checkAllSwitch.container);
        checkAllSwitch.exclusions.push(checkSelectedSwitch.container);
        if (esgst.wbc_checkAll) {
          if (checkSingleSwitch) {
            checkSingleSwitch.container.classList.add(`esgst-hidden`);
          }
          if (checkPagesSwitch) {
            checkPagesSwitch.container.classList.add(`esgst-hidden`);
          }
          checkSelectedSwitch.container.classList.add(`esgst-hidden`);
        } else if (esgst.wbc_checkSelected) {
          checkAllSwitch.container.classList.add(`esgst-hidden`);
        }
      }
      if (checkPagesSwitch) {
        if (checkSingleSwitch) {
          checkPagesSwitch.exclusions.push(checkSingleSwitch.container);
        }
        if (checkAllSwitch) {
          checkPagesSwitch.exclusions.push(checkAllSwitch.container);
        }
        checkSelectedSwitch.exclusions.push(checkPagesSwitch.container);
        checkPagesSwitch.exclusions.push(checkSelectedSwitch.container);
        if (esgst.wbc_checkPages) {
          if (checkSingleSwitch) {
            checkSingleSwitch.container.classList.add(`esgst-hidden`);
          }
          if (checkAllSwitch) {
            checkAllSwitch.container.classList.add(`esgst-hidden`);
          }
          checkSelectedSwitch.container.classList.add(`esgst-hidden`);
        } else if (esgst.wbc_checkSelected) {
          checkPagesSwitch.container.classList.add(`esgst-hidden`);
        }
      }
    }
    popup.Options.insertAdjacentHTML(`afterEnd`, `<div class="esgst-description">If an user is highlighted, that means they have been either checked for the first time or updated.</div>`);
    popup.description.appendChild(new ButtonSet(`green`, `grey`, WBC.Update ? `fa-refresh` : `fa-question-circle`, `fa-times-circle`, WBC.Update ? `Update` : `Check`, `Cancel`, Callback => {
      WBC.ShowResults = false;
      WBCButton.classList.add(`esgst-busy`);
      wbc_setCheck(WBC, skip, () => {
        skip.innerHTML = ``;
        WBCButton.classList.remove(`esgst-busy`);
        Callback();
        WBC.popup.setDone();
      });
    }, () => {
      skip.innerHTML = ``;
      clearInterval(WBC.Request);
      clearInterval(WBC.Save);
      WBC.Canceled = true;
      setTimeout(() => {
        WBC.Progress.innerHTML = ``;
      }, 500);
      WBCButton.classList.remove(`esgst-busy`);
    }).set);
    skip = insertHtml(popup.description, `beforeEnd`, `<div></div>`);
    WBC.Progress = insertHtml(popup.description, `beforeEnd`, `<div></div>`);
    WBC.OverallProgress = insertHtml(popup.description, `beforeEnd`, `<div></div>`);
    popup.Results = insertHtml(popup.scrollable, `beforeEnd`, `<div></div>`);
    createResults(popup.Results, WBC, [{
      Icon: `<i class="fa fa-heart esgst-whitelist"></i> `,
      Description: `You are whitelisted by`,
      Key: `whitelisted`
    }, {
      Icon: `<i class="fa fa-ban esgst-blacklist"></i> `,
      Description: `You are blacklisted by`,
      Key: `blacklisted`
    }, {
      Icon: `<i class="fa fa-check-circle"></i> `,
      Description: WBC.B ? "You are neither whitelisted nor blacklisted by" : `You are not whitelisted by`,
      Key: `none`
    }, {
      Icon: `<i class="fa fa-question-circle"></i> `,
      Description: `You are not blacklisted and there is not enough information to know if you are whitelisted by`,
      Key: `notBlacklisted`
    }, {
      Icon: `<i class="fa fa-question-circle"></i> `,
      Description: `There is not enough information to know if you are whitelisted${WBC.B ? ` or blacklisted` : ``} by`,
      Key: `unknown`
    }, {
      Icon: `<i class="fa fa-forward"></i> `,
      Description: `Skipped users`,
      Key: `skipped`
    }]);
    WBCButton.addEventListener(`click`, () => {
      if (WBCButton.getAttribute(`data-mm`)) {
        if (!esgst.wbc_checkSelected) {
          if (esgst.wbc_checkSingle && checkSingleSwitch) {
            let element = insertHtml(checkSingleSwitch.container, `afterBegin`, `
              <span class="esgst-bold esgst-red">Disable this --></span>
            `);
            setTimeout(() => element.remove(), 5000);
          } else if (esgst.wbc_checkAll) {
            let element = insertHtml(checkAllSwitch.container, `afterBegin`, `
              <span class="esgst-bold esgst-red">Disable this --></span>
            `);
            setTimeout(() => element.remove(), 5000);
          } else if (esgst.wbc_checkPages) {
            let element = insertHtml(checkPagesSwitch.container, `afterBegin`, `
              <span class="esgst-bold esgst-red">Disable this --></span>
            `);
            setTimeout(() => element.remove(), 5000);
          }
          let element = insertHtml(checkSelectedSwitch.container, `afterBegin`, `
            <span class="esgst-bold esgst-red">Enable this --></span>
          `);
          setTimeout(() => element.remove(), 5000);
        }
        WBCButton.removeAttribute(`data-mm`);
      }
      WBC.popup = popup;
      popup.open(() => {
        if (WBC.Update) {
          WBC.ShowResults = true;
          wbc_setCheck(WBC, skip);
        }
      });
    });
  }

  async function wbc_setCheck(WBC, skip, Callback) {
    let SavedUsers, I, N;
    WBC.Progress.innerHTML = WBC.OverallProgress.innerHTML = ``;
    WBC.whitelisted.classList.add(`esgst-hidden`);
    WBC.blacklisted.classList.add(`esgst-hidden`);
    WBC.none.classList.add(`esgst-hidden`);
    WBC.notBlacklisted.classList.add(`esgst-hidden`);
    WBC.unknown.classList.add(`esgst-hidden`);
    WBC.skipped.classList.add(`esgst-hidden`);
    WBC.whitelistedCount.textContent = WBC.blacklistedCount.textContent = WBC.noneCount.textContent = WBC.notBlacklistedCount.textContent = WBC.unknownCount.textContent = WBC.skippedCount.textContent = `0`;
    WBC.whitelistedUsers.innerHTML = WBC.blacklistedUsers.innerHTML = WBC.noneUsers.innerHTML = WBC.notBlacklistedUsers.innerHTML = WBC.unknownUsers.innerHTML = WBC.skippedUsers.innerHTML = ``;
    WBC.Users = [];
    WBC.Canceled = false;
    if (WBC.Update) {
      SavedUsers = JSON.parse(await getValue(`users`));
      for (I in SavedUsers.users) {
        if (SavedUsers.users[I].wbc && SavedUsers.users[I].wbc.result) {
          WBC.Users.push(SavedUsers.users[I].username);
        }
      }
      WBC.Users = sortArray(WBC.Users);
      if (WBC.ShowResults) {
        for (I = 0, N = WBC.Users.length; I < N; ++I) {
          let user = {
            steamId: SavedUsers.steamIds[WBC.Users[I]],
            id: SavedUsers.users[SavedUsers.steamIds[WBC.Users[I]]].id,
            username: WBC.Users[I]
          };
          wbc_setResult(WBC, user, SavedUsers.users[SavedUsers.steamIds[WBC.Users[I]]].wbc, SavedUsers.users[SavedUsers.steamIds[WBC.Users[I]]].notes, SavedUsers.users[SavedUsers.steamIds[WBC.Users[I]]].whitelisted, SavedUsers.users[SavedUsers.steamIds[WBC.Users[I]]].blacklisted, false);
        }
      } else {
        skip.appendChild(new ButtonSet(`green`, ``, `fa-forward`, ``, `Skip User`, ``, callback => {
          callback();
          WBC.manualSkip = true;
        }).set);
        wbc_checkUsers(WBC, 0, WBC.Users.length, Callback);
      }
    } else if (WBC.User && esgst.wbc_checkSingle) {
      WBC.Users.push(WBC.User.Username);
      wbc_checkUsers(WBC, 0, 1, Callback);
    } else {
      if (esgst.wbc_checkSelected) {
        WBC.Users = Array.from(esgst.mmWbcUsers);
      } else if (!esgst.wbc_checkPages) {
        let elements = esgst.pageOuterWrap.querySelectorAll(`a[href*="/user/"]`);
        for (let element of elements) {
          let match = element.getAttribute(`href`).match(/\/user\/(.+)/);
          if (!match) continue;
          let username = match[1];
          if (WBC.Users.indexOf(username) > -1 || username === esgst.username || username !== element.textContent || element.closest(`.markdown`)) continue;
          WBC.Users.push(username);
        }
      }
      if ((esgst.wbc_checkAll || esgst.wbc_checkPages) && ((((WBC.User && !esgst.wbc_checkSingle) || !WBC.User) && !WBC.Update && !location.pathname.match(/^\/(discussions|users|archive)/)))) {
        WBC.lastPage = esgst.wbc_checkPages ? `of ${esgst.wbc_maxPage}` : ``;
        wbc_getUsers(WBC, esgst.wbc_checkPages ? (esgst.wbc_minPage - 1) : 0, esgst.currentPage, esgst.searchUrl, () => {
          skip.appendChild(new ButtonSet(`green`, ``, `fa-forward`, ``, `Skip User`, ``, callback => {
            callback();
            WBC.manualSkip = true;
          }).set);
          WBC.Users = sortArray(WBC.Users);
          wbc_checkUsers(WBC, 0, WBC.Users.length, Callback);
        });
      } else {
        skip.appendChild(new ButtonSet(`green`, ``, `fa-forward`, ``, `Skip User`, ``, callback => {
          callback();
          WBC.manualSkip = true;
        }).set);
        WBC.Users = sortArray(WBC.Users);
        wbc_checkUsers(WBC, 0, WBC.Users.length, Callback);
      }
    }
  }

  function wbc_skipUser(wbc, username) {
    wbc.manualSkip = false;
    wbc.skipped.classList.remove(`esgst-hidden`);
    wbc.skippedCount.textContent = parseInt(wbc.skippedCount.textContent) + 1;
    wbc.skippedUsers.insertAdjacentHTML(`beforeEnd`, `<a href="/user/${username}">${username}</a>`);
  }

  async function wbc_checkUsers(WBC, I, N, Callback) {
    let User, Result;
    if (!WBC.Canceled) {
      WBC.Progress.innerHTML = ``;
      WBC.OverallProgress.textContent = `${I} of ${N} users checked...`;
      if (I < N) {
        if (WBC.manualSkip) {
          wbc_skipUser(WBC, WBC.Users[I]);
          setTimeout(() => wbc_checkUsers(WBC, ++I, N, Callback), 0);
        } else {
          User = (WBC.User && esgst.wbc_checkSingle) ? WBC.User : {
            Username: WBC.Users[I]
          };
          let user = {
            steamId: User.SteamID64,
            id: User.ID,
            username: User.Username
          };
          let notes, whitelisted, blacklisted, wbc;
          const savedUser = await getUser(null, user);
          if (savedUser) {
            notes = savedUser.notes;
            whitelisted = savedUser.whitelisted;
            blacklisted = savedUser.blacklisted;
            wbc = savedUser.wbc;
          }
          if (wbc && wbc.result) {
            Result = wbc.result;
          }
          if (!wbc || !esgst.wbc_checkNew) {
            wbc_checkUser(WBC, wbc, user.username, wbc => {
              if (wbc) {
                setTimeout(() => wbc_setResult(WBC, user, wbc, notes, whitelisted, blacklisted, (Result != wbc.result) ? true : false, I, N, Callback), 0);
              } else {
                wbc_skipUser(WBC, user.username);
                setTimeout(() => wbc_checkUsers(WBC, ++I, N, Callback), 0);
              }
            });
          } else {
            setTimeout(() => wbc_setResult(WBC, user, wbc, notes, whitelisted, blacklisted, (Result != wbc.result) ? true : false, I, N, Callback), 0);
          }
        }
      } else if (Callback) {
        Callback();
      }
    }
  }

  async function wbc_setResult(WBC, user, wbc, notes, whitelisted, blacklisted, New, I, N, Callback) {
    let Key;
    if (!WBC.Canceled) {
      Key = ((wbc.result === `blacklisted` || wbc.result === `notBlacklisted`) && !WBC.B) ? `unknown` : wbc.result;
      WBC[Key].classList.remove(`esgst-hidden`);
      WBC[`${Key}Count`].textContent = parseInt(WBC[`${Key}Count`].textContent) + 1;
      WBC[`${Key}Users`].insertAdjacentHTML(`beforeEnd`, `<a ${New ? `class="esgst-bold esgst-italic" ` : ``}href="/user/${user.username}">${user.username}</a>`);
      if (!WBC.ShowResults) {
        if ((esgst.wbc_returnWhitelists && (wbc.result === `whitelisted`) && !whitelisted) || (WBC.B && esgst.wbc_returnBlacklists && (wbc.result === `blacklisted`) && !blacklisted)) {
          if (user.id) {
            wbc_returnWlBl(WBC, wbc, user.username, user.id, notes, async (success, notes) => {
              if (success) {
                user.values = {
                  wbc: wbc,
                  whitelisted: false,
                  blacklisted: false
                };
                if (notes) {
                  user.values.notes = notes;
                }
                user.values[wbc.result] = true;
                user.values[`${wbc.result}Date`] = Date.now();
              }
              await saveUser(null, null, user);
              setTimeout(() => wbc_checkUsers(WBC, ++I, N, Callback), 0);
            });
          } else {
            await getUserId(user);
            wbc_returnWlBl(WBC, wbc, user.username, user.id, notes, async (success, notes) => {
              if (success) {
                user.values = {
                  wbc: wbc,
                  whitelisted: false,
                  blacklisted: false
                };
                if (notes) {
                  user.values.notes = notes;
                }
                user.values[wbc.result] = true;
                user.values[`${wbc.result}Date`] = Date.now();
              }
              await saveUser(null, null, user);
              setTimeout(() => wbc_checkUsers(WBC, ++I, N, Callback), 0);
            });
          }
        } else if (wbc.result === `whitelisted` || wbc.result === `blacklisted` || whitelisted || blacklisted) {
          user.values = {
            wbc: wbc
          };
          await saveUser(null, null, user);
          setTimeout(() => wbc_checkUsers(WBC, ++I, N, Callback), 0);
        } else if (New) {
          user.values = {
            wbc: null
          };
          await saveUser(null, null, user);
          setTimeout(() => wbc_checkUsers(WBC, ++I, N, Callback), 0);
        } else {
          setTimeout(() => wbc_checkUsers(WBC, ++I, N, Callback), 0);
        }
      }
    }
  }

  async function wbc_returnWlBl(WBC, wbc, username, id, notes, Callback) {
    let Key, Type;
    if (!WBC.Canceled) {
      Key = wbc.result;
      Type = Key.match(/(.+)ed/)[1];
      WBC.Progress.innerHTML = `
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <span>Returning ${Type} for ${username}...</span>
      `;
      if (location.pathname.match(new RegExp(`^/user/${username}`))) {
        document.getElementsByClassName(`sidebar__shortcut__${Type}`)[0].click();
        if (esgst.wbc_n) {
          let msg = `Returned ${Type}.`;
          if (notes) {
            notes = `${msg}\n\n${notes}`;
          } else {
            notes = msg;
          }
        }
        Callback(true, notes);
      } else {
        let success = false;
        if (JSON.parse((await request({data: `xsrf_token=${esgst.xsrfToken}&do=${Type}&child_user_id=${id}&action=insert`, method: `POST`, queue: true, url: `/ajax.php`})).responseText).type === `success`) {
          success = true;
          if (esgst.wbc_n) {
            let msg = `${Key} in return.`;
            if (notes) {
              notes = `${msg}\n\n${notes}`;
            } else {
              notes = msg;
            }
          }
        }
        Callback(success, notes);
      }
    }
  }

  function wbc_checkUser(WBC, wbc, username, Callback) {
    let match;
    if (!WBC.Canceled) {
      if (WBC.manualSkip) {
        Callback();
      } else {
        if (esgst.wbc_clearCache) {
          wbc = null;
        }
        if (!wbc) {
          wbc = {
            lastCheck: 0,
            timestamp: 0
          };
        }
        if (wbc.giveaway) {
          match = wbc.giveaway.match(/\/giveaway\/(.+?)\//);
          if (match) {
            delete wbc.giveaway;
            wbc.ga = match[1];
          }
        }
        if (wbc.whitelistGiveaway) {
          match = wbc.whitelistGiveaway.match(/\/giveaway\/(.+?)\//);
          if (match) {
            delete wbc.whitelistGiveaway;
            wbc.wl_ga = match[1];
          }
        }
        if (wbc.groupGiveaways) {
          let key;
          for (key in wbc.groupGiveaways) {
            match = key.match(/^(.+?)\//);
            if (match) {
              if (!wbc.g_wl_gas) {
                wbc.g_wl_gas = {};
              }
              wbc.g_wl_gas[match[1]] = wbc.groupGiveaways[key];
              delete wbc.groupGiveaways[key];
            }
          }
          if (Object.keys(wbc.groupGiveaways).length === 0) {
            delete wbc.groupGiveaways;
          }
        }
        if (((Date.now() - wbc.lastCheck) > 86400000) || WBC.Update) {
          if (((!esgst.wbc_checkBlacklist || !WBC.B) && (wbc.wl_ga || wbc.g_wl_ga)) || (esgst.wbc_checkBlacklist && WBC.B && wbc.ga)) {
            WBC.Timestamp = wbc.timestamp;
            wbc_checkGiveaway(WBC, wbc, username, Callback);
          } else {
            WBC.Timestamp = 0;
            WBC.GroupGiveaways = [];
            match = location.href.match(new RegExp(`/user/${username}(/search?page=(\\d+))?`));
            wbc_getGiveaways(WBC, wbc, username, 1, match ? (match[2] ? parseInt(match[2]) : 1) : 0, `/user/${username}/search?page=`, Callback);
          }
        } else {
          Callback(wbc);
        }
      }
    }
  }

  async function wbc_checkGiveaway(WBC, wbc, username, Callback) {
    if (WBC.Canceled) return;
    let responseHtml = parseHtml((await request({method: `GET`, queue: true, url: `/giveaway/${wbc.wl_ga || wbc.g_wl_ga || wbc.ga}/`})).responseText);
    let errorMessage = responseHtml.getElementsByClassName(`table--summary`)[0];
    let stop;
    if (errorMessage) {
      errorMessage = errorMessage.textContent;
      if (errorMessage.match(/blacklisted the giveaway creator/)) {
        wbc.result = `notBlacklisted`;
        stop = true;
      } else if (errorMessage.match(/blacklisted by the giveaway creator/)) {
        wbc.result = `blacklisted`;
      } else if (errorMessage.match(/not a member of the giveaway creator's whitelist/)) {
        wbc.result = `none`;
      } else {
        wbc.result = `notBlacklisted`;
      }
      wbc.lastCheck = Date.now();
      wbc.timestamp = WBC.Timestamp;
      Callback(wbc, stop);
    } else if (wbc.wl_ga) {
      wbc.result = `whitelisted`;
      wbc.lastCheck = Date.now();
      wbc.timestamp = WBC.Timestamp;
      Callback(wbc, stop);
    } else if (wbc.g_wl_ga) {
      let found, groups, i, j, n;
      found = false;
      groups = JSON.parse(await getValue(`groups`, `[]`));
      for (i = 0, n = wbc.g_wl_gas[wbc.g_wl_ga].length; i < n && !found; ++i) {
        for (j = groups.length - 1; j > -1 && groups[j].code !== wbc.g_wl_gas[wbc.g_wl_ga][i]; --j);
        if (j > -1 && groups[j].member) {
          found = true;
        }
      }
      if (found) {
        WBC.Timestamp = 0;
        WBC.GroupGiveaways = [];
        let match = location.href.match(new RegExp(`/user/${username}(/search?page=(\\d+))?`));
        wbc_getGiveaways(WBC, wbc, username, 1, match ? (match[2] ? parseInt(match[2]) : 1) : 0, `/user/${username}/search?page=`, Callback);
      } else {
        wbc.result = `whitelisted`;
        wbc.lastCheck = Date.now();
        wbc.timestamp = WBC.Timestamp;
        Callback(wbc, stop);
      }
    } else {
      wbc.result = `notBlacklisted`;
      wbc.lastCheck = Date.now();
      wbc.timestamp = WBC.Timestamp;
      Callback(wbc, stop);
    }
  }

  async function wbc_getGiveaways(WBC, wbc, username, NextPage, CurrentPage, URL, Callback, Context) {
    let Giveaway, Pagination;
    if (WBC.Canceled) return;
    if (!esgst.wbc_skipUsers || NextPage - 1 <= esgst.wbc_pages) {
      if (WBC.manualSkip) {
        Callback();
      } else {
        if (Context) {
          if (NextPage === 2) {
            WBC.lastPage = lpl_getLastPage(Context, false, false, true);
            WBC.lastPage = WBC.lastPage === 999999999 ? `` : ` of ${WBC.lastPage}`;
          }
          WBC.Progress.innerHTML = `
            <i class="fa fa-circle-o-notch fa-spin"></i>
            <span>Retrieving ${username}'s giveaways (page ${NextPage - 1}${WBC.lastPage})...</span>
          `;
          if (!wbc.ga) {
            Giveaway = Context.querySelector(`[class="giveaway__heading__name"][href*="/giveaway/"]`);
            wbc.ga = Giveaway ? Giveaway.getAttribute(`href`).match(/\/giveaway\/(.+?)\//)[1] : null;
          }
          Pagination = Context.getElementsByClassName(`pagination__navigation`)[0];
          Giveaway = Context.getElementsByClassName(`giveaway__summary`)[0];
          if (Giveaway && (WBC.Timestamp === 0)) {
            WBC.Timestamp = parseInt(Giveaway.querySelector(`[data-timestamp]`).getAttribute(`data-timestamp`));
            if (WBC.Timestamp >= (new Date().getTime())) {
              WBC.Timestamp = 0;
            }
          }
          if (wbc.ga) {
            wbc_checkGiveaway(WBC, wbc, username, (wbc, stop) => {
              let WhitelistGiveaways, I, N, GroupGiveaway;
              if ((wbc.result === `notBlacklisted`) && !stop && (!esgst.wbc_checkBlacklist || !WBC.B)) {
                WhitelistGiveaways = Context.getElementsByClassName(`giveaway__column--whitelist`);
                for (I = 0, N = WhitelistGiveaways.length; (I < N) && !wbc.wl_ga; ++I) {
                  GroupGiveaway = WhitelistGiveaways[I].parentElement.getElementsByClassName(`giveaway__column--group`)[0];
                  if (GroupGiveaway) {
                    WBC.GroupGiveaways.push(GroupGiveaway.getAttribute(`href`).match(/\/giveaway\/(.+?)\//)[1]);
                  } else {
                    wbc.wl_ga = WhitelistGiveaways[I].closest(`.giveaway__summary`).getElementsByClassName(`giveaway__heading__name`)[0].getAttribute(`href`).match(/\/giveaway\/(.+?)\//)[1];
                  }
                }
                if (wbc.wl_ga) {
                  wbc_checkGiveaway(WBC, wbc, username, Callback);
                } else if (((WBC.Timestamp >= wbc.timestamp) || (WBC.Timestamp === 0)) && Pagination && !Pagination.lastElementChild.classList.contains(`is-selected`)) {
                  setTimeout(() => wbc_getGiveaways(WBC, wbc, username, NextPage, CurrentPage, URL, Callback), 0);
                } else if ((wbc.g_wl_gas && Object.keys(wbc.g_wl_gas).length) || WBC.GroupGiveaways.length) {
                  wbc_getGroupGiveaways(WBC, 0, WBC.GroupGiveaways.length, wbc, username, async (wbc, Result) => {
                    let Groups, GroupGiveaways, Found;
                    if (wbc) {
                      if (Result) {
                        Callback(wbc);
                      } else {
                        Groups = JSON.parse(await getValue(`groups`, `[]`));
                        for (GroupGiveaway in wbc.g_wl_gas) {
                          Found = false;
                          GroupGiveaways = wbc.g_wl_gas[GroupGiveaway];
                          for (I = 0, N = GroupGiveaways.length; (I < N) && !Found; ++I) {
                            let i;
                            for (i = Groups.length - 1; i >= 0 && Groups[i].code !== GroupGiveaways[I]; --i);
                            if (i >= 0 && Groups[i].member) {
                              Found = true;
                            }
                          }
                          if (!Found) {
                            wbc.g_wl_ga = GroupGiveaway;
                            break;
                          }
                        }
                        if (Found) {
                          Callback(wbc);
                        } else {
                          wbc.result = `whitelisted`;
                          Callback(wbc);
                        }
                      }
                    } else {
                      Callback();
                    }
                  });
                } else {
                  Callback(wbc);
                }
              } else {
                Callback(wbc);
              }
            });
          } else if (((WBC.Timestamp >= wbc.timestamp) || (WBC.Timestamp === 0)) && Pagination && !Pagination.lastElementChild.classList.contains(`is-selected`)) {
            setTimeout(() => wbc_getGiveaways(WBC, wbc, username, NextPage, CurrentPage, URL, Callback), 0);
          } else {
            wbc.result = `unknown`;
            wbc.lastCheck = Date.now();
            wbc.timestamp = WBC.Timestamp;
            Callback(wbc);
          }
        } else if (!WBC.Canceled) {
          if (CurrentPage != NextPage) {
            let Response = await request({method: `GET`, queue: true, url: URL + NextPage});
            if (Response.finalUrl.match(/\/user\//)) {
              setTimeout(() => wbc_getGiveaways(WBC, wbc, username, ++NextPage, CurrentPage, URL, Callback, parseHtml(Response.responseText)), 0);
            } else {
              wbc.result = `unknown`;
              wbc.lastCheck = Date.now();
              wbc.timestamp = WBC.Timestamp;
              Callback(wbc);
            }
          } else {
            setTimeout(() => wbc_getGiveaways(WBC, wbc, username, ++NextPage, CurrentPage, URL, Callback, document), 0);
          }
        }
      }
    } else {
      Callback();
    }
  }

  function wbc_getGroupGiveaways(WBC, I, N, wbc, username, callback) {
    if (!WBC.Canceled) {
      if (I < N) {
        if (WBC.manualSkip) {
          callback();
        } else {
          WBC.Progress.innerHTML = `
            <i class="fa fa-circle-o-notch"></i>
            <span>Retrieving ${username}'s group giveaways (${I + 1} of ${N})...</span>
          `;
          if (wbc.groupGiveaways && wbc.groupGiveaways[WBC.GroupGiveaways[I]]) {
            setTimeout(() => wbc_getGroupGiveaways(WBC, ++I, N, wbc, username, callback), 0);
          } else {
            wbc_getGroups(WBC, `/giveaway/${WBC.GroupGiveaways[I]}/_/groups/search?page=`, 1, wbc, username, (wbc, Result) => {
              if (wbc) {
                if (Result) {
                  callback(wbc, Result);
                } else {
                  setTimeout(() => wbc_getGroupGiveaways(WBC, ++I, N, wbc, username, callback), 0);
                }
              } else {
                callback();
              }
            });
          }
        }
      } else {
        callback(wbc);
      }
    }
  }

  async function wbc_getGroups(WBC, URL, NextPage, wbc, username, Callback) {
    if (WBC.Canceled) return;
    if (WBC.manualSkip) {
      Callback();
    } else {
      let Response = await request({method: `GET`, queue: true, url: URL + NextPage});
      let ResponseText, ResponseHTML, Groups, N, GroupGiveaway, I, Group, Pagination;
      ResponseText = Response.responseText;
      ResponseHTML = parseHtml(ResponseText);
      Groups = ResponseHTML.getElementsByClassName(`table__column__heading`);
      N = Groups.length;
      if (N > 0) {
        if (!wbc.g_wl_gas) {
          wbc.g_wl_gas = {};
        }
        GroupGiveaway = URL.match(/\/giveaway\/(.+?)\//)[1];
        if (!wbc.g_wl_gas[GroupGiveaway]) {
          wbc.g_wl_gas[GroupGiveaway] = [];
        }
        for (I = 0; I < N; ++I) {
          Group = Groups[I].getAttribute(`href`).match(/\/group\/(.+?)\//)[1];
          if (wbc.g_wl_gas[GroupGiveaway].indexOf(Group) < 0) {
            wbc.g_wl_gas[GroupGiveaway].push(Group);
          }
        }
        Pagination = ResponseHTML.getElementsByClassName(`pagination__navigation`)[0];
        if (Pagination && !Pagination.lastElementChild.classList.contains(`is-selected`)) {
          setTimeout(() => wbc_getGroups(WBC, NextPage === 1 ? `${Response.finalUrl}/search?page=` : URL, ++NextPage, wbc, username, Callback), 0);
        } else {
          Callback(wbc);
        }
      } else {
        wbc.result = `none`;
        Callback(wbc, true);
      }
    }
  }

  async function wbc_getUsers(WBC, NextPage, CurrentPage, URL, Callback, Context) {
    let Matches, I, N, Match, Username, Pagination;
    if (WBC.Canceled) return;
    if (Context) {
      if (!WBC.lastPage) {
        WBC.lastPage = lpl_getLastPage(Context, true);
        WBC.lastPage = WBC.lastPage === 999999999 ? `` : ` of ${WBC.lastPage}`;
      }
      WBC.Progress.innerHTML = `
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <span>Retrieving users (page ${NextPage}${WBC.lastPage})...</span>
      `;
      Matches = Context.querySelectorAll(`a[href*="/user/"]`);
      for (I = 0, N = Matches.length; I < N; ++I) {
        Match = Matches[I].getAttribute(`href`).match(/\/user\/(.+)/);
        if (Match) {
          Username = Match[1];
          if ((WBC.Users.indexOf(Username) < 0) && (Username != WBC.Username) && (Username === Matches[I].textContent) && !Matches[I].closest(`.markdown`)) {
            WBC.Users.push(Username);
          }
        }
      }
      Pagination = Context.getElementsByClassName(`pagination__navigation`)[0];
      if (Pagination && !Pagination.lastElementChild.classList.contains(`is-selected`)) {
        setTimeout(() => wbc_getUsers(WBC, NextPage, CurrentPage, URL, Callback), 0);
      } else {
        Callback();
      }
    } else if (!WBC.Canceled) {
      if (!esgst.wbc_checkPages || NextPage <= esgst.wbc_maxPage) {
        NextPage += 1;
        if (CurrentPage != NextPage) {
          setTimeout(async () => wbc_getUsers(WBC, NextPage, CurrentPage, URL, Callback, parseHtml((await request({method: `GET`, queue: true, url: URL + NextPage})).responseText)), 0);
        } else {
          setTimeout(() => wbc_getUsers(WBC, NextPage, CurrentPage, URL, Callback, esgst.pageOuterWrap), 0);
        }
      } else {
        Callback();
      }
    }
  }

  // [WBH]
  
  _MODULES.push({
    description: `
      <ul>
        <li>Adds an icon (<i class="fa fa-heart esgst-whitelist"></i> if the user is whitelisted and <i class="fa fa-ban esgst-blacklist"></i> if they are blacklisted) next to the a user's username (in any page) to indicate that they are on your whitelist/blacklist.</li>
        <li>If you hover over the icon, it shows the date when you added the user to your whitelist/blacklist.</li>
      </ul>
    `,
    features: {
      wbh_b: {
        colors: true,
        description: `
          <ul>
            <li>Adds a background color of your own preference to the user's username if they are blacklisted, instead of an icon.</li>
            <li>If you hover over the username, it shows the date when you added the user to your whitelist/blacklist.</li>
          </ul>
        `,
        name: `Use background colors for blacklisted users instead of icons.`,
        sg: true,
        st: true
      },
      wbh_w: {
        colors: true,
        description: `
          <ul>
            <li>Adds a background color of your own preference to the user's username if they are whitelisted, instead of an icon.</li>
            <li>If you hover over the username, it shows the date when you added the user to your whitelist/blacklist.</li>
          </ul>
        `,
        name: `Use background colors for whitelisted users instead of icons.`,
        sg: true,
        st: true
      }
    },
    id: `wbh`,
    name: `Whitelist/Blacklist Highlighter`,
    sg: {include: [{enabled: 1, pattern: `.*`}], exclude: [{enabled: 1, pattern: `^/account/manage/(whitelist|blacklist)`}]},
    st: true,
    sync: `Whitelist and Blacklist`,
    type: `users`
  });

  // [WBS]

  _MODULES.push({
    description: `
      <ul>
        <li>Adds 2 buttons (<i class="fa fa-sort-amount-asc"></i> to sort in ascending order and <i class="fa fa-sort-amount-desc"></i> to sort in descending order) to the main page heading of your <a href="https://www.steamgifts.com/account/manage/whitelist">whitelist</a>/<a href="https://www.steamgifts.com/account/manage/blacklist">blacklist</a> pages that allow you to view all of the users in your whitelist/blacklist at once sorted by added date.</li>
      </ul>
    `,
    id: `wbs`,
    load: wbs,
    name: `Whitelist/Blacklist Sorter`,
    sg: true,
    sync: `Whitelist and Blacklist`,
    type: `users`
  });

  function wbs() {
    if (!esgst.whitelistPath && !esgst.blacklistPath) return;

    let [dateKey, mainKey, saveKey] = esgst.whitelistPath ? [`whitelistedDate`, `whitelist`, `whitelisted`] : [`blacklistedDate`, `blacklist`, `blacklisted`];

    // add ascending button
    let object = {
      dateKey,
      icon: `fa-sort-amount-asc`,
      key: mainKey,
      saveKey,
      title: `Oldest to newest ${saveKey} users:`
    };
    createHeadingButton({featureId: `wbs`, id: `wbsAsc`, icons: [`fa-sort-amount-asc`], title: `Sort by added date from oldest to newest`}).addEventListener(`click`, wbs_sort.bind(null, object));

    // add descending button
    object = {
      dateKey,
      icon: `fa-sort-amount-desc`,
      isDescending: true,
      key: mainKey,
      saveKey,
      title: `Newest to oldest ${saveKey} users:`
    };
    createHeadingButton({featureId: `wbs`, id: `wbsDesc`, icons: [`fa-sort-amount-desc`], title: `Sort by added date from newest to oldest`}).addEventListener(`click`, wbs_sort.bind(null, object));
  }

  async function wbs_sort(obj) {
    let savedUsers = JSON.parse(await getValue(`users`)).users;
    let users = [];
    for (let steamId in savedUsers) {
      let savedUser = savedUsers[steamId];
      if (!savedUser[obj.saveKey]) continue;
      savedUser.steamId = steamId;
      users.push(savedUser);
    }
    users = sortArrayByNumberKey(users, obj.dateKey, obj.isDescending);

    let popup = new Popup(obj.icon, obj.title, true);
    popup.popup.classList.add(`esgst-wbs-popup`);
    let table = insertHtml(popup.scrollable, `beforeEnd`, `
      <div class="esgst-text-left table">
        <div class="table__heading">
        <div class="table__column--width-fill">User</div>
        <div class="table__column--width-small text-center">Added</div>
          <div class="table__column--width-small text-center">Remove</div>
        </div>
        <div class="table__rows"></div>
      </div>
    `);
    let rows = table.lastElementChild;
    users.forEach(user => {
      let row = insertHtml(rows, `beforeEnd`, `
        <div class="table__row-outer-wrap">
          <div class="table__row-inner-wrap">
            <div class="table__column--width-fill">
              <a class="table__column__heading" href="/user/${user.username}">${user.username}</a>
            </div>
            <div class="table__column--width-small text-center">${getTimestamp(user[obj.dateKey])}</div>
            <div class="table__column--width-small text-center">
              <div class="table__remove-default esgst-clickable">
                <i class="icon-red fa fa-times-circle"></i>
                <span class="table__column__secondary-link">Remove</span>
              </div>
              <div class="table__remove-loading esgst-hidden">
                <i class="fa fa-refresh fa-spin"></i> Removing...
              </div>
              <div class="table__remove-complete esgst-hidden">
                <i class="fa fa-times-circle"></i> Removed
              </div>
            </div>
          </div>
        </div>
      `);
      let object = {
        dateKey: obj.dateKey,
        key: obj.key,
        saveKey: obj.saveKey,
        user
      };
      object.removeButton = row.firstElementChild.lastElementChild.firstElementChild;
      object.removingButton = object.removeButton.nextElementSibling;
      object.removedButton = object.removingButton.nextElementSibling;
      object.removeButton.addEventListener(`click`, obj.wbs_removeMember.bind(obj, object));
    });
    popup.open();
    endless_load(table);
  }

  async function wbs_removeMember(obj) {
    obj.removeButton.classList.add(`esgst-hidden`);
    obj.removingButton.classList.remove(`esgst-hidden`);
    await request({data: `xsrf_token=${esgst.xsrfToken}&do=${obj.key}&action=delete&child_user_id=${obj.user.id}`, method: `POST`, url: `/ajax.php`});
    let deleteLock = await createLock(`userLock`, 300);
    let savedUsers = JSON.parse(await getValue(`users`));
    delete savedUsers.users[obj.user.steamId][obj.dateKey];
    delete savedUsers.users[obj.user.steamId][obj.saveKey];
    await setValue(`users`, JSON.stringify(savedUsers));
    deleteLock();
    obj.removingButton.classList.add(`esgst-hidden`);
    obj.removedButton.classList.remove(`esgst-hidden`);
  }

  // [WBM]

  _MODULES.push({
    description: `
      <ul>
        <li>Adds a button (<i class="fa fa-arrow-up"></i> <i class="fa fa-arrow-down"></i> <i class="fa fa-trash"></i>) to the main page heading of your <a href="https://www.steamgifts.com/account/manage/whitelist">whitelist</a>/<a href="https://www.steamgifts.com/account/manage/blacklist">blacklist</a> pages that allows you to import/export/clear your whitelist/blacklist.</li>
      </ul>
    `,
    id: `wbm`,
    load: wbm,
    name: `Whitelist/Blacklist Manager`,
    sg: true,
    type: `users`
  });

  function wbm() {
    if (!esgst.whitelistPath && !esgst.blacklistPath) return;
    let wbm = {};
    if (esgst.whitelistPath) {
      wbm.key = `whitelist`;
      wbm.name = `Whitelist`;
    } else {
      wbm.key = `blacklist`;
      wbm.name = `Blacklist`;
    }
    wbm.button = createHeadingButton({id: `wbm`, icons: [`fa-arrow-up`, `fa-arrow-down`, `fa-trash`], title: `Manage ${wbm.key}`});
    wbm.button.addEventListener(`click`, wbm_openPopup.bind(null, wbm));
  }

  function wbm_openPopup(wbm) {
    if (!wbm.popup) {
      wbm.popup = new Popup(`fa-gear`, `Manage ${wbm.name}:`);
      new ToggleSwitch(wbm.popup.description, `wbm_useCache`, false, `Use cache.`, false, false, `Uses the cache created the last time you synced your whitelist/blacklist. This speeds up the process, but could lead to incomplete results if your cache isn't up-to-date.`, esgst.wbm_useCache);
      new ToggleSwitch(wbm.popup.description, `wbm_clearTags`, false, `Only clear users who are tagged with these specific tags (separate with comma): <input class="esgst-switch-input esgst-switch-input-large" type="text" value="${esgst.wbm_tags.join(`, `)}">`, false, false, `Uses the User Tags database to remove only users with the specified tags.`, esgst.wbm_clearTags).name.firstElementChild.addEventListener(`change`, event => {
        let tags = event.currentTarget.value.replace(/(,\s*)+/g, formatTags).split(`, `);
        setSetting(`wbm_tags`, tags);
        esgst.wbm_tags = tags;
      });
      wbm.input = insertHtml(wbm.popup.description, `beforeEnd`, `<input type="file"/>`);
      wbm.message = insertHtml(wbm.popup.description, `beforeEnd`, `<div class="esgst-description"></div>`);
      wbm.warning = insertHtml(wbm.popup.description, `beforeEnd`, `<div class="esgst-description esgst-warning"></div>`);
      wbm.popup.description.appendChild(new ButtonSet(`green`, `grey`, `fa-arrow-up`, `fa-times`, `Import`, `Cancel`, wbm_start.bind(null, wbm, wbm_importList.bind(null, wbm)), wbm_cancel.bind(null, wbm)).set);
      wbm.popup.description.appendChild(new ButtonSet(`green`, `grey`, `fa-arrow-down`, `fa-times`, `Export`, `Cancel`, wbm_start.bind(null, wbm, wbm_exportList.bind(null, wbm, [], 1)), wbm_cancel.bind(null, wbm)).set);
      wbm.popup.description.appendChild(new ButtonSet(`green`, `grey`, `fa-trash`, `fa-times`, `Clear`, `Cancel`, wbm_start.bind(null, wbm, wbm_clearList.bind(null, wbm, [], 1)), wbm_cancel.bind(null, wbm)).set);
      wbm.results = insertHtml(wbm.popup.scrollable,  `beforeEnd`, `<div></div>`);
    }
    wbm.popup.open();
  }

  function wbm_start(wbm, callback, mainCallback) {
    createConfirmation(`Are you sure you want to do this?`, () => {
      wbm.isCanceled = false;
      wbm.button.classList.add(`esgst-busy`);
      wbm.usernames = [];
      wbm.results.innerHTML = ``;
      callback(wbm_complete.bind(null, wbm, mainCallback));
    }, mainCallback);
  }

  function wbm_complete(wbm, callback) {
    wbm.button.classList.remove(`esgst-busy`);
    callback();
  }

  function wbm_cancel(wbm) {
    wbm.isCanceled = true;
    wbm.button.classList.remove(`esgst-busy`);
  }

  function wbm_importList(wbm, callback) {
    let file = wbm.input.files[0];
    if (file) {
      let reader = new FileReader();
      reader.readAsText(file);
      reader.onload = () => {
        try {
          let list = JSON.parse(reader.result);
          wbm_insertUsers(wbm, list, 0, list.length, callback);
        } catch (error) {
          createFadeMessage(wbm.warning, `Cannot parse file!`);
          callback();
        }
      };
    } else {
      createFadeMessage(wbm.warning, `No file was loaded!`);
      callback();
    }
  }

  async function wbm_insertUsers(wbm, list, i, n, callback) {
    if (wbm.isCanceled) return;
    wbm.message.innerHTML = `
      <i class="fa fa-circle-o-notch fa-spin"></i>
      <span>Importing list (${i} of ${n})...</span>
    `;
    if (i < n) {
      await request({data: `xsrf_token=${esgst.xsrfToken}&do=${wbm.key}&action=insert&child_user_id=${list[i]}`, method: `POST`, url: `/ajax.php`});
      setTimeout(() => wbm_insertUsers(wbm, list, ++i, n, callback), 0);
    } else {
      createFadeMessage(wbm.message, `List imported with success!`);
      callback();
    }
  }

  async function wbm_exportList(wbm, list, nextPage, callback) {
    if (wbm.isCanceled) return;
    if (esgst.wbm_useCache) {
      let file, steamId, url;
      for (steamId in esgst.users.users) {
        if (esgst.users.users[steamId][`${wbm.key}ed`]) {
          list.push(esgst.users.users[steamId].id);
        }
      }
      downloadFile(JSON.stringify(list), `esgst_${wbm.key}_${new Date().toISOString()}.json`);
      createFadeMessage(wbm.message, `List exported with success!`);
      callback();
    } else {
      wbm.message.innerHTML = `
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <span>Retrieving list (page ${nextPage})...</span>
      `;
      let elements, i, n, pagination, responseHtml;
      responseHtml = parseHtml((await request({method: `GET`, url: `https://www.steamgifts.com/account/manage/${wbm.key}/search?page=${nextPage}`})).responseText);
      elements = responseHtml.querySelectorAll(`[name="child_user_id"]`);
      for (i = 0, n = elements.length; i < n; ++i) {
        list.push(elements[i].value);
      }
      pagination = responseHtml.getElementsByClassName(`pagination__navigation`)[0];
      if (pagination && !pagination.lastElementChild.classList.contains(`is-selected`)) {
        setTimeout(() => wbm_exportList(wbm, list, ++nextPage, callback), 0);
      } else {
        downloadFile(JSON.stringify(list), `esgst_${wbm.key}_${new Date().toISOString()}.json`);
        createFadeMessage(wbm.message, `List exported with success!`);
        callback();
      }
    }
  }

  async function wbm_clearList(wbm, list, nextPage, callback) {
    if (wbm.isCanceled) return;
    if (esgst.wbm_useCache) {
      let steamId;
      for (steamId in esgst.users.users) {
        let user = esgst.users.users[steamId];
        if (user[`${wbm.key}ed`]) {
          if (esgst.wbm_clearTags) {
            if (user.tags) {
              let i;
              for (i = user.tags.length - 1; i > -1 && esgst.wbm_tags.indexOf(user.tags[i]) < 0; --i);
              if (i > -1) {
                list.push(user.id);
                wbm.usernames.push(user.username);
              }
            }
          } else {
            list.push(user.id);
          }
        }
      }
      wbm_deleteUsers(wbm, list, 0, list.length, callback);
    } else {
      wbm.message.innerHTML = `
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <span>Retrieving list (page ${nextPage})...</span>
      `;
      let element, elements, i, n, pagination, responseHtml;
      responseHtml = parseHtml((await request({method: `GET`, url: `https://www.steamgifts.com/account/manage/${wbm.key}/search?page=${nextPage}`})).responseText);
      elements = responseHtml.querySelectorAll(`[name="child_user_id"]`);
      for (i = 0, n = elements.length; i < n; ++i) {
        element = elements[i];
        if (esgst.wbm_clearTags) {
          let steamId, username;
          username = element.closest(`.table__row-inner-wrap`).getElementsByClassName(`table__column__heading`)[0].textContent;
          steamId = esgst.users.steamIds[username];
          if (steamId) {
            let user = esgst.users.users[steamId];
            if (user.tags) {
              let j;
              for (j = user.tags.length - 1; j > -1 && esgst.wbm_tags.indexOf(user.tags[j]) < 0; --j);
              if (j > -1) {
                list.push(element.value);
                wbm.usernames.push(username);
              }
            }
          }
        } else {
          list.push(element.value);
        }
      }
      pagination = responseHtml.getElementsByClassName(`pagination__navigation`)[0];
      if (pagination && !pagination.lastElementChild.classList.contains(`is-selected`)) {
        setTimeout(() => wbm_clearList(wbm, list, ++nextPage, callback), 0);
      } else {
        wbm_deleteUsers(wbm, list, 0, list.length, callback);
      }
    }
  }

  async function wbm_deleteUsers(wbm, list, i, n, callback) {
    if (wbm.isCanceled) return;
    wbm.message.innerHTML = `
      <i class="fa fa-circle-o-notch fa-spin"></i>
      <span>Clearing list (${i} of ${n})...</span>
    `;
    if (i < n) {
      await request({data: `xsrf_token=${esgst.xsrfToken}&do=${wbm.key}&action=delete&child_user_id=${list[i]}`, method: `POST`, url: `/ajax.php`});
      setTimeout(() => wbm_deleteUsers(wbm, list, ++i, n, callback), 0);
    } else {
      createFadeMessage(wbm.message, `List cleared with success!`);
      wbm.results.innerHTML = `
        <span class="esgst-bold">Users cleared (${wbm.usernames.length}):</span>
        <span class="esgst-popup-actions"></span>
      `;
      wbm.usernames.forEach(username => {
        wbm.results.lastElementChild.insertAdjacentHTML(`beforeEnd`, `<a href="/user/${username}">${username}</a>`);
      });
      callback();
    }
  }
  
  // [URLR]

  _MODULES.push({
    description: `
      <ul>
        <li>Redirects broken URLs to the correct URLs. For example, "/giveaway/XXXXX" redirects to "/giveaway/XXXXX/".</li>
      </ul>
    `,
    id: `urlr`,
    name: `URL Redirector`,
    sg: true,
    st: true,
    type: `general`
  });

  // [UT]
  
  _MODULES.push({
    description: `
      <ul>
        <li>Adds a button (<i class="fa fa-tag"></i>) next a user's username (in any page) that allows you to save tags for the user (only visible to you).</li>
        <li>You can press Enter to save the tags.</li>
        <li>Each tag can be colored individually.</li>
        <li>There is a button (<i class="fa fa-list"></i>) in the tags popup that allows you to view a list with all of the tags that you have used ordered from most used to least used.</li>
        <li>Adds a button (<i class="fa fa-user"></i> <i class="fa fa-tags"></i>) to the page heading of this menu that allows you to manage all of the tags that have been saved.</li>
        <li>This feature is recommended for cases where you want to associate a short text with a user, since the tags are displayed next to their username. For a long text, check [id=un].</li>
      </ul>
    `,
    id: `ut`,
    name: `User Tags`,
    sg: true,
    st: true,
    type: `users`
  });

  function ut_addButton(context, key, steamId, username) {
    const isHeading = context.classList.contains(`featured__heading__medium`);
    const container = context.parentElement;
    if (container.classList.contains(`comment__username`)) {
      context = container;
    }
    insertHtml(isHeading ? container : context, isHeading ? `beforeEnd` : `afterEnd`, `
      <a class="esgst-ut-button esgst-faded" title="${getFeatureTooltip(`ut`, `Edit user tags`)}">
        <i class="fa fa-tag"></i>
        <span class="esgst-ut-tags"></span>
      </a>
    `).addEventListener(`click`, ut_openPopup.bind(null, key, steamId, username));
  }

  function ut_openPopup(key, steamId, username) {
    let popup, set;
    const user = {
      steamId: steamId,
      username: username
    };
    popup = new Popup(`fa-tag`, `Edit user tags for <span>${key}</span>:`);
    set = new ButtonSet(`green`, `grey`, `fa-check`, `fa-circle-o-notch fa-spin`, `Save`, `Saving...`, ut_saveTags.bind(null, key, popup, user));
    popup.description.insertAdjacentHTML(`beforeEnd`, `<div class="esgst-description">Drag the tags to move them.<br/><br/>When editing a tag color, it will also alter the color for all users with that tag (you have to refresh the page for it to take effect).</div>`);
    popup.tags = insertHtml(popup.description, `beforeEnd`, `<div class="esgst-ut-tags"></div>`);
    popup.input = insertHtml(popup.description, `beforeEnd`, `<input type="text"/>`);
    insertHtml(popup.description, `beforeEnd`, `<i class="esgst-ut-existing-button esgst-clickable fa fa-list" title="Select from existing tags"></i>`).addEventListener(`click`, ut_showExistingTags.bind(null, popup));
    popup.input.addEventListener(`keydown`, triggerSetOnEnter.bind(null, set));
    popup.input.addEventListener(`input`, ut_createTags.bind(null, popup));
    popup.description.insertAdjacentHTML(`beforeEnd`, `<div class="esgst-description">Use commas to separate tags, for example: Tag1, Tag2, ...</div>`);
    popup.description.appendChild(set.set);
    popup.open(ut_loadTags.bind(null, popup, user));
  }

  async function ut_showExistingTags(mainPopup) {
    let key, list, popup, savedUsers, selectedTags, tag, tagCount, tags;
    popup = new Popup(`fa-list`, `Select from existing tags:`, true);
    tagCount = {};
    savedUsers = JSON.parse(await getValue(`users`)).users;
    for (key in savedUsers) {
      tags = savedUsers[key].tags;
      if (tags) {
        tags.forEach(tag => {
          if (!tagCount[tag]) {
            tagCount[tag] = 0;
          }
          tagCount[tag] += 1;
        });
      }
    }
    tags = [];
    for (tag in tagCount) {
      tags.push({
        count: tagCount[tag],
        tag: tag
      });
    }
    list = insertHtml(popup.scrollable, `beforeEnd`, `<div class="esgst-ut-existing-tags popup__keys__list"></div>`);
    selectedTags = [];
    tags = sortArrayByNumberKey(tags, `count`, true);
    tags.forEach(tag => {
      let checkbox, item;
      tag = tag.tag;
      item = insertHtml(list, `beforeEnd`, `
        <div>
          <span></span> ${tag}
        </div>
      `);
      if (esgst.ut_colors[tag]) {
        item.style.color = esgst.ut_colors[tag].color;
        item.style.backgroundColor = esgst.ut_colors[tag].bgColor;
      }
      checkbox = new Checkbox(item);
      checkbox.onEnabled = () => {
        selectedTags.push(tag);
      };
      checkbox.onDisabled = () => {
        selectedTags.splice(selectedTags.indexOf(tag), 1);
      };
    });
    popup.description.appendChild(new ButtonSet(`green`, ``, `fa-check`, ``, `Add Tags`, ``, callback => {
      selectedTags.forEach(tag => {
        ut_createTag(mainPopup, tag);
      });
      mainPopup.input.value = mainPopup.input.value ? `${mainPopup.input.value}, ${selectedTags.join(`, `)}` : selectedTags.join(`, `);
      callback();
      popup.close();
    }).set);
    popup.open();
  }

  function ut_createTags(popup) {
    let i, n, tags;
    tags = popup.input.value.replace(/(,\s*)+/g, formatTags).split(`, `);
    popup.tags.innerHTML = ``;
    for (i = 0, n = tags.length; i < n; ++i) {
      ut_createTag(popup, tags[i]);
    }
  }

  function ut_createTag(popup, tag) {
    let bgColorInput, colorInput, colors, container, deleteButton, editButton, input, resetButton, tagBox, tagContainer;
    container = insertHtml(popup.tags, `beforeEnd`, `
      <div class="esgst-ut-preview" draggable="true">
        <div class="esgst-ut-tags">
          <span class="global__image-outer-wrap author_avatar is_icon">${tag}</span>
        </div>
        <input class="esgst-hidden" type="text"/>
        <input title="Set text color for this tag" type="color"/>
        <input title="Set background color for this tag" type="color"/>
        <i class="esgst-clickable fa fa-edit" title="Edit tag"></i>
        <i class="esgst-clickable fa fa-trash" title="Delete tag"></i>
        <i class="esgst-clickable fa fa-rotate-left" title="Reset tag color"></i>
      </div>
    `);
    tagContainer = container.firstElementChild;
    tagBox = tagContainer.firstElementChild;
    input = tagContainer.nextElementSibling;
    colorInput = input.nextElementSibling;
    bgColorInput = colorInput.nextElementSibling;
    editButton = bgColorInput.nextElementSibling;
    deleteButton = editButton.nextElementSibling;
    resetButton = deleteButton.nextElementSibling;
    colors = esgst.ut_colors[tag];
    if (colors) {
      colorInput.value = tagBox.style.color = colors.color;
      bgColorInput.value = tagBox.style.backgroundColor = colors.bgColor;
    }
    container.addEventListener(`dragstart`, ut_startDrag.bind(null, container, popup));
    container.addEventListener(`dragenter`, ut_continueDrag.bind(null, container, popup));
    container.addEventListener(`dragend`, ut_endDrag.bind(null, popup));
    input.addEventListener(`keydown`, ut_editTag.bind(null, bgColorInput, colorInput, input, popup, tagBox, tagContainer));
    colorInput.addEventListener(`change`, ut_saveColor.bind(null, colorInput, `color`, `color`, tagBox));
    bgColorInput.addEventListener(`change`, ut_saveColor.bind(null, bgColorInput, `backgroundColor`, `bgColor`, tagBox));
    editButton.addEventListener(`click`, ut_showEdit.bind(null, input, tagBox, tagContainer));
    deleteButton.addEventListener(`click`, ut_deleteTag.bind(null, container, popup));
    resetButton.addEventListener(`click`, ut_resetColor.bind(null, bgColorInput, colorInput, tagBox));
  }

  function ut_startDrag(container, popup, event) {
    event.dataTransfer.setData(`text/plain`, ``);
    popup.dragged = container;
  }

  function ut_continueDrag(container, popup) {
    let current;
    current = popup.dragged;
    do {
      current = current.previousElementSibling;
      if (current && current === container) {
        popup.tags.insertBefore(popup.dragged, container);
        return;
      }
    } while (current);
    popup.tags.insertBefore(popup.dragged, container.nextElementSibling);
  }

  function ut_endDrag(popup) {
    let children, i, n, tags;
    tags = [];
    children = popup.tags.children;
    for (i = 0, n = children.length; i < n; ++i) {
      tags.push(children[i].firstElementChild.firstElementChild.textContent);
    }
    popup.input.value = tags.join(`, `);
  }

  function ut_editTag(bgColorInput, colorInput, input, popup, tagBox, tagContainer, event) {
    let colors, tag;
    if (event.key === `Enter`) {
      tagContainer.classList.remove(`esgst-hidden`);
      input.classList.add(`esgst-hidden`);
      tag = input.value;
      tagBox.textContent = tag;
      colors = esgst.ut_colors[tag];
      if (colors) {
        colorInput.value = tagBox.style.color = colors.color;
        bgColorInput.value = tagBox.style.backgroundColor = colors.bgColor;
      }
      ut_endDrag(popup);
    }
  }

  function ut_saveColor(input, key, saveKey, tagBox) {
    let tag;
    tag = tagBox.textContent;
    if (!esgst.ut_colors[tag]) {
      esgst.ut_colors[tag] = {
        bgColor: ``,
        color: ``
      };
    }
    esgst.ut_colors[tag][saveKey] = tagBox.style[key] = input.value;
  }

  function ut_resetColor(bgColorInput, colorInput, tagBox) {
    bgColorInput.value = ``;
    colorInput.value = ``;
    tagBox.style.backgroundColor = ``;
    tagBox.style.color = ``;
    delete esgst.ut_colors[tagBox.textContent];
  }

  function ut_showEdit(input, tagBox, tagContainer) {
    tagContainer.classList.add(`esgst-hidden`);
    input.classList.remove(`esgst-hidden`);
    input.value = tagBox.textContent;
    input.focus();
  }

  function ut_deleteTag(container, popup) {
    container.remove();
    ut_endDrag(popup);
  }

  async function ut_saveTags(key, popup, user, callback) {
    let tags;
    tags = popup.input.value.replace(/(,\s*)+/g, formatTags).split(`, `);
    if (tags.length === 1 && !tags[0].trim()) {
      tags = ``;
    }
    user.values = {
      tags: tags
    };
    await saveUser(null, null, user);
    ut_completeSave(key, popup, tags, callback);
  }

  async function ut_completeSave(key, popup, tags, callback) {
    await setSetting(`ut_colors`, esgst.ut_colors);
    ut_addTags(key, tags);
    callback();
    popup.close();
  }

  async function ut_loadTags(popup, user) {
    let i, n, savedUser, tags;
    savedUser = await getUser(null, user);
    popup.input.focus();
    if (savedUser) {
      tags = savedUser.tags;
      if (tags) {
        popup.tags.innerHTML = ``;
        for (i = 0, n = tags.length; i < n; ++i) {
          ut_createTag(popup, tags[i]);
        }
        popup.input.value = tags.join(`, `);
      }
    }
  }

  function ut_addTags(key, tags) {
    let button, children, colors, container, context, elements, html, i, n, prefix, suffix, tagsBox, tagsContainer;
    elements = esgst.currentUsers[key].elements;
    prefix = `<span class="global__image-outer-wrap author_avatar is_icon">`;
    suffix = `</span>`;
    html = tags.length && tags[0] ? `${prefix}${tags.join(`${suffix}${prefix}`)}${suffix}` : ``;
    for (i = 0, n = elements.length; i < n; ++i) {
      context = elements[i];
      container = context.parentElement;
      if (container) {
        if (container.classList.contains(`comment__username`)) {
          context = container;
        }
        button = context.parentElement.getElementsByClassName(`esgst-ut-button`)[0];
        if (html) {
          button.classList.remove(`esgst-faded`);
        } else {
          button.classList.add(`esgst-faded`);
        }
        tagsContainer = button.lastElementChild;
        tagsContainer.innerHTML = html;
        children = tagsContainer.children;
        for (let j = 0, numTags = children.length; j < numTags; ++j) {
          tagsBox = children[j];
          colors = esgst.ut_colors[tagsBox.textContent];
          if (colors) {
            tagsBox.style.color = colors.color;
            tagsBox.style.backgroundColor = colors.bgColor;
          }
        }
      }
    }
  }
  
  // [AT]

  _MODULES.push({
    description: `
      <ul>
        <li>Replaces a timestamp (in any page) with an accurate timestamp. For example, "2 hours ago" becomes "Jan 1, 2017, 0:00:00 - 2 hours ago".</li>
        <li>You can choose whether to show seconds or not and whether to use a 12-hour clock or a 24-hour one.</li>
      </ul>
    `,
    features: {
      at_s: {
        name: `Show seconds.`,
        sg: true,
        st: true
      },
      at_24: {
        name: `Use a 24-hour clock.`,
        sg: true,
        st: true
      }
    },
    id: `at`,
    load: at,
    name: `Accurate Timestamp`,
    sg: true,
    st: true,
    type: `general`
  });

  function at() {
    esgst.endlessFeatures.push(at_getTimestamps);
  }

  function at_getTimestamps(context, main, source, endless) {
    let timestamps, i, n, timestamp, text, edited, seconds, accurateTimestamp;
    timestamps = context.querySelectorAll(`${endless ? `.esgst-es-page-${endless} [data-timestamp], .esgst-es-page-${endless}[data-timestamp]` : `[data-timestamp]`}`);
    for (i = 0, n = timestamps.length; i < n; ++i) {
      timestamp = timestamps[i];
      if (((esgst.activeDiscussions && ((esgst.activeDiscussions.contains(timestamp) && esgst.adots_index === 0) || !esgst.activeDiscussions.contains(timestamp))) || !esgst.activeDiscussions) && !timestamp.classList.contains(`esgst-at`)) {
        text = timestamp.textContent;
        edited = text.match(/\*/);
        seconds = parseInt(timestamp.getAttribute(`data-timestamp`));
        accurateTimestamp = getTimestamp(seconds * 1e3, esgst.at_24, esgst.at_s);
        if (edited) {
          text = ` (Edited ${accurateTimestamp})`;
        } else {
          text = `${accurateTimestamp} - ${text}`;
        }
        timestamp.classList.add(`esgst-at`);
        timestamp.textContent = text;
      }
    }
  }
  
  // [EV]

  _MODULES.push({
    description: `
      <ul>
        <li>Embeds any YouTube/Vimeo videos found in a comment (in any page) into the comment.</li>
        <li>Videos are only embedded if their links are in the [URL](URL) format and are the only content in a line. For example, "[https://youtu.be/ihd9dKek2gc](https://youtu.be/ihd9dKek2gc)" gets embedded, but "[Watch this!](https://youtu.be/ihd9dKek2gc)" and "Watch this: [https://youtu.be/ihd9dKek2gc](https://youtu.be/ihd9dKek2gc)" do not.</li>
      </ul>
    `,
    id: `ev`,
    load: ev,
    name: `Embedded Videos`,
    sg: true,
    st: true,
    type: `general`
  });

  function ev() {
    esgst.endlessFeatures.push(ev_getVideos);
  }

  function ev_getVideos(context, main, source, endless) {
    let types, i, numTypes, type, videos, j, numVideos, video, previous, next, embedUrl, url, text, title;
    types = [`youtube.com`, `youtu.be`, `vimeo.com`];
    for (i = 0, numTypes = types.length; i < numTypes; ++i) {
      type = types[i];
      videos = context.querySelectorAll(`${endless ? `.esgst-es-page-${endless} a[href*="${type}"], .esgst-es-page-${endless}a[href*="${type}"]` : `a[href*="${type}"]`}`);
      for (j = 0, numVideos = videos.length; j < numVideos; ++j) {
        video = videos[j];
        previous = video.previousSibling;
        next = video.nextSibling;
        if ((!previous || !previous.textContent.trim()) && (!next || !next.textContent.trim())) {
          // video is the only content in the line
          url = video.getAttribute(`href`);
          embedUrl = ev_getEmbedUrl(i, url);
          if (embedUrl) {
            text = video.textContent;
            if (url !== text) {
              title = `<div>${text}</div>`;
            } else {
              title = ``;
            }
            video.outerHTML = `
              <div>
                ${title}
                <iframe width="640" height="360" src="${embedUrl}" frameborder="0" allowfullscreen></iframe>
              </div>
            `;
          }
        }
      }
    }
  }

  function ev_getEmbedUrl(i, url) {
    let regExps, regExp, match, baseUrls, baseUrl, code;
    regExps = [
      /youtube.com\/watch\?v=(.+?)(\/.*)?(&.*)?$/,
      /youtu.be\/(.+?)(\/.*)?$/,
      /vimeo.com\/(.+?)(\/.*)?$/
    ];
    regExp = regExps[i];
    match = url.match(regExp);
    if (match) {
      baseUrls = [
        `https://www.youtube.com/embed/`,
        `https://www.youtube.com/embed/`,
        `https://player.vimeo.com/video/`
      ];
      baseUrl = baseUrls[i];
      code = match[1];
      return `${baseUrl}${code}`;
    } else {
      return null;
    }
  }

  // [IB]

  _MODULES.push({
    description: `
      <ul>
        <li>Brings back image borders to SteamGifts.</li>
      </ul>
    `,
    id: `ib`,
    load: ib,
    name: `Image Borders`,
    sg: true,
    type: `general`
  });

  function ib() {
    esgst.endlessFeatures.push(ib_addBorders);
  }

  function ib_addBorders(context, main, source, endless) {
    const userElements = context.querySelectorAll(`${endless ? `.esgst-es-page-${endless} .giveaway_image_avatar, .esgst-es-page-${endless}.giveaway_image_avatar` : `.giveaway_image_avatar`}, ${endless ? `.esgst-es-page-${endless} .featured_giveaway_image_avatar, .esgst-es-page-${endless}.featured_giveaway_image_avatar` : `.featured_giveaway_image_avatar`}, ${endless ? `.esgst-es-page-${endless} :not(.esgst-ggl-panel) .table_image_avatar, .esgst-es-page-${endless}:not(.esgst-ggl-panel) .table_image_avatar` : `:not(.esgst-ggl-panel) .table_image_avatar`}`);
    for (let i = 0, n = userElements.length; i < n; ++i) {
      userElements[i].classList.add(`esgst-ib-user`);
    }
    const gameElements = context.querySelectorAll(`${endless ? `.esgst-es-page-${endless} .giveaway_image_thumbnail, .esgst-es-page-${endless}.giveaway_image_thumbnail` : `.giveaway_image_thumbnail`}, ${endless ? `.esgst-es-page-${endless} .giveaway_image_thumbnail_missing, .esgst-es-page-${endless}.giveaway_image_thumbnail_missing` : `.giveaway_image_thumbnail_missing`}, ${endless ? `.esgst-es-page-${endless} .table_image_thumbnail, .esgst-es-page-${endless}.table_image_thumbnail` : `.table_image_thumbnail`}, ${endless ? `.esgst-es-page-${endless} .table_image_thumbnail_missing, .esgst-es-page-${endless}.table_image_thumbnail_missing` : `.table_image_thumbnail_missing`}`);
    for (let i = 0, n = gameElements.length; i < n; ++i) {
      gameElements[i].classList.add(`esgst-ib-game`);
    }
  }

  // [VAI]

  _MODULES.push({
    conflicts: [
      {id: `ail`, name: `Attached Image Loader`}
    ],
    description: `
      <ul>
        <li>Displays all of the attached images (in any page) by default so that you do not need to click on "View attached image" to view them.</li>
      </ul>
    `,
    features: {
      vai_gifv: {
        name: `Rename .gifv images to .gif so that they are properly attached.`,
        sg: true,
        st: true
      }
    },
    id: `vai`,
    load: vai,
    name: `Visible Attached Images`,
    sg: true,
    st: true,
    type: `general`
  });

  function vai() {
    esgst.endlessFeatures.push(vai_getImages);
  }

  function vai_getImages(context, main, source, endless) {
    let buttons = context.querySelectorAll(`${endless ? `.esgst-es-page-${endless} .comment__toggle-attached, .esgst-es-page-${endless}.comment__toggle-attached` : `.comment__toggle-attached`}, ${endless ? `.esgst-es-page-${endless} .view_attached, .esgst-es-page-${endless}.view_attached` : `.view_attached`}`);
    for (let i = 0, n = buttons.length; i < n; i++) {
      let button = buttons[i];
      let image = button.nextElementSibling.firstElementChild;
      let url = image.getAttribute(`src`);
      if (url && esgst.vai_gifv) {
        url = url.replace(/\.gifv/, `.gif`);
        image.setAttribute(`src`, url);
      }
      image.classList.remove(`is_hidden`, `is-hidden`);
    }
  }

  // [AIL]

  _MODULES.push({
    conflicts: [
      {id: `vai`, name: `Visible Attached Images`}
    ],
    description: `
      <ul>
        <li>Only loads an attached image (in any page) when you click on its "View attached image" button, instead of loading it on page load, which should speed up page loads.</li>
      </ul>
    `,
    id: `ail`,
    load: ail,
    name: `Attached Image Loader`,
    sg: true,
    st: true,
    type: `general`
  });

  function ail() {
    if (esgst.vai) return;
    esgst.endlessFeatures.push(ail_getImages);
  }

  function ail_getImages(context, main, source, endless) {
    const buttons = context.querySelectorAll(`${endless ? `.esgst-es-page-${endless} .comment__toggle-attached, .esgst-es-page-${endless}.comment__toggle-attached` : `.comment__toggle-attached`}, ${endless ? `.esgst-es-page-${endless} .view_attached, .esgst-es-page-${endless}.view_attached` : `.view_attached`}`);
    for (let i = 0, n = buttons.length; i < n; i++) {
      const button = buttons[i],
          image = button.nextElementSibling.firstElementChild,
          url = image.getAttribute(`src`);
      image.removeAttribute(`src`);
      button.addEventListener(`click`, image.setAttribute.bind(image, `src`, url));
    }
  }

  // [CEWGD]

  _MODULES.push({
    description: `
      <ul>
        <li>Adds more details to each giveaway in your <a href="https://www.steamgifts.com/giveaways/created">created</a>/<a href="https://www.steamgifts.com/giveaways/entered">entered</a>/<a href="https://www.steamgifts.com/giveaways/won">won</a> pages:</li>
        <ul>
          <li>How many points the giveaway is worth next to the game's name.</li>
          <li>An icon (<i class="fa fa-steam"></i>) next to the game's name that links to the game's Steam store page.</li>
          <li>For the entered/won pages only, the creator's username next to the giveaway's end time.</li>
          <li>A column "Type" containing the giveaway's type (public, invite only, group, whitelist or region restricted).</li>
          <li>A column "Level" containing the giveaway's level.</li>
          <li>For the created page only, a column "Winner(s)" containing the giveaway's winner(s) and how many of them have marked it as received/not received.</li>
        </ul>
      </ul>
    `,
    id: `cewgd`,
    load: cewgd,
    name: `Created/Entered/Won Giveaway Details`,
    sg: true,
    type: `giveaways`
  });

  function cewgd() {
    if (!esgst.createdPath && !esgst.enteredPath && !esgst.wonPath) return;
    esgst.endlessFeatures.push(cewgd_addHeading);
    esgst.giveawayFeatures.push(cewgd_getDetails_pre);
  }

  function cewgd_addHeading(context, main, source, endless) {
    if (!main) return;
    const table = context.querySelector(`${endless ? `.esgst-es-page-${endless} .table__heading, .esgst-es-page-${endless}.table__heading` : `.table__heading`}`);
    if (!table || table.getElementsByClassName(`esgst-cewgd-heading`)[0]) return;
    table.firstElementChild.insertAdjacentHTML(`afterEnd`, `
      <div class="table__column--width-small text-center esgst-cewgd-heading">Type</div>
      <div class="table__column--width-small text-center esgst-cewgd-heading">Level</div>
      ${esgst.createdPath ? `
        <div class="table__column--width-small text-center esgst-cewgd-heading">Winner(s)</div>
      ` : ``}
    `);
  }

  function cewgd_getDetails_pre(giveaways, main) {
    cewgd_getDetails(giveaways, main);
  }

  async function cewgd_getDetails(giveaways, main) {
    if (!main) return;
    let cewgd = {
      giveaways: [],
      savedGiveaways: JSON.parse(await getValue(`giveaways`, `{}`))
    };
    let promises = [];
    for (let i = 0, n = giveaways.length; i < n; ++i) {
      promises.push(cewgd_getDetail(cewgd, giveaways, i));
    }
    await Promise.all(promises);
    let deleteLock = await createLock(`giveawayLock`, 300);
    for (let i = 0, n = cewgd.giveaways.length; i < n; ++i) {
      let currentGiveaway = cewgd.giveaways[i];
      if (cewgd.savedGiveaways[currentGiveaway.code]) {
        for (let key in currentGiveaway) {
          cewgd.savedGiveaways[currentGiveaway.code][key] = currentGiveaway[key];
        }
      } else {
        cewgd.savedGiveaways[currentGiveaway.code] = currentGiveaway;
      }
    }
    await setValue(`giveaways`, JSON.stringify(cewgd.savedGiveaways));
    deleteLock();
  }

  async function cewgd_getDetail(cewgd, giveaways, i) {
    let giveaway = giveaways[i];
    let code = giveaway.code;
    let j;
    if (esgst.createdPath && cewgd.savedGiveaways[code] && cewgd.savedGiveaways[code].gameSteamId && Array.isArray(cewgd.savedGiveaways[code].winners)) {
      for (j = cewgd.savedGiveaways[code].winners.length - 1; j > -1; j--) {
        let winner = cewgd.savedGiveaways[code].winners[j];
        if (winner.status !== `Received` && winner.status !== `Not Received`) {
          break;
        }
      }
    }
    if (cewgd.savedGiveaways[code] && cewgd.savedGiveaways[code].gameSteamId && (!esgst.createdPath || j < 0) && (!esgst.wonPath || cewgd.savedGiveaways[code].creator !== esgst.username)) {
      cewgd_addDetails(giveaway, cewgd.savedGiveaways[code]);
    } else if (esgst.createdPath) {
      let currentGiveaway = null;
      let nextPage = 1;
      let pagination = null;
      do {
        let response = await request({method: `GET`, url: `${giveaway.url}/winners/search?page=${nextPage}`});
        let responseHtml = parseHtml(response.responseText);
        if (!currentGiveaway) {
          let currentGiveaways = await giveaways_get(responseHtml, false, response.finalUrl);
          if (currentGiveaways.length > 0) {
            currentGiveaway = currentGiveaways[0];
            currentGiveaway.winners = [];
          }
        }
        if (currentGiveaway) {
          let elements = responseHtml.getElementsByClassName(`table__row-inner-wrap`);
          for (let i = 0, n = elements.length; i < n; ++i) {
            let element = elements[i];
            currentGiveaway.winners.push({
              status: element.lastElementChild.textContent.trim(),
              username: element.firstElementChild.nextElementSibling.firstElementChild.textContent.trim()
            });
          }
          pagination = responseHtml.getElementsByClassName(`pagination__navigation`)[0];
        } else {
          (giveaway.panel || (esgst.gm_enable && esgst.createdPath ? giveaway.innerWrap.firstElementChild.nextElementSibling.nextElementSibling : giveaway.innerWrap.firstElementChild.nextElementSibling)).insertAdjacentHTML(`afterEnd`, `
            <div class="table__column--width-small text-center">-</div>
            <div class="table__column--width-small text-center">-</div>
            <div class="table__column--width-small text-center">-</div>
          `);
          pagination = null;
        }
        nextPage += 1;
      } while (pagination && !pagination.lastElementChild.classList.contains(`is-selected`));
      if (currentGiveaway) {
        cewgd.giveaways.push(currentGiveaway);
        cewgd_addDetails(giveaway, currentGiveaway);
      }
    } else {
      let response = await request({method: `GET`, url: giveaway.url});
      let responseHtml = parseHtml(response.responseText);
      let currentGiveaways = await giveaways_get(responseHtml, false, response.finalUrl);
      if (currentGiveaways.length > 0) {
        let currentGiveaway = currentGiveaways[0];
        cewgd.giveaways.push(currentGiveaway);
        cewgd_addDetails(giveaway, currentGiveaway);
        cewgd.count += 1;
      } else {
        (giveaway.panel || (esgst.gm_enable && esgst.createdPath ? giveaway.innerWrap.firstElementChild.nextElementSibling.nextElementSibling : giveaway.innerWrap.firstElementChild.nextElementSibling)).insertAdjacentHTML(`afterEnd`, `
          <div class="table__column--width-small text-center">-</div>
          <div class="table__column--width-small text-center">-</div>
        `);
      }
    }
  }

  function cewgd_addDetails(giveaway, details) {
    let type, typeColumn;
    if (!giveaway.id) {
      giveaway.id = details.gameSteamId;
      giveaway.type = details.gameType;
      if (esgst.games && esgst.games[giveaway.type][giveaway.id]) {
        const keys = [`owned`, `wishlisted`, `hidden`, `ignored`, `previouslyEntered`, `previouslyWon`, `reducedCV`, `noCV`];
        for (const key of keys) {
          if (esgst.games[giveaway.type][giveaway.id][key === `previouslyEntered` ? `entered` : (key === `previouslyWon` ? `won` : key)]) {
            giveaway[key] = true;
          }
        }
      }
    }
    giveaway.points = details.points;
    if (giveaway.gwcContext) {
      giveaway.chancePerPoint = Math.round(giveaway.chance / Math.max(1, giveaway.points) * 100) / 100;
      giveaway.gwcContext.title = getFeatureTooltip(`gwc`, `Giveaway Winning Chance (${giveaway.chancePerPoint}% per point)`);
    }
    giveaway.level = details.level;
    giveaway.headingName.insertAdjacentHTML(`beforeEnd`, `
      <span>(${details.points}P)</span>
      ${details.gameType ? `
        <a class="giveaway__icon" href="http://store.steampowered.com/${details.gameType.slice(0, -1)}/${details.gameSteamId}" target="_blank">
          <i class="fa fa-steam"></i>
        </a>
      ` : ``}
    `);
    giveaway.inviteOnly = details.inviteOnly;
    giveaway.regionRestricted = details.regionRestricted;
    giveaway.group = details.group;
    giveaway.whitelist = details.whitelist;
    if (details.inviteOnly) {
      if (details.regionRestricted) {
        type = `Invite + Region`;
      } else {
        type = `Invite`;
      }
    } else if (details.group) {
      if (details.whitelist) {
        if (details.regionRestricted) {
          type = `Group + Whitelist + Region`;
        } else {
          type = `Group + Whitelist`;
        }
      } else if (details.regionRestricted) {
        type = `Group + Region`;
      } else {
        type = `Group`;
      }
    } else if (details.whitelist) {
      if (details.regionRestricted) {
        type = `Whitelist + Region`;
      } else {
        type = `Whitelist`;
      }
    } else if (details.regionRestricted) {
      type = `Region`;
    } else {
      type = `Public`;
    }
    typeColumn = insertHtml(giveaway.panel || giveaway.innerWrap.firstElementChild.nextElementSibling, `afterEnd`, `
      <div class="table__column--width-small text-center">${type}</div>
      <div class="table__column--width-small text-center">${details.level}</div>
      ${esgst.createdPath ? `
        <div class="table__column--width-small text-center"></div>
      ` : ``}
    `);
    if (esgst.createdPath) {
      let n, winner, winnersColumn;
      winnersColumn = typeColumn.nextElementSibling.nextElementSibling;
      n = details.winners.length;
      if (n > 0) {
        if (n > 1) {
          winner = details.winners[0].username;
          winnersColumn.innerHTML = `<a class="table__column__secondary-link" href="/user/${winner}">${winner}</a> <span class="esgst-clickable table__column__secondary-link">(+${n - 1} more)</span>`;
          winnersColumn.lastElementChild.addEventListener(`click`, cewgd_openWinnersPopup.bind(null, details));
          let received = 0;
          for (const winner of details.winners) {
            if (winner.status === `Received`) {
              received += 1;
            }
          }
          giveaway.innerWrap.lastElementChild.insertAdjacentText(`beforeEnd`, ` (${received}/${n})`);
        } else {
          winner = details.winners[0].username;
          winnersColumn.innerHTML = `<a class="table__column__secondary-link" href="/user/${winner}">${winner}</a>`;
        }
      } else {
        winnersColumn.textContent = `-`;
      }
    } else if (esgst.enteredPath || esgst.wonPath) {
      giveaway.endTimeColumn.insertAdjacentHTML(`beforeEnd`, `
        by <a class="table__column__secondary-link" href="/user/${details.creator}">${details.creator}</a>
      `);
      giveaway.creator = details.creator;
      giveaway.creators.push(giveaway.creator.toLowerCase());
    }
    if (giveaway.group && esgst.ggl) {
      ggl_getGiveaways([giveaway]);
    }
  }

  function cewgd_openWinnersPopup(details) {
    const popup = new Popup_v2({
      icon: `fa-users`,
      title: `Winners`,
      addScrollable: `left`
    });
    let html = `
      <div class="table__heading">
        <div class="table__column--width-small">Winner</div>
        <div class="table__column--width-small">Received</div>
      </div>
      <div class="table__rows">
    `;
    for (const winner of details.winners) {
      html += `
        <div class="table__row-outer-wrap">
          <div class="table__row-inner-wrap">
            <div class="table__column--width-small">
              <a class="table__column__secondary-link" href="/user/${winner.username}">${winner.username}</a>
            </div>
            <div class="table__column--width-small">
            ${{
              [`Received`]: `<i class="fa fa-check-circle esgst-green"></i>`,
              [`Not Received`]: `<i class="fa fa-times-circle esgst-red"></i>`,
              [`Awaiting Feedback`]: `<i class="fa fa-question-circle esgst-grey"></i>`
            }[winner.status]}
            </div>
          </div>
        </div>
      `;
    }
    html += `
      </div>
    `;
    popup.open();
    endless_load(popup.getScrollable(html));
  }

  // [DKC]

  _MODULES.push({
    description: `
      <ul>
        <li>Shows a confirmation popup if you try to delete a giveaway's key(s) (in any <a href="https://www.steamgifts.com/giveaway/aeqw7/dead-space/winners">winners</a> page).</li>
      </ul>
    `,
    id: `dkc`,
    load: dkc,
    name: `Delete Key Confirmation`,
    sg: true,
    type: `giveaways`
  });

  function dkc() {
    if (!esgst.giveawayPath) return;
    esgst.endlessFeatures.push(dkc_getLinks);
  }

  function dkc_getLinks(context, main, source, endless) {
    const elements = context.querySelectorAll(`${endless ? `.esgst-es-page-${endless} .form__key-btn-delete, .esgst-es-page-${endless}.form__key-btn-delete` : `.form__key-btn-delete`}`);
    for (let i = elements.length - 1; i > -1; --i) {
      const element = elements[i];
          newElement = insertHtml(element, `afterEnd`, `
            <span class="table__column__secondary-link esgst-clickable">Delete</span>
          `);
      element.remove();
      newElement.addEventListener(`click`, createConfirmation.bind(null, `Are you sure you want to delete this key?`, dkc_deleteKey.bind(null, newElement), null));
    }
  }

  async function dkc_deleteKey(link) {
    let row = link.closest(`.table__row-inner-wrap`);
    row.getElementsByClassName(`form__key-read`)[0].classList.add(`is-hidden`);
    row.getElementsByClassName(`form__key-loading`)[0].classList.remove(`is-hidden`);
    row.querySelector(`[name="key_value"]`).value = ``;
    row.getElementsByClassName(`form__key-value`)[0].textContent = ``;
    await request({data: `xsrf_token=${esgst.xsrfToken}&do=set_gift_key&key_value=&winner_id=${row.querySelector(`[name="winner_id"]`).value}`, method: `POST`, url: `/ajax.php`});
    row.getElementsByClassName(`form__key-loading`)[0].classList.add(`is-hidden`);
    row.getElementsByClassName(`form__key-insert`)[0].classList.remove(`is-hidden`);
    row.getElementsByClassName(`js__sent-text`)[0].textContent = `Sent Gift`;
    row.getElementsByClassName(`js__sent-text`)[1].textContent = `Sent Gift`;
  }

  // [GCL]

  _MODULES.push({
    description: `
      <ul>
        <li>If you click on/hover over (you can decide which one) the region restricted icon (<i class="fa fa-globe"></i>) of a giveaway (in any page) it shows the countries that the giveaway is restricted to.</li>
      </ul>
    `,
    id: `gcl`,
    load: gcl,
    name: `Giveaway Country Loader`,
    options: {
      title: `Load as:`,
      values: [`Popout (On Hover)`, `Popout (On Click)`, `Popup (On Click)`]
    },
    sg: true,
    type: `giveaways`
  });

  function gcl() {
    esgst.giveawayFeatures.push(gcl_setButton);
  }

  function gcl_setButton(giveaways, main) {
    if (main && (esgst.createdPath || esgst.enteredPath || esgst.wonPath)) return;
    giveaways.forEach(giveaway => {
      let container, context, delay, eventType, exitTimeout, onClick, timeout;
      if (giveaway.regionRestricted) {
        switch (esgst.gcl_index) {
          case 0:
            eventType = `mouseenter`;
            onClick = false;
            delay = 1000;
            giveaway.regionRestricted.addEventListener(`mouseleave`, event => {
              if (timeout) {
                clearTimeout(timeout);
                timeout = null;
              }
              exitTimeout = setTimeout(() => {
                if (context && !container.contains(event.relatedTarget)) {
                  context.close();
                }
              }, 1000);
            });
            giveaway.regionRestricted.addEventListener(`click`, () => {
              if (timeout) {
                clearTimeout(timeout);
                timeout = null;
              }
            });
            break;
          case 1:
            eventType = `click`;
            onClick = true;
            delay = 0;
            giveaway.regionRestricted.removeAttribute(`href`);
            giveaway.regionRestricted.classList.add(`esgst-clickable`);
            break;
          case 2:
            eventType = `click`;
            delay = 0;
            giveaway.regionRestricted.removeAttribute(`href`);
            giveaway.regionRestricted.classList.add(`esgst-clickable`);
            break;
        }
        giveaway.regionRestricted.addEventListener(eventType, () => {
          timeout = setTimeout(() => {
            if (context) {
              switch (esgst.gcl_index) {
                case 0:
                  context.open(giveaway.regionRestricted);
                  break;
                case 1:
                  if (context.isOpen) {
                    context.close();
                  } else {
                    context.open(giveaway.regionRestricted);
                  }
                  break;
                case 2:
                  context.open();
                  break;
              }
            } else {
              if (esgst.gcl_index === 2) {
                context = new Popup(`fa-globe`, `<a href="${giveaway.url}/region-restrictions">Giveaway Countries</a>`);
                container = context.scrollable;
                context.open();
              } else {
                context = new Popout(`esgst-gcl-popout`, null, 1000, onClick);
                container = context.popout;
                context.open(giveaway.regionRestricted);
              }
              container.innerHTML = `
                <i class="fa fa-circle-o-notch fa-spin"></i>
                <span>Loading countries...</span>
              `;
              gcl_getCountries([], 1, `${giveaway.url}/region-restrictions/search?page=`, async countries => {
                if (countries) {
                  container.innerHTML = `
                    <input placeholder="Search country..." type="text"/>
                    <div class="esgst-text-left table">
                      <div class="table__rows"></div>
                    </div>
                  `;
                  container.firstElementChild.addEventListener(`input`, () => {
                    let elements, i, value;
                    value = container.firstElementChild.value.toLowerCase();
                    elements = container.lastElementChild.firstElementChild.children;
                    if (value) {
                      for (i = elements.length - 1; i > -1; --i) {
                        const element = elements[i];
                        if (element.getElementsByClassName(`table__column__heading`)[0].textContent.toLowerCase().match(value)) {
                          element.classList.remove(`esgst-hidden`);
                        } else {
                          element.classList.add(`esgst-hidden`);
                        }
                      }
                    } else {
                      for (i = elements.length - 1; i > -1; --i) {
                        elements[i].classList.remove(`esgst-hidden`);
                      }
                    }
                    context.reposition();
                  });
                  countries.forEach(country => {
                    container.lastElementChild.firstElementChild.insertAdjacentHTML(`beforeEnd`, country);
                  });
                  await endless_load(container);
                  if (esgst.gcl_index === 1) {
                    container.insertAdjacentHTML(`afterBegin`, `<a class="esgst-ggl-heading" href="${giveaway.url}/region-restrictions">Giveaway Countries</a>`);
                  }
                  context.reposition();
                } else {
                  container.innerHTML = `
                    <i class="fa fa-times-circle"></i>
                    <span>An error ocurred.</span>
                  `;
                  if (esgst.gcl_index === 1) {
                    container.insertAdjacentHTML(`afterBegin`, `<a class="esgst-ggl-heading" href="${giveaway.url}/region-restrictions">Giveaway Countries</a>`);
                  }
                  context.reposition();
                }
              });
            }
            if (esgst.gcl_index === 0) {
              container.onmouseenter = () => {
                if (exitTimeout) {
                  clearTimeout(exitTimeout);
                  exitTimeout = null;
                }
              };
            }
          }, delay);
        });
      }
    });
  }

  async function gcl_getCountries(countries, nextPage, url, callback) {
    let responseHtml = parseHtml((await request({method: `GET`, url: `${url}${nextPage}`})).responseText);
    if (responseHtml.getElementsByClassName(`table--summary`)[0]) {
      setTimeout(callback, 0, null);
    } else {
      let elements, i, n, pagination;
      elements = responseHtml.getElementsByClassName(`table__row-outer-wrap`);
      for (i = 0, n = elements.length; i < n; ++i) {
        countries.push(elements[i].outerHTML);
      }
      pagination = responseHtml.getElementsByClassName(`pagination__navigation`)[0];
      if (pagination && !pagination.lastElementChild.classList.contains(`is-selected`)) {
        setTimeout(() => gcl_getCountries(countries, ++nextPage, url, callback), 0);
      } else {
        setTimeout(callback, 0, countries);
      }
    }
  }
  
  // [GWC]
  
  _MODULES.push({
    description: `
      <ul>
        <li>Adds an element (<i class="fa fa-area-chart"></i> [Chance]%) below a giveaway's start time (in any page) that shows your chance of winning the giveaway.</li>
        <li>The chance is calculated by rounding up (using 2 decimals) the result of the following formula: number_of_copies / number_of_entries * 100
        <li>You can move the element around by dragging and dropping it.</li>
      </ul>
    `,
    features: {
      gwc_e: {
        description: `
          <ul>
            <li>The formula changes to: number_of_copies / (number_of_entries + 1) * 100
            <li>For example, if a giveaway has 5 entries, the current chance of winning it is 20%, but after you enter it, it will have 6 entries, so the chance will decrease to 16.67%.</li>
          </ul>
        `,
        name: `Show what the chance will be when you enter the giveaway instead of the current chance.`,
        sg: true
      },
      gwc_a: {
        description: `
          <ul>
            <li>Uses an advanced formula (number_of_copies / (number_of_entries / time_open_in_milliseconds * duration_in_milliseconds) * 100) to calculate the chance based on how much time the giveaway has been open and the duration of the giveaway. This gives you an estimate of what the chance will be when the giveaway ends.</li>
          </ul>
        `,
        features: {
          gwc_a_b: {
            name: `Show the basic chance along with the advanced one (the advanced chance will appear in a parenthesis, like "[Basic]% ([Advanced]%)").`,
            sg: true
          }
        },
        name: `Use advanced formula.`,
        sg: true
      },
      gwc_h: {
        conflicts: [
          {id: `gwr_h`, name: `Giveaway Winning Ratio > Highlight the giveaway.`}
        ],
        description: `
          <ul>
            <li>Changes the color of the giveaway's title to the same color as the chance and adds a border of same color to the giveaway's game image.</li>
          </ul>
        `,
        inputItems: [
          {
            id: `gwc_h_width`,
            prefix: `Image Border Width: `
          }
        ],
        name: `Highlight the giveaway.`,
        sg: true
      }
    },
    id: `gwc`,
    load: gwc,
    name: `Giveaway Winning Chance`,
    sg: true,
    type: `giveaways`
  });

  function gwc() {
    esgst.giveawayFeatures.push(gwc_addChances);
    if (!esgst.enteredPath) return;
    esgst.endlessFeatures.push(gwc_addHeading);
  }

  function gwc_addChances(giveaways, main, source) {
    giveaways.forEach(giveaway => {
      if (giveaway.sgTools || (main && (esgst.createdPath || esgst.wonPath || esgst.newGiveawayPath || esgst.archivePath))) return;
      if (((giveaway.inviteOnly && ((main && (esgst.giveawayPath || esgst.enteredPath)) || !main || giveaway.ended)) || !giveaway.inviteOnly) && !giveaway.innerWrap.getElementsByClassName(`esgst-gwc`)[0]) {
        if (giveaway.started) {
          giveaway.gwcContext = insertHtml(giveaway.panel, (esgst.gv && ((main && esgst.giveawaysPath) || (source === `gb` && esgst.gv_gb) || (source === `ged` && esgst.gv_ged) || (source === `ge` && esgst.gv_ge))) ? `afterBegin` : `beforeEnd`, `<div class="${esgst.giveawayPath ? `featured__column` : ``} esgst-gwc" data-columnId="gwc" title="${getFeatureTooltip(`gwc`, `Giveaway Winning Chance`)}">`);
          gwc_addChance(giveaway);
          if (!esgst.lockGiveawayColumns && (!main || esgst.giveawaysPath || esgst.userPath || esgst.groupPath)) {
            giveaway.gwcContext.setAttribute(`draggable`, true);
            giveaway.gwcContext.addEventListener(`dragstart`, giveaways_setSource.bind(null, giveaway));
            giveaway.gwcContext.addEventListener(`dragenter`, giveaways_getSource.bind(null, giveaway, false));
            giveaway.gwcContext.addEventListener(`dragend`, giveaways_saveSource.bind(null, giveaway));
          }
        } else {
          giveaway.chance = 100;
          giveaway.chancePerPoint = Math.round(100 / Math.max(1, giveaway.points) * 100) / 100;
        }
      }
    });
  }

  function gwc_addChance(giveaway) {
    let advancedChance, advancedColor, basicChance, basicColor, colors, entries, i;
    entries = giveaway.entered || giveaway.ended || giveaway.created || !esgst.gwc_e ? giveaway.entries : giveaway.entries + 1;
    basicChance = entries > 0 ? Math.round(giveaway.copies / entries * 10000) / 100 : 100;
    basicChance = basicChance > 100 ? 100 : (basicChance <= 0 ? 0.01 : basicChance);
    if (esgst.gwc_a && !giveaway.ended && giveaway.startTime) {
      advancedChance = entries > 0 ? Math.round(giveaway.copies / (entries / (Date.now() - giveaway.startTime) * (giveaway.endTime - giveaway.startTime)) * 10000) / 100 : 100;
      advancedChance = advancedChance > 100 ? 100 : (advancedChance <= 0 ? 0.01 : advancedChance);
    }
    giveaway.chance = esgst.gwc_a && !esgst.gwc_a_b ? advancedChance : basicChance;
    giveaway.chancePerPoint = Math.round(giveaway.chance / Math.max(1, giveaway.points) * 100) / 100;
    if (giveaway.points) {
      giveaway.gwcContext.title = getFeatureTooltip(`gwc`, `Giveaway Winning Chance (${giveaway.chancePerPoint}% per point)`);
    }
    giveaway.gwcContext.setAttribute(`data-chance`, giveaway.chance);
    for (i = esgst.gwc_colors.length - 1; i > -1; --i) {
      colors = esgst.gwc_colors[i];
      if (basicChance >= parseFloat(colors.lower) && basicChance <= parseFloat(colors.upper)) {
        basicColor = colors.color;
        break;
      }
    }
    for (i = esgst.gwc_colors.length - 1; i > -1; --i) {
      colors = esgst.gwc_colors[i];
      if (advancedChance >= parseFloat(colors.lower) && advancedChance <= parseFloat(colors.upper)) {
        advancedColor = colors.color;
        break;
      }
    }
    if (esgst.gwc_h) {
      giveaway.headingName.classList.add(`esgst-gwc-highlight`);
      giveaway.headingName.style.color = esgst.gwc_a && !esgst.gwc_a_b ? advancedColor : basicColor;
      if (giveaway.image) {
        giveaway.image.classList.add(`esgst-gwc-highlight`);
        giveaway.image.style.color = `${esgst.gwc_a && !esgst.gwc_a_b ? advancedColor : basicColor}`;
        giveaway.image.style.boxShadow = `${esgst.gwc_a && !esgst.gwc_a_b ? advancedColor : basicColor} 0px 0px 0px var(--esgst-gwc-highlight-width, 3px) inset`;
      }
    }
    if (esgst.enteredPath) {
      giveaway.gwcContext.style.display = `inline-block`;
    }
    giveaway.gwcContext.innerHTML = `
      ${esgst.enteredPath ? `` : `<i class="fa fa-area-chart"></i>`}
      <span>${esgst.gwc_a && advancedChance ? (esgst.gwc_a_b ? `<span${basicColor ? ` style="color: ${basicColor}; font-weight: bold;"` : ``}>${basicChance}%</span> (<span${advancedColor ? ` style="color: ${advancedColor}; font-weight: bold;"` : ``}>${advancedChance}%</span>)` : `<span${advancedColor ? ` style="color: ${advancedColor}; font-weight: bold;"` : ``}>${advancedChance}%</span>`) : `<span${basicColor ? ` style="color: ${basicColor}; font-weight: bold;"` : ``}>${basicChance}%</span>`}${esgst.enteredPath && esgst.gwr ? ` / ` : ``}</span>
    `;
  }

  function gwc_addHeading(context, main, source, endless) {
    if (esgst.createdPath || esgst.wonPath || !main) return;
    const table = context.querySelector(`${endless ? `.esgst-es-page-${endless} .table__heading, .esgst-es-page-${endless}.table__heading` : `.table__heading`}`);
    if (!table || table.getElementsByClassName(`esgst-gwcr-heading`)[0]) return;
    let title;
    if (esgst.gwc && esgst.gwr) {
      title = `Chance / Ratio`;
    } else if (esgst.gwc) {
      title = `Chance`;
    } else {
      title = `Ratio`;
    }
    table.firstElementChild.insertAdjacentHTML(`afterEnd`, `<div class="table__column--width-small text-center esgst-gwcr-heading">${title}</div>`);
  }
  
  // [GWR]
  
  _MODULES.push({
    description: `
      <ul>
        <li>Adds an element (<i class="fa fa-pie-chart"></i> [Ratio]:1) below a giveaway's start time (in any page) that shows the ratio (number of entries per copy) of the giveaway.</li>
        <li>The ratio is calculated by rounding up the result of the following formula: number_of_entries / number_of_copies
        <li>You can move the element around by dragging and dropping it.</li>
      </ul>
    `,
    features: {
      gwr_e: {
        description: `
          <ul>
            <li>The formula changes to: (number_of_entries + 1) / number_of_copies
            <li>For example, if a giveaway has 2 copies and 6 entries, the current ratio is 3:1, but after you enter it, it will have 7 entries, so the ratio will increase to 4:1.</li>
          </ul>
        `,
        name: `Show what the ratio will be when you enter the giveaway instead of the current ratio.`,
        sg: true
      },
      gwr_a: {
        description: `
          <ul>
            <li>Uses an advanced formula ((number_of_entries / time_open_in_milliseconds * duration_in_milliseconds) / number_of_copies) to calculate the ratio based on how much time the giveaway has been open and the duration of the giveaway. This gives you an estimate of what the ratio will be when the giveaway ends.</li>
          </ul>
        `,
        features: {
          gwr_a_b: {
            name: `Show the basic ratio along with the advanced one (the advanced ratio will appear in a parenthesis, like "[Basic]:1 ([Advanced]:1)").`,
            sg: true
          }
        },
        name: `Use advanced formula.`,
        sg: true
      },
      gwr_h: {
        conflicts: [
          {id: `gwc_h`, name: `Giveaway Winning Chance > Highlight the giveaway.`}
        ],
        description: `
          <ul>
            <li>Changes the color of the giveaway's title to the same color as the ratio and adds a border of same color to the giveaway's game image.</li>
          </ul>
        `,
        inputItems: [
          {
            id: `gwr_h_width`,
            prefix: `Image Border Width: `
          }
        ],
        name: `Highlight the giveaway.`,
        sg: true
      }
    },
    id: `gwr`,
    load: gwr,
    name: `Giveaway Winning Ratio`,
    sg: true,
    type: `giveaways`
  });

  function gwr() {
    esgst.giveawayFeatures.push(gwr_addRatios);
    if (esgst.gwc || !esgst.enteredPath) return;
    esgst.endlessFeatures.push(gwc_addHeading);
  }

  function gwr_addRatios(giveaways, main, source) {
    giveaways.forEach(giveaway => {
      if (giveaway.sgTools || (main && (esgst.createdPath || esgst.wonPath || esgst.newGiveawayPath || esgst.archivePath))) return;
      if (giveaway.started && ((giveaway.inviteOnly && ((main && (esgst.giveawayPath || esgst.enteredPath)) || !main || giveaway.ended)) || !giveaway.inviteOnly) && !giveaway.innerWrap.getElementsByClassName(`esgst-gwr`)[0]) {
        let context = insertHtml(giveaway.panel, (esgst.gv && ((main && esgst.giveawaysPath) || (source === `gb` && esgst.gv_gb) || (source === `ged` && esgst.gv_ged) || (source === `ge` && esgst.gv_ge))) ? `afterBegin` : `beforeEnd`, `<div class="${esgst.giveawayPath ? `featured__column` : ``} esgst-gwr" data-columnId="gwr" title="${getFeatureTooltip(`gwr`, `Giveaway Winning Ratio`)}">`);
        gwr_addRatio(context, giveaway);
        if (!esgst.lockGiveawayColumns && (!main || esgst.giveawaysPath || esgst.userPath || esgst.groupPath)) {
          context.setAttribute(`draggable`, true);
          context.addEventListener(`dragstart`, giveaways_setSource.bind(null, giveaway));
          context.addEventListener(`dragenter`, giveaways_getSource.bind(null, giveaway, false));
          context.addEventListener(`dragend`, giveaways_saveSource.bind(null, giveaway));
        }
      }
    });
  }

  function gwr_addRatio(context, giveaway) {
    let advancedColor, advancedRatio, basicColor, basicRatio, colors, entries, i;
    entries = giveaway.entered || giveaway.ended || giveaway.created || !esgst.gwr_e ? giveaway.entries : giveaway.entries + 1;
    basicRatio = Math.ceil(entries / giveaway.copies);
    if (esgst.gwr_a && !giveaway.ended && giveaway.startTime) {
      advancedRatio = Math.ceil((entries / (Date.now() - giveaway.startTime) * (giveaway.endTime - giveaway.startTime)) / giveaway.copies);
    }
    giveaway.ratio = esgst.gwr_a && !esgst.gwr_a_b ? advancedRatio : basicRatio;
    context.setAttribute(`data-ratio`, giveaway.ratio);
    for (i = esgst.gwr_colors.length - 1; i > -1; --i) {
      colors = esgst.gwr_colors[i];
      if (basicRatio >= parseInt(colors.lower) && basicRatio <= parseInt(colors.upper)) {
        basicColor = colors.color;
        break;
      }
    }
    for (i = esgst.gwr_colors.length - 1; i > -1; --i) {
      colors = esgst.gwr_colors[i];
      if (advancedRatio >= parseInt(colors.lower) && advancedRatio <= parseInt(colors.upper)) {
        advancedColor = colors.color;
        break;
      }
    }
    if (esgst.gwr_h) {
      giveaway.headingName.classList.add(`esgst-gwr-highlight`);
      giveaway.headingName.style.color = esgst.gwr_a && !esgst.gwr_a_b ? advancedColor : basicColor;
      if (giveaway.image) {
        giveaway.image.classList.add(`esgst-gwr-highlight`);
        giveaway.image.style.color = `${esgst.gwr_a && !esgst.gwr_a_b ? advancedColor : basicColor}`;
        giveaway.image.style.boxShadow = `${esgst.gwr_a && !esgst.gwr_a_b ? advancedColor : basicColor} 0px 0px 0px var(--esgst-gwr-highlight-width, 3px)  inset`;
      }
    }
    if (esgst.enteredPath) {
      context.style.display = `inline-block`;
    }
    context.innerHTML = `
      ${esgst.enteredPath ? `` : `<i class="fa fa-pie-chart"></i>`}
      <span>${esgst.gwr_a && advancedRatio ? (esgst.gwr_a_b ? `<span${basicColor ? ` style="color: ${basicColor}; font-weight: bold;"` : ``}>${basicRatio}:1</span> (<span${advancedColor ? ` style="color: ${advancedColor}; font-weight: bold;"` : ``}>${advancedRatio}:1</span>)` : `<span${advancedColor ? ` style="color: ${advancedColor}; font-weight: bold;"` : ``}>${advancedRatio}:1</span>`) : `<span${basicColor ? ` style="color: ${basicColor}; font-weight: bold;"` : ``}>${basicRatio}:1</span>`}</span>
    `;
  }
  
  // [GETH]
  
  _MODULES.push({
    description: `
      <ul>
        <li>Allows you to highlight the end time of a giveaway (in any page) by coloring it based on how many hours there are left.</li>
      </ul>
    `,
    id: `geth`,
    load: geth,
    name: `Giveaway End Time Highlighter`,
    sg: true,
    type: `giveaways`
  });

  function geth() {
    esgst.giveawayFeatures.push(geth_getGiveaways);
  }

  function geth_getGiveaways(giveaways) {
    if (!esgst.geth_colors.length) {
      return;
    }

    for (const giveaway of giveaways) {
      if (!giveaway.started) {
        continue;
      }

      const hoursLeft = (giveaway.endTime - Date.now()) / 3600000;
      for (let i = esgst.geth_colors.length - 1; i > -1; i--) {
        const colors = esgst.geth_colors[i];
        if (hoursLeft >= parseFloat(colors.lower) && hoursLeft <= parseFloat(colors.upper)) {
          (giveaway.endTimeColumn_gv || giveaway.endTimeColumn).style.color = colors.color;
          break;
        }
      }
    }
  }
  
  // [SAL]

  _MODULES.push({
    description: `
      <ul>
        <li>Adds 2 optional icons (<i class="fa fa-steam"></i> for the Steam client and <i class="fa fa-globe"></i> for the browser) next to each key in the "Key" column of your <a href="https://www.steamgifts.com/giveaways/won">won</a> page that allow you to quickly activate a won game on Steam, either through the client or the browser.</li>
        <li>When you click on the icon, the key is automatically copied to the clipboard.</li>
      </ul>
    `,
    id: `sal`,
    load: sal,
    name: `Steam Activation Links`,
    options: {
      title: `Show links to:`,
      values: [`Steam Client`, `Browser`, `Both`]
    },
    sg: true,
    type: `giveaways`
  });

  function sal() {
    if (!esgst.wonPath) return;
    esgst.endlessFeatures.push(sal_addLinks, sal_addObservers);
  }

  function sal_addObservers(context, main, source, endless) {
    const elements = context.querySelectorAll(`${endless ? `.esgst-es-page-${endless} .view_key_btn, .esgst-es-page-${endless}.view_key_btn` : `.view_key_btn`}`);
    for (const element of elements) {
      sal_addObserver(element);
    }
  }

  function sal_addObserver(button) {
    let interval = null;
    const context = button.closest(`.table__row-outer-wrap`);
    button.addEventListener(`click`, () => {
      if (interval) {
        return;
      }
      interval = setInterval(() => {
        if (!context.contains(button)) {
          clearInterval(interval);
          interval = null;
          if (esgst.sal) {
            const element = context.querySelector(`[data-clipboard-text]`);
            const match = element.getAttribute(`data-clipboard-text`).match(/^[\d\w]{5}(-[\d\w]{5}){2,}$/);
            if (match) {
              sal_addLink(element, match[0]);
            }
          }
          if (esgst.ef) {
            ef_hideElements(context);
          }
        }
      }, 100);
    });
  }

  function sal_addLinks(context, main, source, endless) {
    const elements = context.querySelectorAll(`${endless ? `.esgst-es-page-${endless} [data-clipboard-text], .esgst-es-page-${endless}[data-clipboard-text]` : `[data-clipboard-text]`}`);
    for (const element of elements) {
      if (element.parentElement.getElementsByClassName(`esgst-sal`)[0]) {
        continue;
      }
      const match = element.getAttribute(`data-clipboard-text`).match(/^[\d\w]{5}(-[\d\w]{5}){2,}$/);
      if (match) {
        sal_addLink(element, match[0]);
      }
    }
  }

  function sal_addLink(element, match) {
    let link, textArea;
    if ((element.nextElementSibling && !element.nextElementSibling.classList.contains(`esgst-sal`)) || !element.nextElementSibling) {
      link = insertHtml(element, `afterEnd`, `
        <span></span>
      `);
      switch (esgst.sal_index) {
        case 0:
          insertHtml(link, `beforeEnd`, `
            <span class="esgst-sal esgst-clickable" title="${getFeatureTooltip(`sal`, `Activate on Steam (client)`)}">
              <i class="fa fa-steam"></i>
            </span>
          `).addEventListener(`click`, () => {
            textArea = insertHtml(document.body, `beforeEnd`, `
              <textarea></textarea>
            `);
            textArea.value = match;
            textArea.select();
            document.execCommand(`copy`);
            textArea.remove();
            location.href = `steam://open/activateproduct`;
          });
          break;
        case 1:
          link.insertAdjacentHTML(`beforeEnd`, `
            <a class="esgst-sal esgst-clickable" href="https://store.steampowered.com/account/registerkey?key=${match}" target="_blank" title="${getFeatureTooltip(`sal`, `Activate on Steam (browser)`)}">
              <i class="fa fa-globe"></i>
            </a>
          `);
          break;
        case 2:
          insertHtml(link, `beforeEnd`, `
            <span class="esgst-sal esgst-clickable" title="${getFeatureTooltip(`sal`, `Activate on Steam (client)`)}">
              <i class="fa fa-steam"></i>
            </span>
            <a class="esgst-sal esgst-clickable" href="https://store.steampowered.com/account/registerkey?key=${match}" target="_blank" title="${getFeatureTooltip(`sal`, `Activate on Steam (browser)`)}">
              <i class="fa fa-globe"></i>
            </a>
          `).previousElementSibling.addEventListener(`click`, () => {
            textArea = insertHtml(document.body, `beforeEnd`, `
              <textarea></textarea>
            `);
            textArea.value = match;
            textArea.select();
            document.execCommand(`copy`);
            textArea.remove();
            location.href = `steam://open/activateproduct`;
          });
          break;
      }
    }
  }

  // [UEG]

  _MODULES.push({
    description: `
      <ul>
        <li>Removes SteamGifts' default fade for entered giveaways.</li>
      </ul>
    `,
    id: `ueg`,
    load: ueg,
    name: `Unfaded Entered Giveaway`,
    sg: true,
    type: `giveaways`
  });

  function ueg() {
    esgst.endlessFeatures.push(ueg_remove);
  }

  function ueg_remove(context, main, source, endless) {
    const elements = context.querySelectorAll(`${endless ? `.esgst-es-page-${endless} .giveaway__row-inner-wrap.is-faded, .esgst-es-page-${endless}.giveaway__row-inner-wrap.is-faded` : `.giveaway__row-inner-wrap.is-faded`}`);
    for (let i = 0, n = elements.length; i < n; ++i) {
      elements[i].classList.add(`esgst-ueg`);
    }
  }

  // [SGG]

  _MODULES.push({
    description: `
      <ul>
        <li>Adds a button (<i class="fa fa-thumb-stack"></i> if the group is stickied and <i class="fa fa-thumb-stack esgst-faded"></i> if it is not) next to each group in the <a href="https://www.steamgifts.com/giveaways/new">new giveaway</a>/<a href="https://www.steamgifts.com/account/steam/groups">groups</a> pages that allows you to sticky the group so that it appears at the top of the group list for quick use.</li>
      </ul>
    `,
    id: `sgg`,
    load: sgg,
    name: `Stickied Giveaway Groups`,
    sg: true,
    type: `giveaways`
  });

  function sgg() {
    if (esgst.newGiveawayPath && !document.getElementsByClassName(`table--summary`)[0]) {
      sgg_setGiveawayGroups();
    }
    if (esgst.groupsPath) {
      esgst.endlessFeatures.push(sgg_setGroups);
    }
  }

  function sgg_setGiveawayGroups() {
    let avatar, code, container, context, elements, i, id, j, n, savedGroups, separator, stickied;
    savedGroups = JSON.parse(esgst.storage.groups);
    container = document.querySelector(`.form_list[data-input="group_item_string"]`);
    separator = container.firstElementChild.nextElementSibling;
    elements = container.children;
    for (i = 1, n = elements.length; i < n; ++i) {
      context = elements[i];
      id = context.getAttribute(`data-item-id`);
      avatar = context.firstElementChild.style.backgroundImage;
      code = null;
      stickied = false;
      for (j = savedGroups.length - 1; j >= 0; --j) {
        if (avatar.match(savedGroups[j].avatar)) {
          code = savedGroups[j].code;
          if (savedGroups[j].stickied) {
            stickied = true;
          }
          break;
        }
      }
      if (code) {
        if (stickied) {
          if (context === separator) {
            separator = separator.nextElementSibling;
          }
          container.insertBefore(context, separator);
        }
        new Button(context, `afterBegin`, {
          callbacks: [sgg_stickyGroup.bind(null, code, container, context, id, separator), null, sgg_unstickyGroup.bind(null, code, container, context, id, separator), null],
          className: `esgst-sgg-button`,
          icons: [`fa-thumb-tack esgst-clickable esgst-faded`, `fa-circle-o-notch fa-spin`, `fa-thumb-tack esgst-clickable`, `fa-circle-o-notch fa-spin`],
          id: `sgg`,
          index: stickied ? 2 : 0,
          titles: [`Sticky group`, `Stickying...`, `Unsticky group`, `Unstickying...`]
        });
      }
    }
  }

  async function sgg_setGroups(context, main, source, endless) {
    const elements = context.querySelectorAll(`${endless ? `.esgst-es-page-${endless} .table__row-inner-wrap, .esgst-es-page-${endless}.table__row-inner-wrap` : `.table__row-inner-wrap`}`);
    if (!elements.length) return;
    const savedGroups = JSON.parse(await getValue(`groups`, `[]`));
    for (let i = 0, n = elements.length; i < n; i++) {
      let element = elements[i];
      let avatar = element.getElementsByClassName(`table_image_avatar`)[0].style.backgroundImage;
      let stickied = false;
      let code = null;
      for (let j = savedGroups.length - 1; j >= 0; j--) {
        if (!avatar.match(savedGroups[j].avatar)) {
          continue;
        }
        code = savedGroups[j].code;
        if (savedGroups[j].stickied) {
          stickied = true;
        }
        break;
      }
      if (!code) {
        continue;
      }
      new Button(element, `afterBegin`, {
        callbacks: [sgg_stickyGroup.bind(null, code, null, element, null, null), null, sgg_unstickyGroup.bind(null, code, null, element, null, null), null],
        className: `esgst-sgg-button`,
        icons: [`fa-thumb-tack esgst-clickable esgst-faded`, `fa-circle-o-notch fa-spin`, `fa-thumb-tack esgst-clickable`, `fa-circle-o-notch fa-spin`],
        id: `sgg`,
        index: stickied ? 2 : 0,
        titles: [`Sticky group`, `Stickying...`, `Unsticky group`, `Unstickying...`]
      });
    }
  }

  async function sgg_stickyGroup(code, container, context, id, separator, event) {
    event.stopPropagation();
    if (container) {
      if (context === separator) {
        separator = separator.nextElementSibling;
      }
      container.insertBefore(context, separator);
    }
    let groups = {};
    groups[code] = {
      stickied: true
    };
    if (id) {
      groups[code].id = id;
    }
    await lockAndSaveGroups(groups);
    return true;
  }

  async function sgg_unstickyGroup(code, container, context, id, separator, event) {
    event.stopPropagation();
    if (container) {
      container.insertBefore(context, separator);
      separator = separator.previousElementSibling;
    }
    let groups = {};
    groups[code] = {
      stickied: false
    };
    if (id) {
      groups[code].id = id;
    }
    await lockAndSaveGroups(groups);
    return true;
  }

  // [MR]

  _MODULES.push({
    description: `
      <ul>
        <li>Replaces SteamGifts' native comment box (in any page) with a comment box that allows you to reply to multiple comments at the same time and does not reload the page after submitting a reply (submitting a comment that is not a reply to another comment still reloads the page).</li>
        <li>Has [id=ded] built-in.</li>
      </ul>
    `,
    id: `mr`,
    load: mr,
    name: `Multi-Reply`,
    sg: true,
    st: true,
    type: `comments`
  });

  function mr() {
    esgst.endlessFeatures.push(mr_getButtons);
  }

  function mr_getButtons(context, main, source, endless) {
    if ((!esgst.mr || esgst.inboxPath) && (!esgst.rfi || (!esgst.inboxPath && main))) return;
    const elements = context.querySelectorAll(`${endless ? `.esgst-es-page-${endless} .comment__actions, .esgst-es-page-${endless}.comment__actions` : `.comment__actions`}, ${endless ? `.esgst-es-page-${endless} .action_list, .esgst-es-page-${endless}.action_list` : `.action_list`}`);
    for (let i = 0, n = elements.length; i < n; ++i) {
      mr_addButton(elements[i], main);
    }
  }

  function mr_addButton(Context, main) {
    let MR, Parent, ReplyButton, Permalink;
    MR = {
      Context: Context,
      Comment: Context.closest(esgst.sg ? `.comment` : `.comment_outer`)
    };
    if (MR.Comment) {
      Parent = MR.Comment.closest(esgst.sg ? `.comment` : `.comment_outer`);
      MR.Container = MR.Comment.getElementsByClassName(esgst.sg ? `comment__summary` : `comment_inner`)[0];
      MR.Timestamp = MR.Context.firstElementChild;
      ReplyButton = MR.Context.getElementsByClassName(esgst.sg ? `js__comment-reply` : `js_comment_reply`)[0];
      Permalink = MR.Context.querySelectorAll(`[href*="/go/comment/"]`);
      Permalink = Permalink[Permalink.length - 1];
      if (ReplyButton || !main || esgst.inboxPath) {
        if (ReplyButton) {
          ReplyButton.remove();
          MR.ParentID = Parent.getAttribute(esgst.sg ? `data-comment-id` : `data-id`);
          if (!main || esgst.inboxPath) {
            MR.URL = Permalink.getAttribute(`href`);
          }
          MR.url = Permalink.getAttribute(`href`);
        } else {
          MR.url = MR.URL = Permalink.getAttribute(`href`);
          MR.Comment.insertAdjacentHTML(`beforeEnd`, `<div class="comment__children comment_children"></div>`);
        }
        if (esgst.sg) {
          MR.TradeCode = ``;
        } else {
          if (main && !esgst.inboxPath) {
            MR.TradeCode = location.pathname.match(/^\/trade\/(.+?)\//)[1];
          }
          MR.Username = MR.Comment.getElementsByClassName(`author_name`)[0].textContent;
        }
        MR.Timestamp.insertAdjacentHTML(`afterEnd`, `<a class="comment__actions__button esgst-mr-reply">Reply</a>`);
        MR.Timestamp.nextElementSibling.addEventListener(`click`, () => {
          if (!MR.Box) {
            mr_addBox(MR);
          } else {
            MR.Description.focus();
          }
        });
      }
      MR.Children = MR.Comment.getElementsByClassName(esgst.sg ? `comment__children` : `comment_children`)[0];
      mr_setEdit(MR);
      mr_setDelete(MR);
      mr_setUndelete(MR);
    }
  }

  function mr_addBox(MR) {
    let Username;
    Username = esgst.username;
    MR.Children.insertAdjacentHTML(`afterBegin`, `
      <div class="comment reply_form MRBox">
      ${esgst.sg ? `
        <div class="comment__child">
          <a href="/user/${Username}" class="global__image-outer-wrap global__image-outer-wrap--avatar-small">
            <div class="global__image-inner-wrap" style="background-image: url(${esgst.avatar});"></div>
          </a>
          <div class="comment__summary">
            <div class="comment__author">
              <div class="comment__username">
                <a href="/user/${Username}">${Username}</a>
              </div>
            </div>
            <div class="comment__display-state">
              <div class="comment__description">
      ` : ``}
                <input name="trade_code" type="hidden" value="${MR.TradeCode}">
                <input name="parent_id" type="hidden" value="${MR.ParentID}">
                <textarea class="esgst-mr-description" name="description"${esgst.sg ? `` : ` placeholder="Write a reply to ${MR.Username}..."`}></textarea>
                <div class="align-button-container btn_actions">
                  <div></div>
                  <div class="comment__cancel-button btn_cancel esgst-mr-cancel">
                    <span>Cancel</span>
                  </div>
                </div>
      ${esgst.sg ? `
              </div>
            </div>
          </div>
        </div>
      ` : ``}
      </div>
    `);
    MR.Box = MR.Children.firstElementChild;
    MR.Description = MR.Box.getElementsByClassName(`esgst-mr-description`)[0];
    MR.Cancel = MR.Box.getElementsByClassName(`esgst-mr-cancel`)[0];
    if (esgst.cfh) {
      cfh_addPanel(MR.Description);
    }
    MR.Description.focus();
    ded_addButton(MR.Box, MR.URL, async (id, Response, DEDStatus) => {
      let Reply;
      if (esgst.sg) {
        if (id) {
          Reply = parseHtml(Response.responseText).getElementById(id).closest(`.comment`);
          if (esgst.rfi && esgst.rfi_s) {
            await rfi_saveReply(id, Reply.outerHTML, MR.url);
          }
          rml_addLink(MR.Container, [Reply]);
          await endless_load(Reply);
          MR.Box.remove();
          MR.Box = null;
          MR.Children.appendChild(Reply);
          if (!esgst.qiv.comments || !esgst.qiv.comments.contains(Reply)) {
            location.hash = id;
          }
        } else {
          DEDStatus.innerHTML = `
            <i class="fa fa-times"></i>
            <span>Failed!</span>
          `;
        }
      } else {
        if (id) {
          Reply = parseHtml(JSON.parse(Response.responseText).html).getElementById(id);
          if (esgst.rfi && esgst.rfi_s) {
            await rfi_saveReply(id, Reply.outerHTML, MR.url);
          }
          rml_addLink(MR.Container, [Reply]);
          await endless_load(Reply);
          MR.Box.remove();
          MR.Box = null;
          MR.Children.appendChild(Reply);
          if (!esgst.qiv.comments || !esgst.qiv.comments.contains(Reply)) {
            location.hash = id;
          }
        } else {
          DEDStatus.innerHTML = `
            <i class="fa fa-times"></i>
            <span>Failed!</span>
          `;
        }
      }
    });
    MR.Cancel.addEventListener(`click`, () => {
      MR.Box.remove();
      MR.Box = null;
    });
  }

  function mr_setEdit(MR) {
    let DisplayState, EditState, EditSave, ID, AllowReplies, Description;
    MR.Edit = MR.Context.getElementsByClassName(esgst.sg ? `js__comment-edit` : `js_comment_edit`)[0];
    if (MR.Edit) {
      MR.Edit.insertAdjacentHTML(`afterEnd`, `<a class="comment__actions__button esgst-mr-edit">Edit</a>`);
      MR.Edit = MR.Edit.nextElementSibling;
      MR.Edit.previousElementSibling.remove();
      DisplayState = MR.Comment.getElementsByClassName(esgst.sg ? `comment__display-state` : `comment_body_default`)[0];
      EditState = MR.Comment.getElementsByClassName(esgst.sg ? `comment__edit-state` : `edit_form`)[0];
      EditSave = EditState.querySelector(`.js__comment-edit-save, .js_submit, .EditSave`);
      EditSave.insertAdjacentHTML(`afterEnd`, `
        <a class="comment__submit-button btn_action white EditSave">
          <i class="fa fa-edit"></i>
          <span>Edit</span>
        </a>
      `);
      EditSave = EditSave.nextElementSibling;
      EditSave.previousElementSibling.remove();
      ID = EditState.querySelector(`[name="comment_id"]`).value;
      AllowReplies = esgst.sg ? EditState.querySelector(`[name="allow_replies"]`).value : ``;
      Description = EditState.querySelector(`[name="description"]`);
      MR.Edit.addEventListener(`click`, () => {
        let Temp;
        if (esgst.sg) {
          DisplayState.classList.add(`is-hidden`);
          MR.Context.classList.add(`is-hidden`);
        } else {
          MR.Container.classList.add(`is_hidden`);
        }
        EditState.classList.remove(esgst.sg ? `is-hidden` : `is_hidden`);
        Temp = Description.value;
        Description.focus();
        Description.value = ``;
        Description.value = Temp;
      });
      EditSave.addEventListener(`click`, async () => {
        let ResponseJSON, ResponseHTML;
        ResponseJSON = JSON.parse((await request({data: `xsrf_token=${esgst.xsrfToken}&do=comment_edit&comment_id=${ID}&allow_replies=${AllowReplies}&description=${encodeURIComponent(Description.value)}`, method: `POST`, url: `/ajax.php`})).responseText);
        if (ResponseJSON.type === `success` || ResponseJSON.success) {
          ResponseHTML = parseHtml(ResponseJSON[esgst.sg ? `comment` : `html`]);
          if (esgst.rfi && esgst.rfi_s) {
            let reply = MR.Comment.cloneNode(true);
            if (esgst.sg) {
              reply.innerHTML = `
                <div class="ajax comment__child">${ResponseHTML.body.innerHTML}</div>
                <div class="comment__children"></div>
              `;
            } else {
              reply.innerHTML = `
                ${ResponseHTML.body.innerHTML}
                <div class="comment_children"></div>
              `;
            }
            await rfi_saveReply(MR.url.match(/\/comment\/(.+)/)[1], reply.outerHTML, null, true);
          }
          DisplayState.innerHTML = ResponseHTML.getElementsByClassName(esgst.sg ? `comment__display-state` : `comment_body_default`)[0].innerHTML;
          EditState.classList.add(esgst.sg ? `is-hidden` : `is_hidden`);
          MR.Timestamp.innerHTML = ResponseHTML.getElementsByClassName(esgst.sg ? `comment__actions` : `action_list`)[0].firstElementChild.innerHTML;
          if (esgst.at) {
            at_getTimestamps(MR.Timestamp);
          }
          if (esgst.ged) {
            await esgst.ged_addIcons([{
              actions: MR.Container.getElementsByClassName(esgst.sg ? `comment__actions` : `action_list`)[0],
              displayState: DisplayState,
              comment: MR.Container,
              id: MR.url.match(/\/comment\/(.+)/)[1]
            }]);
          }
          if (esgst.sg) {
            DisplayState.classList.remove(`is-hidden`);
            MR.Context.classList.remove(`is-hidden`);
          } else {
            MR.Container.classList.remove(`is_hidden`);
          }
        }
      });
    }
  }

  function mr_setDelete(mr) {
    let allowReplies, data, id;
    mr.delete = mr.Context.getElementsByClassName(esgst.sg ? `js__comment-delete` : `js_comment_delete`)[0];
    if (mr.delete) {
      if (esgst.sg) {
        allowReplies = mr.delete.parentElement.querySelector(`[name="allow_replies"]`).value;
        id = mr.delete.parentElement.querySelector(`[name="comment_id"]`).value;
        data = `xsrf_token=${esgst.xsrfToken}&do=comment_delete&allow_replies=${allowReplies}&comment_id=${id}`;
      } else {
        data = mr.delete.getAttribute(`data-form`);
      }
      mr.delete.insertAdjacentHTML(`afterEnd`, `<a class="comment__actions__button esgst-mr-delete">Delete</a>`);
      mr.delete = mr.delete.nextElementSibling;
      mr.delete.previousElementSibling.remove();
      mr.delete.addEventListener(`click`, async () => {
        mr_editReply(mr, await request({data, method: `POST`, url: `/ajax.php`}));
      });
    }
  }

  function mr_setUndelete(mr) {
    let allowReplies, data, id;
    mr.undelete = mr.Context.getElementsByClassName(esgst.sg ? `js__comment-undelete` : `js_comment_undelete`)[0];
    if (mr.undelete) {
      if (esgst.sg) {
        allowReplies = mr.undelete.parentElement.querySelector(`[name="allow_replies"]`).value;
        id = mr.undelete.parentElement.querySelector(`[name="comment_id"]`).value;
        data = `xsrf_token=${esgst.xsrfToken}&do=comment_undelete&allow_replies=${allowReplies}&comment_id=${id}`;
      } else {
        data = mr.undelete.getAttribute(`data-form`);
      }
      mr.undelete.insertAdjacentHTML(`afterEnd`, `<a class="comment__actions__button esgst-mr-undelete">Undelete</a>`);
      mr.undelete = mr.undelete.nextElementSibling;
      mr.undelete.previousElementSibling.remove();
      mr.undelete.addEventListener(`click`, async () => {
        mr_editReply(mr, await request({data, method: `POST`, url: `/ajax.php`}));
      });
    }
  }

  async function mr_editReply(mr, response) {
    let responseHtml, responseJson;
    responseJson = JSON.parse(response.responseText);
    if (responseJson.type === `success` || responseJson.success) {
      responseHtml = parseHtml(responseJson[esgst.sg ? `comment` : `html`]);
      if (esgst.sg) {
        mr.Container.innerHTML = responseHtml.getElementsByClassName(`comment__summary`)[0].innerHTML;
      } else {
        mr.Container.innerHTML = responseHtml.getElementsByClassName(`comment_inner`)[0].innerHTML;
      }
      if (esgst.rfi && esgst.rfi_s) {
        let reply = mr.Comment.cloneNode(true);
        if (esgst.sg) {
          reply.innerHTML = `
            <div class="ajax comment__child">${responseHtml.body.innerHTML}</div>
            <div class="comment__children"></div>
          `;
        } else {
          reply.innerHTML = `
            ${responseHtml.body.innerHTML}
            <div class="comment_children"></div>
          `;
        }
        await rfi_saveReply(mr.url.match(/\/comment\/(.+)/)[1], reply.outerHTML, null, true);
      }
      await endless_load(mr.Container);
    }
  }
  
  // [RFI]
  
  _MODULES.push({
    description: `
      <ul>
        <li>Adds a "Reply" link next to a comment's "Permalink" (in your <a href="/messages">inbox</a> page) that allows you to reply to the comment directly from your inbox.</li>
        <li>It is essentially [id=mr] for the inbox page.</li>
      </ul>
    `,
    features: {
      rfi_s: {
        description: `
          <ul>
            <li>Caches any replies you submit for 1 week so that they are still in your inbox page when you refresh it.</li>
            <li>If you edit/delete/undelete a saved reply its cache is updated and lasts 1 week longer.</li>
          </ul>
        `,
        name: `Cache replies.`,
        sg: true,
        st: true
      },
      rfi_c: {
        description: `
          <ul>
            <li>Whenever you try to submit a reply to a comment, the feature will check if there are other replies to that comment and show them to you so that you can review your reply before sending it.</li>
            <li>This option is useful if you want to avoid repeating something that another user already said or discard your reply if someone else already said everything that you were going to say.</li>
          </ul>
        `,
        name: `Check if there are other replies to a comment before submitting a reply.`,
        sg: true,
        st: true
      }
    },
    id: `rfi`,
    load: rfi,
    name: `Reply From Inbox`,
    sg: true,
    st: true,
    type: `comments`
  });

  function rfi() {
    if (esgst.mr) return;
    esgst.endlessFeatures.push(mr_getButtons);
  }

  async function rfi_saveReply(id, reply, url, edit) {
    let i, n, source, saved;
    if (url) {
      source = url.match(/\/comment\/(.+)/)[1];
    }
    saved = JSON.parse(await getValue(`${esgst.name}RfiCache`, `{}`));
    if (edit) {
      for (const key in saved) {
        for (i = 0, n = saved[key].length; i < n && saved[key][i].id !== id; ++i);
        if (i < n) {
          saved[key][i].reply = reply;
          saved[key][i].timestamp = Date.now();
        }
      }
    } else {
      if (!saved[source]) {
        saved[source] = [];
      }
      saved[source].push({
        id: id,
        reply: reply,
        timestamp: Date.now()
      });
    }
    await setValue(`${esgst.name}RfiCache`, JSON.stringify(saved));
  }

  async function rfi_getReplies(comments, endless) {
    let children, comment, i, id, j, key, n, numReplies, saved, edited = false;
    saved = JSON.parse(await getValue(`${esgst.name}RfiCache`, `{}`));
    for (i = 0, n = comments.length; i < n; ++i) {
      comment = comments[i];
      id = comment.id;
      if (id && saved[id]) {
        children = comment.comment.closest(`.comment, .comment_outer`).querySelector(`.comment__children, .comment_children`);
        for (j = 0, numReplies = saved[id].length; j < numReplies; ++j) {
          insertHtml(children, `beforeEnd`, saved[id][j].reply).querySelector(`[data-timestamp]`).textContent = getTimeSince(saved[id][j].timestamp);
        }
        children.setAttribute(`data-rfi`, true);
        await endless_load(children, false, null, false, endless);
        children.removeAttribute(`data-rfi`);
      }
    }
    for (key in saved) {
      for (i = 0, n = saved[key].length; i < n; ++i) {
        if (Date.now() - saved[key][i].timestamp > 604800000) {
          edited = true;
          saved[key].splice(i, 1);
          i -= 1;
          n -= 1;
        }
      }
      if (!saved[key].length) {
        edited = true;
        delete saved[key];
      }
    }
    if (edited) {
      await setValue(`${esgst.name}RfiCache`, JSON.stringify(saved));
    }
  }

  // [RML]

  _MODULES.push({
    description: `
      <ul>
        <li>Adds a link (@user) next to a reply's "Permalink" (in any page) that mentions the user being replied to and links to their comment.</li>
        <li>This feature is useful for conversations that have very deep nesting levels, which makes it impossible to know who replied to whom.</li>
      </ul>
    `,
    id: `rml`,
    load: rml,
    name: `Reply Mention Link`,
    sg: true,
    st: true,
    type: `comments`
  });

  function rml() {
    esgst.endlessFeatures.push(rml_addLinks);
  }

  function rml_addLinks(context, main, source, endless) {
    const elements = context.querySelectorAll(`${endless ? `.esgst-es-page-${endless} .comment__children, .esgst-es-page-${endless}.comment__children` : `.comment__children`}, ${endless ? `.esgst-es-page-${endless} .comment_children, .esgst-es-page-${endless}.comment_children` : `.comment_children`}`);
    for (let i = 0, n = elements.length; i < n; ++i) {
      const children = elements[i].children;
      if (children.length) {
        rml_addLink(esgst.sg ? elements[i].parentElement.getElementsByClassName(`comment__summary`)[0] : elements[i].parentElement, children);
      }
    }
  }

  function rml_addLink(Context, Matches) {
    let Username, ID, I, N, RMLLink;
    Username = Context.getElementsByClassName(esgst.sg ? `comment__username` : `author_name`)[0].textContent.trim();
    ID = Context.id;
    for (I = 0, N = Matches.length; I < N; ++I) {
      Context = Matches[I].getElementsByClassName(esgst.sg ? `comment__actions` : `action_list`)[0];
      RMLLink = Context.getElementsByClassName(`esgst-rml-link`)[0];
      if (RMLLink) {
        RMLLink.textContent = `@${Username}`;
      } else {
        Context.insertAdjacentHTML(`beforeEnd`, `<a class="comment__actions__button esgst-rml-link" href="#${ID}">@${Username}</a>`);
      }
    }
  }

  // [IWH]
  
  _MODULES.push({
    description: `
      <ul>
        <li>Adds an icon (<i class="fa fa-trophy"></i>) next to the username of a giveaway comment made by the giveaway's winner(s) (in the <a href="https://www.steamgifts.com/messages">inbox</a> page).</li>
        <li>A winner is only highlighted if you sent the gift to them after this feature was enabled.</li>
      </ul>
    `,
    id: `iwh`,
    load: iwh,
    name: `Inbox Winner Highlighter`,
    sg: true,
    type: `users`
  });

  function iwh() {
    esgst.endlessFeatures.push(iwh_getUsers);
  }

  async function iwh_getUsers(context, main, source, endless) {
    if (!esgst.winnersPath && !esgst.inboxPath && (!context.getAttribute || !context.getAttribute(`data-esgst-qiv`))) return;
    const [callback, query] = esgst.winnersPath ? [iwh_setObserver, `${endless ? `.esgst-es-page-${endless} .table__gift-not-sent, .esgst-es-page-${endless}.table__gift-not-sent` : `.table__gift-not-sent`}`] : [iwh_highlightWinner, `${endless ? `.esgst-es-page-${endless} .comments__entity, .esgst-es-page-${endless}.comments__entity` : `.comments__entity`}`],
        elements = context.querySelectorAll(query);
    if (!elements.length) return;
    const winners = JSON.parse(await getValue(`winners`, `{}`));
    for (let i = 0, n = elements.length; i < n; ++i) {
      callback(elements[i], winners);
    }
  }

  function iwh_setObserver(Context) {
    let Key, Username;
    Key = location.pathname.match(/\/giveaway\/(.+?)\//)[1];
    Username = Context.closest(`.table__row-inner-wrap`).getElementsByClassName(`table__column__heading`)[0].querySelector(`a[href*="/user/"]`).textContent;
    Context.addEventListener(`click`, async () => {
      let Winners;
      Winners = JSON.parse(await getValue(`winners`, `{}`));
      if (!Winners[Key]) {
        Winners[Key] = [];
      }
      if (Winners[Key].indexOf(Username) < 0) {
        Winners[Key].push(Username);
      }
      setValue(`winners`, JSON.stringify(Winners));
    });
  }

  function iwh_highlightWinner(Context, Winners) {
    let Match, Key, Matches, I, N, Username;
    Match = Context.firstElementChild.firstElementChild.getAttribute(`href`).match(/\/giveaway\/(.+?)\//);
    if (Match) {
      Key = Match[1];
      if (Winners[Key]) {
        Matches = Context.nextElementSibling.children;
        for (I = 0, N = Matches.length; I < N; ++I) {
          Context = Matches[I].getElementsByClassName(`comment__username`)[0];
          Username = Context.textContent;
          if (Winners[Key].indexOf(Username) >= 0) {
            Context.insertAdjacentHTML(`afterEnd`, `<i class="fa fa-trophy esgst-iwh-icon" title="${getFeatureTooltip(`iwh`, `This is the winner or one of the winners of this giveaway`)}"></i>`);
          }
        }
      }
    }
  }
  
  // [US]
 
  _MODULES.push({
    description: `
      <ul>
        <li>Adds 5 columns ("Last Online", "Gifts Sent", "Gifts Won", "Ratio" and "Contributor Value") to your <a href="https://www.steamgifts.com/account/manage/whitelist">whitelist</a>/<a href="https://www.steamgifts.com/account/manage/blacklist">blacklist</a> pages and the popup from [id=wbs] that show some stats about each user.</li>
      </ul>
    `,
    id: `us`,
    load: us,
    name: `User Stats`,
    sg: true,
    type: `users`
  });

  function us() {
    if (!esgst.whitelistPath && !esgst.blacklistPath) return;
    esgst.endlessFeatures.push(us_get);
  }

  async function us_get(context, main, source, endless) {
    if (!main && !context.closest(`.esgst-wbs-popup`)) {
      return;
    }
    if (context === document || !main) {
      context.getElementsByClassName(`table__heading`)[0].firstElementChild.insertAdjacentHTML(`afterEnd`, `
        <div class="table__column--width-small text-center">Last Online</div>
        <div class="table__column--width-small text-center">Gifts Won</div>
        <div class="table__column--width-small text-center">Gifts Sent</div>
        <div class="table__column--width-small text-center">Ratio</div>
        <div class="table__column--width-small text-center">Contributor Level</div>
      `);
    }
    let users = {};
    let elements = context.querySelectorAll(`${endless ? `.esgst-es-page-${endless} .table__row-inner-wrap, .esgst-es-page-${endless}.table__row-inner-wrap` : `.table__row-inner-wrap`}`);
    for (let i = 0, n = elements.length; i < n; ++i) {
      let element = elements[i];
      users[element.getElementsByClassName(`table__column__heading`)[0].textContent] = (main && element.firstElementChild.nextElementSibling) || element.firstElementChild;
    }
    let promises = [];
    for (let username in users) {
      let promise = request({method: `GET`, url: `/user/${username}`});
      promise.then(us_load.bind(null, users[username], username));
      promises.push(promise);
    }
    Promise.all(promises).then(ts_sortTables);
  }

  function us_load(context, username, response) {
    let element, elements, html, i, n, profile, cvrow, rows;
    html = [];
    profile = {};
    elements = parseHtml(response.responseText).getElementsByClassName(`featured__table__row__left`);
    for (i = 0, n = elements.length; i < n; ++i) {
      element = elements[i];
      switch (element.textContent) {
        case `Last Online`:
          html.push(`
            <div class="table__column--width-small text-center">${element.nextElementSibling.innerHTML}</div>
          `);
          break;
        case `Gifts Won`:
          profile.wonRow = element.parentElement;
          profile.wonRowLeft = element;
          profile.wonRowRight = element.nextElementSibling;
          rows = JSON.parse(profile.wonRowRight.firstElementChild.firstElementChild.getAttribute(`data-ui-tooltip`)).rows;
          profile.wonCount = parseInt(rows[0].columns[1].name.replace(/,/g, ``));
          profile.wonFull = parseInt(rows[1].columns[1].name.replace(/,/g, ``));
          profile.wonReduced = parseInt(rows[2].columns[1].name.replace(/,/g, ``));
          profile.wonZero = parseInt(rows[3].columns[1].name.replace(/,/g, ``));
          cvrow = profile.wonRowRight.firstElementChild.lastElementChild;
          rows = JSON.parse(cvrow.getAttribute(`data-ui-tooltip`)).rows;
          profile.wonCV = parseFloat(cvrow.textContent.replace(/\$|,/g, ``));
          profile.realWonCV = parseFloat(rows[0].columns[1].name.replace(/\$|,/g, ``));
          element.nextElementSibling.firstElementChild.firstElementChild.firstElementChild.removeAttribute(`style`);
          html.push(`
            <div class="table__column--width-small text-center">${element.nextElementSibling.innerHTML}</div>
          `);
          break;
        case `Gifts Sent`:
          profile.sentRow = element.parentElement;
          profile.sentRowLeft = element;
          profile.sentRowRight = element.nextElementSibling;
          rows = JSON.parse(profile.sentRowRight.firstElementChild.firstElementChild.getAttribute(`data-ui-tooltip`)).rows;
          profile.sentCount = parseInt(rows[0].columns[1].name.replace(/,/g, ``));
          profile.sentFull = parseInt(rows[1].columns[1].name.replace(/,/g, ``));
          profile.sentReduced = parseInt(rows[2].columns[1].name.replace(/,/g, ``));
          profile.sentZero = parseInt(rows[3].columns[1].name.replace(/,/g, ``));
          profile.notSent = parseInt(rows[5].columns[1].name.replace(/,/g, ``));
          cvrow = profile.sentRowRight.firstElementChild.lastElementChild;
          rows = JSON.parse(cvrow.getAttribute(`data-ui-tooltip`)).rows;
          profile.sentCV = parseFloat(cvrow.textContent.replace(/\$|,/g, ``));
          profile.realSentCV = parseFloat(rows[0].columns[1].name.replace(/\$|,/g, ``));
          element.nextElementSibling.firstElementChild.firstElementChild.firstElementChild.removeAttribute(`style`);
          html.push(`
            <div class="table__column--width-small text-center">${element.nextElementSibling.innerHTML}</div>
          `);
          break;
        case `Contributor Level`:
          swr_add(profile);
          html.push(`
            <div class="table__column--width-small text-center">${profile.sentRow.nextElementSibling.lastElementChild.innerHTML}</div>
          `);
          html.push(`
            <div class="table__column--width-small text-center">${parseFloat(JSON.parse(element.nextElementSibling.firstElementChild.getAttribute(`data-ui-tooltip`)).rows[0].columns[1].name)}</div>
          `);
          break;
      }
    }
    context.insertAdjacentHTML(`afterEnd`, html.join(``));
  }

  // [GH]

  _MODULES.push({
    description: `
      <ul>
        <li>Adds a green background to a group that you are a member of (in any page).</li>
      </ul>
    `,
    id: `gh`,
    load: gh,
    name: `Group Highlighter`,
    sg: true,
    sync: `Steam Groups`,
    type: `groups`
  });

  function gh() {
    if (esgst.groupsPath) return;
    esgst.endlessFeatures.push(gh_highlightGroups);
  }

  async function gh_highlightGroups(context, main, source, endless) {
    const elements = context.querySelectorAll(`${endless ? `.esgst-es-page-${endless} .table__column__heading[href*="/group/"], .esgst-es-page-${endless}.table__column__heading[href*="/group/"]` : `.table__column__heading[href*="/group/"]`}`);
    if (!elements.length) return;
    const savedGroups = JSON.parse(await getValue(`groups`, `[]`));
    for (let i = 0, n = elements.length; i < n; ++i) {
      const element = elements[i],
          code = element.getAttribute(`href`).match(/\/group\/(.+?)\//)[1];
      let j;
      for (j = savedGroups.length - 1; j >= 0 && savedGroups[j].code !== code; --j);
      if (j >= 0 && savedGroups[j].member) {
        element.closest(`.table__row-outer-wrap`).classList.add(`esgst-gh-highlight`);
      }
    }
  }

  // [AP]

  _MODULES.push({
    description: `
      <ul>
        <li>If you click on/hover over (you can decide which one) a user/group's avatar/username, it shows a popout containing all of the basic information that you can find in their page.</li>
      </ul>
    `,
    id: `ap`,
    load: ap,
    name: `Avatar Popout`,
    options: {
      title: `Open on:`,
      values: [`Hover`, `Click`]
    },
    sg: true,
    type: `general`
  });

  function ap() {
    esgst.endlessFeatures.push(ap_getAvatars);
  }

  function ap_getAvatars(context, main, source, endless) {
    const elements = context.querySelectorAll(`${endless ? `.esgst-es-page-${endless} .global__image-outer-wrap--avatar-small, .esgst-es-page-${endless}.global__image-outer-wrap--avatar-small` : `.global__image-outer-wrap--avatar-small`}, ${endless ? `.esgst-es-page-${endless} .giveaway_image_avatar, .esgst-es-page-${endless}.giveaway_image_avatar` : `.giveaway_image_avatar`}, ${endless ? `.esgst-es-page-${endless} .table_image_avatar, .esgst-es-page-${endless}.table_image_avatar` : `.table_image_avatar`}, ${endless ? `.esgst-es-page-${endless} .featured_giveaway_image_avatar, .esgst-es-page-${endless}.featured_giveaway_image_avatar` : `.featured_giveaway_image_avatar`}, ${endless ? `.esgst-es-page-${endless} .nav__avatar-outer-wrap, .esgst-es-page-${endless}.nav__avatar-outer-wrap` : `.nav__avatar-outer-wrap`}`);
    for (let i = 0, n = elements.length; i < n; ++i) {
      ap_setAvatar(elements[i]);
    }
  }

  function ap_setAvatar(apAvatar) {
    let delay, eventType, exitTimeout, id, match, onClick, popout, timeout, type, url;
    apAvatar.classList.add(`esgst-ap-avatar`);
    url = apAvatar.getAttribute(`href`);
    if (url) {
      if (esgst.ap_index === 0) {
        eventType = `mouseenter`;
        onClick = false;
        delay = 1000;
        apAvatar.addEventListener(`mouseleave`, event => {
          if (timeout) {
            clearTimeout(timeout);
            timeout = null;
          }
          exitTimeout = setTimeout(() => {
            if (popout && !popout.popout.contains(event.relatedTarget)) {
              popout.close();
            }
          }, 1000);
        });
        apAvatar.addEventListener(`click`, () => {
          if (timeout) {
            clearTimeout(timeout);
            timeout = null;
          }
        });
      } else {
        eventType = `click`;
        onClick = true;
        delay = 0;
        apAvatar.classList.add(`esgst-clickable`);
      }
      match = url.match(/\/(user|group)\/(.+?)(\/.*)?$/);
      if (match) {
        id = match[2];
        type = match[1];
        apAvatar.addEventListener(eventType, event => {
          event.preventDefault();
          timeout = setTimeout(async () => {
            popout = esgst.apPopouts[id];
            if (popout) {
              if (esgst.ap_index === 1 && popout.isOpen) {
                popout.close();
              } else {
                popout.open(apAvatar);
              }
            } else {
              esgst.apPopouts[id] = popout = new Popout(`esgst-ap-popout`, null, 1000, onClick);
              popout.popout.innerHTML = `
                <i class="fa fa-circle-o-notch fa-spin"></i>
                <span>Loading ${type}...</span>
              `;
              popout.open(apAvatar);
              let avatar, columns, i, link, n, reportButton, responseHtml, table;
              responseHtml = parseHtml((await request({method: `GET`, url})).responseText);
              popout.popout.innerHTML = ``;
              popout.popout.appendChild(responseHtml.getElementsByClassName(`featured__outer-wrap`)[0]);
              avatar = popout.popout.getElementsByClassName(`global__image-outer-wrap--avatar-large`)[0];
              link = insertHtml(avatar, `afterEnd`, `<a class="esgst-ap-link"></a>`);
              link.appendChild(avatar);
              link.setAttribute(`href`, url);
              table = popout.popout.getElementsByClassName(`featured__table`)[0];
              responseHtml.getElementsByClassName(`sidebar__shortcut-outer-wrap`)[0].lastElementChild.remove();
              table.parentElement.insertBefore(responseHtml.getElementsByClassName(`sidebar__shortcut-outer-wrap`)[0], table);
              reportButton = popout.popout.getElementsByClassName(`js__submit-form-inner`)[0];
              if (reportButton) {
                const form = reportButton.getElementsByTagName(`form`)[0];
                reportButton.addEventListener(`click`, form.submit.bind(form));
              }
              columns = table.children;
              for (i = 0, n = columns[1].children.length; i < n; ++i) {
                columns[0].appendChild(columns[1].firstElementChild);
              }
              const suspension = responseHtml.getElementsByClassName(`sidebar__suspension`)[0];
              if (suspension) {
                columns[0].insertAdjacentHTML(`beforeEnd`, `
                  <div class="esgst-ap-suspended featured__table__row">
                    <div class="featured__table__row__left">${suspension.textContent}</div>
                    <div class="featured__table__row__right">${suspension.nextElementSibling.textContent}</div>
                  </div>
                `);
              }
              columns[1].remove();
              if (type === `user`) {
                await profile_load(popout.popout);
              }
              popout.reposition();
            }
            if (esgst.ap_index === 0) {
              popout.popout.onmouseenter = () => {
                if (exitTimeout) {
                  clearTimeout(exitTimeout);
                  exitTimeout = null;
                }
              };
            }
          }, delay);
        });
      }
    }
  }
  
  // [GP]

  _MODULES.push({
    description: `
      <ul>
        <li>Adds a button (<i class="fa fa-external-link"></i>) below a giveaway's start time (in any page) that allows you to read the description of the giveaway and/or add a comment to it without having to access it.</li>
        <li>You can move the button around by dragging and dropping it.</li>
      </ul>
    `,
    id: `gp`,
    load: gp,
    name: `Giveaway Popup`,
    sg: true,
    type: `giveaways`
  });

  function gp() {
    esgst.giveawayFeatures.push(gp_addButton);
  }

  function gp_addButton(giveaways, main, source) {
    giveaways.forEach(giveaway => {
      if (giveaway.sgTools || (main && (esgst.createdPath || esgst.enteredPath || esgst.wonPath || esgst.giveawayPath || esgst.newGiveawayPath))) return;
      if (!giveaway.innerWrap.getElementsByClassName(`esgst-gp-button`)[0] && (!giveaway.inviteOnly || giveaway.url)) {
        let buttonSet = new ButtonSet(`grey`, `grey`, `fa-external-link`, `fa-circle-o-notch fa-spin`, ``, ``, callback => {
          elgb_openPopup(giveaway, main, source, error => {
            if (error) {
              buttonSet.firstElementChild.classList.remove(`form__saving-button`, `grey`);
              buttonSet.firstElementChild.classList.add(`sidebar__error`, `red`);
              buttonSet.title = getFeatureTooltip(`gp`, `Could not access giveaway`);
            } else if (buttonSet.firstElementChild.classList.contains(`sidebar__error`)) {
              buttonSet.firstElementChild.classList.remove(`sidebar__error`, `red`);
              buttonSet.firstElementChild.classList.add(`form__saving-button`, `grey`);
              buttonSet.title = getFeatureTooltip(`gp`, `View giveaway description/add a comment`);
            }
            callback();
          });
        }).set;
        buttonSet.classList.add(`esgst-gp-button`);
        buttonSet.setAttribute(`data-columnId`, `gp`);
        buttonSet.title = getFeatureTooltip(`gp`, `View giveaway description/add a comment`);
        giveaway.panel.appendChild(buttonSet);
        if (!esgst.lockGiveawayColumns && (!main || esgst.giveawaysPath || esgst.userPath || esgst.groupPath)) {
          buttonSet.setAttribute(`draggable`, true);
          buttonSet.addEventListener(`dragstart`, giveaways_setSource.bind(null, giveaway));
          buttonSet.addEventListener(`dragenter`, giveaways_getSource.bind(null, giveaway, false));
          buttonSet.addEventListener(`dragend`, giveaways_saveSource.bind(null, giveaway));
        }
      }
    });
  }

  // [ELGB]

  _MODULES.push({
    description: `
      <ul>
        <li>Adds a button ("<i class="fa fa-plus-circle"></i> Enter" to enter and "<i class="fa fa-minus-circle"></i> Leave" to leave) below a giveaway's start time (in any page) that allows you to enter/leave the giveaway without having to access it.</li>
        <li>You can move the button around by dragging and dropping it.</li>
      </ul>
    `,
    features: {
      elgb_c: {
        name: `Cache repeated descriptions from the same creator for 1 hour and only show them once.`,
        sg: true
      },
      elgb_f: {
        inputItems: [
          {
            id: `elgb_filters`,
            prefix: `Filters: `,
            title: `Enter only lowercase letters with no spaces and separate filters with '|'.\n\nFor example, if you want to filter out 'Good luck! No need to thank, unless you're the winner.', use the filter 'goodlucknoneedtothankunlessyourethewinner'.\n\nIf you're familiar with regular expressions, you can also use them. For example, to include a variation of the description above that uses 'you are' instead of 'you're' you could use the filter 'goodlucknoneedtothankunlessyoua?rethewinner'. 'a?' will match or not an 'a' between 'you' and 're'.\n\nThe '.' filter, for example, filters out any descriptions that only have one letter.`
          }
        ],
        name: `Filter out useless descriptions.`,
        sg: true
      },
      elgb_p: {
        description: `
          <ul>
            <li>Only shows the button in popups ([id=gb], [id=ged], [id=ge], etc...), so basically only for any giveaways that are loaded dynamically by ESGST.</li>
          </ul>
        `,
        name: `Only enable for popups.`,
        sg: true
      },
      elgb_r: {
        features: {
          elgb_r_d: {
            name: `Only pop up if the giveaway has a description.`,
            sg: true
          }
        },
        name: `Pop up a box to reply to the giveaway when entering it.`,
        sg: true
      },
      elgb_d: {
        name: `Pop up the giveaway description when entering it, if it has any.`,
        sg: true
      }
    },
    id: `elgb`,
    load: elgb,
    name: `Enter/Leave Giveaway Button`,
    sg: true,
    type: `giveaways`
  });

  function elgb() {
    esgst.giveawayFeatures.push(elgb_addButtons);
  }

  async function elgb_addButtons(giveaways, main, source) {
    giveaways.forEach(giveaway => {
      if (giveaway.sgTools || (main && (esgst.elgb_p || esgst.createdPath || esgst.wonPath))) return;
      if (giveaway.innerWrap.getElementsByClassName(`esgst-elgb-button`)[0]) {
        return;
      }
      if (esgst.enteredPath && main) {
        elgb_setEntryButton(giveaway);
        return;
      }
      if (giveaway.blacklist || (giveaway.inviteOnly && !giveaway.url) || !giveaway.started || giveaway.ended || giveaway.created || giveaway.level > esgst.level || (giveaway.id && (esgst.games[giveaway.type][giveaway.id] && (esgst.games[giveaway.type][giveaway.id].owned || esgst.games[giveaway.type][giveaway.id].won || (esgst.games[giveaway.type][giveaway.id].hidden && esgst.hgebd))))) {
        return;
      }
      if (esgst.giveawayPath && main) {
        let sidebarButton = document.getElementsByClassName(`sidebar__error is-disabled`)[0];
        if (!sidebarButton || sidebarButton.textContent.trim() !== `Not Enough Points`) {
          return;
        }
        giveaway.elgbPanel = insertHtml(sidebarButton.parentElement, `afterBegin`, `<div></div>`);
        sidebarButton.remove();
        elgb_addButton(giveaway, main, source);
      } else {
        elgb_addButton(giveaway, main, source);
      }
    });
  }

  function elgb_setEntryButton(giveaway) {
    let button = giveaway.outerWrap.getElementsByClassName(`table__remove-default`)[0];
    if (!button) return;
    let form = button.parentElement;
    let errorButton = insertHtml(form.parentElement, `beforeEnd`, `
      <div class="esgst-clickable esgst-hidden" title="${getFeatureTooltip(`elgb`)}">
        <i class="fa fa-plus-circle esgst-green"></i>
        <span class="table__column__secondary-link">Add</span>
      </div>
      <div class="esgst-clickable" title="${getFeatureTooltip(`elgb`)}">
        <i class="fa fa-times-circle esgst-red"></i>
        <span class="table__column__secondary-link">Remove</span>
      </div>
      <div class="esgst-hidden" title="${getFeatureTooltip(`elgb`)}">
        <i class="fa fa-refresh fa-spin"></i>
        <span>Adding...</span>
      </div>
      <div class="esgst-hidden" title="${getFeatureTooltip(`elgb`)}">
        <i class="fa fa-refresh fa-spin"></i>
        <span>Removing...</span>
      </div>
      <div class="esgst-hidden" title="${getFeatureTooltip(`elgb`)}">
        <i class="fa fa-exclamation esgst-red"></i>
        <span>Error</span>
      </div>
    `);
    let removingButton = errorButton.previousElementSibling;
    let addingButton = removingButton.previousElementSibling;
    let removeButton = addingButton.previousElementSibling;
    let addButton = removeButton.previousElementSibling;
    addButton.addEventListener(`click`, elgb_addEntry.bind(null, addButton, addingButton, errorButton, giveaway, removeButton));
    removeButton.addEventListener(`click`, elgb_removeEntry.bind(null, addButton, errorButton, giveaway, removeButton, removingButton));
    form.remove();
  }

  async function elgb_addEntry(addButton, addingButton, errorButton, giveaway, removeButton) {
    addButton.classList.add(`esgst-hidden`);
    addingButton.classList.remove(`esgst-hidden`);
    try {
      let responseJson = JSON.parse((await request({data: `xsrf_token=${esgst.xsrfToken}&do=entry_insert&code=${giveaway.code}`, method: `POST`, url: `/ajax.php`})).responseText);
      if (responseJson.type === `success`) {
        removeButton.classList.remove(`esgst-hidden`);
      } else {
        errorButton.classList.remove(`esgst-hidden`);
      }
      esgst.pointsContainer.textContent = responseJson.points;
      hr_refreshHeaderElements(document);
    } catch (e) {
      errorButton.classList.remove(`esgst-hidden`);
    }
    addingButton.classList.add(`esgst-hidden`);
    if (esgst.et) {
      et_setEntry(giveaway.code, true, giveaway.name);
    }
  }

  async function elgb_removeEntry(addButton, errorButton, giveaway, removeButton, removingButton) {
    removeButton.classList.add(`esgst-hidden`);
    removingButton.classList.remove(`esgst-hidden`);
    try {
      let responseJson = JSON.parse((await request({data: `xsrf_token=${esgst.xsrfToken}&do=entry_delete&code=${giveaway.code}`, method: `POST`, url: `/ajax.php`})).responseText);
      if (responseJson.type === `success`) {
        addButton.classList.remove(`esgst-hidden`);
      } else {
        errorButton.classList.remove(`esgst-hidden`);
      }
      esgst.pointsContainer.textContent = responseJson.points;
      hr_refreshHeaderElements(document);
    } catch (e) {
      errorButton.classList.remove(`esgst-hidden`);
    }
    removingButton.classList.add(`esgst-hidden`);
    if (esgst.et) {
      et_setEntry(giveaway.code, false, giveaway.name);
    }
  }

  function elgb_addButton(giveaway, main, source) {
    let doAppend = !giveaway.elgbButton;
    if (giveaway.entered) {
      giveaway.elgbButton = new ButtonSet_v2({color1: `yellow`, color2: `grey`, icon1: `fa-minus-circle`, icon2: `fa-circle-o-notch fa-spin`, title1: `Leave`, title2: `Leaving...`, callback1: elgb_leaveGiveaway.bind(null, giveaway, main, source), set: giveaway.elgbButton}).set;
      giveaway.elgbButton.removeAttribute(`title`);
    } else if (giveaway.error) {
      giveaway.elgbButton = new ButtonSet_v2({color1: `red`, color2: `grey`, icon1: `fa-plus-circle`, icon2: `fa-circle-o-notch fa-spin`, title1: `Enter`, title2: `Entering...`, callback1: elgb_enterGiveaway.bind(null, giveaway, main, null, source), set: giveaway.elgbButton}).set;
      giveaway.elgbButton.setAttribute(`title`, giveaway.error);
    } else {
      if (giveaway.points <= esgst.points) {
        giveaway.elgbButton = new ButtonSet_v2({color1: `green`, color2: `grey`, icon1: `fa-plus-circle`, icon2: `fa-circle-o-notch fa-spin`, title1: `Enter`, title2: `Entering...`, callback1: elgb_enterGiveaway.bind(null, giveaway, main, null, source), set: giveaway.elgbButton}).set;
        giveaway.elgbButton.removeAttribute(`title`);
      } else {
        giveaway.elgbButton = new ButtonSet_v2({color1: `red`, color2: `grey`, icon1: `fa-plus-circle`, icon2: `fa-circle-o-notch fa-spin`, title1: `Enter`, title2: `Entering...`, callback1: elgb_enterGiveaway.bind(null, giveaway, main, null, source), set: giveaway.elgbButton}).set;
        giveaway.elgbButton.setAttribute(`title`, `Not Enough Points`);
      }
    }
    if (doAppend) {
      giveaway.elgbButton.classList.add(`esgst-elgb-button`);
      if (esgst.gv && ((main && esgst.giveawaysPath) || (source === `gb` && esgst.gv_gb) || (source === `ged` && esgst.gv_ged) || (source === `ge` && esgst.gv_ge))) {
        giveaway.elgbPanel.insertBefore(giveaway.elgbButton, giveaway.elgbPanel.firstElementChild);
      } else {
        giveaway.elgbPanel.appendChild(giveaway.elgbButton);
      }
      giveaway.elgbButton.setAttribute(`data-columnId`, `elgb`);
      if (!esgst.lockGiveawayColumns && (!main || esgst.giveawaysPath || esgst.userPath || esgst.groupPath)) {
        giveaway.elgbButton.setAttribute(`draggable`, true);
        giveaway.elgbButton.addEventListener(`dragstart`, giveaways_setSource.bind(null, giveaway));
        giveaway.elgbButton.addEventListener(`dragenter`, giveaways_getSource.bind(null, giveaway, false));
        giveaway.elgbButton.addEventListener(`dragend`, giveaways_saveSource.bind(null, giveaway));
      }
    }
  }

  async function elgb_openPopup(giveaway, main, source, mainCallback) {
    let popup = new Popup(`fa-file-text-o`, `<a href="${giveaway.url}"><span>${giveaway.name}</span></a> by <a href="/user/${giveaway.creator}">${giveaway.creator}</a>`, true);
    if (giveaway.entered) {
      let set = new ButtonSet(`yellow`, `grey`, `fa-minus-circle`, `fa-circle-o-notch fa-spin`, `Leave Giveaway`, `Leaving...`, callback => {
        elgb_leaveGiveaway(giveaway, main, source, () => {
          callback();
          popup.close();
        });
      });
      popup.description.appendChild(set.set);
    } else {
      let games = JSON.parse(await getValue(`games`));
      if (giveaway.started && !giveaway.ended && !giveaway.created && giveaway.level <= esgst.level && ((giveaway.id && ((games[giveaway.type][giveaway.id] && !games[giveaway.type][giveaway.id].owned && (!games[giveaway.type][giveaway.id].hidden || !esgst.hgebd)) || !games[giveaway.type][giveaway.id])) || !giveaway.id)) {
        let set = new ButtonSet(`green`, `grey`, `fa-plus-circle`, `fa-circle-o-notch fa-spin`, `Enter Giveaway`, `Entering...`, callback => {
          elgb_enterGiveaway(giveaway, main, true, source, () => {
            callback();
            popup.close();
          });
        });
        popup.description.appendChild(set.set);
      }
    }
    let description = null;
    if (esgst.elgb_d || (esgst.elgb_r && esgst.elgb_r_d) || mainCallback) {
      const responseHtml = parseHtml((await request({method: `GET`, url: giveaway.url})).responseText);
      if (mainCallback && !responseHtml.getElementsByClassName(`featured__outer-wrap--giveaway`)[0]) {
        mainCallback(true);
        return;
      }
      description = responseHtml.getElementsByClassName(`page__description`)[0];
    }
    if (description && description.textContent.trim() && !mainCallback) {
      if (esgst.elgb_c) {
        if (Date.now() - esgst.elgbCache.timestamp > 3600000) {
          esgst.elgbCache = {
            descriptions: {},
            timestamp: Date.now()
          };
          setLocalValue(`elgbCache`, JSON.stringify(esgst.elgbCache));
        }
        if (!esgst.elgbCache.descriptions[giveaway.creator]) {
          esgst.elgbCache.descriptions[giveaway.creator] = [];
        }
        let html = description.innerHTML;
        let i;
        for (i = esgst.elgbCache.descriptions[giveaway.creator].length - 1; i > -1 && esgst.elgbCache.descriptions[giveaway.creator][i] !== html; --i);
        if (i > -1) {
          description = null;
        } else {
          esgst.elgbCache.descriptions[giveaway.creator].push(html);
          setLocalValue(`elgbCache`, JSON.stringify(esgst.elgbCache));
          if (esgst.elgb_f) {
            let text = description.textContent.replace(/[^a-zA-Z]/g, ``).toLowerCase();
            if (text.match(new RegExp(`^(${esgst.elgb_filters})$`))) {
              description = null;
            }
          }
        }
      } else if (esgst.elgb_f) {
        let text = description.textContent.replace(/[^a-zA-Z]/g, ``).toLowerCase();
        if (text.match(new RegExp(`^(${esgst.elgb_filters})$`))) {
          description = null;
        }
      }
    }
    if (description) {
      description.classList.add(`esgst-text-left`);
      popup.scrollable.insertAdjacentHTML(`beforeEnd`, description.outerHTML);
    }
    let box = null;
    if ((esgst.elgb_r && (!esgst.elgb_r_d || description)) || mainCallback) {
      box = insertHtml(popup.scrollable, `beforeEnd`, `<textarea></textarea>`);
      if (esgst.cfh) {
        cfh_addPanel(box);
      }
      popup.description.appendChild(new ButtonSet(`green`, `grey`, `fa-arrow-circle-right`, `fa-circle-o-notch fa-spin`, `Add Comment`, `Saving...`, async callback => {
        if (box.value) {
          await request({data: `xsrf_token=${esgst.xsrfToken}&do=comment_new&description=${box.value}`, method: `POST`, url: giveaway.url});
        }
        callback();
        popup.close();
      }).set);
    }
    if (description && esgst.elgb_f) {
      let set = new ButtonSet(`grey`, `grey`, `fa-eye`, `fa-circle-o-notch fa-spin`, `Add Description To Filters`, `Filtering...`, async callback => {
        esgst.elgb_filters = `${esgst.elgb_filters}|${description.textContent.replace(/[^a-zA-Z]/g, ``).toLowerCase()}`;
        await setSetting(`elgb_filters`, esgst.elgb_filters);
        callback();
        set.remove();
      }).set;
      popup.description.appendChild(set);
    }
    if ((esgst.elgb_d && description) || (esgst.elgb_r && (!esgst.elgb_r_d || description)) || mainCallback) {
      if (mainCallback) {
        popup.onClose = mainCallback;
      }
      popup.open(() => {
        if (box) {
          box.focus();
        }
      });
    }
  }

  async function elgb_enterGiveaway(giveaway, main, popup, source, callback) {
    let responseJson = JSON.parse((await request({data: `xsrf_token=${esgst.xsrfToken}&do=entry_insert&code=${giveaway.code}`, method: `POST`, url: `/ajax.php`})).responseText);
    if (responseJson.type === `success`) {
      if (!esgst.giveawayPath || !main) {
        giveaway.innerWrap.classList.add(`is-faded`);
      }
      giveaway.entered = true;
      giveaway.error = null;
      elgb_addButton(giveaway, main, source);
      if (esgst.et) {
        et_setEntry(giveaway.code, true, giveaway.name);
      }
      esgst.pointsContainer.textContent = responseJson.points;
      await hr_refreshHeaderElements(document);
      if (esgst.hr) {
        setLocalValue(`hrCache`, JSON.stringify(hr_getCache()));
      }
      elgb_updateButtons();
      if (esgst.egh) {
        egh_saveGame(giveaway.id, giveaway.type);
      }
      if (esgst.gb && esgst.gb_ue && giveaway.gbButton) {
        if (giveaway.gbButton.index === 3) {
          giveaway.gbButton.change(giveaway.gbButton.callbacks[2]);
        }
        if (!esgst.gb_se) {
          giveaway.gbButton.button.classList.add(`esgst-hidden`);
        }
      }
      if (esgst.gf && esgst.gf.filteredCount && esgst[`gf_enable${esgst.gf.type}`]) {
        filters_filter(esgst.gf);
      }
      if (esgst.gfPopup && esgst.gfPopup.filteredCount && esgst[`gf_enable${esgst.gfPopup.type}`]) {
        filters_filter(esgst.gfPopup);
      }
      if (callback) {
        callback();
      }
      if (!popup && (!esgst.giveawayPath || !main)) {
        elgb_openPopup(giveaway, main, source);
      }
    } else {
      giveaway.entered = false;
      giveaway.error = responseJson.msg;
      elgb_addButton(giveaway, main, source);
      if (callback) {
        callback();
      }
    }
  }

  async function elgb_leaveGiveaway(giveaway, main, source, callback) {
    let responseJson = JSON.parse((await request({data: `xsrf_token=${esgst.xsrfToken}&do=entry_delete&code=${giveaway.code}`, method: `POST`, url: `/ajax.php`})).responseText);
    if (responseJson.type === `success`) {
      giveaway.innerWrap.classList.remove(`is-faded`);
      giveaway.entered = false;
      giveaway.error = false;
      elgb_addButton(giveaway, main, source);
      if (esgst.et) {
        et_setEntry(giveaway.code, false, giveaway.name);
      }
      esgst.pointsContainer.textContent = responseJson.points;
      await hr_refreshHeaderElements(document);
      if (esgst.hr) {
        setLocalValue(`hrCache`, JSON.stringify(hr_getCache()));
      }
      elgb_updateButtons();
      if (esgst.gb && giveaway.gbButton) {
        giveaway.gbButton.button.classList.remove(`esgst-hidden`);
      }
      if (esgst.gf && esgst.gf.filteredCount && esgst[`gf_enable${esgst.gf.type}`]) {
        filters_filter(esgst.gf);
      }
      if (esgst.gfPopup && esgst.gfPopup.filteredCount && esgst[`gf_enable${esgst.gfPopup.type}`]) {
        filters_filter(esgst.gfPopup);
      }
      if (callback) {
        callback();
      }
    } else if (callback) {
      callback();
    }
  }

  function elgb_updateButtons() {
    let giveaway, i, n;
    for (i = 0, n = esgst.mainGiveaways.length; i < n; ++i) {
      giveaway = esgst.mainGiveaways[i];
      if (giveaway.elgbButton && !giveaway.entered) {
        elgb_addButton(giveaway, true);
      }
    }
    if (esgst.ttec) {
      ttec_calculateTime(esgst.mainGiveaways, true);
    }
  }
  
  // [ITADI]
  
  _MODULES.push({
    description: `
      <ul>
        <li>Adds a box to the sidebar of any <a href="https://www.steamgifts.com/giveaway/aeqw7/">giveaway</a> page that shows the best current deal for the game, the historical lowest price of the game (optional) and a list with all of the bundles that the game has been in. All of this information is retrieved from <a href="https://isthereanydeal.com">IsThereAnyDeal</a>.</li>
        <li>Results are cached for 24 hours, so if you access a giveaway for the same game again within that timeframe, the information will not change.</li>
      </ul>
    `,
    features: {
      itadi_h: {
        name: `Retrieve the historical lowest price of the game (takes longer).`,
        sg: true
      }
    },
    id: `itadi`,
    load: itadi,
    name: `IsThereAnyDeal Info`,
    sg: true,
    type: `giveaways`
  });

  function itadi() {
    if (!esgst.giveawayPath) return;
    esgst.giveawayFeatures.push(itadi_getInfo);
  }

  function itadi_getInfo(giveaways, main) {
    let game, loading, plain;
    if (!main) return;
    giveaways.forEach(async giveaway => {
      game = esgst.games[giveaway.type][giveaway.id];
      plain = itadi_getPlain(giveaway.name);
      if (game && game.itadi && ((esgst.itadi_h && typeof game.itadi.historical !== `undefined`) || !esgst.itadi_h) && (Date.now() - game.itadi.lastCheck < 86400000)) {
        itadi_addInfo(game.itadi, plain);
      } else {
        loading = insertHtml(esgst.sidebar, `beforeEnd`, `
          <h3 class="sidebar__heading">
            <i class="fa fa-circle-o-notch fa-spin"></i> Loading IsThereAnyDeal info...
          </h3>
        `);
        itadi_loadInfo(giveaway, await request({method: `GET`, queue: true, url: `https://isthereanydeal.com/ajax/game/info?plain=${plain}`}), loading, plain, esgst.itadi_h ? (await request({method: `GET`, queue: true, url: `https://isthereanydeal.com/ajax/game/price?plain=${plain}`})): null);
      }
    });
  }

  async function itadi_loadInfo(giveaway, infoResponse, loading, plain, priceResponse) {
    let bundles, current, currentBundle, currentBundles, currentDeal, currentDeals, date, deals, found, games, heading, headings, historical, i, infoHtml, itadi, n, name, parent, priceHtml, tag;
    infoHtml = parseHtml(infoResponse.responseText);
    deals = [];
    currentDeals = infoHtml.getElementsByClassName(`new`);
    n = currentDeals.length;
    if (n > 0) {
      for (i = 0; i < n; ++i) {
        currentDeal = currentDeals[i];
        deals.push({
          price: currentDeal.textContent,
          source: currentDeal.closest(`.row`).firstElementChild.firstElementChild.textContent
        });
      }
      deals.sort((a, b) => {
        a = parseFloat(a.price.replace(/(\$|£|€)/, ``));
        b = parseFloat(b.price.replace(/(\$|£|€)/, ``));
        if (a < b) {
          return -1;
        } else if (a > b) {
          return 1;
        } else {
          return 0;
        }
      });
      current = deals[0];
    } else {
      current = null;
    }
    if (esgst.itadi_h && priceResponse) {
      priceHtml = parseHtml(priceResponse.responseText);
      headings = priceHtml.getElementsByTagName(`th`);
      n = headings.length;
      if (n > 0) {
        found = false;
        for (i = 0; i < n && !found; ++i) {
          heading = headings[i];
          if (heading.textContent === `Lowest price`) {
            found = true;
            parent = heading.parentElement;
            historical = {
              date: parent.getElementsByClassName(`date`)[0].textContent,
              price: parent.getElementsByClassName(`primary`)[0].textContent,
              source: parent.getElementsByClassName(`shopTitle`)[0].textContent
            };
          }
        }
        if (!found) {
          historical = null;
        }
      } else {
        historical = null;
      }
    } else {
      historical = null;
    }
    bundles = [];
    currentBundles = infoHtml.getElementsByClassName(`bundle-head`);
    n = currentBundles.length;
    if (n > 0) {
      for (i = 0; i < n; ++i) {
        currentBundle = currentBundles[i];
        tag = currentBundle.firstElementChild;
        if (tag.textContent === `bundle`) {
          date = tag.nextElementSibling;
          name = date.nextElementSibling.firstElementChild;
          bundles.push({
            date: date.textContent.replace(/expired\s/, ``),
            id: name.getAttribute(`href`).match(/\d+/)[0],
            name: name.textContent
          });
        }
      }
      if (!bundles.length) {
        bundles = null;
      }
    } else {
      bundles = null;
    }
    itadi = {
      bundles: bundles,
      current: current,
      historical: historical,
      lastCheck: Date.now()
    };
    let deleteLock = await createLock(`gameLock`, 300);
    games = JSON.parse(await getValue(`games`));
    if (!games[giveaway.type][giveaway.id]) {
      games[giveaway.type][giveaway.id] = {};
    }
    games[giveaway.type][giveaway.id].itadi = itadi;
    await setValue(`games`, JSON.stringify(games));
    deleteLock();
    loading.remove();
    itadi_addInfo(itadi, plain);
  }

  function itadi_addInfo(itadi, plain) {
    let bundle, bundlesHtml, bundlesItem, currentHtml, currentItem, historicalHtml, historicalItem, i, n;
    if (itadi.current) {
      currentItem = `
        <li class="sidebar__navigation__item">
          <a class="sidebar__navigation__item__link" href="https://isthereanydeal.com/#/page:game/info?plain=${plain}">
            <div class="sidebar__navigation__item__name">${itadi.current.source}</div>
            <div class="sidebar__navigation__item__underline"></div>
            <div class="sidebar__navigation__item__count">${itadi.current.price}</div>
          </a>
        </li>
      `;
    } else {
      currentItem = `There are no current deals for this game.`;
    }
    currentHtml = `
      <h3 class="sidebar__heading">Best Current Deal</h3>
      <ul class="sidebar__navigation">
        ${currentItem}
      </ul>
    `;
    if (esgst.itadi_h) {
      if (itadi.historical) {
        historicalItem = `
          <li class="sidebar__navigation__item">
            <a class="sidebar__navigation__item__link" href="https://isthereanydeal.com/#/page:game/price?plain=${plain}">
              <div class="sidebar__navigation__item__name">${itadi.historical.source}</div>
              <div class="sidebar__navigation__item__underline"></div>
              <div class="sidebar__navigation__item__count">${itadi.historical.price} (${itadi.historical.date})</div>
            </a>
          </li>
        `;
      } else {
        historicalItem = `There is no price history for this game.`;
      }
      historicalHtml = `
        <h3 class="sidebar__heading">Historical Lowest Price</h3>
        <ul class="sidebar__navigation">
          ${historicalItem}
        </ul>
      `;
    } else {
      historicalHtml = ``;
    }
    if (itadi.bundles) {
      bundlesItem = ``;
      for (i = 0, n = itadi.bundles.length; i < n; ++i) {
        bundle = itadi.bundles[i];
        bundlesItem += `
          <li class="sidebar__navigation__item">
            <a class="sidebar__navigation__item__link" href="https://isthereanydeal.com/specials/#/filter:id/${bundle.id}">
              <div class="sidebar__navigation__item__name">${bundle.name}</div>
              <div class="sidebar__navigation__item__underline"></div>
              <div class="sidebar__navigation__item__count">${bundle.date}</div>
            </a>
          </li>
        `;
      }
    } else {
      bundlesItem = `This game has never been in a bundle.`;
    }
    bundlesHtml = `
      <h3 class="sidebar__heading">Bundles</h3>
      <ul class="sidebar__navigation">
        ${bundlesItem}
      </ul>
    `;
    esgst.sidebar.insertAdjacentHTML(`beforeEnd`, `
      ${currentHtml}${historicalHtml}${bundlesHtml}
    `);
  }

  function itadi_getPlain(name) {
    return name.toLowerCase()
      .replace(/\sthe|the\s/g, ``)
      .replace(/\s/g, ``)
      .replace(/\d/g, m => { return [`0`, `i`, `ii`, `iii`, `iv`, `v`, `vi`, `vii`, `viii`, `ix`][m]; })
      .replace(/&/g, `and`)
      .replace(/\+/g, `plus`)
      .replace(/[^\d\w]/g, ``);
  }
  
  // [UGB]

  _MODULES.push({
    description: `
      <ul>
        <li>Adds a button (<i class="fa fa-eye"></i>) next to a giveaway's game name (in any page), if you have hidden the game on SteamGifts, that allows you to unhide the game without having to access your <a href="https://www.steamgifts.com/account/settings/giveaways/filters">giveaway filters</a> page.</li>
      </ul>
    `,
    id: `ugb`,
    load: ugb,
    name: `Unhide Giveaway Button`,
    sg: true,
    type: `giveaways`
  });

  function ugb() {
    esgst.giveawayFeatures.push(ugb_add);
  }

  function ugb_add(giveaways, main) {
    giveaways.forEach(giveaway => {
      let hideButton = giveaway.innerWrap.querySelector(`.giveaway__hide, .featured__giveaway__hide`);
      if (!hideButton && (!main || esgst.giveawaysPath || esgst.giveawayPath)) {
        if (esgst.giveawayPath && main) {
          hideButton = insertHtml(giveaway.headingName.parentElement, `beforeEnd`, `
            <a>
              <i class="fa fa-eye giveaway__hide" title="${getFeatureTooltip(`ugb`, `Unhide all giveaways for this game`)}"></i>
            </a>
          `);
        } else {
          hideButton = insertHtml(giveaway.headingName.parentElement, `beforeEnd`, `
            <i class="fa fa-eye giveaway__hide giveaway__icon" title="${getFeatureTooltip(`ugb`, `Unhide all giveaways for this game`)}"></i>
          `);
        }
        hideButton.addEventListener(`click`, unhideGame.bind(null, hideButton, giveaway.gameId, giveaway.name, giveaway.id, giveaway.type));
      }
    });
  }
  
  // [OCHGB]

  _MODULES.push({
    description: `
      <ul>
        <li>When you click on the icon <i class="fa fa-eye-slash"></i> next to a giveaway's game name, the game will be hidden immediately, without any confirmation popup being shown.</li>
      </ul>
    `,
    features: {
      ochgb_f: {
        description: `
          <ul>
            <li>With this option enabled, when you hide a game, instead of all of the giveaways for the game being removed from the page, they are simply faded out.</li>
          </ul>
        `,
        name: `Fade hidden giveaways instead of removing them.`,
        sg: true
      }
    },
    id: `ochgb`,
    load: ochgb,
    name: `One-Click Hide Giveaway Button`,
    sg: true,
    type: `giveaways`
  });

  function ochgb() {
    esgst.giveawayFeatures.push(ochgb_setButton);
  }

  function ochgb_setButton(giveaways, main) {
    giveaways.forEach(giveaway => {
      let button = giveaway.innerWrap.querySelector(`.giveaway__hide, .featured__giveaway__hide`);
      if (!button) return;
      let unhide = button.classList.contains(`fa-eye`);
      if (esgst.giveawayPath && main) {
        button = button.parentElement;
      }
      giveaway.fade = ochgb_fadeGiveaway.bind(null, giveaway, main);
      giveaway.unfade = ochgb_unfadeGiveaway.bind(null, giveaway, main);
      giveaway.ochgbButton = new Button(button, `afterEnd`, {
        callbacks: [ochgb_hideGiveaway.bind(null, giveaway, main), null, ochgb_unhideGiveaway.bind(null, giveaway, main), null],
        className: `esgst-ochgb ${esgst.giveawayPath && main ? `` : `giveaway__icon`}`,
        icons: [`fa-eye-slash esgst-clickable`, `fa-circle-o-notch fa-spin`, `fa-eye esgst-clickable`, `fa-circle-o-notch fa-spin`],
        id: `ochgb`,
        index: unhide ? 2 : 0,
        titles: [`Hide all giveaways for this game`, `Hiding giveaways...`, `Unhide all giveaways for this game`, `Unhiding giveaways...`]
      });
      button.remove();
    });
  }

  function ochgb_fadeGiveaway(giveaway, main) {
    if ((esgst.giveawayPath && !main) || !esgst.giveawayPath) {
      giveaway.innerWrap.classList.add(`esgst-faded`);
    }
  }

  function ochgb_unfadeGiveaway(giveaway, main) {
    if ((esgst.giveawayPath && !main) || !esgst.giveawayPath) {
      giveaway.innerWrap.classList.remove(`esgst-faded`);
    }
  }

  async function ochgb_hideGiveaway(giveaway, main) {
    await request({data: `xsrf_token=${esgst.xsrfToken}&do=hide_giveaways_by_game_id&game_id=${giveaway.gameId}`, method: `POST`, url: `/ajax.php`});
    ochgb_completeProcess(giveaway, `fade`, main);
    await updateHiddenGames(giveaway.id, giveaway.type);
    return true;
  }

  async function ochgb_unhideGiveaway(giveaway, main) {
    await request({data: `xsrf_token=${esgst.xsrfToken}&do=remove_filter&game_id=${giveaway.gameId}`, method: `POST`, url: `/ajax.php`});
    ochgb_completeProcess(giveaway, `unfade`, main);
    await updateHiddenGames(giveaway.id, giveaway.type, true);
    return true;
  }

  function ochgb_completeProcess(giveaway, key, main) {
    if (main && esgst.giveawayPath) return;
    let source = main ? `mainGiveaways` : `popupGiveaways`;
    if (esgst.ochgb_f) {
      for (let i = 0, n = esgst[source].length; i < n; i++) {
        if (esgst[source][i].gameId === giveaway.gameId) {
          esgst[source][i][key]();
          if (esgst[source][i] !== giveaway && esgst[source][i].ochgbButton) {
            esgst[source][i].ochgbButton.index = key === `fade` ? 2 : 0;
            esgst[source][i].ochgbButton.change();
          }
        }
      }
    } else {
      for (let i = 0, n = esgst[source].length; i < n; i++) {
        if (esgst[source][i].gameId === giveaway.gameId) {
          esgst[source][i].outerWrap.remove();
        }
      }
    }
  }
  
  // [GWL]
  
  _MODULES.push({
    description: `
      <ul>
        <li>Adds a link next to an ended giveaway's "Entries" link (in any page) that shows how many winners the giveaway has and takes you to the giveaway's <a href="https://www.steamgifts.com/giveaway/aeqw7/dead-space/winners">winners</a> page.</li>
      </ul>
    `,
    id: `gwl`,
    load: gwl,
    name: `Giveaway Winners Link`,
    sg: true,
    type: `giveaways`
  });

  function gwl() {
    esgst.giveawayFeatures.push(gwl_addLinks);
  }

  function gwl_addLinks(giveaways, main) {
    if (((!esgst.createdPath && !esgst.enteredPath && !esgst.wonPath && !esgst.giveawayPath && !esgst.archivePath) || main) && (esgst.giveawayPath || esgst.createdPath || esgst.enteredPath || esgst.wonPath || esgst.archivePath)) return;
    giveaways.forEach(giveaway => {
      if (giveaway.innerWrap.getElementsByClassName(`esgst-gwl`)[0] || !giveaway.ended) return;
      giveaway.entriesLink.insertAdjacentHTML(`afterEnd`, `
        <a class="esgst-gwl" ${giveaway.url ? `href="${giveaway.url}/winners"` : ``}>
          <i class="fa fa-trophy"></i>
          <span>${giveaway.winners} winners</span>
        </a>
      `);
    });
  }
  
  // [TTEC]

  _MODULES.push({
    description: `
      <ul>
        <li>Adds an element (<i class="fa fa-clock-o"></i> [Time]) below the start time of a giveaway that you do not have enough points to enter (in any page) that shows how much time you have to wait until you have enough points to enter the giveaway.</li>
        <li>The time is calculated by rounding up the result (which is in milliseconds) of the following formula: next_refresh_in_milliseconds + (15 * ⌊(number_of_points_to_enter - number_of_points_you_have) / 6⌋), where next_refresh_in_milliseconds = the time that the next point refresh will happen (you get 6 points every 15 minutes of the hour on SteamGifts, so if it is currently 12:10pm, the next refresh will be at 12:15pm)</li>
        <li>You can move the element around by dragging and dropping it.</li>
      </ul>
    `,
    id: `ttec`,
    load: ttec,
    name: `Time To Enter Calculator`,
    sg: true,
    type: `giveaways`
  });

  function ttec() {
    esgst.giveawayFeatures.push(ttec_calculateTime);
  }

  function ttec_calculateTime(giveaways, main, source) {
    let nextRefresh;
    if (!main || (!esgst.createdPath && !esgst.enteredPath && !esgst.wonPath && !esgst.newGiveawayPath)) {
      nextRefresh = 60 - new Date().getMinutes();
      while (nextRefresh > 15) {
        nextRefresh -= 15;
      }
      giveaways.forEach(giveaway => {
        if (!giveaway.ended && !giveaway.entered && giveaway.points > esgst.points) {
          if (!giveaway.ttec) {
            giveaway.ttec = insertHtml(giveaway.panel, (esgst.gv && ((main && esgst.giveawaysPath) || (source === `gb` && esgst.gv_gb) || (source === `ged` && esgst.gv_ged) || (source === `ge` && esgst.gv_ge))) ? `beforeEnd` : `afterBegin`, `<div class="${esgst.giveawayPath ? `featured__column` : ``} esgst-ttec" data-columnId="ttec" title="${getFeatureTooltip(`ttec`, `Time to wait until you have enough points to enter this giveaway`)}"></div>`);
            if (!esgst.lockGiveawayColumns && (!main || esgst.giveawaysPath || esgst.userPath || esgst.groupPath)) {
              giveaway.ttec.setAttribute(`draggable`, true);
              giveaway.ttec.addEventListener(`dragstart`, giveaways_setSource.bind(null, giveaway));
              giveaway.ttec.addEventListener(`dragenter`, giveaways_getSource.bind(null, giveaway, false));
              giveaway.ttec.addEventListener(`dragend`, giveaways_saveSource.bind(null, giveaway));
            }
          }
          giveaway.ttec.classList.remove(`esgst-hidden`);
          giveaway.ttec.innerHTML = `
            <i class="fa fa-clock-o"></i> ${ttec_getTime(Math.round((nextRefresh + (15 * Math.floor((giveaway.points - esgst.points) / 6))) * 100) / 100)}
          `;
        } else if (giveaway.ttec) {
          giveaway.ttec.classList.add(`esgst-hidden`);
        }
      });
    }
  }

  function ttec_getTime(m) {
    let d, h, w;
    h = Math.round(m / 60 * 10) / 10;
    if (Math.floor(h) > 0) {
      d = Math.round(m / 60 / 24 * 10) / 10;
      if (Math.floor(d) > 0) {
        w = Math.round(d / 60 / 24 / 7 * 10) / 10;
        if (Math.floor(w) > 0) {
          return `${w}w`;
        } else {
          return `${d}d`;
        }
      } else {
        return `${h}h`;
      }
    } else {
      return `${m}m`;
    }
  }
  
  // [GGL]

  _MODULES.push({
    description: `
      <ul>
        <li>If you click on/hover over (you can decide which one) the group icon (<i class="fa fa-user"></i>) of a giveaway (in any page) it shows the groups that the giveaway is for. There is also an option to automatically load the groups on page load and show them below the giveaway (which also works in your <a href="https://www.steamgifts.com/giveaways/created">created</a>/<a href="https://www.steamgifts.com/giveaways/entered">entered</a>/<a href="https://www.steamgifts.com/giveaways/won">won</a> pages if [id=cewgd] is enabled).</li>
        <li>Has [id=gh] built-in.</li>
      </ul>
    `,
    features: {
      ggl_m: {
        name: `Only show groups that you are a member of.`,
        sg: true
      }
    },
    id: `ggl`,
    load: ggl,
    name: `Giveaway Group Loader`,
    options: {
      title: `Load as:`,
      values: [`Panel (On Page Load)`, `Popout (On Hover)`, `Popout (On Click)`, `Popup (On Click)`]
    },
    sg: true,
    sync: `Steam Groups`,
    type: `giveaways`
  });

  function ggl() {
    esgst.giveawayFeatures.push(
      esgst.ggl_index === 0 ?
      ggl_getGiveaways :
      ggl_setButtons
    );
  }

  function ggl_setButtons(giveaways, main) {
    let i, n;
    if ((main && !esgst.createdPath && !esgst.enteredPath && !esgst.wonPath) || !main) {
      for (i = 0, n = giveaways.length; i < n; ++i) {
        ggl_setButton(giveaways[i]);
      }
    }
  }

  function ggl_setButton(giveaway) {
    let container, context, delay, eventType, exitTimeout, newGiveaways, newGroups, onClick, savedGiveaways, savedGroups, timeout;
    if (giveaway.group) {
      switch (esgst.ggl_index) {
        case 1:
          eventType = `mouseenter`;
          onClick = false;
          delay = 1000;
          giveaway.group.addEventListener(`mouseleave`, event => {
            if (timeout) {
              clearTimeout(timeout);
              timeout = null;
            }
            exitTimeout = setTimeout(() => {
              if (context && !container.contains(event.relatedTarget)) {
                context.close();
              }
            }, 1000);
          });
          giveaway.group.addEventListener(`click`, () => {
            if (timeout) {
              clearTimeout(timeout);
              timeout = null;
            }
          });
          break;
        case 2:
          giveaway.group.removeAttribute(`href`);
          giveaway.group.classList.add(`esgst-clickable`);
          eventType = `click`;
          onClick = true;
          delay = 0;
          break;
        case 3:
          giveaway.group.removeAttribute(`href`);
          giveaway.group.classList.add(`esgst-clickable`);
          eventType = `click`;
          delay = 0;
          break;
      }
      giveaway.group.addEventListener(eventType, () => {
        timeout = setTimeout(async () => {
          if (context) {
            switch (esgst.ggl_index) {
              case 1:
                context.open(giveaway.group);
                break;
              case 2:
                if (context.isOpen) {
                  context.close();
                } else {
                  context.open(giveaway.group);
                }
                break;
              case 3:
                context.open();
                break;
            }
          } else {
            if (esgst.ggl_index === 3) {
              context = new Popup(`fa-user`, `<a href="${giveaway.url}/groups">Giveaway Groups</a>`);
              container = context.scrollable;
              context.open();
            } else {
              context = new Popout(`esgst-ggl-popout`, null, 1000, onClick);
              container = context.popout;
              context.open(giveaway.group);
            }
            container.innerHTML = `
              <i class="fa fa-circle-o-notch fa-spin"></i>
              <span>Loading groups...</span>
            `;
            newGiveaways = {};
            newGroups = {};
            let values = await getValues({
              giveaways: `{}`,
              groups: `[]`
            });
            savedGiveaways = JSON.parse(values.giveaways);
            savedGroups = JSON.parse(values.groups);
            ggl_loadGroups([giveaway], 0, 1, newGiveaways, newGroups, savedGiveaways, savedGroups, groups => {
              let className, code, group, groupCount, i, j, n, link;
              if (groups) {
                container.innerHTML = `
                  <div class="esgst-text-left table esgst-hidden">
                    <div class="table__rows"></div>
                  </div>
                `;
                groupCount = 0;
                for (i = 0, n = groups.length; i < n; ++i) {
                  code = groups[i];
                  for (j = savedGroups.length - 1; j >= 0 && savedGroups[j].code !== code; --j);
                  if (j >= 0) {
                    group = savedGroups[j];
                  } else {
                    group = newGroups[code];
                  }
                  if (group && group.member) {
                    className = `esgst-ggl-member`;
                    groupCount += 1;
                  } else if (esgst.ggl_m) {
                    className = `esgst-hidden`;
                  } else {
                    className = ``;
                    groupCount += 1;
                  }
                  if (className !== `esgst-hidden`) {
                    link = insertHtml(container.firstElementChild.firstElementChild, `beforeEnd`, `
                      <div class="table__row-outer-wrap ${className}">
                        <div class="table__row-inner-wrap">
                          <div>
                            <a class="table_image_avatar" href="/group/${group.code}/" style="background-image:url(http://cdn.edgecast.steamstatic.com/steamcommunity/public/images/avatars/${group.avatar}_medium.jpg)"></a>
                          </div>
                          <div class="table__column--width-fill">
                            <a class="table__column__heading" href="/group/${group.code}/"></a>
                          </div>
                        </div>
                      </div>
                    `).getElementsByClassName(`table__column__heading`)[0];
                    link.textContent = group.name;
                  }
                }
                if (groupCount === 0) {
                  container.innerHTML = `
                    <i class="fa fa-exclamation-mark"></i>
                    <span>You are not a member of any group in this giveaway.</span>
                  `;
                } else {
                  container.firstElementChild.classList.remove(`esgst-hidden`);
                  endless_load(container);
                }
                if (esgst.ggl_index === 2) {
                  container.insertAdjacentHTML(`afterBegin`, `<div><a class="esgst-ggl-heading" href="${giveaway.url}/groups">Giveaway Groups</a></div>`);
                }
                context.reposition();
              } else {
                container.innerHTML = `
                  <i class="fa fa-times-circle"></i>
                  <span>An error ocurred.</span>
                `;
                if (esgst.ggl_index === 2) {
                  container.insertAdjacentHTML(`afterBegin`, `<div><a class="esgst-ggl-heading" href="${giveaway.url}/groups">Giveaway Groups</a></div>`);
                }
                context.reposition();
              }
            });
          }
          if (esgst.ggl_index === 1) {
            container.onmouseenter = () => {
              if (exitTimeout) {
                clearTimeout(exitTimeout);
                exitTimeout = null;
              }
            };
          }
        }, delay);
      });
    }
  }

  async function ggl_getGiveaways(giveaways) {
    let newGiveaways = {};
    let newGroups = {};
    let values = await getValues({
      giveaways: `{}`,
      groups: `[]`
    });
    let savedGiveaways = JSON.parse(values.giveaways);
    let savedGroups = JSON.parse(values.groups);
    ggl_loadGroups(giveaways, 0, giveaways.length, newGiveaways, newGroups, savedGiveaways, savedGroups);
  }

  async function ggl_loadGroups(giveaways, i, n, newGiveaways, newGroups, savedGiveaways, savedGroups, callback) {
    let giveaway, found, j, k;
    if (i < n) {
      giveaway = giveaways[i];
      if (giveaway.group) {
        if (savedGiveaways[giveaway.code] && Array.isArray(savedGiveaways[giveaway.code].groups) && savedGiveaways[giveaway.code].groups.length) {
          found = true;
          for (j = savedGiveaways[giveaway.code].groups.length - 1; j > -1 && found; --j) {
            for (k = esgst.groups.length - 1; k > -1 && esgst.groups[k].code !== savedGiveaways[giveaway.code].groups[j]; --k);
            if (k <= -1) {
              found = false;
            }
          }
        }
        if (found) {
          if (callback) {
            callback(savedGiveaways[giveaway.code].groups);
          } else {
            ggl_addPanel(giveaway, savedGiveaways[giveaway.code].groups, newGroups, savedGroups);
          }
          setTimeout(() => ggl_loadGroups(giveaways, ++i, n, newGiveaways, newGroups, savedGiveaways, savedGroups), 0);
        } else {
          ggl_getGroups([], 1, newGroups, `${giveaway.url}/groups/search?page=`, groups => {
            if (groups) {
              newGiveaways[giveaway.code] = {
                groups: groups
              };
              if (callback) {
                callback(groups);
              } else {
                ggl_addPanel(giveaway, groups, newGroups, savedGroups);
              }
              setTimeout(() => ggl_loadGroups(giveaways, ++i, n, newGiveaways, newGroups,  savedGiveaways, savedGroups), 0);
            } else if (callback) {
              callback(null);
            } else {
              setTimeout(() => ggl_loadGroups(giveaways, ++i, n, newGiveaways, newGroups,  savedGiveaways, savedGroups), 0);
            }
          });
        }
      } else {
        setTimeout(() => ggl_loadGroups(giveaways, ++i, n, newGiveaways, newGroups,  savedGiveaways, savedGroups), 0);
      }
    } else {
      await lockAndSaveGiveaways(newGiveaways);
      await lockAndSaveGroups(newGroups);
    }
  }

  function ggl_addPanel(giveaway, groups, newGroups, savedGroups) {
    let className, code, group, groupCount, i, j, link, n, panel;
    if (!giveaway.summary.getElementsByClassName(`esgst-ggl-panel`)[0]) {
      panel = insertHtml(giveaway.summary, `beforeEnd`, `
        <div class="esgst-ggl-panel"></div>
      `);
      groupCount = 0;
      giveaway.groups = [];
      for (i = 0, n = groups.length; i < n; ++i) {
        code = groups[i];
        for (j = savedGroups.length - 1; j >= 0 && savedGroups[j].code !== code; --j);
        if (j >= 0) {
          group = savedGroups[j];
        } else {
          group = newGroups[code];
        }
        giveaway.groups.push(group.name.toLowerCase());
        if (group && group.member) {
          className = `esgst-ggl-member`;
          groupCount += 1;
        } else if (esgst.ggl_m) {
          className = `esgst-hidden`;
        } else {
          className = ``;
          groupCount += 1;
        }
        if (className !== `esgst-hidden`) {
          link = insertHtml(panel, `beforeEnd`, `
            <div class="${className}">
              <a class="table_image_avatar" href="/group/${group.code}/"  style="background-image:url(http://cdn.edgecast.steamstatic.com/steamcommunity/public/images/avatars/${group.avatar}_medium.jpg)"></a>
              <a href="/group/${group.code}/"></a>
            </div>
          `).lastElementChild;
          link.textContent = group.name;
          if (esgst.ap) {
            ap_getAvatars(panel);
          }
        }
      }
      if (groupCount === 0) {
        panel.remove();
      }
    }
  }

  async function ggl_getGroups(groups, nextPage, newGroups, url, callback) {
    let code, element, elements, error, heading, i, match, n, pagination, responseHtml;
    responseHtml = parseHtml((await request({method: `GET`, url: `${url}${nextPage}`})).responseText);
    error = responseHtml.getElementsByClassName(`table--summary`)[0];
    if (error) {
      setTimeout(callback, 0, null);
    } else {
      elements = responseHtml.getElementsByClassName(`table__row-inner-wrap`);
      for (i = 0, n = elements.length; i < n; ++i) {
        element = elements[i];
        heading = element.getElementsByClassName(`table__column__heading`)[0];
        match = heading.getAttribute(`href`).match(/group\/(.+?)\//);
        code = match[1];
        newGroups[code] = {
          avatar: element.getElementsByClassName(`table_image_avatar`)[0].style.backgroundImage.match(/\/avatars\/(.+)_medium/)[1],
          code: code,
          name: heading.textContent
        };
        groups.push(code);
      }
      pagination = responseHtml.getElementsByClassName(`pagination__navigation`)[0];
      if (pagination && !pagination.lastElementChild.classList.contains(`is-selected`)) {
        setTimeout(() => ggl_getGroups(groups, ++nextPage, newGroups, url, callback), 0);
      } else {
        setTimeout(callback, 0, groups);
      }
    }
  }

  // [RRBP]

  _MODULES.push({
    description: `
      <ul>
        <li>Pops up a reply box when you mark a giveaway as received (in your <a href="https://www.steamgifts.com/giveaways/won">won</a> page) so that you can add a comment thanking the creator.</li>
      </ul>
    `,
    id: `rrbp`,
    load: rrbp,
    name: `Received Reply Box Popup`,
    sg: true,
    type: `comments`
  });

  function rrbp() {
    if (!esgst.wonPath) return;
    esgst.giveawayFeatures.push(rrbp_addEvent);
  }

  function rrbp_addEvent(giveaways) {
    giveaways.forEach(giveaway => {
      let feedback = giveaway.outerWrap.getElementsByClassName(`table__gift-feedback-awaiting-reply`)[0];
      if (feedback) {
        feedback.addEventListener(`click`, rrbp_openPopup.bind(null, giveaway));
      }
    });
  }

  function rrbp_openPopup(giveaway) {
    let popup, progress, textArea;
    popup = new Popup(`fa-comment`, `Add a comment:`);
    textArea = insertHtml(popup.scrollable, `beforeEnd`, `<textarea></textarea>`);
    if (esgst.cfh) {
      cfh_addPanel(textArea);
    }
    popup.description.appendChild(new ButtonSet(`green`, `grey`, `fa-check`, `fa-circle-o-notch fa-spin`, `Save`, `Saving...`, callback => {
      progress.innerHTML = ``;
      saveComment(``, ``, textArea.value, giveaway.url, progress, callback, () => {
        popup.close();
      });
    }).set);
    progress = insertHtml(popup.description, `beforeEnd`, `<div></div>`);
    popup.open(() => {
      textArea.focus();
    });
  }

  // Giveaways
  
  _MODULES.push({
    endless: true,
    id: `giveaways`,
    load: giveaways
  });
  
  function giveaways() {
    esgst.endlessFeatures.push(giveaways_load);
  }

  async function giveaways_load(context, main, source, endless) {
    if (context.getAttribute && context.getAttribute(`data-rfi`)) return;
    let giveaways = await giveaways_get(context, main, null, false, null, false, endless, source);
    if (!giveaways.length) return;
    if (main) {
      for (let i = giveaways.length - 1; i > -1; --i) {
        giveaways[i].sortIndex = esgst.mainGiveaways.length;
        esgst.mainGiveaways.push(giveaways[i]);
      }
    } else {
      for (let i = giveaways.length - 1; i > -1; --i) {
        giveaways[i].sortIndex = esgst.popupGiveaways.length;
        esgst.popupGiveaways.push(giveaways[i]);
      }
    }
    for (let feature of esgst.giveawayFeatures) {
      await feature(giveaways, main, source);
    }
    if (!main || esgst.giveawaysPath || esgst.userPath || esgst.groupPath) {
      giveaways.forEach(giveaway => giveaways_reorder(giveaway));
    }
    if (esgst.gas && esgst[esgst.gas.autoKey]) {
      sortContent(esgst[esgst.gas.mainKey], esgst.gas.mainKey, esgst[esgst.gas.optionKey]);
    }
    if (esgst.gf && esgst.gf.filteredCount && esgst[`gf_enable${esgst.gf.type}`]) {
      filters_filter(esgst.gf, false, endless);
    }
    if (esgst.gfPopup && esgst.gfPopup.filteredCount && esgst[`gf_enable${esgst.gfPopup.type}`]) {
      filters_filter(esgst.gfPopup);
    }
    if (esgst.mm_enableGiveaways && esgst.mm_enable) {
      esgst.mm_enable(esgst[main ? `mainGiveaways` : `popupGiveaways`], `Giveaways`);
    }
  }

  async function giveaways_get(context, main, mainUrl, hr, key, ged, endless, source) {
    let giveaway, giveaways, i, mainContext, matches, query;
    giveaways = [];
    if (!hr && main && (esgst.createdPath || esgst.enteredPath || esgst.wonPath || esgst.archivePath)) {
      query = `${endless ? `.esgst-es-page-${endless} .giveaway__row-outer-wrap, .esgst-es-page-${endless}.giveaway__row-outer-wrap` : `.giveaway__row-outer-wrap`}, ${endless ? `.esgst-es-page-${endless} .featured__outer-wrap--giveaway, .esgst-es-page-${endless}.featured__outer-wrap--giveaway` : `.featured__outer-wrap--giveaway`}, ${endless ? `.table:not(.table--summary) .esgst-es-page-${endless} .table__row-outer-wrap, .table:not(.table--summary) .esgst-es-page-${endless}.table__row-outer-wrap` : `.table:not(.table--summary) .table__row-outer-wrap`}`;
    } else {
      query = `${endless ? `.esgst-es-page-${endless} .giveaway__row-outer-wrap, .esgst-es-page-${endless}.giveaway__row-outer-wrap` : `.giveaway__row-outer-wrap`}, ${endless ? `.esgst-es-page-${endless} .featured__outer-wrap--giveaway, .esgst-es-page-${endless}.featured__outer-wrap--giveaway` : `.featured__outer-wrap--giveaway`}`;
    }
    if (key) {
      mainContext = context;
    } else {
      if (mainUrl) {
        mainContext = context;
        key = `data`;
      } else {
        mainContext = document;
        key = `giveaway`;
      }
    }
    matches = context.querySelectorAll(query);
    for (i = matches.length - 1; i > -1; --i) {
      giveaway = await giveaways_getInfo(matches[i], mainContext, null, null, main, mainUrl, ged, endless, source);
      if (giveaway) {
        giveaways.push(giveaway[key]);
      }
    }
    return giveaways;
  }

  async function giveaways_getInfo(context, mainContext, ugd, ugdType, main, mainUrl, ged, endless, source) {
    let chance, giveaway, i, info, key, keys, match, n, savedUser, uf, thinHeadings;
    giveaway = {
      creators: [],
      groups: []
    };
    giveaway.outerWrap = context;
    giveaway.gameId = giveaway.outerWrap.getAttribute(`data-game-id`);
    info = games_getInfo(giveaway.outerWrap);
    if (info) {
      giveaway.id = info.id;
      giveaway.type = info.type;
      if (esgst.games && esgst.games[giveaway.type][giveaway.id]) {
        keys = [`owned`, `wishlisted`, `hidden`, `ignored`, `previouslyEntered`, `previouslyWon`, `reducedCV`, `noCV`];
        for (i = 0, n = keys.length; i < n; ++i) {
          key = keys[i];
          if (esgst.games[giveaway.type][giveaway.id][key === `previouslyEntered` ? `entered` : (key === `previouslyWon` ? `won` : key)]) {
            giveaway[key] = true;
          }
        }
      }
    }
    if (giveaway.outerWrap.classList.contains(`table__row-outer-wrap`) && esgst.giveawayPath) {
      return;
    }
    giveaway.innerWrap = giveaway.outerWrap.querySelector(`.giveaway__row-inner-wrap, .featured__inner-wrap, .table__row-inner-wrap`);
    giveaway.avatar = giveaway.outerWrap.querySelector(`.giveaway_image_avatar, .featured_giveaway_image_avatar`);
    giveaway.image = giveaway.outerWrap.querySelector(`.giveaway_image_thumbnail, .giveaway_image_thumbnail_missing, .global__image-outer-wrap--game-medium`);
    giveaway.summary = giveaway.innerWrap.querySelector(`.giveaway__summary, .featured__summary, .table__column--width-fill`);
    if (source === `gb`) {
      giveaway.entered = giveaway.outerWrap.getAttribute(`data-entered`);
    } else if (esgst.giveawayPath && main) {
      let button = mainContext.getElementsByClassName(`sidebar__entry-delete`)[0];
      if (button) {
        giveaway.entered = !button.classList.contains(`is-hidden`);
      }
    } else if (esgst.enteredPath && main) {
      giveaway.entered = true;
    } else {
      giveaway.entered = giveaway.innerWrap.classList.contains(`is-faded`);
    }
    giveaway.headingName = giveaway.innerWrap.querySelector(`.giveaway__heading__name, .featured__heading__medium, .table__column__heading`);
    giveaway.name = giveaway.headingName.textContent;
    match = giveaway.name.match(/\s\((.+) Copies\)/);
    if (match) {
      giveaway.name = giveaway.name.replace(match[0], ``);
      giveaway.copies = parseInt(match[1].replace(/,/g, ``).match(/\d+/)[0]);
    } else {
      giveaway.copies = 1;
    }
    giveaway.url = esgst.giveawayPath && main && !ugd ? location.pathname : (mainUrl || giveaway.headingName.getAttribute(`href`));
    if (giveaway.url) {
      giveaway.url = giveaway.url.replace(/\/(entries|groups|region-restrictions|winners)$/, ``);
      match = giveaway.url.match(/\/giveaway\/(.+?)(\/.+?)$/);
      if (match) {
        giveaway.code = match[1];
      } else {
        match = giveaway.url.match(/\/giveaways\/(.+)/);
        if (match) {
          giveaway.code = match[1];
          giveaway.sgTools = true;
        } else {
          return;
        }
      }
    }
    giveaway.pinned = giveaway.outerWrap.closest(`.pinned-giveaways__outer-wrap`);
    thinHeadings = giveaway.innerWrap.querySelectorAll(`.giveaway__heading__thin, .featured__heading__small`);
    n = thinHeadings.length;
    giveaway.points = 0;
    if (n > 0) {
      if (n > 1) {
        giveaway.copies = parseInt(thinHeadings[0].textContent.replace(/,/g, ``).match(/\d+/)[0]);
        if (esgst.gch && !giveaway.pinned) {
          let color, bgColor;
          for (const colors of esgst.gch_colors) {
            if (giveaway.copies >= parseInt(colors.lower) && giveaway.copies <= parseInt(colors.upper)) {
              color = colors.color;
              bgColor = colors.bgColor;
              break;
            }
          }
          thinHeadings[0].classList.add(`esgst-bold`);
          if (color) {
            thinHeadings[0].style.color = color;
            if (bgColor) {
              thinHeadings[0].classList.add(`esgst-gch-highlight`);
              thinHeadings[0].style.backgroundColor = bgColor;
            }
          } else {
            thinHeadings[0].classList.add(`esgst-red`);
          }
        }
        giveaway.pointsContainer = thinHeadings[1];
        giveaway.points = parseInt(thinHeadings[1].textContent.match(/\d+/)[0]);
      } else {
        giveaway.copies = 1;
        giveaway.pointsContainer = thinHeadings[0];
        giveaway.points = parseInt(thinHeadings[0].textContent.match(/\d+/)[0]);
      }
    }
    giveaway.columns = giveaway.innerWrap.querySelector(`.giveaway__columns, .featured__columns`);
    if (giveaway.columns && (!esgst.archivePath || !main)) {
      giveaway.endTimeColumn = giveaway.columns.firstElementChild;
      if (giveaway.endTimeColumn.classList.contains(`esgst-ged-source`)) {
        giveaway.sourceColumn = giveaway.endTimeColumn;
        giveaway.endTimeColumn = giveaway.sourceColumn.nextElementSibling;
      }
      giveaway.startTimeColumn = giveaway.columns.querySelector(`.giveaway__column--width-fill.text-right, .featured__column--width-fill.text-right`);
      giveaway.started = !giveaway.endTimeColumn.textContent.match(/Begins/);
      giveaway.endTime = parseInt(giveaway.endTimeColumn.lastElementChild.getAttribute(`data-timestamp`)) * 1e3;
      giveaway.ended = Boolean(giveaway.deleted || giveaway.endTime < Date.now());
      giveaway.startTime = parseInt(giveaway.startTimeColumn.firstElementChild.getAttribute(`data-timestamp`)) * 1e3;
      if (!main || !esgst.userPath || (ugd && ugdType === `won`) || ged) {
        giveaway.creatorContainer = giveaway.startTimeColumn.lastElementChild;
        giveaway.creator = giveaway.creatorContainer.textContent;
      }
      giveaway.winners = giveaway.columns.textContent.match(/No winners/) ? 0 : giveaway.copies;
    } else {
      giveaway.started = true;
    }
    if (main && esgst.archivePath) {
      giveaway.startTimeColumn = giveaway.innerWrap.querySelector(`[data-timestamp]`);
      if (giveaway.startTimeColumn) {
        giveaway.startTime = parseInt(giveaway.startTimeColumn.getAttribute(`data-timestamp`)) * 1e3;
        giveaway.creatorContainer = giveaway.startTimeColumn.nextElementSibling;
        giveaway.creator = giveaway.creatorContainer.textContent;
      } else {
        giveaway.startTime = 0;
      }
    }
    if (!giveaway.endTime && main && (esgst.createdPath || esgst.enteredPath || esgst.wonPath)) {
      giveaway.endTime = giveaway.innerWrap.querySelector(`[data-timestamp]`);
      if (giveaway.endTime) {
        giveaway.endTimeColumn = giveaway.endTime.parentElement;
        giveaway.started = !giveaway.endTimeColumn.textContent.match(/Begins/);
        giveaway.deleted = giveaway.endTimeColumn.parentElement.textContent.match(/Deleted/);
        giveaway.endTime = parseInt(giveaway.endTime.getAttribute(`data-timestamp`)) * 1e3;
      } else {
        giveaway.endTime = 0;
      }
      giveaway.ended = Boolean(giveaway.deleted || giveaway.endTime < Date.now());
    }
    if (!giveaway.ended) {
      giveaway.winners = 0;
    }
    if (ugd) {
      if (ugdType === `sent`) {
        giveaway.creator = ugd;
      }
    } else if (esgst.userPath && main && !ged) {
      giveaway.creator = location.pathname.match(/^\/user\/(.+?)(\/.*)?$/)[1];
    } else if (esgst.createdPath && main) {
      giveaway.creator = esgst.username;
    }
    if (giveaway.creator) {
      giveaway.creators.push(giveaway.creator.toLowerCase());
    }
    if (esgst.createdPath && main) {
      let status = giveaway.outerWrap.querySelector(`.table__column--width-small.text-center:last-of-type`);
      if (status) {
        if (status.textContent.match(/Not\sReceived/)) {
          giveaway.notReceived = true;
        } else if (status.textContent.match(/Received/)) {
          giveaway.received = true;
        } else if (status.textContent.match(/Awaiting\sFeedback/)) {
          giveaway.awaitingFeedback = true;
        }
      }
    }
    giveaway.created = giveaway.creator === esgst.username;
    if (esgst.uf && esgst.giveawaysPath && main) {
      savedUser = await getUser(esgst.users, {
        username: giveaway.creator
      });
      if (savedUser) {
        uf = savedUser.uf;
        if (esgst.uf_g && savedUser.blacklisted && !uf) {
          uf_updateCount(giveaway.outerWrap.parentElement.nextElementSibling);
          giveaway.outerWrap.remove();
          return;
        } else if (uf && uf.giveaways) {
          uf_updateCount(giveaway.outerWrap.parentElement.nextElementSibling);
          giveaway.outerWrap.remove();
          return;
        }
      }
    }
    if (esgst.gf && esgst.gf_s && main) {
      let savedGiveaway = esgst.giveaways[giveaway.code];
      if ((esgst.giveawaysPath || esgst.groupPath) && savedGiveaway && savedGiveaway.hidden && savedGiveaway.code) {
        giveaway.outerWrap.remove();
        return;
      }
    }
    giveaway.links = giveaway.innerWrap.getElementsByClassName(`giveaway__links`)[0];
    if (giveaway.links) {
      giveaway.links.classList.add(`esgst-giveaway-links`);
      giveaway.entriesLink = giveaway.links.firstElementChild;
      giveaway.commentsLink = giveaway.entriesLink.nextElementSibling;
    } else {
      giveaway.entriesLink = mainContext.getElementsByClassName(`sidebar__navigation__item__count`)[1];
      giveaway.commentsLink = mainContext.getElementsByClassName(`sidebar__navigation__item__count`)[0];
    }
    if (giveaway.entriesLink && giveaway.commentsLink) {
      giveaway.entries = parseInt(giveaway.entriesLink.textContent.replace(/,/g, ``).match(/\d+/)[0]);
      giveaway.comments = parseInt(giveaway.commentsLink.textContent.replace(/,/g, ``).match(/\d+/)[0]);
    }
    giveaway.panel = giveaway.innerWrap.getElementsByClassName(`esgst-giveaway-panel`)[0];
    if (!giveaway.panel && (esgst.gwc || esgst.gwr || esgst.gp || esgst.elgb || esgst.cewgd)) {
      if (giveaway.links) {
        giveaway.panel = insertHtml(giveaway.links, `afterEnd`, `
          <div class="giveaway__columns esgst-giveaway-panel"></div>
          <div style="clear: both;"></div>
        `);
      } else if (giveaway.columns) {
        if (esgst.archivePath) {
          giveaway.columns.style.justifyContent = `right`;
          giveaway.panel = insertHtml(giveaway.columns, `afterEnd`, `<div class="giveaway__columns esgst-giveaway-panel"></div>`);
        } else {
          giveaway.panel = insertHtml(giveaway.columns, `afterEnd`, `<div class="featured__columns esgst-giveaway-panel"></div>`);
        }
      } else if (esgst.enteredPath && (esgst.gwc || esgst.gwr)) {
        giveaway.panel = insertHtml(giveaway.innerWrap.firstElementChild.nextElementSibling, `afterEnd`, `<div class="table__column--width-small text-center esgst-giveaway-panel"></div>`);
      }
    }
    if (giveaway.sgTools && !giveaway.summary.getElementsByClassName(`esgst-ge-sgt-button`)[0]) {
      const sgTools = insertHtml(giveaway.summary, `beforeEnd`, `
        <a class="esgst-ge-sgt-button esgst-giveaway-column-button" href="https://www.sgtools.info/giveaways/${giveaway.code}" target="_blank">
          <div class="form__submit-button">SGTools</div>
        </a>
      `);
      sgTools.setAttribute(`data-columnId`, `sgTools`);
      if (!esgst.lockGiveawayColumns && (!main || esgst.giveawaysPath || esgst.userPath || esgst.groupPath)) {
        sgTools.setAttribute(`draggable`, true);
        sgTools.addEventListener(`dragstart`, giveaways_setSource.bind(null, giveaway));
        sgTools.addEventListener(`dragenter`, giveaways_getSource.bind(null, giveaway, false));
        sgTools.addEventListener(`dragend`, giveaways_saveSource.bind(null, giveaway));
      }
    }
    giveaway.elgbPanel = giveaway.panel;
    if (!giveaway.entriesLink) {
      let ct = giveaway.panel || (esgst.gm_enable && esgst.createdPath ? giveaway.innerWrap.firstElementChild.nextElementSibling.nextElementSibling : giveaway.innerWrap.firstElementChild.nextElementSibling);
      if (ct.nextElementSibling) {
        giveaway.entries = parseInt(ct.nextElementSibling.textContent.replace(/,/g, ``));
      }
    }
    giveaway.levelColumn = giveaway.outerWrap.querySelector(`.giveaway__column--contributor-level, .featured__column--contributor-level`);
    giveaway.level = giveaway.levelColumn ? parseInt(giveaway.levelColumn.textContent.match(/\d+/)[0]) : 0;
    giveaway.inviteOnly = giveaway.outerWrap.querySelector(`.giveaway__column--invite-only, .featured__column--invite-only`);
    giveaway.regionRestricted = giveaway.outerWrap.querySelector(`.giveaway__column--region-restricted:not(.touhou_giveaway_points), .featured__column--region-restricted:not(.touhou_giveaway_points)`);
    giveaway.group = giveaway.outerWrap.querySelector(`.giveaway__column--group, .featured__column--group`);
    giveaway.whitelist = giveaway.outerWrap.querySelector(`.giveaway__column--whitelist, .featured__column--whitelist`);
    giveaway.public = !giveaway.sgTools && !giveaway.inviteOnly && !giveaway.regionRestricted && !giveaway.group && !giveaway.whitelist;
    giveaway.touhouBox = giveaway.outerWrap.querySelector(`.touhou_giveaway_points`);
    if (!main || !esgst.giveawayPath) {
      if (giveaway.inviteOnly) {
        giveaway.inviteOnly.innerHTML = `<i class="fa fa-lock"></i>`;
      }
      if (giveaway.group) {
        giveaway.group.innerHTML = `<i class="fa fa-user"></i>`;
      }
      if (giveaway.whitelist) {
        giveaway.whitelist.innerHTML = `<i class="fa fa-heart"></i>`;
      }
    }
    if (source === `ge`) {
      if (giveaway.outerWrap.getAttribute(`data-blacklist`)) {
        if (esgst.ge_b) {
          giveaway.outerWrap.classList.add(`esgst-ge-blacklist`);
          giveaway.summary.classList.add(`esgst-ge-blacklist`);
        }
      } else {
        if (giveaway.public && esgst.ge_p) {
          giveaway.outerWrap.classList.add(`esgst-ge-public`);
          giveaway.summary.classList.add(`esgst-ge-public`);
        }
        if ((giveaway.group || giveaway.whitelist) && esgst.ge_g) {
          giveaway.outerWrap.classList.add(`esgst-ge-group`);
          giveaway.summary.classList.add(`esgst-ge-group`);
        }
      }
    }
    chance = context.getElementsByClassName(`esgst-gwc`)[0];
    giveaway.chance = chance ? parseFloat(chance.getAttribute(`data-chance`)) : 0;
    giveaway.chancePerPoint = Math.round(giveaway.chance / Math.max(1, giveaway.points) * 100) / 100;
    giveaway.blacklist = giveaway.outerWrap.getAttribute(`data-blacklist`);
    giveaway.error = giveaway.outerWrap.getAttribute(`data-error`);
    if (main) {
      if (esgst.gr && giveaway.creator === esgst.username && (esgst.gr_a || (giveaway.ended && (giveaway.entries === 0 || giveaway.entries < giveaway.copies))) && (!esgst.gr_r || !esgst.giveaways[giveaway.code] || !esgst.giveaways[giveaway.code].recreated) && !giveaway.headingName.parentElement.getElementsByClassName(`esgst-gr-button`)[0]) {
        let button = insertHtml(giveaway.headingName, `beforeBegin`, `
          <div class="esgst-gr-button" title="${getFeatureTooltip(`gr`, `Recreate giveaway`)}">
            <i class="fa fa-rotate-left"></i>
          </div>
        `);
        button.firstElementChild.addEventListener(`click`, gr_recreateGiveaway.bind(null, button, giveaway));
      }
    }
    let hideButton = giveaway.innerWrap.querySelector(`.giveaway__hide, .featured__giveaway__hide`);
    if (hideButton && !hideButton.classList.contains(`fa-eye`)) {
      if (!main || endless) {
        if (hideButton.classList.contains(`featured__giveaway__hide`)) {
          hideButton = hideButton.parentElement;
        }
        let temp = hideButton.previousElementSibling;
        hideButton.outerHTML = `
          <i class="fa fa-eye-slash giveaway__hide giveaway__icon" title="${getFeatureTooltip(null, `Hide all giveaways for this game`)}"></i>
        `;
        hideButton = temp.nextElementSibling;
        hideButton.addEventListener(`click`, hideGame.bind(null, hideButton, giveaway.gameId, giveaway.name, giveaway.id, giveaway.type));
      } else if (esgst.updateHiddenGames) {
        hideButton.addEventListener(`click`, () => {
          esgst.hidingGame = {
            id: giveaway.id,
            type: giveaway.type
          };
        });
      }
    }
    if (!main || esgst.giveawaysPath || esgst.userPath || esgst.groupPath) {
      if (giveaway.endTimeColumn) {
        giveaway.endTimeColumn.setAttribute(`data-columnId`, `endTime`);
      }
      if (giveaway.startTimeColumn) {
        giveaway.startTimeColumn.setAttribute(`data-columnId`, `startTime`);
        if (esgst.userPath && main) {
          giveaway.startTimeColumn.previousElementSibling.setAttribute(`data-columnId`, `winners`);
        }
      }
      if (giveaway.inviteOnly) {
        giveaway.inviteOnly.setAttribute(`data-columnId`, `inviteOnly`);
      }
      if (giveaway.whitelist) {
        giveaway.whitelist.setAttribute(`data-columnId`, `whitelist`);
      }
      if (giveaway.group) {
        giveaway.group.setAttribute(`data-columnId`, `group`);
      }
      if (giveaway.regionRestricted) {
        giveaway.regionRestricted.setAttribute(`data-columnId`, `regionRestricted`);
      }
      if (giveaway.levelColumn) {
        giveaway.levelColumn.setAttribute(`data-columnId`, `level`);
      }
      if (giveaway.sourceColumn) {
        giveaway.sourceColumn.setAttribute(`data-columnId`, `ged`);
      }
      if (giveaway.touhouBox) {
        giveaway.touhouBox.setAttribute(`data-columnId`, `touhou`);
      }
      if (!esgst.lockGiveawayColumns) {
        if (giveaway.columns) {
          for (let i = giveaway.columns.children.length - 1; i > -1; i--) {
            let item = giveaway.columns.children[i];
            item.setAttribute(`draggable`, true);
            item.addEventListener(`dragstart`, giveaways_setSource.bind(null, giveaway));
            item.addEventListener(`dragenter`, giveaways_getSource.bind(null, giveaway, false));
            item.addEventListener(`dragend`, giveaways_saveSource.bind(null, giveaway));
          }
        }
        if (giveaway.columns) {
          giveaway.columns.addEventListener(`dragenter`, giveaways_getSource.bind(null, giveaway, false));
        }
        if (giveaway.panel) {
          giveaway.panel.addEventListener(`dragenter`, giveaways_getSource.bind(null, giveaway, true));
        }
      }
    }
    return {
      giveaway: giveaway,
      data: {
        gameId: giveaway.gameId,
        gameSteamId: giveaway.id,
        gameType: giveaway.type,
        gameName: giveaway.name,
        code: giveaway.code,
        copies: giveaway.copies,
        points: giveaway.points,
        endTime: giveaway.endTime,
        startTime: giveaway.startTime,
        started: giveaway.started,
        creator: giveaway.creator,
        winners: giveaway.winners,
        entries: giveaway.entries,
        comments: giveaway.comments,
        level: giveaway.level,
        public: giveaway.public,
        inviteOnly: giveaway.inviteOnly || giveaway.sgTools ? true : false,
        regionRestricted: giveaway.regionRestricted ? true : false,
        group: giveaway.group ? true : false,
        whitelist: giveaway.whitelist ? true : false
      }
    };
  }

  function giveaways_reorder(giveaway) {
    if (giveaway.columns) {
      (giveaway.gvIcons ? esgst.giveawayColumns_gv : esgst.giveawayColumns).forEach(id => {
        let element = giveaway.outerWrap.querySelector(`[data-columnId="${id}"]`);
        if (element) {
          (giveaway.gvIcons || giveaway.columns).appendChild(element);
          if (id.match(/^elgb|gp|ttec$/)) {
            element.classList.add(`esgst-giveaway-column-button`);
          }
        }
      });
    }
    if (giveaway.panel) {
      (giveaway.gvIcons ? esgst.giveawayPanel_gv : esgst.giveawayPanel).forEach(id => {
        let element = giveaway.outerWrap.querySelector(`[data-columnId="${id}"]`);
        if (element) {
          giveaway.panel.appendChild(element);
          if (id.match(/^elgb|gp|ttec$/)) {
            element.classList.remove(`esgst-giveaway-column-button`);
          }
        }
      });
    }
  }

  function giveaways_setSource(giveaway, event) {
    event.dataTransfer.setData(`text/plain`, ``);
    giveaway.sourceItem = event.currentTarget;
    giveaway.newSourceItem = null;
    giveaway.newSourcePos = 0;
    giveaway.columnSource = false;
    giveaway.panelSource = false;
    setTimeout(() => {
      if (giveaway.gvIcons && giveaway.gvIcons.children.length < 1) {
        giveaway.gvIcons.style.height = `25px`;
        giveaway.gvIcons.style.width = `100%`;
      } else if (giveaway.columns && giveaway.columns.children.length < 1) {
        giveaway.columns.style.height = `25px`;
        giveaway.columns.style.width = `100%`;
      }
      if (giveaway.panel && giveaway.panel.children.length < 1) {
        giveaway.panel.style.height = `25px`;
        giveaway.panel.style.width = `100%`;
      }
    }, 0);
  }

  function giveaways_getSource(giveaway, panel, event) {
    if (!giveaway.sourceItem) return;
    if (panel) {
      if (giveaway.panel.children.length < 1) {
        giveaway.panel.appendChild(giveaway.sourceItem);
        if (giveaway.sourceItem.getAttribute(`data-columnId`).match(/^elgb|gp|ttec$/)) {
          giveaway.sourceItem.classList.remove(`esgst-giveaway-column-button`);
        }
        giveaway.panelSource = true;
      }
      return;
    }
    let item = event.currentTarget;
    if (item === giveaway.sourceItem) return;
    if (item === giveaway.gvIcons) {
      if (giveaway.gvIcons.children.length < 1) {
        giveaway.gvIcons.appendChild(giveaway.sourceItem);
        if (giveaway.sourceItem.getAttribute(`data-columnId`).match(/^elgb|gp|ttec$/)) {
          giveaway.sourceItem.classList.add(`esgst-giveaway-column-button`);
        }
        giveaway.columnSource = true;
      }
      return;
    }
    if (item === giveaway.columns) {
      if (giveaway.columns.children.length < 1) {
        giveaway.columns.appendChild(giveaway.columns);
        if (giveaway.sourceItem.getAttribute(`data-columnId`).match(/^elgb|gp|ttec$/)) {
          giveaway.sourceItem.classList.add(`esgst-giveaway-column-button`);
        }
        giveaway.columnSource = true;
      }
      return;
    }
    let current = giveaway.sourceItem;
    do {
      current = current.previousElementSibling;
      if (current && current === item) {
        item.parentElement.insertBefore(giveaway.sourceItem, item);
        if (item.getAttribute(`data-columnId`).match(/^elgb|gp|ttec$/)) {
          if (item.parentElement === giveaway.columns || item.parentElement === giveaway.gvIcons) {
            item.classList.add(`esgst-giveaway-column-button`);
          } else {
            item.classList.remove(`esgst-giveaway-column-button`);
          }
        }
        giveaway.newSourceItem = item;
        giveaway.newSourcePos = 0;
        return;
      }
    } while (current);
    item.parentElement.insertBefore(giveaway.sourceItem, item.nextElementSibling);
    if (item.getAttribute(`data-columnId`).match(/^elgb|gp|ttec$/)) {
      if (item.parentElement === giveaway.columns || item.parentElement === giveaway.gvIcons) {
        item.classList.add(`esgst-giveaway-column-button`);
      } else {
        item.classList.remove(`esgst-giveaway-column-button`);
      }
    }
    giveaway.newSourceItem = item;
    giveaway.newSourcePos = 1;
  }

  async function giveaways_saveSource(giveaway) {
    let [columnKey, panelKey] = giveaway.gvIcons ? [`giveawayColumns_gv`, `giveawayPanel_gv`] : [`giveawayColumns`, `giveawayPanel`];
    if (giveaway.panelSource) {
      let index = esgst[columnKey].indexOf(giveaway.sourceItem.getAttribute(`data-columnId`));
      if (index > -1) {
        esgst[columnKey].splice(index, 1);
      }
      esgst[panelKey].push(giveaway.sourceItem.getAttribute(`data-columnId`));
    } else if (giveaway.columnSource) {
      let index = esgst[panelKey].indexOf(giveaway.sourceItem.getAttribute(`data-columnId`));
      if (index > -1) {
        esgst[panelKey].splice(index, 1);
      }
      esgst[columnKey].push(giveaway.sourceItem.getAttribute(`data-columnId`));
    } else if (giveaway.newSourceItem) {
      let columnsIndex = esgst[columnKey].indexOf(giveaway.sourceItem.getAttribute(`data-columnId`));
      let panelIndex = esgst[panelKey].indexOf(giveaway.sourceItem.getAttribute(`data-columnId`));
      if (giveaway.newSourceItem.parentElement === giveaway.columns || giveaway.newSourceItem.parentElement === giveaway.gvIcons) {
        if (columnsIndex > -1) {
          let id = esgst[columnKey].splice(columnsIndex, 1)[0];
          esgst[columnKey].splice(esgst[columnKey].indexOf(giveaway.newSourceItem.getAttribute(`data-columnId`)) + giveaway.newSourcePos, 0, id);
        } else {
          let id = esgst[panelKey].splice(panelIndex, 1)[0];
          esgst[columnKey].splice(esgst[columnKey].indexOf(giveaway.newSourceItem.getAttribute(`data-columnId`)) + giveaway.newSourcePos, 0, id);
        }
      } else {
        if (columnsIndex > -1) {
          let id = esgst[columnKey].splice(columnsIndex, 1)[0];
          esgst[panelKey].splice(esgst[panelKey].indexOf(giveaway.newSourceItem.getAttribute(`data-columnId`)) + giveaway.newSourcePos, 0, id);
        } else {
          let id = esgst[panelKey].splice(panelIndex, 1)[0];
          esgst[panelKey].splice(esgst[panelKey].indexOf(giveaway.newSourceItem.getAttribute(`data-columnId`)) + giveaway.newSourcePos, 0, id);
        }
      }
    }
    giveaway.sourceItem = null;
    giveaway.newSourceItem = null;
    giveaway.newSourcePos = 0;
    giveaway.columnSource = false;
    giveaway.panelSource = false;
    if (giveaway.gvIcons) {
      giveaway.gvIcons.style.height = ``;
      giveaway.gvIcons.style.width = ``;
    }
    if (giveaway.columns) {
      giveaway.columns.style.height = ``;
      giveaway.columns.style.width = ``;
    }
    if (giveaway.panel) {
      giveaway.panel.style.height = ``;
      giveaway.panel.style.width = ``;
    }
    await setSetting(columnKey, esgst[columnKey]);
    await setSetting(panelKey, esgst[panelKey]);
  }

  // Discussions
  
  _MODULES.push({
    endless: true,
    id: `discussions`,
    load: discussions
  });
  
  function discussions() {
    esgst.endlessFeatures.push(discussions_load);
  }

  async function discussions_load(context, main, source, endless) {
    let discussions = await discussions_get(context, main, endless);
    if (!discussions.length) return;
    if (main) {
      for (let i = discussions.length - 1; i > -1; --i) {
        discussions[i].sortIndex = esgst.mainDiscussions.length;
        esgst.mainDiscussions.push(discussions[i]);
      }
    } else {
      for (let i = discussions.length - 1; i > -1; --i) {
        discussions[i].sortIndex = esgst.popupDiscussions.length;
        esgst.popupDiscussions.push(discussions[i]);
      }
    }
    if (!main || esgst.discussionsPath) {
      if (esgst.df && esgst.df.filteredCount && esgst[`df_enable${esgst.df.type}`]) {
        filters_filter(esgst.df, false, endless);
      }
      if (esgst.ds && esgst.ds_auto) {
        sortContent(esgst.mainDiscussions, null, esgst.ds_option);
      }
    }
    if (esgst.mm_enableDiscussions && esgst.mm_enable) {
      esgst.mm_enable(esgst[main ? `mainDiscussions` : `popupDiscussions`], `Discussions`);
    }
  }

  async function discussions_get(context, main, endless) {
    let discussions = [];
    let elements = context.querySelectorAll(`${endless ? `.esgst-es-page-${endless} .table__row-outer-wrap, .esgst-es-page-${endless}.table__row-outer-wrap` : `.table__row-outer-wrap`}`);
    for (let i = elements.length - 1; i > -1; --i) {
      let discussion = await discussions_getInfo(elements[i], main);
      if (!discussion) continue;
      discussions.push(discussion);
    }
    if (context === document && main && esgst.discussionPath) {
      let discussion = {
        code: location.pathname.match(/^\/discussion\/(.+?)\//)[1],
        heading: document.getElementsByClassName(`page__heading__breadcrumbs`)[0],
        headingContainer: document.getElementsByClassName(`page__heading`)[0]
      };
      discussion.title = discussion.heading.getElementsByTagName(`H1`)[0].textContent.trim();
      checkVersion(discussion);
      discussion.category = discussion.heading.firstElementChild.nextElementSibling.nextElementSibling.textContent;
      discussions.push(discussion);
    }
    discussions.forEach(discussion => {
      let savedDiscussion = esgst.discussions[discussion.code];
      if (esgst.codb && discussion.author === esgst.username && !discussion.heading.parentElement.getElementsByClassName(`esgst-codb-button`)[0]) {
        if (discussion.closed) {
          discussion.closed.remove();
          discussion.closed = true;
        }
        new Button(discussion.headingContainer.firstElementChild, `beforeBegin`, {
          callbacks: [codb_close.bind(null, discussion), null, codb_open.bind(null, discussion), null],
          className: `esgst-codb-button`,
          icons: [`fa-lock esgst-clickable`, `fa-circle-o-notch fa-spin`, `fa-lock esgst-clickable esgst-red`, `fa-circle-o-notch fa-spin`],
          id: `codb`,
          index: discussion.closed ? 2 : 0,
          titles: [`Close discussion`, `Closing discussion...`, `Open discussion`, `Opening discussion...`]
        });
      }
      if (esgst.df && esgst.df_s && !discussion.heading.parentElement.getElementsByClassName(`esgst-df-button`)[0]) {
        new Button(discussion.headingContainer.firstElementChild, `beforeBegin`, {
          callbacks: [df_hideDiscussion.bind(null, discussion, main), null, df_unhideDiscussion.bind(null, discussion, main), null],
          className: `esgst-df-button`,
          icons: [`fa-eye-slash esgst-clickable`, `fa-circle-o-notch fa-spin`, `fa-eye esgst-clickable`, `fa-circle-o-notch fa-spin`],
          id: `df_s`,
          index: savedDiscussion && savedDiscussion.hidden ? 2 : 0,
          titles: [`Hide discussion`, `Hiding discussion...`, `Unhide discussion`, `Unhiding discussion...`]
        });
      }
      if (esgst.dh && !discussion.heading.parentElement.getElementsByClassName(`esgst-dh-button`)[0]) {
        let context = main && esgst.discussionPath ? discussion.heading : discussion.outerWrap;
        let index = 0;
        if (savedDiscussion && savedDiscussion.highlighted) {
          dh_highlightDiscussion(discussion.code, context);
          if (esgst.dh_t && main && esgst.discussionsPath) {
            discussion.outerWrap.parentElement.insertBefore(discussion.outerWrap, discussion.outerWrap.parentElement.firstElementChild);
          }
          index = 2;
        }
        discussion.dhButton = new Button(discussion.heading.parentElement, `afterBegin`, {
          callbacks: [dh_highlightDiscussion.bind(null, discussion.code, context, true), null, dh_unhighlightDiscussion.bind(null, discussion.code, context, true), null],
          className: `esgst-dh-button`,
          icons: [`fa-star-o esgst-clickable`, `fa-circle-o-notch fa-spin`, `fa-star esgst-clickable`, `fa-circle-o-notch fa-spin`],
          id: `dh`,
          index: index,
          titles: [`Click to highlight this discussion`, `Highlighting discussion...`, `Click to unhighlight this discussion`, `Unhighlighting discussion...`]
        });
      }
      if (esgst.pm && (esgst.pm_a || discussion.category === `Puzzles`)) {
        let context = main && esgst.discussionPath ? discussion.headingContainer : discussion.outerWrap;
        if (!context.getElementsByClassName(`esgst-pm-button`)[0]) {
          context.classList.add(`esgst-relative`);
          new Button(context, `afterBegin`, {
            callbacks: [pm_change.bind(null, discussion.code, `unsolved`), null, pm_change.bind(null, discussion.code, `in progress`), null, pm_change.bind(null, discussion.code, `solved`), null, pm_change.bind(null, discussion.code, `off`), null],
            className: `esgst-pm-button`,
            icons: [`fa-circle-o esgst-clickable esgst-grey`, `fa-circle-o-notch fa-spin`, `fa-times-circle esgst-clickable esgst-red`, `fa-circle-o-notch fa-spin`, `fa-exclamation-circle esgst-clickable esgst-orange`, `fa-circle-o-notch fa-spin`, `fa-check-circle esgst-clickable esgst-green`, `fa-circle-o-notch fa-spin`],
            id: `pm`,
            index: [`off`, ``, `unsolved`, ``, `in progress`, ``, `solved`].indexOf((savedDiscussion && savedDiscussion.status) || `off`),
            titles: [`Current status is 'off', click to change to 'unsolved'`, `Changing status...`, `Current status is 'unsolved', click to change to 'in progress'`, `Changing status...`, `Current status is 'in progress', click to change to 'solved'`, `Changing status...`, `Current status is 'solved', click to change to 'off'`, `Changing status...`]
          });
        }
      }
    });
    return discussions;
  }

  async function discussions_getInfo(context, main) {
    let match, discussion, savedUser, uf;
    if (context.closest(`.poll`)) return;
    discussion = {};
    discussion.outerWrap = context;
    discussion.innerWrap = discussion.outerWrap.getElementsByClassName(`table__row-inner-wrap`)[0];
    if (!discussion.innerWrap) return;
    discussion.avatarColumn = discussion.innerWrap.firstElementChild;
    if (!discussion.avatarColumn) return;
    discussion.avatar = discussion.avatarColumn.firstElementChild;
    if (!discussion.avatar) return;
    discussion.headingColumn = discussion.avatarColumn.nextElementSibling;
    discussion.headingContainer = discussion.headingColumn.firstElementChild;
    if (!discussion.headingContainer) return;
    discussion.closed = discussion.headingContainer.getElementsByClassName(`fa-lock`)[0];
    discussion.heading = discussion.headingContainer.lastElementChild;
    discussion.info = discussion.headingContainer.nextElementSibling;
    if (!discussion.heading) {
      return;
    }
    discussion.title = discussion.heading.textContent;
    discussion.url = discussion.heading.getAttribute(`href`);
    if (!discussion.url) {
      return;
    }
    match = discussion.url.match(/discussion\/(.+?)\//);
    if (!match) {
      return;
    }
    discussion.code = match[1];
    checkVersion(discussion);
    if (main && esgst.df && esgst.df_s && esgst.discussions[discussion.code] && esgst.discussions[discussion.code].hidden) {
      discussion.outerWrap.remove();
      return;
    }
    if (esgst.discussions[discussion.code]) {
      discussion.highlighted = esgst.discussions[discussion.code].highlighted;
      discussion.visited = esgst.discussions[discussion.code].visited;
    }
    discussion.categoryContainer = discussion.info.firstElementChild;
    if (discussion.headingColumn.nextElementSibling) {
      discussion.category = discussion.categoryContainer.textContent;
      discussion[discussion.category.replace(/\W/g, ``).replace(/^(.)/, (m, p1) => { return p1.toLowerCase(); })] = true;
    } else {
      discussion.category = ``;
    }
    discussion.createdContainer = discussion.categoryContainer.nextElementSibling;
    if (discussion.createdContainer) {
      discussion.createdTime = discussion.createdContainer.textContent;
      discussion.createdTimestamp = parseInt(discussion.createdContainer.getAttribute(`data-timestamp`)) * 1e3;
      if (esgst.giveawaysPath) {
        discussion.author = discussion.avatar.getAttribute(`href`).match(/\/user\/(.+)/)[1];
      } else {
        discussion.author = discussion.createdContainer.nextElementSibling.textContent;
      }
    }
    if (!discussion.author) return;
    discussion.authors = [discussion.author.toLowerCase()];
    discussion.created = discussion.author === esgst.username;
    discussion.poll = discussion.outerWrap.getElementsByClassName(`fa-align-left`)[0];
    discussion.commentsColumn = discussion.headingColumn.nextElementSibling || discussion.headingColumn.children[1];
    if (discussion.commentsColumn) {
      discussion.comments = parseInt(discussion.commentsColumn.firstElementChild.textContent.replace(/,/g, ``));
      if (esgst.giveawaysPath && esgst.adots && esgst.adots_index === 1 && esgst.ns) {
        discussion.commentsColumn.firstElementChild.textContent = discussion.commentsColumn.firstElementChild.textContent.replace(/\sComments/, ``);
      }
    }
    discussion.lastPost = discussion.outerWrap.getElementsByClassName(`table__column--last-comment`)[0];
    if (discussion.lastPost && discussion.lastPost.firstElementChild) {
      discussion.lastPostTime = discussion.lastPost.firstElementChild.firstElementChild;
      discussion.lastPostAuthor = discussion.lastPostTime.nextElementSibling;
      discussion.lastPostCode = discussion.lastPostAuthor.lastElementChild.getAttribute(`href`).match(/\/comment\/(.+)/)[1];
      discussion.lastPostAuthor = discussion.lastPostAuthor.firstElementChild.textContent;
      discussion.lastPostTime = discussion.lastPostTime.firstElementChild;
      discussion.lastPostTimestamp = discussion.lastPostTime.getAttribute(`data-timestamp`);
      discussion.lastPostTime = discussion.lastPostTime.textContent;
    }
    if (esgst.uf) {
      savedUser = await getUser(esgst.users, {
        username: discussion.author
      });
      if (savedUser) {
        uf = savedUser.uf;
        if (esgst.uf_d && savedUser.blacklisted && !uf) {
          if (!esgst.giveawaysPath) {
            uf_updateCount(discussion.outerWrap.parentElement.parentElement.nextElementSibling);
          }
          discussion.outerWrap.remove();
          return;
        } else if (uf && uf.discussions) {
          if (!esgst.giveawaysPath) {
            uf_updateCount(discussion.outerWrap.parentElement.parentElement.nextElementSibling);
          }
          discussion.outerWrap.remove();
          return;
        }
      }
    }
    return discussion;
  }

  // Discussion Panels
  
  _MODULES.push({
    endless: true,
    id: `discussionPanels`,
    load: discussionPanels
  });

  function discussionPanels() {
    if ((esgst.ct && (esgst.giveawaysPath || esgst.discussionsPath)) || (esgst.gdttt && (esgst.giveawaysPath || esgst.discussionsPath || esgst.discussionsTicketsTradesPath)) || (esgst.ust && esgst.ticketsPath)) {
      esgst.endlessFeatures.push(ct_addDiscussionPanels);
    }
  }

  // Comments
  
  _MODULES.push({
    endless: true,
    id: `comments`,
    load: comments
  });

  function comments() {
    esgst.endlessFeatures.push(comments_load);
  }

  async function comments_load(context, main, source, endless, mainEndless) {
    let count, comments, i, n;
    comments = await comments_get(context, document, main, endless);
    if (!comments.length) return;
    if (main) {
      for (i = 0, n = comments.length; i < n; ++i) {
        comments[i].index = i;
        esgst.mainComments.push(comments[i]);
      }
    }
    if (!main || esgst.commentsPath || esgst.inboxPath) {
      if (esgst.cf && esgst.cf.filteredCount && esgst[`cf_enable${esgst.cf.type}`]) {
        filters_filter(esgst.cf, false, endless);
      }
    }
    if (esgst.ct) {
      if (!main || esgst.inboxPath) {
        count = 0;
      } else {
        count = context.getElementsByClassName(`page__heading__breadcrumbs`)[1];
        if (count) {
          count = parseInt(count.firstElementChild.textContent.replace(/,/g, ``).match(/\d+/));
        } else {
          count = 0;
        }
      }
      ct_getComments(count, comments, null, false, false, false, main || endless || mainEndless);
    }
    if (esgst.rfi) {
      if (esgst.rfi_s && (!main || esgst.inboxPath) && (!context.getAttribute || !context.getAttribute(`data-rfi`))) {
        await rfi_getReplies(comments, main || endless || mainEndless);
      }
    }
    if (esgst.ged) {
      esgst.ged_addIcons(comments);
    }
  }

  async function comments_get(context, mainContext, main, endless) {
    let comment, comments, i, matches, sourceLink;
    comments = [];
    matches = context.querySelectorAll(`${endless ? `.esgst-es-page-${endless} :not(.comment--submit) > .comment__parent, .esgst-es-page-${endless}:not(.comment--submit) > .comment__parent` : `:not(.comment--submit) > .comment__parent`}, ${endless ? `.esgst-es-page-${endless} .comment__child, .esgst-es-page-${endless}.comment__child` : `.comment__child`}, ${endless ? `.esgst-es-page-${endless} .comment_inner, .esgst-es-page-${endless}.comment_inner` : `.comment_inner`}`);
    sourceLink = mainContext.querySelector(`.page__heading__breadcrumbs a[href*="/giveaway/"], .page__heading__breadcrumbs a[href*="/discussion/"], .page__heading__breadcrumbs a[href*="/ticket/"], .page_heading_breadcrumbs a[href*="/trade/"]`);
    for (i = matches.length - 1; i >= 0; --i) {
      comment = await comments_getInfo(matches[i], sourceLink, endless ? esgst.users : JSON.parse(await getValue(`users`)), main);
      if (comment) {
        comments.push(comment);
      }
    }
    return comments;
  }

  async function comments_getInfo(context, sourceLink, savedUsers, main) {
    let comment, matches, n, source;
    comment = {};
    comment.comment = context;
    comment.outerWrap = comment.comment;
    comment.author = comment.comment.querySelector(`.comment__author, .author_name`).textContent.trim();
    if (esgst.uf && savedUsers) {
      let savedUser = await getUser(savedUsers, {
        username: comment.author
      });
      if (savedUser) {
        let uf = savedUser.uf, comments, extraCount;
        if (esgst.uf_p && savedUser.blacklisted && !uf) {
          comments = comment.comment.closest(`.comments`);
          if (!main || esgst.inboxPath) {
            uf_updateCount(comments.parentElement.nextElementSibling);
            comment.comment.parentElement.remove();
            if (!comments.children.length) {
              comments.previousElementSibling.remove();
              comments.remove();
            }
          } else {
            if (comment.comment.nextElementSibling) {
              extraCount = comment.comment.nextElementSibling.children.length;
            } else {
              extraCount = 0;
            }
            uf_updateCount(comments.nextElementSibling, extraCount);
            comment.comment.parentElement.remove();
          }
          return;
        } else if (uf && uf.posts) {
          comments = comment.comment.closest(`.comments`);
          uf_updateCount(comment.comment.closest(`.comments`).nextElementSibling);
          if (!main || esgst.inboxPath) {
            uf_updateCount(comments.parentElement.nextElementSibling);
            comment.comment.parentElement.remove();
            if (!comments.children.length) {
              comments.previousElementSibling.remove();
              comments.remove();
            }
          } else {
            if (comment.comment.nextElementSibling) {
              extraCount = comment.comment.nextElementSibling.children.length;
            } else {
              extraCount = 0;
            }
            uf_updateCount(comments.nextElementSibling, extraCount);
            comment.comment.parentElement.remove();
          }
          return;
        }
      }
    }
    comment.summary = comment.comment.querySelector(`.comment__summary`, `.comment_inner`);
    comment.displayState = comment.comment.querySelector(`.comment__display-state, .comment_body_default`);
    comment.text = comment.displayState ? comment.displayState.textContent.trim().replace(/View\sattached\simage\./, ``) : ``;
    comment.bump = comment.text.replace(/[^A-Za-z]/g, ``).match(/^(havea|takea|thanksand|thankyou)?bump(ing|ity|o)?$/i);
    comment.length = comment.text.length;
    comment.words = Array.from(new Set(comment.text.split(/\s/)));
    comment.actions = comment.comment.querySelector(`.comment__actions, .action_list`);
    matches = comment.actions.querySelectorAll(`[href*="/comment/"]`);
    n = matches.length;
    if (n > 0) {
      comment.permalink = matches[n - 1];
    }
    comment.id = comment.permalink ? comment.permalink.getAttribute(`href`).match(/\/comment\/(.+)/)[1] : ``;
    comment.timestamp = parseInt(comment.actions.firstElementChild.lastElementChild.getAttribute(`data-timestamp`));
    if (!main || esgst.inboxPath) {
      if (esgst.sg) {
        try {
          source = comment.comment.closest(`.comments`).previousElementSibling.firstElementChild.firstElementChild.getAttribute(`href`);
        } catch (e) { /**/ }
      } else {
        source = comment.actions.querySelector(`[href*="/trade/"]`).getAttribute(`href`);
      }
    } else if (sourceLink) {
      source = sourceLink.getAttribute(`href`);
    }
    if (source) {
      source = source.match(/(giveaway|discussion|ticket|trade)\/(.+?)(\/.*)?$/);
      comment.type = `${source[1]}s`;
      comment.code = source[2];
      return comment;
    }
  }

  // Games
  
  _MODULES.push({
    endless: true,
    id: `games`,
    load: games
  });

  function games() {
    esgst.endlessFeatures.push(games_load);
  }

  async function games_load(context, main, source, endless) {
    let games = games_get(context, main, endless ? esgst.games : JSON.parse(await getValue(`games`)), endless);
    if (!Object.keys(games.apps).length && !Object.keys(games.subs).length) return;
    [`apps`, `subs`].forEach(type => {
      for (let id in games[type]) {
        games[type][id].forEach(game => {
          esgst[main ? `mainGames` : `popupGames`].push({
            code: id,
            innerWrap: game.headingName,
            name: game.name,
            outerWrap: game.headingName,
            type: type
          });
        });
      }
    });
    if (esgst.gc && (!esgst.menuPath || esgst.gbPath || esgst.gedPath || esgst.gePath)) {
      gc_getGames(games, endless);
    }
    if (esgst.mm_enableGames && esgst.mm_enable) {
      esgst.mm_enable(esgst[main ? `mainGames` : `popupGames`], `Games`);
    }
  }

  function games_get(context, main, savedGames, endless) {
    let game, games, i, id, info, matches, n, headingQuery, matchesQuery, type;
    games = {
      apps: {},
      subs: {}
    };
    if (esgst.discussionPath && main) {
      matchesQuery = `${endless ? `.esgst-es-page-${endless} .featured__outer-wrap--giveaway, .esgst-es-page-${endless}.featured__outer-wrap--giveaway` : `.featured__outer-wrap--giveaway`}, ${endless ? `.esgst-es-page-${endless} .giveaway__row-outer-wrap, .esgst-es-page-${endless}.giveaway__row-outer-wrap` : `.giveaway__row-outer-wrap`}, ${endless ? `.esgst-es-page-${endless} .table__row-outer-wrap, .esgst-es-page-${endless}.table__row-outer-wrap` : `.table__row-outer-wrap`}, ${endless ? `.esgst-es-page-${endless} .markdown table td, .esgst-es-page-${endless}.markdown table td` : `.markdown table td`}`;
      headingQuery = `.featured__heading, .giveaway__heading, .table__column__heading, a`;
    } else {
      matchesQuery = `${endless ? `.esgst-es-page-${endless} .featured__outer-wrap--giveaway, .esgst-es-page-${endless}.featured__outer-wrap--giveaway` : `.featured__outer-wrap--giveaway`}, ${endless ? `.esgst-es-page-${endless} .giveaway__row-outer-wrap, .esgst-es-page-${endless}.giveaway__row-outer-wrap` : `.giveaway__row-outer-wrap`}, ${endless ? `.esgst-es-page-${endless} .table__row-outer-wrap, .esgst-es-page-${endless}.table__row-outer-wrap` : `.table__row-outer-wrap`}`;
      headingQuery = `.featured__heading, .giveaway__heading, .table__column__heading`;
    }
    matches = context.querySelectorAll(matchesQuery);
    for (i = 0, n = matches.length; i < n; ++i) {
      game = {
        container: matches[i]
      };
      game.columns = game.container.querySelector(`.giveaway__columns, .featured__columns`);
      game.table = game.container.closest(`table`) ? true : false;
      game.grid = game.container.closest(`.esgst-gv-view`);
      if (game.grid) {
        game.gvIcons = game.container.getElementsByClassName(`esgst-gv-icons`)[0];
      }
      info = games_getInfo(game.container);
      game.heading = game.container.querySelector(headingQuery);
      if (info && game.heading) {
        game.headingName = game.heading.querySelector(`.featured__heading__medium, .giveaway__heading__name`) || game.heading;
        game.name = game.headingName.textContent;
        id = info.id;
        type = info.type;
        if (esgst.updateHiddenGames && location.pathname.match(/^\/account\/settings\/giveaways\/filters/) && main) {
          const removeButton = game.container.getElementsByClassName(`table__remove-default`)[0];
          if (removeButton) {
            removeButton.addEventListener(`click`, updateHiddenGames.bind(null, id, type, true));
          }
        }
        if (!games[type][id]) {
          games[type][id] = [];
        }
        if (esgst.wishlistPath && main && esgst.cwsl) {
          let giveawayCount = game.heading.parentElement.nextElementSibling.nextElementSibling;
          giveawayCount.innerHTML = `
            <a class="table__column__secondary-link" href="/giveaways/search?${type.slice(0, -1)}=${id}">${giveawayCount.innerHTML}</a>
          `;
        }
        if (esgst.egh) {
          if (esgst.giveawayPath) {
            let button = document.querySelector(`.sidebar__entry-insert`);
            if (button) {
              button.addEventListener(`click`, egh_saveGame.bind(null, id, type));
            }
          }
          if (!esgst.menuPath && savedGames[type][id] && savedGames[type][id].entered && !game.container.getElementsByClassName(`esgst-egh-button`)[0]) {
            insertHtml((game.container.closest(`.poll`) && game.container.getElementsByClassName(`table__column__heading`)[0]) || game.headingName, `beforeBegin`, `
              <a class="esgst-egh-button" title="${getFeatureTooltip(`egh`, `You have entered giveaways for this game before. Click to unhighlight it`)}">
                <i class="fa fa-star esgst-egh-icon"></i>
              </a>
            `).addEventListener(`click`, egh_unhighlightGame.bind(null, id, type));
          }
        }
        if (esgst.gt) {
          if (!game.container.getElementsByClassName(`esgst-gt-button`)[0]) {
            insertHtml((game.container.closest(`.poll`) && game.container.getElementsByClassName(`table__column__heading`)[0]) || game.heading.lastElementChild || game.heading, `afterEnd`, `
              <a class="esgst-faded esgst-gt-button" title="${getFeatureTooltip(`gt`, `Edit game tags`)}">
                <i class="fa fa-tag"></i>
                <span class="esgst-gt-tags"></span>
              </a>
            `).addEventListener(`click`, gt_openPopup.bind(null, id, game.name, type));
          }
          if (savedGames[type][id] && savedGames[type][id].tags) {
            gt_addTags([game], id, savedGames[type][id].tags, type);
          }
        }
        games[type][id].push(game);
      }
    }
    return games;
  }

  function games_getInfo(context) {
    const missing = context.querySelector(`.table_image_thumbnail_missing`);
    const link = context.querySelector(`[href*="/app/"], [href*="/sub/"]`);
    const image = context.querySelector(`[style*="/apps/"], [style*="/subs/"]`);
    if (link || image) {
      const url = (link && link.getAttribute(`href`)) || (image && image.getAttribute(`style`));
      if (url) {
        const info = url.match(/\/(app|sub)s?\/(\d+)/);
        return {
          type: `${info[1]}s`,
          id: info[2]
        };
      } else {
        return null;
      }
    } else if (missing) {
      const heading = context.querySelector(`.table__column__heading`);
      if (!heading) {
        return null;
      }
      const name = heading.textContent.trim();
      for (const id in esgst.games.apps) {
        if (esgst.games.apps[id].name === name) {
          return {
            type: `apps`,
            id: id
          };
        }
      }
      for (const id in esgst.games.subs) {
        if (esgst.games.subs[id].name === name) {
          return {
            type: `subs`,
            id: id
          };
        }
      }
      request({method: `GET`, url: heading.getAttribute(`href`)}).then(async response => {
        const html = parseHtml(response.responseText);
        const giveaway = (await giveaways_get(html, false, response.finalUrl))[0];
        if (giveaway && giveaway.gameType && giveaway.gameSteamId) {
          const games = {
            apps: {},
            subs: {}
          };
          games[giveaway.gameType][giveaway.gameSteamId] = {
            name
          };
          esgst.mainGiveaways.map(x => {
            if (x.name !== name || x.id) {
              return x;
            }
            x.id = giveaway.gameSteamId;
            x.type = giveaway.gameType;
            if (esgst.games && esgst.games[x.type][x.id]) {
              const keys = [`owned`, `wishlisted`, `hidden`, `ignored`, `previouslyEntered`, `previouslyWon`, `reducedCV`, `noCV`];
              for (const key of keys) {
                if (esgst.games[x.type][x.id][key === `previouslyEntered` ? `entered` : (key === `previouslyWon` ? `won` : key)]) {
                  x[key] = true;
                }
              }
            }
            return x;
          });
          if (esgst.gf && esgst.gf.filteredCount && esgst[`gf_enable${esgst.gf.type}`]) {
            filters_filter(esgst.gf);
          }
          lockAndSaveGames(games);
        }
      });
    } else {
      return null;
    }
  }

  // Users
  
  _MODULES.push({
    endless: true,
    id: `users`,
    load: users
  });

  function users() {
    esgst.endlessFeatures.push(users_load);
  }

  function users_load(mainContext, main, source, endless) {
    let elements = mainContext.querySelectorAll(`${endless ? `.esgst-es-page-${endless} a[href*='/user/'], .esgst-es-page-${endless}a[href*='/user/']` : `a[href*='/user/']`}`);
    if (!elements.length) return;
    let found = false;
    for (let i = elements.length - 1; i > -1; i--) {
      let element = elements[i];
      let sg = (esgst.sg && !element.getAttribute(`data-st`)) || element.getAttribute(`data-sg`);
      let match = element.getAttribute(`href`).match(/\/user\/(.+)/);
      if (!match) continue;
      let id = match[1];
      if (((!sg || element.textContent !== id) && (sg || !element.textContent || element.children.length)) || element.closest(`.markdown`)) continue;
      if (!esgst.currentUsers[id]) {
        esgst.currentUsers[id] = {
          elements: []
        };
        let steamId = sg ? esgst.users.steamIds[id] : id;
        esgst.currentUsers[id].savedUser = esgst.users.users[steamId];
        if (esgst.currentUsers[id].savedUser) {
          esgst.currentUsers[id].steamId = steamId;
        }
      }
      let j;
      for (j = esgst.currentUsers[id].elements.length - 1; j > -1 && esgst.currentUsers[id].elements[j] !== element; j--);
      if (j > -1) continue;
      let savedUser = esgst.currentUsers[id].savedUser;
      let container = element.parentElement;
      let oldElement = element;
      if (esgst.userPath && container.classList.contains(`page__heading__breadcrumbs`)) {
        element = document.getElementsByClassName(`featured__heading__medium`)[0];        
      }
      esgst.currentUsers[id].elements.push(element);
      let context = container.classList.contains(`comment__username`) ? container : element;
      esgst[main ? `mainUsers` : `popupUsers`].push({
        code: id,
        innerWrap: context,
        outerWrap: context,
        sg
      });
      if (savedUser) {
        let html = ``;
        if (esgst.namwc && esgst.namwc_h && savedUser.namwc && savedUser.namwc.results && !context.parentElement.querySelector(`.esgst-namwc-highlight, .esgst-namwc-icon`)) {
          let results = savedUser.namwc.results;
          let highlight = null;
          let icon = null;
          if (results.activated && (results.notMultiple || esgst.namwc_h_m)) {
            highlight = `positive`;
            icon = `fa-thumbs-up`;
          } else if (results.unknown) {
            highlight = `unknown`;
            icon = `fa-warning`;
          } else {
            highlight = `negative`;
            icon = `fa-thumbs-down`;
          }
          if (((highlight === `positive` || highlight === `unknown`) && !esgst.namwc_h_f) || highlight === `negative`) {
            let title = `${savedUser.username} has ${results.unknown ? `?` : Array.isArray(results.notActivated) ? results.notActivated.length : results.notActivated} not activated wins and ${Array.isArray(results.multiple) ? results.multiple.length : results.multiple} multiple wins (last checked ${getTimestamp(savedUser.namwc.lastCheck)})`;
            if (esgst.namwc_h_i || (esgst.wbh && (esgst.wbh_w || esgst.wbh_b))) {
              html += `
                <span class="esgst-namwc-icon esgst-user-icon" title="${getFeatureTooltip(`namwc`, title)}">
                  <i class="fa ${icon} esgst-${highlight}"></i>
                </span>
              `;
            } else {
              element.classList.add(`esgst-namwc-highlight`, `esgst-${highlight}`);
              element.title = getFeatureTooltip(`namwc`, title);
            }
          }
        }
        if (esgst.wbc && esgst.wbc_h && savedUser.wbc && !context.parentElement.getElementsByClassName(`esgst-wbc-icon`)[0]) {
          let result = savedUser.wbc.result;
          if ((result === `whitelisted`) || ((result === `blacklisted`) && !esgst.wbc_hb)) {
            html += `
              <span class="esgst-wbc-icon esgst-user-icon" title="${getFeatureTooltip(`wbc`, `${savedUser.username} has ${result} you (last checked ${getTimestamp(savedUser.wbc.lastCheck)})`)}">
                <i class="fa ${(result === `whitelisted`) ? `fa-check esgst-whitelist` : `fa-times esgst-blacklist`}"></i>
              </span>
            `;
          }
        }
        if (esgst.wbh && (savedUser.whitelisted || savedUser.blacklisted) && !context.parentElement.querySelector(`.esgst-wbh-highlight, .esgst-wbh-icon`)) {
          let [icon, status] = savedUser.whitelisted ? [`fa-heart sidebar__shortcut__whitelist`, `whitelisted`] : [`fa-ban sidebar__shortcut__blacklist`, `blacklisted`];
          let title = `You ${status} ${savedUser.username} on ${getTimestamp(savedUser[`${status}Date`])}`;
          if ((esgst.wbh_w && savedUser.whitelisted) || (esgst.wbh_b && savedUser.blacklisted)) {
            element.classList.add(`esgst-wbh-highlight`, `esgst-wbh-highlight-${status}`);
            element.title = getFeatureTooltip(`wbh`, title);
          } else {
            html += `
              <span class="esgst-wbh-icon esgst-user-icon" title="${getFeatureTooltip(`wbh`, title)}">
                <i class="fa ${icon} esgst-${status.slice(0, -2)}"></i>
              </span>
            `;
          }
        }
        if (html) {
          insertHtml(context, `beforeBegin`, html);
        }
        if (esgst.ut && !context.parentElement.getElementsByClassName(`esgst-ut-button`)[0]) {
          ut_addButton(context, id, esgst.currentUsers[id].steamId, savedUser.username);
          if (savedUser.tags) {
            ut_addTags(id, savedUser.tags);
          }
        }
      } else if (esgst.ut && !context.parentElement.getElementsByClassName(`esgst-ut-button`)[0]) {
        ut_addButton(context, id, sg ? null : id, sg ? id : null);
      }
      if (esgst.ap && !oldElement.classList.contains(`esgst-ap-avatar`)[0]) {
        ap_setAvatar(oldElement);
      }
      if (!found) {
        found = true;
      }
    }
    if (found) {
      if (esgst.wbcButton && mainContext === document && !esgst.aboutPath) {
        esgst.wbcButton.classList.remove(`esgst-hidden`);
        esgst.wbcButton.parentElement.classList.remove(`esgst-hidden`);
      }
      if (esgst.mm_enableUsers && esgst.mm_enable) {
        esgst.mm_enable(esgst[main ? `mainUsers` : `popupUsers`], `Users`);
      }
    }
  }

  // [TS]

  _MODULES.push({
    description: `
      <ul>
        <li>Adds a button (<i class="fa fa-sort"></i> if the table is sorted by the default order, <i class="fa fa-sort-asc"></i> if it is sorted by ascending order and <i class="fa fa-sort-desc"></i> if it is sorted by descending order) to the heading of each table's column (in any page) that allows you to sort the table by the values of the column.</li>
      </ul>
    `,
    id: `ts`,
    load: ts,
    name: `Table Sorter`,
    sg: true,
    st: true,
    type: `general`
  });

  function ts() {
    esgst.endlessFeatures.push(ts_getTables);
  }

  function ts_getTables(context, main, source, endless) {
    const tables = context.querySelectorAll(`${endless ? `.esgst-es-page-${endless} .table, .esgst-es-page-${endless}.table` : `.table`}, ${endless ? `.esgst-es-page-${endless} table, .esgst-es-page-${endless}table` : `table`}`);
    for (let i = 0, n = tables.length; i < n; ++i) {
      ts_setTable(tables[i]);
    }
    if (!endless && !esgst.us) {
      ts_sortTables();
    }
  }

  function ts_sortTables() {
    let i, tsTable;
    for (i = esgst.tsTables.length - 1; i > -1; --i) {
      tsTable = esgst.tsTables[i];
      if (tsTable.columnName) {
        sortContent(ts_getArray(tsTable.columnName, tsTable.columnIndex, tsTable.table), null, `${tsTable.key}_${tsTable.name}`);
      }
    }
  }

  function ts_setTable(table) {
    let button, columnName, columns, heading, tsTable;
    heading = table.querySelector(`.table__heading, .header, thead`);
    if (!heading) return;
    tsTable = {
      columnName: ``,
      key: `sortIndex`,
      name: `asc`,
      outerWrap: table,
      table: table
    };
    esgst.tsTables.push(tsTable);
    columns = heading.querySelectorAll(`.table__column--width-fill, .table__column--width-medium, .table__column--width-small, .column_flex, .column_medium, .column_small, th`);
    for (let i = 0, n = columns.length; i < n; ++i) {
      let column = columns[i];
      columnName = column.textContent.trim();
      if (!columnName.match(/^(Keys|Key|Not\sReceived|Remove)$/) && (!esgst.wonPath || !columnName.match(/^Received$/)) && !column.getElementsByClassName(`esgst-ts-button`)[0]) {
        button = insertHtml(column, `beforeEnd`, `
          <span class="esgst-ts-button esgst-clickable"></span>
        `);
        ts_addDescButton(button, columnName, i, table, tsTable);
      }
    }
  }

  function ts_addAscButton(button, columnName, i, table, tsTable) {
    button.innerHTML = `
      <i class="fa fa-sort-desc" title="${getFeatureTooltip(`ts`, `Currently sorted descending. Click to sort ascending.`)}"></i>
    `;
    button.firstElementChild.addEventListener(`click`, ts_sortTable.bind(null, button, columnName, i, `asc`, table, tsTable));
  }

  function ts_addDescButton(button, columnName, i, table, tsTable) {
    button.innerHTML = `
      <i class="fa fa-sort" title="${getFeatureTooltip(`ts`, `Currently sorted by default. Click to sort descending.`)}"></i>
    `;
    button.firstElementChild.addEventListener(`click`, ts_sortTable.bind(null, button, columnName, i, `desc`, table, tsTable));
  }

  function ts_addDefButton(button, columnName, i, table, tsTable) {
    button.innerHTML = `
      <i class="fa fa-sort-asc" title="${getFeatureTooltip(`ts`, `Currently sorted ascending. Click to sort by default.`)}"></i>
    `;
    button.firstElementChild.addEventListener(`click`, ts_sortTable.bind(null, button, columnName, i, `def`, table, tsTable));
  }

  function ts_sortTable(button, columnName, i, key, table, tsTable) {
    tsTable.columnName = columnName;
    tsTable.columnIndex = i;
    tsTable.key = key === `def` ? `sortIndex` : `value`;
    tsTable.name = key;
    if (key === `desc`) {
      sortContent(ts_getArray(columnName, i, table), null, `value_${key}`);
      ts_addAscButton(button, columnName, i, table, tsTable);
    } else if (key === `asc`) {
      sortContent(ts_getArray(columnName, i, table), null, `value_${key}`);
      ts_addDefButton(button, columnName, i, table, tsTable);
    } else {
      sortContent(ts_getArray(columnName, i, table), null, `sortIndex_asc`);
      ts_addDescButton(button, columnName, i, table, tsTable);
    }
  }

  function ts_getArray(columnName, i, table) {
    let array, column, element, j, match, n, row, rows, value;
    array = [];
    rows = table.querySelectorAll(`.table__row-outer-wrap, .row_outer_wrap, tbody tr`);
    let isNumeric = false;
    for (j = 0, n = rows.length; j < n; ++j) {
      row = rows[j];
      column = row.querySelectorAll(`.table__column--width-fill, .table__column--width-medium, .table__column--width-small, .column_flex, .column_medium, .column_small, td`)[i];
      value = column && column.textContent.trim();
      element = {
        outerWrap: row
      };
      if (row.hasAttribute(`data-sort-index`)) {
        element.sortIndex = parseInt(row.getAttribute(`data-sort-index`));
      } else {
        element.sortIndex = j;
        row.setAttribute(`data-sort-index`, j);
      }
      if (value.length > 0 || columnName === `Trending`) {
        if (column.hasAttribute(`data-sort-value`)) {
          element.value = parseFloat(column.getAttribute(`data-sort-value`));
        } else {
          switch (columnName) {
            case `Trending`:
              element.value = column.getElementsByClassName(`fa-caret-up`).length - column.getElementsByClassName(`fa-caret-down`).length;
              break;
            case `Added`:
            case `Date Entered`:
            case `Last Online`:
            case `Last Post`:
            case `Last Update`:
              element.value = value.match(/Online\sNow/) ? Date.now() : parseInt(column.querySelector(`[data-timestamp]`).getAttribute(`data-timestamp`)) * 1e3;
              break;
            case `Game`:
            case `Giveaway`:
            case `Group`:
            case `Status`:
            case `Summary`:
            case `Type`:
            case `User`:
            case `Winner(s)`:
              element.value = value;
              break;
            default:
              if (value.match(/\d+\.\d+/)) {
                element.value = parseFloat(value.replace(/\$/g, ``));
                if (isNaN(element.value)) {
                  element.value = value;
                } else {
                  isNumeric = true;
                }
              } else {
                match = value.replace(/,/g, ``).match(/\d+/);
                if (match) {
                  element.value = parseFloat(match[0]);
                  isNumeric = true;
                } else {
                  element.value = value;
                }
              }
              break;
          }
        }
      } else {
        element.value = 0;
      }
      array.push(element);
    }
    if (isNumeric) {
      for (let i = array.length - 1; i > -1; i--) {
        let element = array[i];
        if (typeof element.value === `string`) {
          element.value = 0;
        }
      }
    }
    return array;
  }
  
  // [STO]

  _MODULES.push({
    description: `
      <ul>
        <li>Opens any link in the page in the same tab.</li>
      </ul>
    `,
    id: `sto`,
    load: sto,
    name: `Same Tab Opener`,
    sg: true,
    st: true,
    type: `general`
  });

  function sto() {
    esgst.endlessFeatures.push(sto_setLinks);
  }

  function sto_setLinks(context, main, source, endless) {
    const elements = context.querySelectorAll(`${endless ? `.esgst-es-page-${endless} [target="_blank"], .esgst-es-page-${endless}[target="_blank"]` : `[target="_blank"]`}`);
    for (let i = 0, n = elements.length; i < n; ++i) {
      elements[i].removeAttribute(`target`);
    }
  }

  // [UH]

  _MODULES.push({
    description: `
      <ul>
        <li>Adds a button (<i class="fa fa-caret-down"></i>) next to a user's username (in their <a href="https://www.steamgifts.com/user/cg">profile</a> page) that allows you to view their username history ever since they started being tracked.</li>
        <li>It is impossible to keep track of every SteamGifts user due to a database capacity limitation (and that would also be impractical), so instead the feature keeps track of a limited number of users (currently around 9000). A user starts being tracked when anyone using ESGST clicks on the button to view their username history.</li>
        <li>Username changes are detected in two instances:</li>
        <ul>
          <li>Every 30 days the usernames of all of the users in the database are updated and if any changes are detected they are added to the history.</li>
          <li>Every time anyone using ESGST clicks on the button to view the username history of a user the username of that user is updated and if a change is detected it is added to the history.</li>
        </ul>
        <li>The database is kept globally in a Google Sheet, which means that everyone using ESGST interacts with the same database and views the same history.</li>
        <li>There is a button (<i class="fa fa-expand"></i>) in the username history popout that allows anyone using ESGST to help expand the database by submitting proof that the user used to have a certain username in the past. The submission will be analyzed and if the proof is authentic the username will be added to the history.</li>
        <li>Adds a button (<i class="fa fa-user"></i> <i class="fa fa-history"></i>) to the page heading of this menu that allows you to view all of the recent username changes detected.</li>
      </ul>
    `,
    id: `uh`,
    load: uh,
    name: `Username History`,
    sg: true,
    type: `users`
  });

  function uh() {
    esgst.profileFeatures.push(uh_add);
  }

  function uh_add(profile) {
    let button, box, container, list;
    container = insertHtml(profile.heading, `beforeEnd`, `
      <div class="esgst-uh-container">
        <a class="esgst-uh-button" title="${getFeatureTooltip(`uh`, `View username history`)}">
          <i class="fa fa-caret-down"></i>
        </a>
        <div class="esgst-uh-box esgst-hidden">
          <div class="esgst-uh-title">
            <span>Username History</span>
            <a href="https://goo.gl/C2wjUh" target="_blank" title="Expand the database">
              <i class="fa fa-expand"></i>
            </a>
          </div>
          <ul class="esgst-uh-list"></ul>
        </div>
      </div>
    `);
    button = container.firstElementChild;
    box = button.nextElementSibling;
    list = box.lastElementChild;
    button.addEventListener(`click`, uh_toggle.bind(null, box, profile, list));
    document.addEventListener(`click`, uh_close.bind(null, box, container));
  }

  async function uh_toggle(box, profile, list) {
    box.classList.toggle(`esgst-hidden`);
    if (!list.innerHTML) {
      list.innerHTML = `
        <div>
          <i class="fa fa-circle-o-notch fa-spin"></i>
          <span>Loading username history...</span>
        </div>
      `;
      list.innerHTML = `<li>${JSON.parse((await request({method: `GET`, url: `https://script.google.com/macros/s/AKfycbzvOuHG913mRIXOsqHIeAuQUkLYyxTHOZim5n8iP-k80iza6g0/exec?Action=1&SteamID64=${profile.steamId}&Username=${profile.username}`})).responseText).Usernames.join(`</li><li>`)}</li>`;
    }
  }

  function uh_close(box, container, event) {
    if (!box.classList.contains(`esgst-hidden`) && !container.contains(event.target)) {
      box.classList.add(`esgst-hidden`);
    }
  }

  // [UN]

  _MODULES.push({
    description: `
      <ul>
        <li>Adds a button (<i class="fa fa-sticky-note"></i> if there are notes saved and <i class="fa fa-sticky-note-o"></i> if there are not) next to a user's username (in their <a href="https://www.steamgifts.com/user/cg">profile</a> page) that allows you to save notes for them (only visible to you).</li>
        <li>You can press Ctrl + Enter to save the notes.</li>
        <li>This feature is recommended for cases where you want to associate a long text with a user, since the notes are not displayed in the page. For a short text, check [id=ut].</li>
      </ul>
    `,
    features: {
      un_p: {
        name: `Pop up when whitelisting/blacklisting a user.`,
        sg: true
      }
    },
    id: `un`,
    load: un,
    name: `User Notes`,
    sg: true,
    st: true,
    type: `users`
  });

  function un() {
    esgst.profileFeatures.push(un_add);
  }

  function un_add(profile, savedUser) {
    let blacklistButton, position, whitelistButton;
    if (esgst.sg) {
      position = `beforeEnd`;
      if (esgst.un_p) {
        whitelistButton = profile.steamButtonContainer.getElementsByClassName(`sidebar__shortcut__whitelist`)[0];
        if (whitelistButton) {
          whitelistButton.addEventListener(`click`, un_open.bind(null, profile));
        }
        blacklistButton = profile.steamButtonContainer.getElementsByClassName(`sidebar__shortcut__blacklist`)[0];
        if (blacklistButton) {
          blacklistButton.addEventListener(`click`, un_open.bind(null, profile));
        }
      }
    } else {
      position = `afterBegin`;
    }
    profile.unButton = insertHtml(profile.heading, position, `
      <a class="esgst-un-button" title="${getFeatureTooltip(`un`, `Edit user notes`)}">
        <i class="fa"></i>
      </a>
    `);
    profile.unIcon = profile.unButton.firstElementChild;
    if (savedUser && savedUser.notes) {
      profile.unIcon.classList.add(`fa-sticky-note`);
    } else {
      profile.unIcon.classList.add(`fa-sticky-note-o`);
    }
    profile.unButton.addEventListener(`click`, un_open.bind(null, profile));
  }

  function un_open(profile) {
    let set;
    profile.unPopup = new Popup(`fa-sticky-note`, `Edit user notes for <span>${profile.name}</span>:`, true);
    profile.unTextArea = insertHtml(profile.unPopup.scrollable, `beforeEnd`, `
      <textarea></textarea>
    `);
    set = new ButtonSet_v2({color1: `green`, color2: `grey`, icon1: `fa-check`, icon2: `fa-circle-o-notch fa-spin`, title1: `Save`, title2: `Saving...`, callback1: un_save.bind(null, profile)});
    profile.unTextArea.addEventListener(`keydown`, event => {
      if (event.ctrlKey && event.key === `Enter`) {
        set.trigger();
      }
    });
    profile.unPopup.description.appendChild(set.set);
    profile.unPopup.open(un_get.bind(null, profile));
  }

  async function un_save(profile) {
    let notes = removeDuplicateNotes(profile.unTextArea.value.trim());
    let user = {
      steamId: profile.steamId,
      id: profile.id,
      username: profile.username,
      values: {
        notes: notes
      }
    };
    if (notes) {
      profile.unIcon.classList.remove(`fa-sticky-note-o`);
      profile.unIcon.classList.add(`fa-sticky-note`);
    } else {
      profile.unIcon.classList.remove(`fa-sticky-note`);
      profile.unIcon.classList.add(`fa-sticky-note-o`);
    }
    await saveUser(null, null, user);
    profile.unPopup.close();
  }

  async function un_get(profile) {
    profile.unTextArea.focus();
    let savedUsers = JSON.parse(await getValue(`users`));
    let savedUser = savedUsers.users[profile.steamId];
    if (savedUser) {
      let notes = savedUser.notes;
      if (notes) {
        profile.unTextArea.value = notes;
      }
    }
  }

  // [UF]

  _MODULES.push({
    description: `
      <ul>
        <li>Adds a button (<i class="fa fa-eye-slash"></i> if the user is being filtered and <i class="fa fa-eye"></i> if they are not) next to a user's username (in their <a href="https://www.steamgifts.com/user/cg">profile</a> page) that allows you to hide their discussions, giveaways and posts (each one can be hidden separately).</li>
        <li>Adds a text in parenthesis to the pagination of the page showing how many users in the page are being filtered by the filters.</li>
        <li>Adds a button (<i class="fa fa-user"></i> <i class="fa fa-eye-slash"></i>) to the page heading of this menu that allows you to view all of the users that have been filtered.</li>
      </ul>
    `,
    features: {
      uf_d: {
        name: `Automatically hide discussions from blacklisted users.`,
        sg: true
      },
      uf_g: {
        name: `Automatically hide giveaways from blacklisted users.`,
        sg: true
      },
      uf_p: {
        name: `Automatically hide posts from blacklisted users.`,
        sg: true
      }
    },
    id: `uf`,
    load: uf,
    name: `User Filters`,
    sg: true,
    type: `users`
  });

  function uf() {
    esgst.profileFeatures.push(uf_add);
  }

  function uf_add(profile, savedUser) {
    if (profile.username !== esgst.username) {
      profile.ufButton = insertHtml(profile.heading, `beforeEnd`, `
        <a class="esgst-uf-button" title="${getFeatureTooltip(`uf`, `Edit user filters`)}">
          <i class="fa"></i>
        </a>
      `);
      profile.ufIcon = profile.ufButton.firstElementChild;
      if (savedUser) {
        profile.ufValues = savedUser.uf;
        if (profile.ufValues && (profile.ufValues.giveaways || profile.ufValues.discussions || profile.ufValues.posts)) {
          profile.ufIcon.classList.add(`fa-eye-slash`);
        } else {
          profile.ufIcon.classList.add(`fa-eye`);
          profile.ufValues = {
            giveaways: false,
            discussions: false,
            posts: false
          };
        }
      } else {
        profile.ufIcon.classList.add(`fa-eye`);
        profile.ufValues = {
          giveaways: false,
          discussions: false,
          posts: false
        };
      }
      profile.ufButton.addEventListener(`click`, uf_open.bind(null, profile));
    }
  }

  function uf_open(profile) {
    let resetSet, saveSet;
    profile.ufPopup = new Popup(`fa-eye`, `Apply user filters for <span>${profile.name}</span>:`, true);
    profile.ufOptions = insertHtml(profile.ufPopup.description, `beforeEnd`, `<div></div>`);
    profile.ufGiveawaysOption = new ToggleSwitch(profile.ufOptions, null, false, `Filter this user's giveaways.`, false, false, `Hides the user's giveaways from the main pages.`, profile.ufValues.giveaways);
    profile.ufDiscussionsOption = new ToggleSwitch(profile.ufOptions, null, false, `Filter this user's discussions.`, false, false, `Hides the user's discussions from the main pages.`, profile.ufValues.discussions);
    profile.ufPostsOption = new ToggleSwitch(profile.ufOptions, null, false, `Filter this user's posts.`, false, false, `Hides the user's posts everywhere.`, profile.ufValues.posts);
    saveSet = new ButtonSet_v2({color1: `green`, color2: `grey`, icon1: `fa-check`, icon2: `fa-circle-o-notch fa-spin`, title1: `Save Settings`, title2: `Saving...`, callback1: uf_save.bind(null, profile, false)});
    resetSet = new ButtonSet_v2({color1: `green`, color2: `grey`, icon1: `fa-rotate-left`, icon2: `fa-circle-o-notch fa-spin`, title1: `Reset Settings`, title2: `Resetting...`, callback1: uf_save.bind(null, profile, true)});
    saveSet.dependencies.push(resetSet.set);
    resetSet.dependencies.push(saveSet.set);
    profile.ufPopup.description.appendChild(saveSet.set);
    profile.ufPopup.description.appendChild(resetSet.set);
    profile.ufPopup.open();
  }

  async function uf_save(profile, reset) {
    let user;
    if (reset) {
      profile.ufGiveawaysOption.input.checked = false;
      profile.ufDiscussionsOption.input.checked = false;
      profile.ufPostsOption.input.checked = false;
      profile.ufValues = {
        giveaways: false,
        discussions: false,
        posts: false
      };
    } else {
      profile.ufValues = {
        giveaways: profile.ufGiveawaysOption.input.checked,
        discussions: profile.ufDiscussionsOption.input.checked,
        posts: profile.ufPostsOption.input.checked
      };
    }
    user = {
      steamId: profile.steamId,
      id: profile.id,
      username: profile.username,
      values: {
        uf: profile.ufValues
      }
    };
    if (profile.ufValues && (profile.ufValues.giveaways || profile.ufValues.discussions || profile.ufValues.posts)) {
      profile.ufIcon.classList.remove(`fa-eye`);
      profile.ufIcon.classList.add(`fa-eye-slash`);
    } else {
      profile.ufIcon.classList.remove(`fa-eye-slash`);
      profile.ufIcon.classList.add(`fa-eye`);
    }
    await saveUser(null, null, user);
    profile.ufPopup.close();
  }

  function uf_updateCount(context, extraCount) {
    let count;
    count = context.getElementsByClassName(`esgst-uf-count`)[0];
    context = context.firstElementChild;
    if (!extraCount) {
      extraCount = 0;
    }
    if (count) {
      count.innerHTML = `
        (<span class="esgst-bold">${parseInt(count.firstElementChild.textContent) + 1 + extraCount}</span> filtered by User Filters)
      `;
    } else {
      context.insertAdjacentHTML(`beforeEnd`, `
        <span class="esgst-uf-count">
          (<span class="esgst-bold">${1 + extraCount}</span> filtered by User Filters)
        </span>
      `);
    }
  }
  
  // [SGC]

  _MODULES.push({
    description: `
      <ul>
        <li>Adds a button (<i class="fa fa-users"></i>) next to a user's username (in their <a href="https://www.steamgifts.com/user/cg">profile</a> page) that allows you to check which groups you are both members of.</li>
      </ul>
    `,
    id: `sgc`,
    load: sgc,
    name: `Shared Group Checker`,
    sg: true,
    type: `users`
  });

  function sgc() {
    esgst.profileFeatures.push(sgc_add);
  }

  function sgc_add(profile) {
    if (profile.username === esgst.username) {
      // no point in checking which groups a user shares with themselves
      return;
    }
    profile.sgcButton = insertHtml(profile.heading, `beforeEnd`, `
      <a class="esgst-sgc-button" title="${getFeatureTooltip(`sgc`, `Check shared groups`)}">
        <i class="fa fa-users"></i>
      </a>
    `);
    profile.sgcButton.addEventListener(`click`, sgc_open.bind(null, profile));
  }

  async function sgc_open(profile) {
    if (profile.sgcPopup) {
      profile.sgcPopup.open();
    } else {
      profile.sgcPopup = new Popup(`fa-users`, `Shared Groups`);
      profile.sgcProgress = insertHtml(profile.sgcPopup.description, `beforeEnd`, `
        <div>
          <i class="fa fa-circle-o-notch fa-spin"></i>
          <span>Checking shared groups...</span>
        </div>
      `);
      profile.sgcResults = insertHtml(profile.sgcPopup.scrollable, `beforeEnd`, `
        <div class="esgst-sgc-results esgst-glwc-results esgst-text-left">
          <div>
            <div class="esgst-glwc-heading">Public</div>
            <div class="table esgst-hidden">
              <div class="table__heading">
                <div class="table__column--width-fill">Group</div>
              </div>
              <div class="table__rows"></div>
            </div>
          </div>
          <div>
            <div class="esgst-glwc-heading">Private</div>
            <div class="table esgst-hidden">
              <div class="table__heading">
                <div class="table__column--width-fill">Group</div>
              </div>
              <div class="table__rows"></div>
            </div>
          </div>
        </div>
      `);
      profile.sgcPublic = profile.sgcResults.firstElementChild.lastElementChild;
      profile.sgcPublicResults = profile.sgcPublic.lastElementChild;
      profile.sgcPrivate = profile.sgcResults.lastElementChild.lastElementChild;
      profile.sgcPrivateResults = profile.sgcPrivate.lastElementChild;
      profile.sgcPopup.open();
      sgc_load(profile);
    }
  }

  async function sgc_load(profile) {
    const publicGroups = [];
    const privateGroups = [];
    let response = await request({method: `GET`, url: `http://steamcommunity.com/profiles/${profile.steamId}/groups/common`});
    let responseHtml = parseHtml(response.responseText);
    let isLoggedIn = true;
    if (!responseHtml.getElementById(`groups_list`)) {
      response = await request({method: `GET`, url: `http://steamcommunity.com/profiles/${profile.steamId}/groups`});
      responseHtml = parseHtml(response.responseText);
      isLoggedIn = false;
    }
    const elements = responseHtml.getElementsByClassName(`group_block`);
    for (const element of elements) {
      const name = element.getElementsByClassName(`linkTitle`)[0].textContent;
      const avatar = element.getElementsByClassName(`avatarMedium`)[0].firstElementChild.firstElementChild.getAttribute(`src`);
      let i;
      for (i = esgst.groups.length - 1; i > -1 && esgst.groups[i].name !== name; i--);
      if (!isLoggedIn && (i < 0 || !esgst.groups[i].member)) {
        continue;
      }
      const code = i > -1 ? esgst.groups[i].code : ``;
      (element.getElementsByClassName(`pubGroup`)[0] ? publicGroups : privateGroups).push({
        name: name,
        html: `
          <div class="table__row-outer-wrap">
            <div class="table__row-inner-wrap">
              <div>
                <a class="table_image_avatar" href="/group/${code}/" style="background-image:url(${avatar})"></a>
              </div>
              <div class="table__column--width-fill">
                <a class="table__column__heading" href="/group/${code}/"></a>
              </div>
            </div>
          </div>
        `
      });
    }
    const n1 = publicGroups.length;
    const n2 = privateGroups.length;
    if (n1 || n2) {
      if (n1 > 0) {
        sortArrayByKey(publicGroups, `name`).map(x => {
          insertHtml(profile.sgcPublicResults, `beforeEnd`, x.html).getElementsByClassName(`table__column__heading`)[0].textContent = x.name;
        });
        profile.sgcPublic.classList.remove(`esgst-hidden`);
      } else {
        profile.sgcPublic.outerHTML = `
          <div>No shared public groups found.</div>
        `;
      }
      if (n2 > 0) {
        sortArrayByKey(privateGroups, `name`).map(x => {
          insertHtml(profile.sgcPrivateResults, `beforeEnd`, x.html).getElementsByClassName(`table__column__heading`)[0].textContent = x.name;
        });
        profile.sgcPrivate.classList.remove(`esgst-hidden`);
      } else {
        profile.sgcPrivate.outerHTML = `
          <div>No shared private groups found.</div>
        `;
      }
      profile.sgcProgress.remove();
      profile.sgcProgress = null;
    } else {
      profile.sgcProgress.innerHTML = `No shared groups found.`;
    }
    endless_load(profile.sgcResults);
  }

  // [RWSCVL]

  _MODULES.push({
    description: `
      <ul>
        <li>Turns "Gifts Won" and "Gifts Sent" in a user's <a href="https://www.steamgifts.com/user/cg">profile</a> page into links that take you to their real won/sent CV pages on <a href="https://www.sgtools.info/">SGTools</a>.</li>
      </ul>
    `,
    features: {
      rwscvl_r: {
        name: `Link SGTools' reverse pages (from newest to oldest).`,
        sg: true
      }
    },
    id: `rwscvl`,
    load: rwscvl,
    name: `Real Won/Sent CV Link`,
    sg: true,
    type: `users`
  });

  function rwscvl() {
    esgst.profileFeatures.push(rwscvl_add);
  }

  function rwscvl_add(profile) {
    let sentUrl, wonUrl;
    wonUrl = `http://www.sgtools.info/won/${profile.username}`;
    sentUrl = `http://www.sgtools.info/sent/${profile.username}`;
    if (esgst.rwscvl_r) {
      wonUrl += `/newestfirst`;
      sentUrl += `/newestfirst`;
    }
    profile.wonRowLeft.innerHTML = `
      <a class="esgst-rwscvl-link" href="${wonUrl}" target="_blank" title="${getFeatureTooltip(`rwscvl`)}">Gifts Won</a>
    `;
    profile.sentRowLeft.innerHTML = `
      <a class="esgst-rwscvl-link" href="${sentUrl}" target="_blank" title="${getFeatureTooltip(`rwscvl`)}">Gifts Sent</a>
    `;
  }
  
  // [UGD]

  _MODULES.push({
    description: `
      <ul>
        <li>Adds 2 identical buttons (<i class="fa fa-bar-chart"></i>) to the "Gifts Won" and "Gifts Sent" rows of a user's <a href="https://www.steamgifts.com/user/cg">profile</a> page that allow you to gather data about their giveaways:</li>
        <ul>
          <li>The won data contains a table with the number and percentage of won giveaways per type/level, a list with the creators that the user has most won from and (optionally) 2 other tables with the user's playtime/achievement stats for the games (DLCs cannot be counted, but packages will be listed with playtime > 0 and achievements > 0 if one or more of the games in the package have playtime/achievements).</li>
          <li>The sent data contains a table with the number and percentage of sent giveaways per type/level and a list with the games that the user has most given away.</li>
        </ul>
        <li>Results are cached forever, so every time you check the same user again the feature will only retrieve the giveaways that they have created/won since the last check, unless you check them with the option to clear the cache enabled, in which case all of their giveaways will be retrieved again as if they were being checked for the first time.</li>
      </ul>
    `,
    features: {
      ugd_s: {
        name: `Display playtime/achievement stats in the user's profile page.`,
        sg: true
      }
    },
    id: `ugd`,
    load: ugd,
    name: `User Giveaway Data`,
    sg: true,
    type: `users`
  });

  function ugd() {
    esgst.profileFeatures.push(ugd_addButtons);
    if (esgst.ugd_s) {
      esgst.profileFeatures.push(ugd_addStats);
    }
  }

  function ugd_addButtons(profile) {
    const user = {
      steamId: profile.steamId,
      id: profile.id,
      username: profile.username
    };
    ugd_add(profile.wonRowLeft, `won`, user);
    ugd_add(profile.sentRowLeft, `sent`, user);
  }

  function ugd_addStats(profile, savedUser) {
    if (!savedUser) {
      return;
    }

    const ugdCache = savedUser.ugdCache;
    if (!ugdCache) {
      return;
    }

    let playtimes = 0;
    let achievements = 0;
    for (const key in ugdCache.playtimes) {
      const playtime = ugdCache.playtimes[key];
      if (playtime[1] > 0) {
        playtimes += 1;
      }
    }
    const totalPlaytimes = Object.keys(ugdCache.playtimes).length;
    playtimes = `${playtimes}/${totalPlaytimes} (${Math.round(playtimes / totalPlaytimes * 10000) / 100}%)`;
    for (const key in ugdCache.achievements) {
      const achievement = ugdCache.achievements[key];
      if (achievement.match(/(.+?)\//)[1] !== `0`) {
        achievements += 1;
      }
    }
    const totalAchievements = Object.keys(ugdCache.achievements).length;
    achievements = `${achievements}/${totalAchievements} (${Math.round(achievements / totalAchievements * 10000) / 100}%)`;
    profile.commentsRow.insertAdjacentHTML(`afterEnd`, `
      <div class="esgst-ugd featured__table__row" title="${getFeatureTooltip(`ugd`)}">
        <div class="featured__table__row__left">Won Games Playtime > 0</div>
        <div class="featured__table__row__right">${playtimes}</div>
      </div>
      <div class="esgst-ugd featured__table__row" title="${getFeatureTooltip(`ugd`)}">
        <div class="featured__table__row__left">Won Games Achievements > 0</div>
        <div class="featured__table__row__right">${achievements}</div>
      </div>
    `);
  }

  function ugd_add(context, key, user, mainPopup) {
    let button = null;
    if (context) {
      button = insertHtml(context, `beforeEnd`, `
        <span class="esgst-ugd-button" title="${getFeatureTooltip(`ugd`, `Get ${key} giveaway data`)}">
          <i class="fa fa-bar-chart"></i>
        </span>
      `);
    }
    const details = {
      button: button,
      popup: {
        icon: `fa-bar-chart`,
        title: `Get ${user.username}'s ${key} giveaway data:`,
        options: [
          {
            check: key === `won`,
            description: `Get playtime stats.`,
            id: `ugd_getPlaytime`,
            tooltip: `Get playtime stats for each won game by this user (requires a Steam API Key inserted into the settings menu - does not check DLCs/packages).`
          }, {
            check: key === `won`,
            description: `Get achievements stats.`,
            id: `ugd_getAchievements`,
            tooltip: `Get achievements stats for each won game by this user (slower - does not check DLCs/packages).`
          }, {
            check: true,
            description: `Clear cache.`,
            id: `ugd_clearCache`,
            tooltip: `If enabled, the cache will be cleared and all giveaways will be retrieved again (slower).`
          }
        ],
        addProgress: true,
        addScrollable: `left`
      },
      mainPopup: mainPopup,
      init: ugd_init.bind(null, key, user),
      requests: [
        {
          url: `/user/${user.username}${key === `won` ? `/giveaways/won` : ``}/search?page=`,
          request: ugd_requestGiveaways
        },
        ugd_requestGiveawaysDone
      ]
    };
    return new Process(details);
  }

  async function ugd_init(key, user, obj) {
    obj.giveaways = {};
    obj.key = key;
    obj.user = user;
    if (obj.key === `sent` && obj.user.username === esgst.username) {
      obj.toGet = true;
    }

    const savedUser = await getUser(null, obj.user);
    obj.ugdCache = savedUser && savedUser.ugdCache;
    obj.userGiveaways = await ugd_getUserGiveaways(savedUser);
    if (obj.popup && esgst.ugd_clearCache) {
      obj.userGiveaways[obj.key] = null;
      if (obj.key === `won`) {
        obj.ugdCache = null;
      }
    }
    if (
      !obj.userGiveaways.sent || (
        obj.key === `sent` &&
        obj.user.username === esgst.username &&
        obj.userGiveaways.version !== `7.13.0`
      )
    ) {
      obj.userGiveaways.sent = {
        apps: {},
        subs: {}
      };
      obj.userGiveaways.sentTimestamp = 0;
      obj.userGiveaways.version = `7.13.0`;
    }
    if (!obj.userGiveaways.won) {
      obj.userGiveaways.won = {
        apps: {},
        subs: {}
      };
      obj.userGiveaways.wonTimestamp = 0;
    }
  }

  async function ugd_getUserGiveaways(savedUser) {
    let userGiveaways = savedUser && savedUser.giveaways;
    if (userGiveaways) {
      return userGiveaways;
    }

    userGiveaways = {
      sent: {
        apps: {},
        subs: {}
      },
      won: {
        apps: {},
        subs: {}
      },
      sentTimestamp: 0,
      wonTimestamp: 0,
      version: `7.13.0`
    };
    if (!savedUser) {
      return userGiveaways;
    }

    const ugd = savedUser.ugd;
    if (!ugd) {
      return userGiveaways;
    }

    let newGiveaways = {};
    const keys = [`sent`, `won`];
    const types = [`apps`, `subs`];
    for (const key of keys) {
      if (!ugd[key]) {
        continue;
      }

      for (const type of types) {
        const ids = ugd[key][type];
        for (const id of ids) {
          userGiveaways[key][type][id] = [];
          const giveaways = ugd[key][type][id];
          const n = giveaways.length;
          for (let i = 0; i < n; i++) {
            const giveaway = giveaways[i];
            const code = giveaway.code;
            newGiveaways[code] = giveaway;
            userGiveaways[key][type][id].push(code);
          }
        }
      }
      userGiveaways[`${key}Timestamp`] = ugd[`${key}Timestamp`];
    }
    if (Object.keys(newGiveaways).length) {
      await lockAndSaveGiveaways(newGiveaways);
    }
    return userGiveaways;
  }

  async function ugd_requestGiveaways(obj, details, response, responseHtml) {
    const msg = `Retrieving giveaways (page ${details.nextPage}${details.lastPage})...`;
    if (obj.popup) {
      obj.popup.setProgress(msg);
    } else {
      obj.mainPopup.progress.lastElementChild.textContent = msg;
    }

    let found = false;
    const currentTime = Date.now();
    const elements = responseHtml.getElementsByClassName(`giveaway__row-outer-wrap`);
    const n = elements.length;
    for (let i = 0; i < n; i++) {
      const giveaway = (
        await giveaways_getInfo(elements[i], document, obj.user.username, obj.key)
      ).data;
      const endTime = giveaway.endTime;

      // giveaway has not ended yet, so cannot store it
      if (endTime >= currentTime) {
        continue;
      }

      if (!obj.timestamp) {
        obj.timestamp = endTime;
      }

      // giveaway has already been stored previously
      if (endTime <= obj.userGiveaways[`${obj.key}Timestamp`]) {
        found = true;
        break;
      }

      const id = giveaway.gameSteamId;
      if (!id) {
        continue;
      }

      const games = obj.userGiveaways[obj.key][giveaway.gameType];
      const code = giveaway.code;
      if (!games[id]) {
        games[id] = [];
      }
      if (code) {
        games[id].push(code);
        obj.giveaways[code] = giveaway;
        if (obj.toGet) {
          const savedGiveaway = esgst.giveaways[code];
          if (!savedGiveaway || !Array.isArray(savedGiveaway.winners)) {
            giveaway.winners = [];
            obj.requests.push({
              giveaway: giveaway,
              request: ugd_requestGiveaway,
              url: `/giveaway/${code}/_/winners/search?page=`
            });
          }
        }
      } else {
        games[id].push(giveaway);
      }
    }
    if (found) {
      return true;
    }
  }

  async function ugd_requestGiveawaysDone(obj) {
    if (!obj.toGet) {
      await ugd_requestGiveawaysDone_2(obj);
      return;
    }

    // check if there are winners of a giveaway in the 'awaiting feedback' status so they can be updated
    const types = [`apps`, `subs`];
    for (const type of types) {
      const games = obj.userGiveaways.sent[type];
      for (const id in games) {
        const game = games[id];
        for (const item of game) {
          const giveaway = typeof item === `string` ? esgst.giveaways[item] : item;
          if (!giveaway || !Array.isArray(giveaway.winners)) {
            break;
          }

          let i;
          for (i = giveaway.winners.length - 1; i > -1; i--) {
            const winner = giveaway.winners[i];
            if (winner.status !== `Received` && winner.status !== `Not Received`) {
              break;
            }
          }
          if (i > -1) {
            const code = giveaway.code;
            if (code) {
              obj.giveaways[code] = giveaway;
            }
            obj.requests.push({
              giveaway: giveaway,
              request: ugd_requestGiveaway,
              url: `/giveaway/${code}/_/winners/search?page=`
            });
          }
        }
      }
    }
    obj.requests.push(ugd_requestGiveawaysDone_2);
  }

  async function ugd_requestGiveawaysDone_2(obj) {
    const lpvCache = JSON.parse(getLocalValue(`lpvCache`, `{}`));
    lpvCache.difference = 0;
    setLocalValue(`lpvCache`, JSON.stringify(lpvCache));

    obj.userGiveaways[`${obj.key}Timestamp`] = obj.timestamp;
    await lockAndSaveGiveaways(obj.giveaways);

    obj.user.values = {
      giveaways: obj.userGiveaways,
      ugd: null
    };

    if (!obj.popup) {
      await saveUser(null, null, obj.user);
      return;
    }

    obj.popup.setProgress(`Calculating results...`);

    obj.games = obj.userGiveaways[obj.key];
    obj.perType = {};
    obj.typeTotal = {};
    obj.levelTotal = new Array(11).fill(0);
    obj.total = 0;
    obj.lists = {};
    if (obj.key === `sent`) {
      obj.lists.gameName = {
        name: `Most given away:`,
        values: []
      };
      if (obj.user.username === esgst.username) {
        obj.lists.username = {
          name: `Most sent to:`,
          values: []
        };
      }
    } else {
      obj.lists.creator = {
        name: `Most won from:`,
        values: []
      };
    }
    const types = {
      public: `Everyone`,
      regionRestricted: {
        name: `Region`,
        combo: [`inviteOnly`, `group`, `whitelist`]
      },
      inviteOnly: `Invite`,
      group: {
        name: `Group`,
        combo: [`whitelist`]
      },
      whitelist: `Whitelist`
    };
    const selectors = [];
    for (const key in types) {
      const type = types[key];
      if (typeof type === `string`) {
        selectors.push(type);
      } else {
        selectors.push(type.name);
        for (const combo of type.combo) {
          const comboType = types[combo];
          selectors.push(`${type.name}_${typeof comboType === `string` ? comboType : comboType.name}`);
          if (comboType.combo) {
            for (const subCombo of comboType.combo) {
              const subComboType = types[subCombo];
              selectors.push(`${type.name}_${typeof comboType === `string` ? comboType : comboType.name}_${typeof subComboType === `string` ? subComboType : subComboType.name}`);
            }
          }
        }
      }
    }
    for (const selector of selectors) {
      obj.perType[selector] = new Array(11).fill(0);
      obj.typeTotal[selector] = 0;
    }
    obj.savedGiveaways = JSON.parse(await getValue(`giveaways`));
    await ugd_count(obj, obj.games.apps, obj.savedGiveaways, types);
    await ugd_count(obj, obj.games.subs, obj.savedGiveaways, types);

    const results = obj.popup.getScrollable();

    const heading = [`Type`];
    for (let i = 0; i < 11; i++) {
      heading.push(`Level ${i}`);
    }
    heading.push(`Total`);
    const table = new Table([
      heading
    ]);
    for (const key in obj.perType) {
      const item = obj.perType[key];
      const columns = [key.replace(/_/g, ` + `)];
      for (let i = 0; i < 11; i++) {
        const value = item[i];
        columns.push(value);
      }
      const typeTotal = obj.typeTotal[key];
      const total = Math.round(typeTotal / obj.total * 10000) / 100;
      columns.push(`${typeTotal} (${total}%)`);
      table.addRow(columns);
    }
    const columns = [`Total`];
    for (let i = 0; i < 11; i++) {
      const levelTotal = obj.levelTotal[i];
      const total = Math.round(levelTotal / obj.total * 10000) / 100;
      columns.push(`${levelTotal} (${total}%)`);
    }
    columns.push(obj.total);
    table.addRow(columns);
    results.appendChild(table.table);

    for (const key in obj.lists) {
      const array = [];
      const list = obj.lists[key];
      const values = list.values;
      for (const selector in values) {
        const item = values[selector];
        item.name = selector;
        array.push(item);
      }
      list.values = sortArrayByNumberKey(array, `value`, true);
    }

    if (
      obj.key !== `won` ||
      (!esgst.ugd_getPlaytime && !esgst.ugd_getAchievements) ||
      !esgst.steamApiKey
    ) {
      await ugd_complete(obj, results);
      await saveUser(null, null, obj.user);
      return;
    }

    obj.playtimeTable = new Table([
      [
        {
          alignment: `left`,
          size: `fill`,
          value: `Game`
        },
        `Playtime (Last 2 Weeks)`,
        `Playtime (Forever)`,
        `Achievements`,
        `Gifter`
      ]
    ]);
    if (!esgst.ugd_getPlaytime) {
      obj.playtimeTable.hideColumns(2, 3);
    }
    if (!esgst.ugd_getAchievements) {
      obj.playtimeTable.hideColumns(4);
    }

    obj.isUpdating = false;
    const currentTime = Date.now();
    if (
      !obj.ugdCache ||
      (currentTime - obj.ugdCache.lastCheck) > 604800000 ||
      (esgst.ugd_getPlaytime && !Object.keys(obj.ugdCache.playtimes).length) ||
      (esgst.ugd_getAchievements && !Object.keys(obj.ugdCache.achievements).length)
    ) {
      obj.isUpdating = true;
      if (!obj.ugdCache) {
        obj.ugdCache = {
          achievements: {},
          playtimes: {}
        };
      }
      obj.ugdCache.lastCheck = currentTime;
    }

    obj.playtimes = null;
    if (esgst.ugd_getPlaytime && obj.isUpdating) {
      obj.popup.setProgress(`Retrieving playtime stats...`);
      obj.ugdCache.playtimes = {};
      try {
        const response = await request({
          method: `GET`,
          url: `https://api.steampowered.com/IPlayerService/GetOwnedGames/v0001/?key=${esgst.steamApiKey}&steamid=${obj.user.steamId}&format=json`
        });
        const responseText = response.responseText;
        obj.playtimes = JSON.parse(responseText).response.games;
      } catch (e) {
        console.log(e);
        alert(`An error ocurred when retrieving playtime stats. Please check your Steam API key in the settings menu or try again later.`);
        await ugd_complete(obj, results);
        await saveUser(null, null, obj.user);
        return;
      }
    }
    if (esgst.ugd_getAchievements && obj.isUpdating) {
      obj.ugdCache.achievements = {};
    }

    obj.playedCount = 0;
    obj.achievementCount = 0;
    obj.achievementTotal = 0;
    obj.appsTotal = Object.keys(obj.games.apps).length;
    obj.subsTotal = Object.keys(obj.games.subs).length;
    const total = obj.appsTotal + obj.subsTotal;
    for (const id in obj.games.apps) {
      await ugd_addGame(obj, id);
      obj.appsTotal--;
    }
    let gcCache = JSON.parse(getLocalValue(`gcCache`, `{ "apps": {}, "subs": {}, "timestamp": 0, "version": 2 }`));
    if (gcCache.version !== 2) {
      gcCache = {
        apps: {},
        subs: {},
        timestamp: 0,
        version: 2
      };
    }
    for (const id in obj.games.subs) {
      const giveaways = obj.games.subs[id];
      const item = giveaways[0];
      const giveaway = typeof item === `string` ? obj.savedGiveaways[item] : item;
      let apps = gcCache.subs[id] && gcCache.subs[id].apps;
      if (!apps) {
        try {
          const response = await request({
            method: `GET`,
            url: `http://store.steampowered.com/api/packagedetails?packageids=${id}&filters=basic`
          });
          const responseText = response.responseText;
          const responseJson = JSON.parse(responseText);
          apps = responseJson[id].data.apps;
          if (!gcCache.subs[id]) {
            gcCache.subs[id] = {};
          }
          gcCache.subs[id].apps = apps;
        } catch (e) {}
      }
      if (apps) {
        for (const app of apps) {
          obj.packagePlayed = false;
          obj.packageAchieved = false;
          await ugd_addGame(obj, app.id, id, app.name);
        }
      }
      obj.subsTotal--;
    }
    setLocalValue(`gcCache`, JSON.stringify(gcCache));

    results.appendChild(obj.playtimeTable.table);
    results.insertAdjacentHTML(`beforeEnd`, `
      ${esgst.ugd_getPlaytime ? `
        <div class="esgst-bold">
          ${obj.playedCount} out of ${total} games with more than 0 hours playtime (${Math.round(obj.playedCount / total * 10000) / 100}%)
        </div>
        ` : ``}
      ${esgst.ugd_getAchievements ? `
        <div class="esgst-bold">${obj.achievementCount} out of ${obj.achievementTotal} games with more than 0 achievements (${Math.round(obj.achievementCount / Math.max(1, obj.achievementTotal) * 10000) / 100}%)</div>
      ` : ``}
    `);

    await ugd_complete(obj, results);

    obj.user.values.ugdCache = obj.ugdCache;
    await saveUser(null, null, obj.user);
  }

  async function ugd_addGame(obj, id, packageId, name) {
    const appId = parseInt(id);
    let i;
    if (obj.playtimes) {
      for (i = obj.playtimes.length - 1; i > -1 && obj.playtimes[i].appid !== appId; i--);
    }
    const giveaways = obj.games[packageId ? `subs` : `apps`][packageId || id];
    const item = giveaways[0];
    const giveaway = typeof item === `string` ? obj.savedGiveaways[item] : item;
    let timestamp2Weeks = 0;
    let timestampForever = 0;
    let time2Weeks = 0;
    let timeForever = 0;
    let achievementsAttributes = null;
    let achievements = `?`;
    if (esgst.ugd_getPlaytime && (i > -1 || obj.ugdCache.playtimes[appId])) {
      if (obj.isUpdating) {
        const game = obj.playtimes[i];
        timestamp2Weeks = game.playtime_2weeks || 0;
        timestampForever = game.playtime_forever;
        obj.ugdCache.playtimes[appId] = [timestamp2Weeks, timestampForever];
      } else {
        [timestamp2Weeks, timestampForever] = obj.ugdCache.playtimes[appId];
      }
      if (timestampForever > 0 && (!packageId || !obj.packagePlayed)) {
        obj.playedCount += 1;
        obj.packagePlayed = true;
      }
      time2Weeks = timestamp2Weeks && timestamp2Weeks > 0 ? (
        timestamp2Weeks > 60
        ? `${Math.round(timestamp2Weeks / 60 * 100) / 100}h`
        : `${timestamp2Weeks}m`
      ) : `0`;
      timeForever = timestampForever > 0 ? (
        timestampForever > 60
          ? `${Math.round(timestampForever / 60 * 100) / 100}h`
          : `${timestampForever}m`
        ) : `0`;
    }
    if (esgst.ugd_getAchievements) {
      let achievementsData = obj.ugdCache && obj.ugdCache.achievements[appId];
      if (obj.isUpdating) {
        obj.popup.setProgress(`Retrieving achievement stats for ${giveaway.gameName || packageId} (${packageId ? `${obj.subsTotal} packages` : obj.appsTotal} left)...`);
        const response = await request({
          method: `GET`,
          url: `http://api.steampowered.com/ISteamUserStats/GetPlayerAchievements/v0001/?appid=${appId}&key=${esgst.steamApiKey}&steamid=${obj.user.steamId}`
        });
        const responseText = response.responseText;
        const responseJson = JSON.parse(responseText).playerstats;
        if (responseJson.success) {
          achievementsData = responseJson.achievements;
        }
      }
      achievements = `0/0`;
      if (achievementsData) {
        let count = 0;
        let total = 0;
        if (obj.isUpdating) {
          for (const achievement of achievementsData) {
            if (achievement.achieved) {
              count += 1;
            }
            total += 1;
          }
          achievementsAttributes = Math.round(count / total * 10000) / 100;
          achievements = `${count}/${total} (${achievementsAttributes}%)`;
          obj.ugdCache.achievements[appId] = achievements;
        } else {
          const parts = achievementsData.match(/(.+?)\/(.+?)\s\((.+?)%\)/);
          count = parseInt(parts[0]);
          total = parseInt(parts[1]);
          achievementsAttributes = parseFloat(parts[2]);
          achievements = achievementsData;
        }
        if (!packageId || !obj.packageAchieved) {
          if (count > 0) {
            obj.achievementCount += 1;
          }
          obj.achievementTotal += 1;
          obj.packageAchieved = true;
        }
      }
    }
    obj.playtimeTable.addRow([
      {
        alignment: `left`,
        size: `fill`,
        value: `${giveaway.gameName}${packageId ? ` => ${name}` : ``}`
      },
      {
        attributes: [`data-sort-value="${timestamp2Weeks}"`],
        value: time2Weeks
      },
      {
        attributes: [`data-sort-value="${timestampForever}"`],
        value: timeForever
      },
      {
        attributes: [`data-sort-value="${achievementsAttributes}"`],
        value: achievements
      },
      `<a class="table__column__secondary-link" href="/user/${giveaway.creator}">${giveaway.creator}</a>`
    ]);
  }

  async function ugd_count(obj, games, savedGiveaways, types) {
    for (const id in games) {
      const giveaways = games[id];
      for (const item of giveaways) {
        const giveaway = typeof item === `string` ? savedGiveaways[item] : item;
        let selector = ``;
        for (const key in types) {
          const type = types[key];
          if (giveaway[key]) {
            selector += typeof type === `string` ? type : type.name;
            selector += `_`;
          }
        }
        selector = selector.slice(0, -1);
        if (!selector) {
          selector = `Everyone`;
        }
        const level = giveaway.level;
        const copies = obj.key === `sent` ? giveaway.copies : 1;
        obj.perType[selector][level] += copies;
        obj.typeTotal[selector] += copies;
        obj.levelTotal[level] += copies;
        obj.total += copies;
        for (const key in obj.lists) {
          const list = obj.lists[key];
          const values = list.values;
          const selectors = key === `username` ? giveaway.winners : [giveaway];
          if (!Array.isArray(selectors)) {
            continue;
          }
          for (const selector of selectors) {
            const value = selector[key];
            if (!values[value]) {
              values[value] = {
                gameSteamId: giveaway.gameSteamId,
                gameType: giveaway.gameType,
                value: 0
              };
            }
            values[value].value += copies;
          }
        }
      }
    }
  }

  async function ugd_requestGiveaway(obj, details, response, responseHtml) {
    const msg = `Retrieving giveaway winners (${details.giveaway.gameName})...`;
    if (obj.popup) {
      obj.popup.setProgress(msg);
    } else {
      obj.mainPopup.progress.lastElementChild.textContent = msg;
    }

    if (responseHtml.getElementsByClassName(`table--summary`)[0]) {
      return true;
    }

    const elements = responseHtml.getElementsByClassName(`table__row-inner-wrap`);
    const n = elements.length;
    for (let i = 0; i < n; i++) {
      const element = elements[i];
      details.giveaway.winners.push({
        status: element.lastElementChild.textContent.trim(),
        username: element.firstElementChild.nextElementSibling.firstElementChild.textContent.trim()
      });
    }
    if (details.nextPage === 1) {
      details.url = `${response.finalUrl}/search?page=`;
    }
  }

  async function ugd_complete(obj, results) {
    let html = `
      <div class="esgst-ugd-lists esgst-text-center markdown">
    `;
    for (const key in obj.lists) {
      const list = obj.lists[key];
      html += `
        <div>
          <div class="esgst-bold">${list.name}</div>
          <ol>
      `;
      const values = list.values;
      for (const item of values) {
        html += `
            <li>
              ${item.name} - <span class="esgst-bold">${item.value}</span>
            </li>
        `;
      }
      html += `
          </ol>
        </div>
      `;
    }
    html += `
      </div>
    `;
    results.insertAdjacentHTML(`beforeEnd`, html);
    await endless_load(results);
  }

  // [NAMWC]

  _MODULES.push({
    description: `
      <ul>
        <li>Adds a button (<i class="fa fa-question-circle"></i>) to the "Gifts Won" row of a user's <a href="https://www.steamgifts.com/user/cg">profile</a> page that allows you to check if they have any not activated/multiple wins (using <a href="https://www.sgtools.info/">SGTools</a>).</li>
        <li>Adds a button (<i class="fa fa-trophy"></i> <i class="fa fa-question-circle"></i>) to the main page heading of any <a href="https://www.steamgifts.com/giveaway/aeqw7/dead-space/winners">winners</a> page that allows you to check all of the winners in the page at once. You cannot check more than that at once due to certain limitations when requesting the data to SGTools.</li>
        <li>Adds a button (<i class="fa fa-trophy"></i> <i class="fa fa-gear"></i>) to the page heading of this menu that allows you to view all of the users that have been checked.</li>
        <li>Results are cached for 1 week, so if you check the same user again within that timeframe, their status will not change.</li>
      </ul>
    `,
    features: {
      namwc_h: {
        description: `
          <ul>
            <li>Changes the color (to green if the user passed the check, red if they failed and grey if their profile is private) of a checked user's username (in any page).</li>
            <li>If you hover over the username, it shows how many not activated/multiple wins the user has and the date when they were checked for the last time.</li>
          </ul>
        `,
        features: {
          namwc_h_m: {
            description: `
              <ul>
                <li>Multiple wins are not the winner's fault sometimes. For example, if they tried to contact the giveaway creator to ask for a reroll and were unable to.</li>
                <li>With this option enabled, multiple wins are ignored when highlighting the user. So if the user has 0 not activated wins and 1 or more multiple wins, they will be considered as having passed the check.</li>
              </ul>
            `,
            name: `Ignore multiple wins.`,
            sg: true,
            st: true
          },
          namwc_h_f: {
            name: `Only highlight users who failed to pass the check.`,
            sg: true,
            st: true
          },
          namwc_h_i: {
            description: `
              <ul>
                <li>Adds an icon (<i class="fa fa-thumbs-up esgst-green"></i> if the user passed the check, <i class="fa fa-thumbs-down esgst-red"></i> if they failed and <i class="fa fa-warning esgst-grey"></i> if their profile is private) next to the user's username instead of coloring it.</li>
                <li>If you hover over the icon, it shows how many not activated/multiple wins the user has and the date when they were checked for the last time.</li>
              </ul>
            `,
            name: `Use icons instead of colors.`,
            sg: true,
            st: true
          },
        },
        name: `Highlight checked users.`,
        sg: true,
        st: true
      }
    },
    id: `namwc`,
    load: namwc,
    name: `Not Activated/Multiple Win Checker`,
    sg: true,
    type: `users`
  });

  function namwc() {
    esgst.profileFeatures.push(namwc_addUser);

    if (!esgst.winnersPath) return;

    namwc_setPopup({
      button: createHeadingButton({id: `namwc`, icons: [`fa-trophy`, `fa-question-circle`], title: `Check for not activated/multiple wins`})
    });
  }

  function namwc_addUser(profile) {
    namwc_setPopup({
      button: insertHtml(profile.wonRowLeft, `beforeEnd`, `
        <span class="esgst-namwc-button">
          <i class="fa fa-question-circle" title="${getFeatureTooltip(`namwc`, `Check for not activated/multiple wins`)}"></i>
        </span>
      `),
      user: {
        id: profile.id,
        steamId: profile.steamId,
        username: profile.username
      }
    });
  }

  function namwc_setPopup(obj) {
    obj.popup = new Popup(obj.isMenu ? `fa-cog` : `fa-question`, obj.isMenu ? `Manage Not Activated / Multiple Wins Checker caches:` : `Check for ${obj.user ? `${obj.user.username}'s ` : ``} not activated / multiple wins:`);
    if (!obj.isMenu) {
      insertHtml(obj.popup.scrollable, `beforeBegin`, `<div></div>`).appendChild(createOptions([{
        check: true,
        description: `Only check for not activated wins.`,
        exclusions: [`namwc_checkMultiple`],
        id: `namwc_checkNotActivated`,
        tooltip: `If enabled, multiple wins will not be checked (faster).`
      }, {
        check: true,
        description: `Only check for multiple wins.`,
        exclusions: [`namwc_checkNotActivated`],
        id: `namwc_checkMultiple`,
        tooltip: `If enabled, not activated wins will not be checked (faster).`
      }]));
      obj.popup.scrollable.insertAdjacentHTML(`beforeBegin`, `<div class="esgst-description">If a user is highlighted, that means that they have been either checked for the first time or updated.</div>`);
      obj.popup.description.insertBefore(new ButtonSet_v2({color1: `green`, color2: `grey`, icon1: `fa-question-circle`, icon2: `fa-times-circle`, title1: `Check`, title2: `Cancel`, callback1: namwc_start.bind(null, obj), callback2: namwc_stop.bind(null, obj)}).set, obj.popup.scrollable);
    }
    obj.popup.progress = insertHtml(obj.popup.scrollable, `beforeBegin`, `<div></div>`);
    obj.popup.overallProgress = insertHtml(obj.popup.scrollable, `beforeBegin`, `<div></div>`);
    obj.popup.results = insertHtml(obj.popup.scrollable, `beforeEnd`, `<div></div>`);
    createResults(obj.popup.results, obj.popup, [{
      Icon: `<i class="fa fa-check-circle esgst-positive"></i> `,
      Description: `Users with 0 not activated wins`,
      Key: `activated`
    }, {
      Icon: `<i class="fa fa-check-circle esgst-positive"></i> `,
      Description: `Users with 0 multiple wins`,
      Key: `notMultiple`
    }, {
      Icon: `<i class="fa fa-times-circle esgst-negative"></i> `,
      Description: `Users with not activated wins`,
      Key: `notActivated`
    }, {
      Icon: `<i class="fa fa-times-circle esgst-negative"></i> `,
      Description: `Users with multiple wins`,
      Key: `multiple`
    }, {
      Icon: `<i class="fa fa-question-circle"></i> `,
      Description: `Users who cannot be checked for not activated wins either because they have a private profile or SteamCommunity is down`,
      Key: `unknown`
    }]);
    obj.button.addEventListener(`click`, obj.popup.open.bind(obj.popup, obj.isMenu ? namwc_start.bind(null, obj) : null));
  }

  async function namwc_start(obj) {
    obj.isCanceled = false;
    obj.button.classList.add(`esgst-busy`);
    obj.popup.progress.innerHTML = obj.popup.overallProgress.innerHTML = ``;
    obj.popup.activated.classList.add(`esgst-hidden`);
    obj.popup.notMultiple.classList.add(`esgst-hidden`);
    obj.popup.notActivated.classList.add(`esgst-hidden`);
    obj.popup.multiple.classList.add(`esgst-hidden`);
    obj.popup.unknown.classList.add(`esgst-hidden`);
    obj.popup.activatedCount.textContent = obj.popup.notMultipleCount.textContent = obj.popup.notActivatedCount.textContent = obj.popup.multipleCount.textContent = obj.popup.unknownCount.textContent = `0`;
    obj.popup.activatedUsers.innerHTML = obj.popup.notMultipleUsers.textContent = obj.popup.notActivatedUsers.innerHTML = obj.popup.multipleUsers.innerHTML = obj.popup.unknownUsers.innerHTML = ``;

    // get users
    let users = [];
    if (obj.isMenu) {
      let savedUsers = JSON.parse(await getValue(`users`));
      for (let id in savedUsers.users) {
        let savedUser = savedUsers.users[id];
        if (!savedUser.namwc || !savedUser.namwc.results) continue;
        users.push(savedUser.username);
      }
    } else if (obj.user) {
      users.push(obj.user.username);
    } else {
      let elements = esgst.pageOuterWrap.querySelectorAll(`a[href*="/user/"]`);
      for (let element of elements) {
        let match = element.getAttribute(`href`).match(/\/user\/(.+)/);
        if (!match) continue;
        let username = match[1];
        if (users.indexOf(username) > -1 || username === esgst.username || username !== element.textContent || element.closest(`.markdown`)) continue;
        users.push(username);
        if (users.length > 25) break;
      }
    }

    if (users.length === 0) {
      obj.popup.setDone();
      return;
    }

    // check users
    users = sortArray(users);
    let steamIds = [];
    let userElements = {
      activated: {},
      notMultiple: {},
      notActivated: {},
      multiple: {},
      unknown: {}
    };
    for (let i = 0, n = users.length; !obj.isCanceled && i < n; i++) {
      obj.popup.progress.innerHTML = ``;
      obj.popup.overallProgress.textContent = `${i} of ${n} users checked...`;
      let user = obj.user || {username: users[i]};
      let savedUser = await getUser(null, user);
      user.values = {
        namwc: savedUser && savedUser.namwc
      };
      let isNew = false;
      if (!obj.isMenu) {
        let resultsBackup = user.values.namwc && user.values.namwc.results;
        if (!user.values.namwc) {
          user.values.namwc = {
            lastCheck: 0,
            results: {}
          };
        }
        if (Date.now() - user.values.namwc.lastCheck > 6.048 * 1e8) {
          if (esgst.namwc_checkNotActivated) {
            await namwc_checkNotActivated(obj, user);
          } else if (esgst.namwc_checkMultiple) {
            await namwc_checkMultiple(obj, user);
          } else {
            await namwc_checkNotActivated(obj, user);
            await namwc_checkMultiple(obj, user);
          }
        }
        if (resultsBackup) {
          for (let key in resultsBackup) {
            if (((Array.isArray(resultsBackup[key]) && resultsBackup[key].length) || (!Array.isArray(resultsBackup[key]) && resultsBackup[key])) === ((Array.isArray(user.values.namwc.results[key]) && user.values.namwc.results[key].length) || (!Array.isArray(user.values.namwc.results[key]) && user.values.namwc.results[key]))) continue;
            isNew = true;
            break;
          }
        } else {
          isNew = true;
        }
      }
      let elements = [];
      for (let key in user.values.namwc.results) {
        let value = (Array.isArray(user.values.namwc.results[key]) && user.values.namwc.results[key].length) || (!Array.isArray(user.values.namwc.results[key]) && user.values.namwc.results[key]);
        if (!value) continue;
        obj.popup[key].classList.remove(`esgst-hidden`);
        let count = obj.popup[`${key}Count`];
        count.textContent = parseInt(count.textContent) + 1;
        elements[key] = insertHtml(obj.popup[`${key}Users`], `beforeEnd`, `
          <a ${isNew ? `class="esgst-bold esgst-italic" ` : ``}href="http://www.sgtools.info/${key.match(/multiple/i) ? `multiple` : `nonactivated`}/${user.username}" target="_blank">${user.username}${key.match(/^(notActivated|multiple)$/) ? ` (${value})` : ``}</a>
        `);
      }
      if (!obj.isMenu) {
        await saveUser(null, null, user);
        steamIds.push(user.steamId);
        userElements[user.steamId] = elements;
      }
      obj.popup.overallProgress.textContent = `${i + 1} of ${n} users checked...`;
    }

    if (obj.isCanceled) {
      obj.popup.setDone();
      return;
    }

    if (!esgst.ust || obj.isMenu) {
      obj.button.classList.remove(`esgst-busy`);
      obj.popup.progress.innerHTML = ``;
      obj.popup.setDone();
      return;
    }

    // check for suspensions
    obj.popup.progress.textContent = `Checking suspensions...`;
    users = [];
    let savedUsers = JSON.parse(await getValue(`users`));
    let suspensions = JSON.parse((await request({method: `GET`, url: `https://script.google.com/macros/s/AKfycbwdKNormCJs-hEKV0GVwawgWj1a26oVtPylgmxOOvNk1Gf17A/exec?steamIds=${steamIds.join(`,`)}`})).responseText).suspensions;
    for (let steamId in suspensions) {
      let suspension = suspensions[steamId];
      let user = {steamId};
      user.values = {
        namwc: (await getUser(savedUsers, user)).namwc
      };
      user.values.namwc.suspension = suspension;
      users.push(user);
      if (Array.isArray(user.values.namwc.results.notActivated)) {
        let i, n;
        for (i = 0, n = user.values.namwc.results.notActivated.length; i < n && user.values.namwc.results.notActivated[i] <= suspension; i++);
        if (i > 0) {
          userElements[steamId].notActivated.insertAdjacentHTML(`beforeEnd`, ` <span title="${getFeatureTooltip(`ust`, `This user already served suspension for ${i} of their not activated wins (until ${getTimestamp(suspension, true, true)})`)}">[-${i}]</span>`);
        } else if (userElements[steamId].activated) {
          userElements[steamId].activated.insertAdjacentHTML(`beforeEnd`, ` <span title="${getFeatureTooltip(`ust`, `This user already served suspension for not activated wins until ${getTimestamp(suspension, true, true)}`)}">[x]</span>`);
        }
      }
      if (Array.isArray(user.values.namwc.results.multiple)) {
        let i, n;
        for (i = 0, n = user.values.namwc.results.multiple.length; i < n && user.values.namwc.results.multiple[i] <= suspension; i++);
        if (i > 0) {
          userElements[steamId].multiple.insertAdjacentHTML(`beforeEnd`, ` <span title="${getFeatureTooltip(`ust`, `This user already served suspension for ${i} of their multiple wins (until ${getTimestamp(suspension, true, true)})`)}">[-${i}]</span>`);
        } else if (userElements[steamId].notMultiple) {
          userElements[steamId].notMultiple.insertAdjacentHTML(`beforeEnd`, ` <span title="${getFeatureTooltip(`ust`, `This user already served suspension for multiple wins until ${getTimestamp(suspension, true, true)}`)}">[x]</span>`);
        }
      }
    }
    await saveUsers(users);
    obj.button.classList.remove(`esgst-busy`);
    obj.popup.progress.innerHTML = ``;
    obj.popup.setDone();
  }

  function namwc_stop(obj) {
    obj.button.classList.remove(`esgst-busy`);
    obj.popup.progress.innerHTML = ``;
    obj.isCanceled = true;
  }

  async function namwc_checkNotActivated(obj, user) {
    if (obj.isCanceled) return;

    if (obj.popup.progress) {
      obj.popup.progress.innerHTML = `
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <span>Retrieving ${user.username}'s not activated wins...</span>
      `;
    }
    let responseText = (await request({method: `GET`, queue: true, url: `http://www.sgtools.info/nonactivated/${user.username}`})).responseText;
    if (responseText.match(/has a private profile/)) {
      user.values.namwc.results.activated = 0;
      user.values.namwc.results.notActivated = [];
      user.values.namwc.results.unknown = 1;
    } else {
      user.values.namwc.results.notActivated = [];
      let elements = parseHtml(responseText).getElementsByClassName(`notActivatedGame`);
      let n = elements.length;
      for (let i = 0; i < n; ++i) {
        user.values.namwc.results.notActivated.push(new Date(elements[i].textContent.match(/\((\d{4}-\d{2}-\d{2}\s\d{2}:\d{2}:\d{2})\)/)[1]).getTime());
      }
      user.values.namwc.results.activated = n === 0 ? 1 : 0;
      user.values.namwc.results.unknown = 0;
    }
    user.values.namwc.lastCheck = Date.now();
  }

  async function namwc_checkMultiple(obj, user) {
    if (obj.isCanceled) return;

    if (obj.popup.progress) {
      obj.popup.progress.innerHTML = `
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <span>Retrieving ${user.username}'s multiple wins...</span>
      `;
    }
    user.values.namwc.results.multiple = [];
    let elements = parseHtml((await request({method: `GET`, queue: true, url: `http://www.sgtools.info/multiple/${user.username}`})).responseText).getElementsByClassName(`multiplewins`);
    let n = elements.length;
    for (let i = 0; i < n; ++i) {
      user.values.namwc.results.multiple.push(new Date(elements[i].textContent.match(/and\s(\d{4}-\d{2}-\d{2}\s\d{2}:\d{2}:\d{2})\)/)[1]).getTime());
    }
    user.values.namwc.results.notMultiple = n === 0 ? 1 : 0;
    user.values.namwc.lastCheck = Date.now();
  }
  
  // [NRF]

  _MODULES.push({
    description: `
      <ul>
        <li>Adds a button (<i class="fa fa-times-circle"></i>) to the "Gifts Sent" row of a user's <a href="https://www.steamgifts.com/user/cg">profile</a> page that allows you to find all of their created giveaways that were marked as not received.</li>
        <li>Giveaways for more than 3 copies that were marked as not received can only be found if the winner(s) that marked it as not received is(are) visible in the creator's profile page or if you can access the giveaway and the option to search inside of giveaways is enabled. If they are not found, a list with all of the creator's giveaways for more than 3 copies will be shown.</li>
        <li>Results are cached for 1 week, so if you check the same user again within that timeframe, their status will not change.</li>
      </ul>
    `,
    id: `nrf`,
    load: nrf,
    name: `Not Received Finder`,
    sg: true,
    type: `users`
  });

  function nrf() {
    esgst.profileFeatures.push(nrf_add);
  }

  function nrf_add(profile) {
    let NRF;
    NRF = {
      N: profile.notSent
    };
    if (NRF.N > 0) {
      NRF.I = 0;
      NRF.Multiple = [];
      profile.sentRowLeft.insertAdjacentHTML(`beforeEnd`, `
        <span class="esgst-nrf-button">
          <i class="fa fa-times-circle" title="${getFeatureTooltip(`nrf`, `Find not received giveaways`)}"></i>
        </span>
      `);
      nrf_setPopup(NRF, profile.sentRowLeft.lastElementChild, profile);
    }
  }

  function nrf_setPopup(NRF, NRFButton, profile) {
    let popup;
    popup = new Popup(`fa-times`, `Find ${profile.username}'s not received giveaways:`);
    popup.Options = insertHtml(popup.description, `beforeEnd`, `<div></div>`);
    popup.Options.appendChild(createOptions([{
      check: true,
      description: `Also search inside giveaways with multiple copies.`,
      id: `nrf_searchMultiple`,
      tooltip: `If disabled, only giveaways with visible not received copies will be found (faster).`
    }]));
    popup.Options.insertAdjacentHTML(`afterEnd`, `<div class="esgst-description">If you're blacklisted / not whitelisted / not a member of the same Steam groups, not all giveaways will be found.`);
    popup.description.appendChild(new ButtonSet(`green`, `grey`, `fa-search`, `fa-times-circle`, `Find`, `Cancel`, Callback => {
      NRFButton.classList.add(`esgst-busy`);
      nrf_setSearch(NRF, profile, () => {
        NRF.Progress.innerHTML = ``;
        NRFButton.classList.remove(`esgst-busy`);
        Callback();
      });
    }, () => {
      clearInterval(NRF.Request);
      clearInterval(NRF.Save);
      NRF.Canceled = true;
      setTimeout(() => {
        NRF.Progress.innerHTML = ``;
      }, 500);
      NRFButton.classList.remove(`esgst-busy`);
    }).set);
    NRF.Progress = insertHtml(popup.description, `beforeEnd`, `<div></div>`);
    NRF.OverallProgress = insertHtml(popup.description, `beforeEnd`, `<div></div>`);
    NRF.Results = insertHtml(popup.scrollable, `beforeEnd`, `<div></div>`);
    NRF.popup = popup;
    NRFButton.addEventListener(`click`, () => {
      popup.open();
    });
  }

  async function nrf_setSearch(NRF, profile, Callback) {
    NRF.Progress.innerHTML = NRF.OverallProgress.innerHTML = NRF.Results.innerHTML = ``;
    NRF.Canceled = false;
    let user = {
      steamId: profile.steamId,
      id: profile.id,
      username: profile.username
    };
    let nrf;
    const savedUser = await getUser(null, user);
    if (savedUser) {
      nrf = savedUser.nrf;
    }
    if (!nrf) {
      nrf = {
        lastCheck: 0,
        found: 0,
        total: 0,
        results: ``
      };
    }
    if ((Date.now() - nrf.lastCheck) > 604800000) {
      nrf_searchUser(NRF, user.username, 1, 0, `/user/${user.username}/search?page=`, async () => {
        nrf.lastCheck = Date.now();
        nrf.found = NRF.I;
        nrf.total = NRF.N;
        nrf.results = NRF.Results.innerHTML;
        user.values = {
          nrf: nrf
        };
        await saveUser(null, null, user);
        await endless_load(NRF.Results);
        NRF.Progress.innerHTML = ``;
        Callback();
      });
    } else {
      NRF.Results.innerHTML = nrf.results;
      NRF.OverallProgress.innerHTML = `${nrf.found} of ${nrf.total} not received giveaways found...`;
      await endless_load(NRF.Results);
      Callback();
    }
  }

  async function nrf_searchUser(NRF, username, NextPage, CurrentPage, URL, Callback, Context) {
    let Matches, I, N, Match, Pagination;
    if (NRF.Canceled) return;
    if (Context) {
      if (NextPage === 2) {
        NRF.lastPage = lpl_getLastPage(Context, false, false, true);
        NRF.lastPage = NRF.lastPage === 999999999 ? `` : ` of ${NRF.lastPage}`;
      }
      NRF.Progress.innerHTML = `
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <span>Searching ${username}'s giveaways (page ${NextPage - 1}${NRF.lastPage})...</span>
      `;
      Matches = Context.querySelectorAll(`div.giveaway__column--negative`);
      for (I = 0, N = Matches.length; I < N; ++I) {
        NRF.I += Matches[I].querySelectorAll(`a[href*="/user/"]`).length;
        NRF.Results.appendChild(Matches[I].closest(`.giveaway__row-outer-wrap`).cloneNode(true));
      }
      NRF.OverallProgress.innerHTML = `${NRF.I} of ${NRF.N} not received giveaways found...`;
      if (NRF.I < NRF.N) {
        if (esgst.nrf_searchMultiple) {
          Matches = Context.getElementsByClassName(`giveaway__heading__thin`);
          for (I = 0, N = Matches.length; I < N; ++I) {
            Match = Matches[I].textContent.match(/\((.+) Copies\)/);
            if (Match && (parseInt(Match[1]) > 3)) {
              NRF.Multiple.push(Matches[I].closest(`.giveaway__row-outer-wrap`).cloneNode(true));
            }
          }
        }
        Pagination = Context.getElementsByClassName(`pagination__navigation`)[0];
        if (Pagination && !Pagination.lastElementChild.classList.contains(`is-selected`)) {
          setTimeout(() => nrf_searchUser(NRF, username, NextPage, CurrentPage, URL, Callback), 0);
        } else if (esgst.nrf_searchMultiple && NRF.Multiple.length) {
          setTimeout(() => nrf_searchMultiple(NRF, 0, NRF.Multiple.length, Callback), 0);
        } else {
          Callback();
        }
      } else {
        Callback();
      }
    } else if (!NRF.Canceled) {
      setTimeout(async () => nrf_searchUser(NRF, username, ++NextPage, CurrentPage, URL, Callback, parseHtml((await request({method: `GET`, queue: true, url: URL + NextPage})).responseText)), 0);
    }
  }

  function nrf_searchMultiple(NRF, I, N, Callback) {
    if (!NRF.Canceled) {
      NRF.Progress.innerHTML = `
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <span>Searching inside giveaways with multiple copies (${I + 1} of ${N})...</span>
      `;
      if (I < N) {
        nrf_searchGiveaway(NRF, `${NRF.Multiple[I].getElementsByClassName(`giveaway__heading__name`)[0].getAttribute(`href`)}/winners/search?page=`, 1, Found => {
          if (Found) {
            NRF.Results.appendChild(NRF.Multiple[I].cloneNode(true));
          }
          if (NRF.I < NRF.N) {
            setTimeout(() => nrf_searchMultiple(NRF, ++I, N, Callback), 0);
          } else {
            Callback();
          }
        });
      } else {
        Callback();
      }
    }
  }

  async function nrf_searchGiveaway(NRF, URL, NextPage, Callback) {
    if (NRF.Canceled) return;
    let ResponseHTML, Matches, I, N, Found, Pagination;
    ResponseHTML = parseHtml((await request({method: `GET`, queue: true, url: URL + NextPage})).responseText);
    Matches = ResponseHTML.getElementsByClassName(`table__column--width-small`);
    for (I = 0, N = Matches.length; I < N; ++I) {
      if (Matches[I].textContent.match(/Not Received/)) {
        Found = true;
        ++NRF.I;
        NRF.OverallProgress.innerHTML = `${NRF.I} of ${NRF.N} not received giveaways found...`;
        if (NRF.I >= NRF.N) {
          break;
        }
      }
    }
    Pagination = ResponseHTML.getElementsByClassName(`pagination__navigation`)[0];
    if ((NRF.I < NRF.N) && Pagination && !Pagination.lastElementChild.classList.contains(`is-selected`)) {
      setTimeout(() => nrf_searchGiveaway(NRF, URL, ++NextPage, Callback), 0);
    } else {
      Callback(Found);
    }
  }
  
  // [SWR]

  _MODULES.push({
    description: `
      <ul>
        <li>Adds a "Ratio" row containing a user's sent/won ratio (which is their number of gifts sent divided by their number of gifts won) below the "Gifts Sent" row of their <a href="https://www.steamgifts.com/user/cg">profile</a> page.</li>
      </ul>
    `,
    id: `swr`,
    load: swr,
    name: `Sent/Won Ratio`,
    sg: true,
    type: `users`
  });

  function swr() {
    esgst.profileFeatures.push(swr_add);
  }

  function swr_add(profile) {
    let ratio, fullRatio, reducedRatio, zeroRatio, cvRatio, realCVRatio;
    ratio = profile.wonCount > 0 ? Math.round(profile.sentCount / profile.wonCount * 100) / 100 : 0;
    fullRatio = profile.wonFull > 0 ? Math.round(profile.sentFull / profile.wonFull * 100) / 100 : 0;
    reducedRatio = profile.wonReduced > 0 ? Math.round(profile.sentReduced / profile.wonReduced * 100) / 100 : 0;
    zeroRatio = profile.wonZero > 0 ? Math.round(profile.sentZero / profile.wonZero * 100) / 100 : 0;
    cvRatio = profile.wonCV > 0 ? Math.round(profile.sentCV / profile.wonCV * 100) / 100 : 0;
    realCVRatio = profile.realWonCV > 0 ? Math.round(profile.realSentCV / profile.realWonCV * 100) / 100 : 0;
    let ratioTooltip = {
      rows: [
        {
          columns: [
            {
              name: `Ratio`
            },
            {
              color: `#8f96a6`,
              name: ratio
            }
          ],
          icon: [
            {
              class: `fa-pie-chart`,
              color: `#77899a`
            }
          ]
        },
        {
          columns: [
            {
              color: `#8f96a6`,
              name: `Full Value`
            },
            {
              color: `#8f96a6`,
              name: fullRatio
            }
          ],
          indent: `80px`
        },
        {
          columns: [
            {
              color: `#8f96a6`,
              name: `Reduced Value`
            },
            {
              color: `#8f96a6`,
              name: reducedRatio
            }
          ],
          indent: `80px`
        },
        {
          columns: [
            {
              color: `#8f96a6`,
              name: `No Value`
            },
            {
              color: `#8f96a6`,
              name: zeroRatio
            }
          ],
          indent: `80px;`
        }
      ]
    };
    let cvTooltip = {
      rows: [
        {
          columns: [
            {
              name: `Real Value`
            },
            {
              color: `#8f96a6`,
              name: `$${realCVRatio}`
            }
          ],
          icon : [
            {
              class: `fa-dollar`,
              color: `#84cfda`
            }
          ]
        }
      ]
    };
    profile.sentRow.insertAdjacentHTML(`afterEnd`, `
      <div class="esgst-swr-ratio featured__table__row" title="${getFeatureTooltip(`swr`)}">
        <div class="featured__table__row__left">Ratio</div>
        <div class="featured__table__row__right">
          <span data-ui-tooltip='${JSON.stringify(ratioTooltip)}'>${ratio}</span>
          (<span data-ui-tooltip='${JSON.stringify(cvTooltip)}'>$${esgst.vrcv ? `${cvRatio} / $${realCVRatio.toLocaleString(`en`)}` : cvRatio}</span>)
        </div>
      </div>
    `);
  }

  // [VRCV]

  _MODULES.push({
    description: `
      <ul>
        <li>Displays the real sent/won CV next to the raw value in a user's <a href="https://www.steamgifts.com/user/cg">profile</a> page.</li>
        <li>This also extends to [id=swr], if you have that feature enabled.</li>
        <li>With this feature disabled, you can still view the real CV, as provided by SteamGifts, by hovering over the raw value.</li>
      </ul>
    `,
    id: `vrcv`,
    load: vrcv,
    name: `Visible Real CV`,
    sg: true,
    type: `users`
  });

  function vrcv() {
    esgst.profileFeatures.push(vrcv_add);
  }

  function vrcv_add(profile) {
    profile.sentCvContainer.insertAdjacentText(`beforeEnd`, ` / $${profile.realSentCV.toLocaleString(`en`)}`);
    profile.wonCvContainer.insertAdjacentText(`beforeEnd`, ` / $${profile.realWonCV.toLocaleString(`en`)}`);
  }

  // [LUC]
  
  _MODULES.push({
    description: `
      <ul>
        <li>Adds how much real CV a user needs to level up (calculated using the information from <a href="https://www.steamgifts.com/discussion/XaCbA/">this discussion</a>) to the "Contributor Level" row of their <a href="https://www.steamgifts.com/user/nobody">profile</a> page.</li>
      </ul>
    `,
    id: `luc`,
    load: luc,
    name: `Level Up Calculator`,
    sg: true,
    type: `users`
  });

  function luc() {
    esgst.profileFeatures.push(luc_calculate);
  }

  function luc_calculate(profile) {
    let base, lower, upper, value, values;
    base = parseInt(profile.level);
    if (base < 10) {
      values = [0, 0.01, 25.01, 50.01, 100.01, 250.01, 500.01, 1000.01, 2000.01, 3000.01, 5000.01];
      lower = values[base];
      upper = values[base + 1];
      value = Math.round((upper - (lower + ((upper - lower) * (profile.level - base)))) * 100) / 100;
      profile.levelRowRight.insertAdjacentHTML(`beforeEnd`, `<span class="esgst-luc-value" title="${getFeatureTooltip(`luc`)}">(~$${value} real CV to level ${base + 1})</span>`);
    }
  }
  
  // [SGPB]

  _MODULES.push({
    description: `
      <ul>
        <li>Adds a button next to the "Visit Steam Profile" button of a user's <a href="https://www.steamtrades.com/user/76561198020696458">profile</a> page that allows you to go to their SteamGifts profile page.</li>
      </ul>
    `,
    id: `sgpb`,
    load: sgpb,
    name: `SteamGifts Profile Button`,
    st: true,
    type: `users`
  });

  function sgpb() {
    if (!esgst.userPath) return;
    esgst.profileFeatures.push(sgpb_add);
  }

  function sgpb_add(profile) {
    let button;
    button = insertHtml(profile.steamButtonContainer, `beforeEnd`, `
      <div class="esgst-sgpb-container" title="${getFeatureTooltip(`sgpb`)}">
        <a class="esgst-sgpb-button" href="https://www.steamgifts.com/go/user/${profile.steamId}" rel="nofollow" target="_blank">
          <i class="fa">
            <img src="${esgst.sgIcon}">
          </i>
          <span>Visit SteamGifts Profile</span>
        </a>
      </div>
    `);
    button.insertBefore(profile.steamButton, button.firstElementChild);
  }
  
  // [STPB]

  _MODULES.push({
    description: `
      <ul>
        <li>Adds a button next to the "Visit Steam Profile" button of a user's <a href="https://www.steamgifts.com/user/cg">profile</a> page that allows you to go to their SteamTrades profile page.</li>
      </ul>
    `,
    id: `stpb`,
    load: stpb,
    name: `SteamTrades Profile Button`,
    sg: true,
    type: `users`
  });

  function stpb() {
    esgst.profileFeatures.push(stpb_add);
  }

  function stpb_add(profile) {
    let button, tooltip;
    button = insertHtml(profile.steamButtonContainer.firstElementChild, `beforeEnd`, `
      <a class="esgst-stpb-button" href="https://www.steamtrades.com/user/${profile.steamId}" rel="nofollow" target="_blank" title="${getFeatureTooltip(`stpb`)}">
        <i class="fa fa-fw">
          <img src="${esgst.stIcon}">
        </i>
      </a>
    `);
    tooltip = profile.steamButtonContainer.getElementsByClassName(`js-tooltip`)[0];
    if (tooltip) {
      button.addEventListener(`mouseenter`, stpb_show.bind(null, button, tooltip));
      button.addEventListener(`mouseleave`, setSiblingsOpacity.bind(null, button, `1`));
    }
  }

  function stpb_show(button, tooltip) {
    tooltip.textContent = `Visit SteamTrades Profile`;
    setSiblingsOpacity(button, `0.2`);
  }

  // [PL]

  _MODULES.push({
    description: `
      <ul>
        <li>Allows you to add links to your <a href="https://www.steamgifts.com/account/manage/whitelist">whitelist</a>/<a href="https://www.steamgifts.com/account/manage/blacklist">blacklist</a>/<a href="https://www.steamgifts.com/account/steam/games">games</a>/<a href="https://www.steamgifts.com/account/steam/games">groups</a>/<a href="https://www.steamgifts.com/account/steam/wishlist">wishlist</a> pages to the sidebar of your <a href="https://www.steamgifts.com/user/your-username">profile</a> page.</li>
        <li>The count for each link might be off if you do not have your whitelist/blacklist/owned games/groups/wishlisted games synced through ESGST (first button in the page heading of this menu). The count for games might be always off, since the method ESGST uses to sync your owned games includes DLCs.</li>
      </ul>
    `,
    features: {
      pl_w: {
        name: `Show whitelist link.`,
        sg: true
      },
      pl_b: {
        name: `Show blacklist link.`,
        sg: true
      },
      pl_g: {
        name: `Show games link.`,
        sg: true
      },
      pl_gs: {
        name: `Show groups link.`,
        sg: true
      },
      pl_wl: {
        name: `Show wishlist link.`,
        sg: true
      }
    },
    id: `pl`,
    load: pl,
    name: `Profile Links`,
    sg: true,
    type: `users`
  });

  function pl() {
    if (!esgst.userPath) return;
    esgst.profileFeatures.push(pl_add);
  }

  function pl_add(profile) {
    if (profile.username !== esgst.username) return;
    let enabled, id, itemsHtml, game, user,
      html = ``,
      sections = [
        {
          items: [
            {
              count: 0,
              id: `pl_w`,
              name: `Whitelist`,
              url: `/account/manage/whitelist`
            },
            {
              count: 0,
              id: `pl_b`,
              name: `Blacklist`,
              url: `/account/manage/blacklist`
            }
          ],
          name: `Manage`
        },
        {
          items: [
            {
              count: 0,
              id: `pl_g`,
              name: `Games`,
              url: `/account/steam/games`
            },
            {
              count: 0,
              id: `pl_gs`,
              name: `Groups`,
              url: `/account/steam/groups`
            },
            {
              count: 0,
              id: `pl_wl`,
              name: `Wishlist`,
              url: `/account/steam/wishlist`
            }
          ],
          name: `Steam`
        }
      ];
    for (id in esgst.users.users) {
      user = esgst.users.users[id];
      if (user.whitelisted) {
        sections[0].items[0].count += 1;
      } else if (user.blacklisted) {
        sections[0].items[1].count += 1;
      }
    }
    for (id in esgst.games.apps) {
      game = esgst.games.apps[id];
      if (game.owned) {
        sections[1].items[0].count += 1;
      } else if (game.wishlisted) {
        sections[1].items[2].count += 1;
      }
    }
    esgst.groups.forEach(group => {
      if (group.member) {
        sections[1].items[1].count += 1
      }
    });
    sections.forEach(section => {
      enabled = false;
      itemsHtml = ``;
      section.items.forEach(item => {
        if (!esgst[item.id]) return;
        itemsHtml += `
          <li class="sidebar__navigation__item">
            <a class="sidebar__navigation__item__link" href="${item.url}">
              <div class="sidebar__navigation__item__name">${item.name}</div>
              <div class="sidebar__navigation__item__underline"></div>
              <div class="sidebar__navigation__item__count">${item.count}</div>
            </a>
          </li>
        `;
        enabled = true;
      });
      if (!enabled) return;
      html += `
        <h3 class="sidebar__heading">${section.name}</h3>
        <ul class="sidebar__navigation" title="${getFeatureTooltip(`pl`)}">${itemsHtml}</ul>
      `;
    });
    esgst.sidebar.getElementsByClassName(`sidebar__navigation`)[0].insertAdjacentHTML(`afterEnd`, html);
  }

  _MODULES.push({
    endless: true,
    id: `profile`,
    load: profile
  });
  
   async function profile() {
    if (!esgst.userPath) return;
    await profile_load(document);
  }

  async function profile_load(context) {
    let element, elements, i, input, key, match, profile, rows;
    profile = {};
    if (esgst.sg) {
      profile.heading = context.getElementsByClassName(`featured__heading`)[0];
      input = context.querySelector(`[name="child_user_id"]`);
      if (input) {
        profile.id = input.value;
      } else {
        profile.id = ``;
      }
      profile.username = profile.heading.textContent.replace(/\s[\s\S]*/, ``);
      profile.steamButtonContainer = context.getElementsByClassName(`sidebar__shortcut-outer-wrap`)[0];
      profile.steamButton = profile.steamButtonContainer.querySelector(`[href*="/profiles/"]`);
      profile.steamId = profile.steamButton.getAttribute(`href`).match(/\d+/)[0];
      profile.name = profile.username;
    } else {
      profile.heading = esgst.mainPageHeading;
      profile.id = ``;
      profile.username = ``;
      profile.steamButtonContainer = context.getElementsByClassName(`profile_links`)[0];
      profile.steamButton = profile.steamButtonContainer.querySelector(`[href*="/profiles/"]`);
      profile.steamId = profile.steamButton.getAttribute(`href`).match(/\d+/)[0];
      profile.name = profile.steamId;
    }
    elements = context.getElementsByClassName(`featured__table__row__left`);
    for (i = elements.length - 1; i >= 0; --i) {
      element = elements[i];
      match = element.textContent.match(/(Comments|Gifts (Won|Sent)|Contributor Level)/);
      if (match) {
        key = match[2];
        if (key) {
          if (key === `Won`) {
            profile.wonRow = element.parentElement;
            profile.wonRowLeft = element;
            profile.wonRowRight = element.nextElementSibling;
            rows = JSON.parse(profile.wonRowRight.firstElementChild.firstElementChild.getAttribute(`data-ui-tooltip`)).rows;
            profile.wonCount = parseInt(rows[0].columns[1].name.replace(/,/g, ``));
            profile.wonFull = parseInt(rows[1].columns[1].name.replace(/,/g, ``));
            profile.wonReduced = parseInt(rows[2].columns[1].name.replace(/,/g, ``));
            profile.wonZero = parseInt(rows[3].columns[1].name.replace(/,/g, ``));
            profile.wonCvContainer = profile.wonRowRight.firstElementChild.lastElementChild;
            rows = JSON.parse(profile.wonCvContainer.getAttribute(`data-ui-tooltip`)).rows;
            profile.wonCV = parseFloat(profile.wonCvContainer.textContent.replace(/\$|,/g, ``));
            profile.realWonCV = parseFloat(rows[0].columns[1].name.replace(/\$|,/g, ``));
          } else {
            profile.sentRow = element.parentElement;
            profile.sentRowLeft = element;
            profile.sentRowRight = element.nextElementSibling;
            rows = JSON.parse(profile.sentRowRight.firstElementChild.firstElementChild.getAttribute(`data-ui-tooltip`)).rows;
            profile.sentCount = parseInt(rows[0].columns[1].name.replace(/,/g, ``));
            profile.sentFull = parseInt(rows[1].columns[1].name.replace(/,/g, ``));
            profile.sentReduced = parseInt(rows[2].columns[1].name.replace(/,/g, ``));
            profile.sentZero = parseInt(rows[3].columns[1].name.replace(/,/g, ``));
            profile.notSent = parseInt(rows[5].columns[1].name.replace(/,/g, ``));
            profile.sentCvContainer = profile.sentRowRight.firstElementChild.lastElementChild;
            rows = JSON.parse(profile.sentCvContainer.getAttribute(`data-ui-tooltip`)).rows;
            profile.sentCV = parseFloat(profile.sentCvContainer.textContent.replace(/\$|,/g, ``));
            profile.realSentCV = parseFloat(rows[0].columns[1].name.replace(/\$|,/g, ``));
          }
        } else if (match[1] === `Comments`) {
          profile.commentsRow = element.parentElement;
        } else {
          profile.levelRow = element.parentElement;
          profile.levelRowLeft = element;
          profile.levelRowRight = element.nextElementSibling;
          rows = JSON.parse(profile.levelRowRight.firstElementChild.getAttribute(`data-ui-tooltip`)).rows;
          profile.level = parseFloat(rows[0].columns[1].name);
        }
      }
    }
    profile.whitelistButton = profile.steamButtonContainer.getElementsByClassName(`sidebar__shortcut__whitelist`)[0];
    profile.blacklistButton = profile.steamButtonContainer.getElementsByClassName(`sidebar__shortcut__blacklist`)[0];
    if (profile.whitelistButton) {
      if (esgst.updateWhitelistBlacklist) {
        profile.whitelistButton.addEventListener(`click`, updateWhitelistBlacklist.bind(null, `whitelisted`, profile));
      }
    }
    if (profile.blacklistButton) {
      if (esgst.updateWhitelistBlacklist) {
        profile.blacklistButton.addEventListener(`click`, updateWhitelistBlacklist.bind(null, `blacklisted`, profile));
      }
    }
    let savedUser = esgst.users.users[profile.steamId];
    if (savedUser) {
      const user = {
        steamId: profile.steamId,
        username: profile.username,
        values: {}
      };
      if (checkUsernameChange(esgst.users, user)) {
        await saveUser(null, esgst.users, user);
        savedUser = esgst.users.users[profile.steamId];
      }
    }
    esgst.profileFeatures.forEach(feature => feature(profile, savedUser));
  }

  _MODULES.push({
    endless: true,
    id: `endlessLoad`,
    load: endlessLoad
  });

  async function endlessLoad() {    
    if (!esgst.menuPath) {
      await endless_load(document, true);
    }
  }
  
  // [QIV]

  _MODULES.push({
    description: `
      <ul>
        <li>If you hover over the inbox icon (<i class="fa fa-envelope"></i>) at the header, it shows a popout with your messages so that you do not need to access your inbox page to read them.</li>
        <li>You can also mark the messages as read from the popout and reply to them if [id=rfi] is enabled.</li>
      </ul>
    `,
    features: {
      qiv_p: {
        description: `
          <ul>
            <li>Preloads the first page so that you do not have to wait for it to load after hovering over the inbox icon (this can slow down the page load though).</li>
          </ul>
        `,
        name: `Preload the first page.`,
        sg: true,
        st: true
      }
    },
    id: `qiv`,
    load: qiv.bind(null, true),
    name: `Quick Inbox View`,
    sg: true,
    st: true,
    type: `general`
  });

  function qiv(first) {
    if (!esgst.inboxButton) return;

    if (typeof esgst.qiv !== `object`) {
      esgst.qiv = {
        nextPage: 1
      };
    }

    if (first && esgst.qiv_p) {
      esgst.qiv.popout = new Popout(`esgst-qiv-popout`, null, 1000);
      esgst.qiv.popout.onClose = qiv_removeNew;
      if (esgst.messageCount > 0) {
        qiv_addMarkReadButton();
      }
      esgst.qiv.comments = insertHtml(esgst.qiv.popout.popout, `beforeEnd`, `<div class="esgst-qiv-comments"></div>`);
      esgst.qiv.comments.addEventListener(`scroll`, qiv_scroll.bind(null, false, false));
      qiv_scroll(true);
    }
    esgst.inboxButton.addEventListener(`mouseenter`, qiv_openPopout);
    esgst.inboxButton.addEventListener(`mouseleave`, event => {
      if (esgst.qiv.timeout) {
        clearTimeout(esgst.qiv.timeout);
        esgst.qiv.timeout = null;
      }
      esgst.qiv.exitTimeout = setTimeout(() => {
        if (esgst.qiv.popout && !esgst.qiv.popout.popout.contains(event.relatedTarget)) {
          esgst.qiv.popout.close();
        }
      }, 1000);
    });
  }

  function qiv_openPopout() {
    esgst.qiv.timeout = setTimeout(() => {
      if (esgst.qiv.popout) {
        esgst.qiv.popout.open(esgst.inboxButton);
      } else {
        esgst.qiv.popout = new Popout(`esgst-qiv-popout`, null, 1000);
        esgst.qiv.popout.onClose = qiv_removeNew;
        if (esgst.messageCount > 0) {
          qiv_addMarkReadButton();
        }
        esgst.qiv.comments = insertHtml(esgst.qiv.popout.popout, `beforeEnd`, `<div class="esgst-qiv-comments"></div>`);
        esgst.qiv.popout.open(esgst.inboxButton);
        esgst.qiv.comments.addEventListener(`scroll`, qiv_scroll.bind(null, false, false));
        qiv_scroll(true);
      }
      esgst.qiv.popout.popout.onmouseenter = () => {
        if (esgst.qiv.exitTimeout) {
          clearTimeout(esgst.qiv.exitTimeout);
          esgst.qiv.exitTimeout = null;
        }
      };
    }, 1000);
  }

  function qiv_removeNew() {
    const elements = esgst.qiv.popout.popout.getElementsByClassName(`esgst-qiv-new`);
    for (let i = elements.length - 1; i > -1; i--) {
      elements[i].remove();
    }
  }

  async function qiv_scroll(first, preload) {
    if ((first || preload || esgst.qiv.comments.scrollTop + esgst.qiv.comments.offsetHeight >= esgst.qiv.comments.scrollHeight) && !esgst.qiv.busy) {
      esgst.qiv.busy = true;
      const firstPage = esgst.qiv.comments.firstElementChild;
      let doContinue = false;
      do {
        const loading = insertHtml(
          esgst.qiv.popout.popout,
          first || preload ? `afterBegin` : `beforeEnd`, `
          <span><i class="fa fa-circle-o-notch fa-spin"></i> Loading...</span>
        `);
        esgst.qiv.popout.reposition(esgst.inboxButton);
        const context = parseHtml((await request({
          method: `GET`,
          url: `/messages/search?page=${esgst.qiv.nextPage}`
        })).responseText).querySelector(`.page__heading, .page_heading`).nextElementSibling;
        loading.remove();

        if (preload) {
          const currentId = esgst.qiv.comments.querySelector(`[href*="/go/comment/"]`)
                .getAttribute(`href`).match(/\/go\/comment\/(.+)/)[1],
              comments = context.querySelectorAll(`.comment, .comment_outer`);
          let i = comments.length - 1;
          while (i > -1 && comments[i].querySelector(`[href*="/go/comment/"]`).getAttribute(`href`).match(/\/go\/comment\/(.+)/)[1] !== currentId) i--;
          if (i > -1) {
            doContinue = false;
            i--;
            for (let j = comments.length - 1; j > i; j--) {
              const container = comments[j].parentElement;
              comments[j].remove();
              if (!container.children.length) {
                container.previousElementSibling.remove();
                container.remove();
              }
            }
          } else {
            doContinue = true;
          }
          if (context.children.length) {
            for (const element of comments) {
              element.insertAdjacentHTML(`afterBegin`, `
                <div class="esgst-qiv-new esgst-warning">[NEW]</div>
              `);
            }
            esgst.qiv.comments.insertBefore(context, firstPage);
          }
        } else {
          const comments = context.querySelectorAll(`.comment, .comment_outer`);
          let i = comments.length - 1;
          while (i > -1 && !esgst.qiv.comments.querySelector(`[href*="/go/comment/${comments[i].querySelector(`[href*="/go/comment/"]`).getAttribute(`href`).match(/\/go\/comment\/(.+)/)[1]}"]`)) i--;
          if (i > -1) {
            while (i > -1) {
              const container = comments[i].parentElements;
              comments[i].remove();
              if (!container.children.length) {
                container.previousElementSibling.remove();
                container.remove();
              }
              i--;
            }
            if (context.children.length) {
              doContinue = false;
            } else {
              doContinue = true;
            }
          } else {
            doContinue = false;
          }
          if (context.children.length) {
            esgst.qiv.comments.appendChild(context);
          }
        }
        if (context.children.length) {
          context.setAttribute(`data-esgst-qiv`, true);
          await endless_load(context);
        }
        if (esgst.qiv.popout.isOpen) {
          esgst.qiv.popout.reposition(esgst.inboxButton);
        }
        esgst.qiv.nextPage += 1;
      } while (doContinue);
      esgst.qiv.busy = false;
    }
  }

  function qiv_addMarkReadButton() {
    let key, url;
    if (esgst.qiv.markReadButton) return;
    if (esgst.sg) {
      esgst.qiv.markReadButton = insertHtml(esgst.qiv.popout.popout, `afterBegin`, `
        <div class="sidebar__action-button">
          <i class="fa fa-check-circle"></i> Mark as Read
        </div>
      `);
      key = `read_messages`;
      url = `/messages`;
    } else {
      esgst.qiv.markReadButton = insertHtml(esgst.qiv.popout.popout, `afterBegin`, `
        <a class="page_heading_btn green">
          <i class="fa fa-check-square-o"></i>
          <span>Mark as Read</span>
        </a>
      `);
      key = `mark_as_read`;
      url = `/ajax.php`;
    }
    esgst.qiv.markReadButton.addEventListener(`click`, async () => {
      await request({data: `xsrf_token=${esgst.xsrfToken}&do=${key}`, method: `POST`, url});
      esgst.qiv.markReadButton.remove();
      esgst.qiv.markReadButton = null;
      let elements = esgst.qiv.comments.querySelectorAll(`.comment__envelope`);
      for (let i = elements.length - 1; i > -1; i--) {
        elements[i].remove();
      }
      esgst.inboxButton.classList.remove(`nav__button-container--active`);
      esgst.messageCountContainer.remove();
      esgst.messageCount = 0;
      if (esgst.hr) {
        hr_notifyChange(esgst.hr);
      }
    });
  }

  // [ES]

  _MODULES.push({
    description: `
      <ul>
        <li>Loads the next page when you scroll down to the end of any page, allowing you to endlessly scroll through pages.</li>
        <li>Adds multiple buttons to the main page heading of the page:</li>
        <ul>
          <li><i class="fa fa-play"></i> if the endless scrolling is paused and <i class="fa fa-pause"></i> if it is not, which allows you to pause/resume the endless scrolling.</li>
          <li><i class="fa fa-step-forward"></i>, which allows you to load the next page without having to scroll down.</li>
          <li><i class="fa fa-fast-forward"></i>, which allows you continously load the next pages until either the last page is reached or you pause the endless scrolling.</li>
          <li><i class="fa fa-refresh"></i> <i class="fa fa-map-marker"></i>, which allows you to refresh the page currently visible in the window.</li>
          <li><i class="fa fa-refresh"></i>, which allows you to refresh all of the pages that have been loaded.</li>
        </ul>
        <li>You can choose whether or not to show page divisors (page headings separating each loaded page).</li>
        <li>As you scroll through the page, the pagination navigation of the page changes according to the page currently visible in the window.</li>
        <li>If you use the pagination navigation of the page to try to go to a page that has been loaded, it scrolls to the page instead of opening it.</li>
        <li>There is a reverse scrolling option for discussions that loads the pages in descending order and loads the last page instead of the first one when visiting a discussion from the main/inbox page.</li>
      </ul>
    `,
    features: {
      es_ch: {
        name: `Enable for Comment History.`,
        sg: true
      },
      es_df: {
        name: `Enable for Discussion Filters.`,
        sg: true
      },
      es_dh: {
        name: `Enable for Discussion Highlighter.`,
        sg: true
      },
      es_gb: {
        name: `Enable for Giveaway Bookmarks.`,
        sg: true
      },
      es_ged: {
        name: `Enable for Giveaway Encrypter/Decrypter.`,
        sg: true
      },
      es_ge: {
        name: `Enable for Giveaway Extractor.`,
        sg: true
      },
      es_gf: {
        name: `Enable for Giveaway Filters.`,
        sg: true
      },
      es_r: {
        description: `
          <ul>
            <li>Loads the pages of a discussion in descending order.</li>
            <li>Loads the last page instead of the first one when visiting a discussion from the main/inbox page.</li>
          </ul>
        `,
        name: `Enable reverse scrolling.`,
        sg: true
      },
      es_rd: {
        name: `Refresh active discussions/deals when refreshing the main page.`,
        sg: true
      },
      es_pd: {
        description: `
          <ul>
            <li>With this option enabled, each loaded page is separated by a page heading, which makes it very clear where a page ends and another begins. With it disabled, there is no such distinction, so it looks like the entire page is a single page, giving a true endless feeling.</li>
          </ul>
        `,
        name: `Show page divisors.`,
        sg: true,
        st: true
      }
    },
    id: `es`,
    load: es,
    name: `Endless Scrolling`,
    sg: true,
    st: true,
    type: `general`
  });

  function es() {
    if (!esgst.mainPageHeading || !esgst.pagination) return;
    let es = {};
    esgst.es = es;
    es.divisors = esgst.es_pd;
    es.mainContext = esgst.pagination.previousElementSibling;
    let rows = es.mainContext.getElementsByClassName(`table__rows`)[0];
    if (rows) {
      es.mainContext = rows;
    }
    es.paginations = [esgst.paginationNavigation ? esgst.paginationNavigation.innerHTML : ``];
    es.reverseScrolling = esgst.es_r && esgst.discussionPath;
    if (es.reverseScrolling) {
      if (esgst.currentPage === 1 && esgst.paginationNavigation && ((document.referrer.match(/www.steamgifts.com\/($|discussions|messages)/) && !location.hash) || location.hash === `#esgst_reverse`)) {
        for (let i = 0, n = es.mainContext.children.length; i < n; ++i) {
          es.mainContext.children[0].remove();
        }
        esgst.mainComments = [];
        esgst.pagination.firstElementChild.firstElementChild.nextElementSibling.textContent = 0;
        if (esgst.paginationNavigation) {
          let lastLink = esgst.paginationNavigation.lastElementChild;
          if (lastLink.classList.contains(`is-selected`) && lastLink.textContent.match(/Last/) && !esgst.lastPageLink) {
            es.currentPage = parseInt(lastLink.getAttribute(`data-page-number`));
          } else {
            es.currentPage = 999999999;
          }
        } else {
          es.currentPage = 999999999;
        }
        es.nextPage = es.currentPage;
        es.reversePages = true;
        es.ended = false;
      } else {
        es.currentPage = esgst.currentPage;
        es.nextPage = es.currentPage - 1;
        es.pageBase = es.currentPage + 1;
        es.ended = es.nextPage === 0;
      }
    } else {
      es.currentPage = esgst.currentPage;
      es.nextPage = es.currentPage + 1;
      es.pageBase = es.currentPage - 1;
      es.ended = (!esgst.paginationNavigation || esgst.paginationNavigation.lastElementChild.classList.contains(esgst.selectedClass));
    }
    const options = {
      rootMargin: `-${esgst.commentsTop + 1}px 0px 0px 0px`
    };
    es.observer = new IntersectionObserver(es_observe.bind(null, es), options);
    es_activate(es);
  }

  function es_observe(es, entries) {
    for (const entry of entries) {
      if (!entry.target.getAttribute(`data-esgst-intersection`)) {
        // So it doesn't get fired when starting to observe an element.
        entry.target.setAttribute(`data-esgst-intersection`, true);
        if (!entry.isIntersecting) {
          continue;
        }
      }

      if (entry.target.classList.contains(`pagination`)) {
        if (entry.isIntersecting) {
          esgst.pagination.setAttribute(`data-esgst-intersecting`, true);
          esgst.es_loadNext(null, true);
        } else {
          esgst.pagination.removeAttribute(`data-esgst-intersecting`);
        }
      } else {
        const index = parseInt(entry.target.className.match(/es-page-(\d+)/)[1]);
        if (entry.isIntersecting) {
          es_changePagination(es, index);
        } else if (entry.boundingClientRect.y <= entry.rootBounds.y) {
          // The intersection element is no longer visible, but was scrolled upwards,
          // so we can now change the pagination.
          es_changePagination(es, es.reverseScrolling ? index - 1 : index + 1);
        }
      }
    }
  }

  async function es_activate(es) {
    for (let i = 0, n = es.mainContext.children.length; i < n; ++i) {
      if (i === n - 1) {
        es.observer.observe(es.mainContext.children[i]);
      }
      es.mainContext.children[i].classList.add(`esgst-es-page-${es.currentPage}`);
    }
    es.nextButton = createHeadingButton({featureId: `es`, id: `esNext`, icons: [`fa-step-forward`], title: `Load next page`});
    es.continuousButton = createHeadingButton({featureId: `es`, id: `esContinuous`, icons: [`fa-fast-forward`], title: `Continuously load pages`});
    if (es.ended) {
      es.continuousButton.classList.add(`esgst-hidden`);
    }
    es.pauseButton = createHeadingButton({featureId: `es`, id: `esPause`, icons: [`fa-pause`], title: `Pause the endless scrolling`});
    es.resumeButton = createHeadingButton({featureId: `es`, id: `esResume`, orderId: `esPause`, icons: [`fa-play`], title: `Resume the endless scrolling`});
    es.refreshButton = createHeadingButton({featureId: `es`, id: `esRefresh`, icons: [`fa-refresh`, `fa-map-marker`], title: `Refresh current page`});
    es.refreshAllButton = createHeadingButton({featureId: `es`, id: `esRefreshAll`, icons: [`fa-refresh`], title: `Refresh all pages`});
    esgst.es_refresh = es_refresh.bind(null, es);
    es.refreshButton.addEventListener(`click`, esgst.es_refresh);
    esgst.es_refreshAll = es_refreshAll.bind(null, es);
    es.refreshAllButton.addEventListener(`click`, esgst.es_refreshAll);
    es.continuousButton.addEventListener(`click`, es_continuouslyLoad.bind(null, es));
    es.nextButton.addEventListener(`click`, es_stepNext.bind(null, es));
    es.pauseButton.addEventListener(`click`, es_pause.bind(null, es, false));
    es.resumeButton.addEventListener(`click`, es_resume.bind(null, es, false));
    if (esgst.paginationNavigation) {
      let lastLink = esgst.paginationNavigation.lastElementChild;
      if (esgst.lastPageLink && esgst.lastPage !== es.pageIndex && !lastLink.classList.contains(`is-selected`) && !lastLink.textContent.match(/Last/)) {
        esgst.paginationNavigation.insertAdjacentHTML(`beforeEnd`, esgst.lastPageLink);
      }
      es_setPagination(es);
    }
    es.busy = false;
    es.paused = await getValue(`esPause`, false);
    esgst.es_loadNext = es_loadNext.bind(null, es);
    if (es.paused) {
      es_pause(es, true);
    } else {
      es_resume(es, true);
    }
    es.pageIndex = es.currentPage;
    const options = {
      rootMargin: `0px 0px ${innerHeight}px 0px`
    };
    const observer = new IntersectionObserver(es_observe.bind(null, es), options);
    observer.observe(esgst.pagination);
    if (es.paused && es.reversePages) {
      esgst.es_loadNext();
    }
  }

  async function es_loadNext(es, callback, force) {
    if (!esgst.stopEs && !es.busy && (!es.paused || es.reversePages) && !es.ended && ((force && !es.continuous && !es.step) || (!force && (es.continuous || es.step)))) {
      es.busy = true;
      es.progress = insertHtml(esgst.pagination.firstElementChild, `beforeEnd`, `
        <span class="esgst-bold"><i class="fa fa-circle-o-notch fa-spin"></i> Loading next page...</span>
      `);
      es_getNext(es, false, false, callback, await request({method: `GET`, url: `${esgst.searchUrl}${es.nextPage}`}));
    } else if (callback && typeof callback === `function`) {
      callback();
    }
  }

  async function es_getNext(es, refresh, refreshAll, callback, response) {
    let pagination = parseHtml(response.responseText).getElementsByClassName(`pagination`)[0],
      context = pagination.previousElementSibling,
      rows = context.getElementsByClassName(`table__rows`)[0];
    if (rows) {
      context = rows;
    }
    let paginationNavigation = pagination.getElementsByClassName(esgst.paginationNavigationClass)[0];
    if (es.reversePages) {
      es.paginations[0] = paginationNavigation.innerHTML;
      esgst.paginationNavigation.innerHTML = es.paginations[0];
      if (esgst.paginationNavigation) {
        let lastLink = esgst.paginationNavigation.lastElementChild;
        if (esgst.lastPageLink && esgst.lastPage !== es.pageIndex && !lastLink.classList.contains(`is-selected`) && !lastLink.textContent.match(/Last/)) {
          esgst.paginationNavigation.insertAdjacentHTML(`beforeEnd`, esgst.lastPageLink);
        }
        es_setPagination(es);
      }
      es.reversePages = false;
      if (es.currentPage === 999999999) {
        es.currentPage = parseInt(paginationNavigation.lastElementChild.getAttribute(`data-page-number`));
        es.nextPage = es.currentPage;
        es.pageBase = es.currentPage + 1;
        es.pageIndex = es.currentPage;
      }
    } else if (refresh) {
      pagination = es.paginations[(es.reverseScrolling ? es.pageBase - (refreshAll || es.pageIndex) : (refreshAll || es.pageIndex) - es.pageBase) - 1];
      if (paginationNavigation && pagination !== paginationNavigation.innerHTML) {
        es.paginations[(es.reverseScrolling ? es.pageBase - (refreshAll || es.pageIndex) : (refreshAll || es.pageIndex) - es.pageBase) - 1] = paginationNavigation.innerHTML;
        es.ended = false;
      }
    } else {
      es.paginations.push(paginationNavigation.innerHTML);
    }
    let fragment = document.createDocumentFragment();
    if (esgst.cr && esgst.discussionPath) {
      reverseComments(context);
    }
    let n = context.children.length;
    const currentPage = refresh ? refreshAll || es.pageIndex : es.nextPage;
    for (let i = 0; i < n; ++i) {
      let child = context.children[0];
      child.classList.add(`esgst-es-page-${currentPage}`);
      fragment.appendChild(child);
    }
    if (refresh) {
      let elements = document.getElementsByClassName(`esgst-es-page-${currentPage}`),
        oldN = elements.length;
      for (let i = 1; i < oldN; ++i) {
        elements[0].remove();
      }
      let element = elements[0];
      es.mainContext.insertBefore(fragment, element);
      es.observer.observe(element.previousElementSibling);
      element.remove();
      if (!refreshAll) {
        es_purgeRemovedElements();
        await endless_load(es.mainContext, true, null, currentPage);
        es_setRemoveEntry(es.mainContext);
        if (esgst.gf && esgst.gf.filteredCount) {
          filters_updateCount(esgst.gf);
        }
        if (esgst.df && esgst.df.filteredCount) {
          filters_updateCount(esgst.df);
        }
        if (esgst.cf && esgst.cf.filteredCount) {
          filters_updateCount(esgst.cf);
        }
        if (esgst.ts && !esgst.us) {
          ts_sortTables();
        }
      }
      esgst.pagination.firstElementChild.firstElementChild.nextElementSibling.textContent = (parseInt(esgst.pagination.firstElementChild.firstElementChild.nextElementSibling.textContent.replace(/,/g, ``)) - oldN + n).toString().replace(/\B(?=(\d{3})+(?!\d))/g, `,`);
      if (refreshAll) {
        es.check.count += 1;
      } else {
        es.refreshButton.addEventListener(`click`, esgst.es_refresh);
        es.refreshButton.innerHTML = `
          <i class="fa fa-refresh"></i>
          <i class="fa fa-map-marker"></i>
        `;
      }
    } else {
      if (es.divisors) {
        es.mainContext.insertAdjacentHTML(`beforeEnd`, `
          <div class="esgst-page-heading esgst-es-page-divisor">
            <div class="page__heading__breadcrumbs page_heading_breadcrumbs">
              <a href="${esgst.searchUrl}${es.nextPage}">Page ${es.nextPage}</a>
            </div>
          </div>
        `);
      }
      es.mainContext.appendChild(fragment);
      es.observer.observe(es.mainContext.lastElementChild);
      await endless_load(es.mainContext, true, null, currentPage);
      es_setRemoveEntry(es.mainContext);
      if (esgst.ts && !esgst.us) {
        ts_sortTables();
      }
      esgst.pagination.firstElementChild.firstElementChild.nextElementSibling.textContent = (parseInt(esgst.pagination.firstElementChild.firstElementChild.nextElementSibling.textContent.replace(/,/g, ``)) + n).toString().replace(/\B(?=(\d{3})+(?!\d))/g, `,`);
      es.progress.remove();
      if (es.reverseScrolling) {
        --es.nextPage;
        es.busy = false;
        if (es.nextPage <= 0) {
          es.ended = true;
          if (callback && typeof callback === `function`) {
            callback();
          }
        } else if (!es.paused && !es.step) {
          if (es.continuous) {
            esgst.es_loadNext(callback);
          } else if (callback && typeof callback === `function`) {
            callback();
          } else if (esgst.pagination.getAttribute(`data-esgst-intersecting`)) {
            esgst.es_loadNext(null, true);
          }
        } else if (callback && typeof callback === `function`) {
          callback();
        }
      } else {
        ++es.nextPage;
        es.busy = false;
        if (paginationNavigation.lastElementChild.classList.contains(esgst.selectedClass)) {
          es.ended = true;
          if (callback && typeof callback === `function`) {
            callback();
          }
        } else if (!es.paused && !es.step) {
          if (es.continuous) {
            esgst.es_loadNext(callback);
          } else if (callback && typeof callback === `function`) {
            callback();
          } else if (esgst.pagination.getAttribute(`data-esgst-intersecting`)) {
            esgst.es_loadNext(null, true);
          }
        } else if (callback && typeof callback === `function`) {
          callback();
        }
      }
    }
  }

  function es_purgeRemovedElements() {
    // there are more elements that need to be purged,
    // but for now these are the most critical ones
    const keys = [`attachedImages`, `mainComments`, `tsTables`, `mainGiveaways`, `mainDiscussions`, `mainUsers`, `mainGames`, `popupGiveaways`, `popupDiscussions`, `popupUsers`, `popupGames`];
    for (const key of keys) {
      for (let i = esgst[key].length - 1; i > -1; i--) {
        if (document.contains(esgst[key][i].outerWrap)) continue;
        esgst[key].splice(i, 1);
      }
    }
    for (const key in esgst.apPopouts) {
      if (document.contains(esgst.apPopouts[key].popout)) continue;
      delete esgst.apPopouts[key];
    }
    for (const key in esgst.currentUsers) {
      const elements = esgst.currentUsers[key].elements;
      for (let i = elements.length - 1; i > -1; i--) {
        if (document.contains(elements[i])) continue;
        elements.splice(i, 1);
      }
      if (elements.length) continue;
      delete esgst.currentUsers[key];
    }
  }

  function es_changePagination(es, index) {
    const pagination = es.paginations[index - 1];
    if (pagination && esgst.paginationNavigation.innerHTML !== pagination) {
      esgst.paginationNavigation.innerHTML = pagination;
      let lastLink = esgst.paginationNavigation.lastElementChild;
      if (esgst.lastPageLink && esgst.lastPage !== es.pageIndex && !lastLink.classList.contains(`is-selected`) && !lastLink.textContent.match(/Last/)) {
        esgst.paginationNavigation.insertAdjacentHTML(`beforeEnd`, esgst.lastPageLink);
      }
      es_setPagination(es);
    }
  }

  async function es_stepNext(es) {
    if (es.step) return;
    es.nextButton.innerHTML = `<i class="fa fa-circle-o-notch fa-spin"></i>`;
    es.step = true;
    const wasPaused = es.paused;
    await es_resume(es);
    esgst.es_loadNext(async () => {
      es.step = false;
      if (wasPaused) {
        await es_pause(es);
      } else {
        await es_resume(es);
      }
      es.nextButton.innerHTML = `<i class="fa fa-step-forward"></i>`;
    });
  }

  async function es_continuouslyLoad(es) {
    if (es.continuous) return;
    es.continuousButton.innerHTML = `<i class="fa fa-circle-o-notch fa-spin"></i>`;
    es.continuous = true;
    const wasPaused = es.paused;
    await es_resume(es);
    esgst.es_loadNext(async () => {
      es.continuous = false;
      if (wasPaused) {
        await es_pause(es);
      } else {
        await es_resume(es);
      }
      es.continuousButton.innerHTML = `<i class="fa fa-fast-forward"></i>`;
    });
  }

  async function es_pause(es, firstRun) {
    es.paused = true;
    es.pauseButton.classList.add(`esgst-hidden`);
    es.resumeButton.classList.remove(`esgst-hidden`);
    if (!firstRun) {
      await setValue(`esPause`, es.paused);
    }
    es.continuous = false;
    es.continuousButton.innerHTML = `<i class="fa fa-fast-forward"></i>`;
  }

  async function es_resume(es, firstRun) {
    es.paused = false;
    es.resumeButton.classList.add(`esgst-hidden`);
    es.pauseButton.classList.remove(`esgst-hidden`);
    if (!firstRun) {
      await setValue(`esPause`, es.paused);
    }
    if (esgst.pagination.getAttribute(`data-esgst-intersecting`)) {
      esgst.es_loadNext(null, true);
    }
  }

  async function es_refresh(es) {
    es.refreshButton.removeEventListener(`click`, esgst.es_refresh);
    es.refreshButton.innerHTML = `
      <i class="fa fa-circle-o-notch fa-spin"></i>
    `;
    let response = await request({method: `GET`, url: `${esgst.searchUrl}${es.pageIndex}`});
    es_getNext(es, true, false, null, response);
    if (esgst.giveawaysPath && esgst.es_rd) {
      if (esgst.oadd) {
        oadd_load(true);
      } else {
        checkMissingDiscussions(true);
      }
    }
    if (esgst.pinnedGiveaways) {
      esgst.pinnedGiveaways.innerHTML = parseHtml(response.responseText).getElementsByClassName(`pinned-giveaways__outer-wrap`)[0].innerHTML;
      await endless_load(esgst.pinnedGiveaways, true);
      pgb();
    }
    if (!esgst.hr) {
      await hr_refreshHeaderElements(parseHtml((await request({method: `GET`, url: esgst.sg ? `/giveaways/search?type=wishlist` : `/`})).responseText));
      hr_refreshHeader(hr_getCache());
    }
  }

  async function es_refreshAll(es) {
    es.refreshAllButton.removeEventListener(`click`, esgst.es_refreshAll);
    es.refreshAllButton.innerHTML = `
      <i class="fa fa-circle-o-notch fa-spin"></i>
    `;
    es.check = new CompletionCheck(es.paginations.length, async () => {
      es_purgeRemovedElements();
      await endless_load(es.mainContext, true);
      es_setRemoveEntry(es.mainContext);
      es.refreshAllButton.addEventListener(`click`, esgst.es_refreshAll);
      es.refreshAllButton.innerHTML = `
        <i class="fa fa-refresh"></i>
      `;
      if (esgst.gf && esgst.gf.filteredCount) {
        filters_updateCount(esgst.gf);
      }
      if (esgst.df && esgst.df.filteredCount) {
        filters_updateCount(esgst.df);
      }
      if (esgst.cf && esgst.cf.filteredCount) {
        filters_updateCount(esgst.cf);
      }
      if (esgst.ts && !esgst.us) {
        ts_sortTables();
      }
      if (esgst.giveawaysPath && esgst.es_rd) {
        if (esgst.oadd) {
          oadd_load(true);
        } else {
          checkMissingDiscussions(true);
        }
      }
      if (esgst.pinnedGiveaways) {
        esgst.pinnedGiveaways.innerHTML = parseHtml(response.responseText).getElementsByClassName(`pinned-giveaways__outer-wrap`)[0].innerHTML;
        await endless_load(esgst.pinnedGiveaways, true);
        pgb();
      }
    });
    let page = es.reverseScrolling ? es.pageBase - 1 : es.pageBase + 1,
      response = await request({method: `GET`, url: `${esgst.searchUrl}${page}`});
    es_getNext(es, true, page, null, response);
    for (let i = 1; i < es.check.total; ++i) {
      page = es.reverseScrolling ? es.pageBase - (i + 1) : es.pageBase + (i + 1);
      es_getNext(es, true, page, null, await request({method: `GET`, url: `${esgst.searchUrl}${page}`}));
    }
    if (!esgst.hr) {
      await hr_refreshHeaderElements(parseHtml((await request({method: `GET`, url: esgst.sg ? `/giveaways/search?type=wishlist` : `/`})).responseText));
      hr_refreshHeader(hr_getCache());
    }
  }

  function es_setPagination(es) {
    let matches = esgst.paginationNavigation.children;
    for (let i = 0, n = matches.length; i < n; ++i) {
      matches[i].addEventListener(`click`, es_setPaginationItem.bind(null, es));
    }
  }

  function es_setPaginationItem(es, event) {
    event.preventDefault();
    let page = parseInt(event.currentTarget.getAttribute(`data-page-number`)),
      element = document.querySelector(`.esgst-es-page-${page}:not(.esgst-hidden)`);
    if (element) {
      animateScroll(element.offsetTop, () => {
        es_changePagination(es, page);
      });
    } else {
      location.href = event.currentTarget.getAttribute(`href`);
    }
  }

  function es_setRemoveEntry(Context) {
    let Matches = Context.getElementsByClassName(`table__row-inner-wrap`);
    for (let I = 0, N = Matches.length; I < N; ++I) {
      es_removeEntry(Matches[I]);
    }
  }

  function es_removeEntry(Context) {
    let Default, Loading, Complete, Data;
    Default = Context.getElementsByClassName(`table__remove-default`)[0];
    if (Default) {
      Loading = Default.nextElementSibling;
      Complete = Loading.nextElementSibling;
      Default.addEventListener(`click`, async () => {
        let Values, I, N;
        Default.classList.toggle(`is-hidden`);
        Loading.classList.toggle(`is-hidden`);
        Values = Context.getElementsByTagName(`input`);
        Data = ``;
        for (I = 0, N = Values.length; I < N; ++I) {
          Data += `${Values[I].getAttribute(`name`)}=${Values[I].value}${I < (N - 1) ? `&` : ``}`;
        }
        Loading.classList.toggle(`is-hidden`);
        let responseJson = JSON.parse((await request({data: Data, method: `POST`, url: `/ajax.php`})).responseText);
        if (responseJson.type === `success`) {
          Context.classList.add(`is-faded`);
          Complete.classList.toggle(`is-hidden`);
          esgst.pointsContainer.textContent = responseJson.points;
          esgst.points = parseInt(esgst.pointsContainer.textContent.replace(/,/g, ``).match(/\d+/)[0]);
        } else {
          Default.classList.toggle(`is-hidden`);
        }
      });
    }
  }

  // Endless

  async function checkNewGiveawayInput(context) {
    if (context.style.opacity === `1`) {
      if (!context.getAttribute(`data-esgst`)) {
        context.setAttribute(`data-esgst`, true);
        await loadNewGiveawayFeatures(context);
      }
    } else {
      context.removeAttribute(`data-esgst`);
    }
    setTimeout(() => checkNewGiveawayInput(context), 1000);
  }

  async function loadNewGiveawayFeatures(context) {
    // check if there are no cv games in the results and if they are already in the database
    let found = false;
    let games = {
      apps: {},
      subs: {}
    };
    let elements = context.getElementsByClassName(`table__row-outer-wrap`);
    for (let i = 0, n = elements.length; i < n; i++) {
      let element = elements[i];
      let date = element.querySelector(`[data-ui-tooltip*="Zero contributor value since..."]`);
      if (!date) continue;
      let info = games_getInfo(element);
      if (!info || (esgst.games[info.type][info.id] && esgst.games[info.type][info.id].noCV)) continue;
      date = JSON.parse(date.getAttribute(`data-ui-tooltip`)).rows;
      games[info.type][info.id] = {
        name: element.getElementsByClassName(`table__column__heading`)[0].firstChild.textContent.trim(),
        noCV: date[date.length - 1].columns[1].name
      };
      found = true;
    }
    if (esgst.noCvButton) {
      esgst.noCvButton.remove();
    }
    if (found) {
      esgst.noCvButton = insertHtml(context.closest(`.form__row__indent`).previousElementSibling, `beforeEnd`, `
        <span class="esgst-no-cv-button">
          <i class="fa fa-calendar-times-o esgst-blinking esgst-bold esgst-clickable esgst-red" title="${getFeatureTooltip(null, `Add no CV games to the database`)}"></i>
        </span>
      `);
      if (esgst.addNoCvGames) {
        addNoCvGames(games);
      } else {
        esgst.noCvButton.firstElementChild.addEventListener(`click`, addNoCvGames.bind(null, games));
      }
    }

    await games_load(document, true);
  }

  async function addNoCvGames(games) {
    let button = esgst.noCvButton;
    esgst.noCvButton = null;
    button.innerHTML= `
      <i class="fa fa-circle-o-notch fa-spin" title="Adding no CV games to the database..."></i>
    `;
    await request({data: JSON.stringify(games), method: `POST`, url: `https://script.google.com/macros/s/AKfycbym0nzeyr3_b93ViuiZRivkBMl9PBI2dTHQxNC0rtgeQSlCTI-P/exec`});
    for (let id in games.apps) {
      delete games.apps[id].name;
    }
    for (let id in games.subs) {
      delete games.subs[id].name;
    }
    await lockAndSaveGames(games);
    button.remove();
  }

  async function endless_load(context, main, source, endless, mainEndless) {
    if (!mainEndless) {
      esgst.edited = {};
      let values = await getValues({
        discussions: `{}`,
        games: `{"apps":{},"subs":{}}`,
        giveaways: `{}`,
        tickets: `{}`,
        trades: `{}`,
        users: `{"steamIds":{},"users":{}}`
      });
      esgst.discussions = JSON.parse(values.discussions);
      esgst.games = JSON.parse(values.games);
      esgst.giveaways = JSON.parse(values.giveaways);
      esgst.tickets = JSON.parse(values.tickets);
      esgst.trades = JSON.parse(values.trades);
      esgst.users = JSON.parse(values.users);
    }

    for (let feature of esgst.endlessFeatures) {
      try {
        await feature(context, main, source, endless, mainEndless);
      } catch(e) {
        console.log(e);
      }
    }

    if (!mainEndless) {
      const newValues = {};
      for (const key in esgst.edited) {
        newValues[key] = JSON.stringify(esgst[key]);
      }
      if (Object.keys(newValues).length) {
        setValues(newValues);
      }
    }
  }

  // Helper

  async function saveComment(tradeCode, parentId, description, url, status, callback, mainCallback) {
    let data = `xsrf_token=${esgst.xsrfToken}&do=${esgst.sg ? `comment_new` : `comment_insert`}&trade_code=${tradeCode}&parent_id=${parentId}&description=${encodeURIComponent(description)}`;
    let response = await request({data: data, method: `POST`, url: url});
    if (esgst.sg) {
      if (response.redirected && url === response.finalUrl) {
        let id;
        let responseHtml = parseHtml(response.responseText);
        if (parentId) {
          id = responseHtml.querySelector(`[data-comment-id="${parentId}"]`).getElementsByClassName(`comment__children`)[0].lastElementChild.getElementsByClassName(`comment__summary`)[0].id;
        } else {
          let elements = responseHtml.getElementsByClassName(`comments`);
          id = elements[elements.length - 1].lastElementChild.getElementsByClassName(`comment__summary`)[0].id;
        }
        if (esgst.ch) {
          ch_saveComment(id, Date.now());
        }
        if (mainCallback) {
          if (callback) {
            callback();
          }
          mainCallback(id, response, status);
        } else {
          await ged_saveGiveaways(responseHtml.getElementById(id).closest(`.comment`), id);
          if (callback) {
            callback();
          }
          location.href = `/go/comment/${id}`;
        }
      } else if (url !== response.finalUrl) {
        response = await request({data: data, method: `POST`, url: response.finalUrl});
        let id;
        let responseHtml = parseHtml(response.responseText);
        if (parentId) {
          id = responseHtml.querySelector(`[data-comment-id="${parentId}"]`).getElementsByClassName(`comment__children`)[0].lastElementChild.getElementsByClassName(`comment__summary`)[0].id;
        } else {
          let elements = responseHtml.getElementsByClassName(`comments`);
          id = elements[elements.length - 1].lastElementChild.getElementsByClassName(`comment__summary`)[0].id;
        }
        if (esgst.ch) {
          ch_saveComment(id, Date.now());
        }
        if (mainCallback) {
          if (callback) {
            callback();
          }
          mainCallback(id, response, status);
        } else {
          await ged_saveGiveaways(responseHtml.getElementById(id).closest(`.comment`), id);
          if (callback) {
            callback();
          }
          location.href = `/go/comment/${id}`;
        }
      } else {
        if (callback) {
          callback();
        }
        if (mainCallback) {
          mainCallback(null, null, status);
        } else {
          status.innerHTML = `
            <i class="fa fa-times-circle"></i>
            <span>Failed!</span>
          `;
        }
      }
    } else {
      let responseJson = JSON.parse(response.responseText);
      if (responseJson.success) {
        let responseHtml = parseHtml(responseJson.html);
        let id = responseHtml.getElementsByClassName(`comment_outer`)[0].id;
        if (esgst.ch) {
          ch_saveComment(id, Date.now());
        }
        if (mainCallback) {
          if (callback) {
            callback();
          }
          mainCallback(id, response, status);
        } else {
          await ged_saveGiveaways(responseHtml.getElementById(id), id);
          if (callback) {
            callback();
          }
          location.href = `/go/comment/${id}`;
        }
      } else {
        if (callback) {
          callback();
        }
        if (mainCallback) {
          mainCallback(null, null, status);
        } else {
          status.innerHTML = `
            <i class="fa fa-times-circle"></i>
            <span>Failed!</span>
          `;
        }
      }
    }
  }

  function getFeatures() {
    const features = {
      general: {
        features: {}
      },
      giveaways: {
        features: {}
      },
      discussions: {
        features: {}
      },
      trades: {
        features: {}
      },
      comments: {
        features: {}
      },
      users: {
        features: {}
      },
      groups: {
        features: {}
      },
      games: {
        features: {}
      },
      others: {
        features: {
          manipulateCookies: {
            description: `
              <ul>
                <li>You should enable this option if you use a single Firefox container for the common sites requested by ESGST that require you to be logged in (SteamGifts, SteamTrades, Steam, SGTools, etc...). With it enabled, ESGST will manipulate your cookies to make sure that requests are sent using the cookies from the current container you are on.</li>
                <li>For example: you are only logged in on SteamGifts and Steam in the personal container. With this option disabled, when you try to sync your owned games on ESGST it will fail because it will use the default cookies (where you are not logged in). With this option enabled, the sync will succeed because the container cookies will be used instead (where you are logged in).</li>
                <li>If you are concerned about what exactly is done, you can check out the source code of the eventPage.js file, where the manipulation occurs. Basically what happens is: the default cookies are backed up and replaced by the container cookies while the request is being made, and after the request is done the default cookies are restored. This is not a pretty solution, but it does the job until a better and more permanent solution comes along.</li>
              </ul>
            `,
            extensionOnly: true,
            name: `Allow ESGST to manipulate your cookies when using Firefox containers.`,
            sg: true,
            st: true
          },
          addNoCvGames: {
            name: `Automatically add no CV games to the database when searching for games in the new giveaway page.`,
            sg: true
          },
          askFileName: {
            name: `Ask for file name when backing up data.`,
            sg: true,
            st: true
          },
          autoBackup: {
            inputItems: [
              {
                id: `autoBackup_days`,
                prefix: `Days: `
              }
            ],
            name: `Automatically backup your data every specified number of days.`,
            options: {
              title: `Backup to:`,
              values: [`Computer`, `Dropbox`, `Google Drive`, `OneDrive`]
            },
            sg: true,
            st: true
          },
          autoSync: {
            name: `Automatically sync games/groups when syncing through SteamGifts.`,
            sg: true
          },
          updateHiddenGames: {
            description: `
              <ul>
                <li>With this enabled, you no longer have to sync your hidden games every time you add/remove a game to/from the list.</li>
              </ul>
            `,
            name: `Automatically update hidden games when adding/removing a game to/from the list.`,
            sg: true
          },
          updateWhitelistBlacklist: {
            description: `
              <ul>
                <li>With this enabled, you no longer have to sync your whitelist/blacklist every time you add/remove a user to/from those lists.</li>
              </ul>
            `,
            name: `Automatically update whitelist/blacklist when adding/removing a user to/from those lists.`,
            sg: true
          },
          calculateDelete: {
            name: `Calculate and show data sizes when opening the delete menu.`,
            sg: true,
            st: true
          },
          calculateExport: {
            name: `Calculate and show data sizes when opening the backup menu.`,
            sg: true,
            st: true
          },
          calculateImport: {
            name: `Calculate and show data sizes when opening the restore menu.`,
            sg: true,
            st: true
          },
          checkVersion: {
            name: `Check whether or not you are on the current version when visiting the ESGST discussion.`,
            sg: true
          },
          checkVersionMain: {
            name: `Check whether or not you are on the current version when visiting the main discussions page if the ESGST discussion is in the current page.`,
            sg: true
          },
          collapseSections: {
            name: `Collapse sections in the settings menu by default.`,
            sg: true,
            st: true
          },
          esgst: {
            name: `Enable ESGST for SteamTrades.`,
            st: true
          },
          enableByDefault: {
            name: `Enable new features and functionalities by default.`,
            sg: true,
            st: true
          },
          hideButtons: {
            description: `
              <ul>
                <li>Adds 2 buttons (<i class="fa fa-ellipsis-h"></i>) to left/right sides of the main page heading of any page that when clicked open a popout where you can hide other buttons from the main page heading to reduce the used space of the buttons.</li>
              </ul>
            `,
            features: {
              hideButtons_as: {
                name: `Archive Searcher Button`,
                sg: true
              },
              hideButtons_aic: {
                name: `Attached Image Carousel Button`,
                sg: true
              },
              hideButtons_cf: {
                name: `Comment Filters Button`,
                sg: true
              },
              hideButtons_cs: {
                name: `Comment Searcher`,
                sg: true,
                st: true
              },
              hideButtons_ctGo: {
                name: `Comment Tracker Button - Go to first unread.`,
                sg: true,
                st: true
              },
              hideButtons_ctRead: {
                name: `Comment Tracker Button - Read all.`,
                sg: true,
                st: true
              },
              hideButtons_ctUnread: {
                name: `Comment Tracker Button - Unread all.`,
                sg: true,
                st: true
              },
              hideButtons_cec: {
                name: `Comment/Entry Checker Button`,
                sg: true
              },
              hideButtons_df: {
                name: `Discussion Filters Button`,
                sg: true
              },
              hideButtons_ds: {
                name: `Discussions Sorter Button`,
                sg: true
              },
              hideButtons_esContinuous: {
                name: `Endless Scrolling Button - Continuously Load`,
                sg: true,
                st: true
              },
              hideButtons_esNext: {
                name: `Endless Scrolling Button - Load Next Page`,
                sg: true,
                st: true
              },
              hideButtons_esPause: {
                name: `Endless Scrolling Button - Pause/Resume`,
                sg: true,
                st: true
              },
              hideButtons_esRefresh: {
                name: `Endless Scrolling Button - Refresh`,
                sg: true,
                st: true
              },
              hideButtons_esRefreshAll: {
                name: `Endless Scrolling Button - Refresh All`,
                sg: true,
                st: true
              },
              hideButtons_ge: {
                name: `Giveaway Extractor Button`,
                sg: true
              },
              hideButtons_gf: {
                name: `Giveaway Filters Button`,
                sg: true
              },
              hideButtons_gts: {
                name: `Giveaway Templates Button`,
                sg: true
              },
              hideButtons_gas: {
                name: `Giveaways Sorter Button`,
                sg: true
              },
              hideButtons_gv: {
                name: `Grid View Button`,
                sg: true
              },
              hideButtons_glwc: {
                name: `Group Library/Wishlist Checker Button`,
                sg: true,
              },
              hideButtons_hgr: {
                name: `Hidden Game Remover Button`,
                sg: true
              },
              hideButtons_mpp: {
                name: `Main Post Popup Button`,
                sg: true,
                st: true
              },
              hideButtons_mm: {
                name: `Multi-Manager`,
                sg: true
              },
              hideButtons_namwc: {
                name: `Not Activated/Multiple Win Checker Button`,
                sg: true
              },
              hideButtons_rbp: {
                name: `Reply Box Popup Button`,
                sg: true,
                st: true
              },
              hideButtons_stbb: {
                name: `Scroll To Bottom  Button`,
                sg: true
              },
              hideButtons_sttb: {
                name: `Scroll To Top Button`,
                sg: true
              },
              hideButtons_sks: {
                name: `Sent Key Searcher Button`,
                sg: true
              },
              hideButtons_tb: {
                name: `Trade Bumper Button`,
                st: true
              },
              hideButtons_ugs: {
                name: `Unsent Gift Sender Button`,
                sg: true
              },
              hideButtons_wbc: {
                name: `Whitelist/Blacklist Checker Button`,
                sg: true
              },
              hideButtons_wbm: {
                name: `Whitelist/Blacklist Manager Button`,
                sg: true
              },
              hideButtons_wbsAsc: {
                name: `Whitelist/Blacklist Sorter Button - Ascending`,
                sg: true
              },
              hideButtons_wbsDesc: {
                name: `Whitelist/Blacklist Sorter Button - Descending`,
                sg: true
              }
            },
            name: `Hide buttons at the left/right sides of the main page heading to reduce the used space.`,
            sg: true,
            st: true
          },
          lockGiveawayColumns: {
            name: `Lock giveaway columns so that they are not draggable (they will remain in the set order).`,
            sg: true
          },
          staticPopups: {
            features: {
              staticPopups_f: {
                inputItems: [
                  {
                    id: `staticPopups_width`,
                    prefix: `Width: `
                  }
                ],
                name: `Define a fixed width for popups, so that they are centered horizontally.`,
                sg: true,
                st: true
              }
            },
            name: `Make popups static (they are fixed at the top left corner of the page instead of being automatically centered).`,
            sg: true,
            st: true
          },
          minimizePanel: {
            description: `
              <ul>
                <li>When you close a non-temporary popup, it will be minimized to a panel that can be accessed by moving your mouse to the left corner of the window in any page. There you can quickly find and re-open all of the popups that you minimized.</li>
                <li>A non-temporary popup is a popup that does not get destroyed when you close it. For example, the settings popup is a temporary popup - when you close it, the popup is destroyed, and when you click on the button to open the settings again, a new popup is created. The Whitelist/Blacklist Checker popup is an example of a non-temporary popup - if you close it and re-open it, it will be the exact same popup.</li>
                <li>With this option enabled, the sync/backup popups become non-temporary, which allows you to close them and keep navigating through the page while ESGST is performing the sync/backup, without having to wait for it to finish.</li>
                <li>Some popups will notify you when they are done. When this happens, a red bar will flash at the left side of the screen that only disappears when you open the minimize panel and re-open the popup that is requiring your attention.</li>
              </ul>
            `,
            name: `Minimize non-temporary popups to a panel when closing them.`,
            sg: true,
            st: true
          },
          getSyncGameNames: {
            description: `
              <ul>
                <li>With this disabled, only the app/sub ids of the games will appear.</li>
                <li>This can lead to lots of requests to the Steam store, so only enable it if you truly need to see the names of the games that were added/removed.</li>
              </ul>
            `,
            name: `Retrieve game names when syncing.`,
            sg: true,
            st: true
          },
          openSettingsInTab: {
            name: `Open settings menu in a separate tab.`,
            sg: true,
            st: true
          },
          openSyncInTab: {
            name: `Open the automatic sync in a new tab.`,
            sg: true,
            st: true
          },
          showChangelog: {
            name: `Show changelog from the new version when updating.`,
            sg: true,
            st: true
          },
          showFeatureNumber: {
            name: `Show the feature number in the tooltips of elements added by ESGST.`,
            sg: true,
            st: true
          }
        }
      },
      themes: {
        features: {
          sgDarkGrey: {
            name: `<a class="esgst-bold" href="https://www.steamgifts.com/discussion/3rINT/">SG Dark Grey</a> by SquishedPotatoe (Very high compatibility with ESGST elements - recommended)`,
            sg: true,
            st: true,
            theme: `https://userstyles.org/styles/141670.css`
          },
          sgv2Dark: {
            name: `<a class="esgst-bold" href="https://www.steamgifts.com/discussion/iO230/">SGv2 Dark</a> by SquishedPotatoe (Very high compatibility with ESGST elements - recommended)`,
            sg: true,
            st: true,
            theme: `https://userstyles.org/styles/109810.css`
          },
          steamGiftiesBlack: {
            name: `<a class="esgst-bold" href="https://www.steamgifts.com/discussion/62TRf/">SteamGifties Black</a> by Mully (Medium compatibility with ESGST elements)`,
            sg: true,
            theme: `https://userstyles.org/styles/110675.css`
          },
          steamGiftiesBlue: {
            name: `<a class="esgst-bold" href="https://www.steamgifts.com/discussion/62TRf/">SteamGifties Blue</a> by Mully (Medium compatibility with ESGST elements)`,
            sg: true,
            theme: `https://userstyles.org/styles/110491.css`
          },
          steamTradiesBlackBlue: {
            name: `<a class="esgst-bold" href="https://www.steamgifts.com/discussion/FIdCm/">SteamTradies Black/Blue</a> by Mully (No compatibility with ESGST elements)`,
            st: true,
            theme: `https://userstyles.org/styles/134348.css`
          },
          customTheme: {
            name: `Custom Theme (Add your own CSS rules)`,
            sg: true,
            st: true,
            theme: true
          }
        }
      },
    };
    for (const type in features) {
      if (type.match(/^(others|themes)$/)) {
        continue;
      }
      const modules = _MODULES.filter(x => x.type == type).sort((x, y) => {
        return x.id.localeCompare(y.id, {sensitivity: `base`});
      });
      for (const modd of modules) {
        features[type].features[modd.id] = modd;
      }
    }
    return features;
  }

  function checkBusy(event) {
    if (document.getElementsByClassName(`esgst-busy`)[0] || esgst.busy) {
      event.returnValue = true;
      return true;
    }
  }

  async function checkVersion(discussion) {
    if (discussion.code === `TDyzv` && ((esgst.checkVersion && esgst.discussionPath) || (esgst.checkVersionMain && !esgst.discussionPath))) {
      let version = discussion.title.match(/v(.+?)\s/)[1];
      if (version !== esgst.version && version !== await getValue(`dismissedVersion`)) {
        notifyNewVersion(version);
      }
    }
  }

  function setMouseEvent(element, id, url, callback) {
    let isDragging = -1;
    let startingPos = [0, 0];
    element.addEventListener(`mousedown`, event => {
      if (event.button === 2) return; // right click, do nothing
      if (event.button === 1) { // middle click
        event.preventDefault();
      }
      isDragging = event.button;
      startingPos = [event.pageX, event.pageY];
    });
    element.addEventListener(`mousemove`, event => {
      if (isDragging === -1 || (event.pageX === startingPos[0] && event.pageY === startingPos[1])) return;
      isDragging = -1;
    });
    element.addEventListener(`mouseup`, () => {
      if (isDragging === -1) return;
      if (esgst[id] || isDragging === 1) {
        open(url);
      } else {
        callback();
      }
      isDragging = -1;
      startingPos = [0, 0];
    });
  }

  function createHeadingButton(details) {
    let [key, position] = esgst.leftButtonIds.indexOf(details.orderId || details.id) > -1 ? [`leftButtons`, `afterBegin`] : [`rightButtons`, `beforeEnd`];
    let icons = ``;
    details.icons.forEach(icon => {
      icons += `<i class="fa ${icon}"></i> `;
    });
    return insertHtml(details.context || (esgst.hideButtons && esgst[`hideButtons_${details.orderId || details.id}`] ? esgst[key] : esgst.mainPageHeading), position, `
    <div class="esgst-heading-button" id="esgst-${details.id}" title="${getFeatureTooltip(details.featureId || details.id, details.title)}">
      ${details.isSwitch ? `<span></span>` : ``}
      ${icons}
    </div>
    `);
  }

  function showPatreonNotice() {
    if (!esgst.storage.patreonNotice) {
      const popup = new Popup(`fa-dollar`, `Hi! ESGST now has a Patreon page. If you want to support ESGST, please check it out: <a href="https://www.patreon.com/revilheart">https://www.patreon.com/revilheart</a>`, true);
      popup.onClose = setValue.bind(null, `patreonNotice`, true);
      popup.open();
    }
  }

  async function checkNewVersion() {
    if (esgst.version !== esgst.currentVersion) {
      if (typeof esgst.version === `undefined`) {
        esgst.firstInstall = true;
        let popup = new Popup(`fa-smile-o`, `<i class="fa fa-circle-o-notch fa-spin"></i> Hi! ESGST is getting things ready for you. This will not take long...`, true);
        popup.open();
        await checkSync(true, true);
        popup.title.innerHTML = `
          <i class="fa fa-check"></i> Thanks for installing ESGST, <span>${esgst.username}</span>. You are ready to go! Click on the <span>Settings</span> link below to choose which features you want to use.
        `;
      } else {
        if (esgst.showChangelog) {
          loadChangelog(esgst.version);
        }
      }
      esgst.version = esgst.currentVersion;
      setValue(`version`, esgst.version);
    }
    if (!esgst.settings.groupPopupDismissed) {
      let i;
      for (i = esgst.groups.length - 1; i > -1 && esgst.groups[i].steamId !== `103582791461018688`; i--);
      if (i < 0 || !esgst.groups[i] || !esgst.groups[i].member) {
        let popup = new Popup(`fa-steam`, `Hello! In case you were not aware ESGST now has a Steam group. If you want to join it, you must first send a request from the <a class="esgst-bold" href="http://steamcommunity.com/groups/esgst">Steam group</a> page, then another request from the settings menu (last button in the heading). Have a good day. :)`);
        popup.description.insertAdjacentHTML(`beforeEnd`, `<div class="esgst-description">This popup will never show up again after you close it.</div>`);
        popup.open();
        popup.onClose = setSetting.bind(null, `groupPopupDismissed`, true);
      }
    }
  }

  function parseHtml(string) {
    return esgst.domParser.parseFromString(string, `text/html`);
  }

  function parseMarkdown(string) {
    return esgst.markdownParser.text(string);
  }

  async function addGiveawayToStorage() {
    let giveaway, ggiveaways, i, key, n, popup, ugd, user;
    popup = new Popup(`fa-circle-o-notch fa-spin`, `Please wait... ESGST is adding this giveaway to the storage...`, true);
    popup.open();
    let giveaways = await giveaways_get(document, true, location.href);
    if (giveaways.length) {
      giveaway = giveaways[0];
      ggiveaways = {};
      ggiveaways[giveaway.code] = giveaway;
      user = {
        steamId: esgst.steamId,
        username: esgst.username
      };
      const savedUser = await getUser(null, user);
      giveaways = null;
      if (savedUser) {
        giveaways = savedUser.giveaways;
      }
      if (!giveaways) {
        giveaways = {
          sent: {
            apps: {},
            subs: {}
          },
          won: {
            apps: {},
            subs: {}
          },
          sentTimestamp: 0,
          wonTimestamp: 0
        };
        if (savedUser) {
          ugd = savedUser.ugd;
          if (ugd) {
            if (ugd.sent) {
              for (key in ugd.sent.apps) {
                giveaways.sent.apps[key] = [];
                for (i = 0, n = ugd.sent.apps[key].length; i < n; ++i) {
                  ggiveaways[ugd.sent.apps[key][i].code] = ugd.sent.apps[key][i];
                  giveaways.sent.apps[key].push(ugd.sent.apps[key][i].code);
                }
              }
              for (key in ugd.sent.subs) {
                giveaways.sent.subs[key] = [];
                for (i = 0, n = ugd.sent.subs[key].length; i < n; ++i) {
                  ggiveaways[ugd.sent.subs[key][i].code] = ugd.sent.subs[key][i];
                  giveaways.sent.subs[key].push(ugd.sent.subs[key][i].code);
                }
              }
              giveaways.sentTimestamp = ugd.sentTimestamp;
            }
            if (ugd.won) {
              for (key in ugd.won.apps) {
                giveaways.won.apps[key] = [];
                for (i = 0, n = ugd.won.apps[key].length; i < n; ++i) {
                  ggiveaways[ugd.won.apps[key][i].code] = ugd.won.apps[key][i];
                  giveaways.won.apps[key].push(ugd.won.apps[key][i].code);
                }
              }
              for (key in ugd.won.subs) {
                giveaways.won.subs[key] = [];
                for (i = 0, n = ugd.won.subs[key].length; i < n; ++i) {
                  ggiveaways[ugd.won.subs[key][i].code] = ugd.won.subs[key][i];
                  giveaways.won.subs[key].push(ugd.won.subs[key][i].code);
                }
              }
              giveaways.wonTimestamp = ugd.wonTimestamp;
            }
          }
        }
      }
      if (!giveaways.sent[giveaway.gameType][giveaway.gameSteamId]) {
        giveaways.sent[giveaway.gameType][giveaway.gameSteamId] = [];
      }
      if (giveaways.sent[giveaway.gameType][giveaway.gameSteamId].indexOf(giveaway.code) < 0) {
        giveaways.sent[giveaway.gameType][giveaway.gameSteamId].push(giveaway.code);
      }
      user.values = {
        giveaways: giveaways
      };
      await lockAndSaveGiveaways(ggiveaways);
      await saveUser(null, null, user);
      popup.close();
    }
  }

  function generateHeaderMenuItem(details, key) {
    if (details.icon) {
      let icon = details.icon;
      if (details.color) {
        icon += ` icon-${details.color}`;
      }
      if (details.url) {
        return `
          <a class="esgst-header-menu-row${details.className || ``}" data-link-id="${details.id}" data-link-key="${key}" href="${details.url}"${details.title ? ` title="${details.title}"` : ``}>
            <i class="fa fa-fw ${icon}"></i>
            <div>
              <p class="esgst-header-menu-name">${details.name}</p>
              ${details.description ? `<p class="esgst-header-menu-description">${details.description}</p>` : ``}
            </div>
          </a>
        `;
      }
      return `
        <div class="esgst-header-menu-row${details.className || ``}" data-link-id="${details.id}" data-link-key="${key}"${details.title ? ` title="${details.title}"` : ``}>
          <i class="fa fa-fw ${icon}"></i>
          <div>
            <p class="esgst-header-menu-name">${details.name}</p>
            ${details.description ? `<p class="esgst-header-menu-description">${details.description}</p>` : ``}
          </div>
        </div>

      `;
    }
    if (esgst.sg) {
      return `
        <a class="nav__row${details.className || ``}" data-link-id="${details.id}" data-link-key="${key}" href="${details.url}"${details.title ? ` title="${details.title}"` : ``}>
          <div class="nav__row__summary">
            <p class="nav__row__summary__name">${details.name}</p>
            ${details.description ? `<p class="esgst-header-menu-description">${details.description}</p>` : ``}
          </div>
        </a>
      `;
    } else {
      return `
        <a class="dropdown_btn${details.className || ``}" data-link-id="${details.id}" data-link-key="${key}" href="${details.url}"${details.title ? ` title="${details.title}"` : ``}>
          <span>${details.name}</p>
        </a>
      `;
    }
  }

  function reorderButtons(leftButton, leftButtons, rightButton, rightButtons) {
    let leftHidden, rightHidden, source;
    leftHidden = leftButton && leftButton.classList.contains(`esgst-hidden`);
    rightHidden = rightButton && rightButton.classList.contains(`esgst-hidden`);
    esgst.leftButtonIds.forEach(id => {
      let button = document.getElementById(`esgst-${id}`);
      if (button) {
        let key = id === `esResume` ? `hideButtons_esPause` : `hideButtons_${id}`;
        button.parentElement.insertBefore(button, leftHidden || !esgst.hideButtons || esgst[key] ? button.parentElement.firstElementChild : button.parentElement.firstElementChild.nextElementSibling);
        button.setAttribute(`draggable`, true);
        button.addEventListener(`dragstart`, event => {
          event.dataTransfer.setData(`text/plain`, ``);
          source = button;
        });
        button.addEventListener(`dragenter`, () => {
          let current;
          current = source;
          do {
            current = current.previousElementSibling;
            if (current && current === button) {
              current.parentElement.insertBefore(source, current);
              return;
            }
          } while (current);
          button.parentElement.insertBefore(source, button.nextElementSibling);
        });
        button.addEventListener(`dragend`, async () => {
          let i, nextSiblingId, previousSiblingId, siblingId;
          if (esgst.hideButtons) {
            if (leftButtons.contains(button) || rightButtons.contains(button)) {
              if (!esgst[key]) {
                await setSetting(key, true, esgst.sg, esgst.st);
              }
            } else if (esgst[key]) {
              await setSetting(key, false, esgst.sg, esgst.st);
            }
          }
          previousSiblingId = button.previousElementSibling && !button.previousElementSibling.classList.contains(`esgst-hidden`) && button.previousElementSibling.id;
          nextSiblingId = button.nextElementSibling && !button.nextElementSibling.classList.contains(`esgst-hidden`) && button.nextElementSibling.id;
          siblingId = previousSiblingId || nextSiblingId;
          if (siblingId) {
            i = esgst.rightButtonIds.indexOf(siblingId.split(`esgst-`)[1]);
            esgst.leftButtonIds.splice(esgst.leftButtonIds.indexOf(id), 1);
            if (i > -1) {
              esgst.rightButtonIds.splice(i, 0, id);
            } else if (previousSiblingId) {
              esgst.leftButtonIds.splice(esgst.leftButtonIds.indexOf(previousSiblingId.split(`esgst-`)[1]), 0, id);
            } else {
              esgst.leftButtonIds.splice(esgst.leftButtonIds.indexOf(nextSiblingId.split(`esgst-`)[1]) + 1, 0, id);
            }
            await setSetting(`leftButtonIds`, esgst.leftButtonIds);
            await setSetting(`rightButtonIds`, esgst.rightButtonIds);
          }
        });
      }
    });
    esgst.rightButtonIds.forEach(id => {
      let button = document.getElementById(`esgst-${id}`);
      if (button) {
        let key = id === `esResume` ? `hideButtons_esPause` : `hideButtons_${id}`;
        if (rightHidden || !esgst.hideButtons || esgst[key]) {
          button.parentElement.appendChild(button);
        } else {
          button.parentElement.insertBefore(button, button.parentElement.lastElementChild);
        }
        button.setAttribute(`draggable`, true);
        button.addEventListener(`dragstart`, event => {
          event.dataTransfer.setData(`text/plain`, ``);
          source = button;
        });
        button.addEventListener(`dragenter`, () => {
          let current;
          current = source;
          do {
            current = current.previousElementSibling;
            if (current && current === button) {
              current.parentElement.insertBefore(source, current);
              return;
            }
          } while (current);
          button.parentElement.insertBefore(source, button.nextElementSibling);
        });
        button.addEventListener(`dragend`, async () => {
          let i, nextSiblingId, previousSiblingId, siblingId;
          if (esgst.hideButtons) {
            if (leftButtons.contains(button) || rightButtons.contains(button)) {
              if (!esgst[key]) {
                await setSetting(key, true, esgst.sg, esgst.st);
              }
            } else if (esgst[key]) {
              await setSetting(key, false, esgst.sg, esgst.st);
            }
          }
          previousSiblingId = button.previousElementSibling && !button.previousElementSibling.classList.contains(`esgst-hidden`) && button.previousElementSibling.id;
          nextSiblingId = button.nextElementSibling && !button.nextElementSibling.classList.contains(`esgst-hidden`) && button.nextElementSibling.id;
          siblingId = previousSiblingId || nextSiblingId;
          if (siblingId) {
            i = esgst.leftButtonIds.indexOf(siblingId.split(`esgst-`)[1]);
            esgst.rightButtonIds.splice(esgst.rightButtonIds.indexOf(id), 1);
            if (i > -1) {
              esgst.leftButtonIds.splice(i, 0, id);
            } else if (previousSiblingId) {
              esgst.rightButtonIds.splice(esgst.rightButtonIds.indexOf(previousSiblingId.split(`esgst-`)[1]) + 1, 0, id);
            } else {
              esgst.rightButtonIds.splice(esgst.rightButtonIds.indexOf(nextSiblingId.split(`esgst-`)[1]), 0, id);
            }
            await setSetting(`leftButtonIds`, esgst.leftButtonIds);
            await setSetting(`rightButtonIds`, esgst.rightButtonIds);
          }
        });
      }
    });
  }

  function repositionPopups() {
    if (esgst.openPopups > 0) {
      esgst.popups.forEach(popup => popup.reposition());
      esgst.isRepositioning = true;
      setTimeout(() => repositionPopups(), 2000);
    } else {
      esgst.isRepositioning = false;
    }
  }

  async function setSetting() {
    const deleteLock = await createLock(`settingsLock`, 100);
    const settings = JSON.parse(await getValue(`settings`, `{}`));
    const values = Array.isArray(arguments[0])
      ? arguments[0]
      : [
        {
          id: arguments[0],
          value: arguments[1],
          sg: arguments[2],
          st: arguments[3]
        }
      ];
    for (const value of values) {
      if (value.sg) {
        value.id = `${value.id}_sg`;
      } else if (value.st) {
        value.id = `${value.id}_st`;
      }
      settings[value.id] = value.value;
      esgst.settings[value.id] = value.value;
    }
    await setValue(`settings`, JSON.stringify(settings));
    deleteLock();
  }

  function getSetting(key, inverse) {
    let value = esgst.settings[key];
    if (typeof value === `undefined`) {
      let defaultValue = esgst.defaultValues[key];
      if (typeof defaultValue === `undefined`) {
        defaultValue = esgst[`enableByDefault_${esgst.name}`] || false;
      }
      let oldKey = esgst.oldValues[key];
      if (typeof oldKey !== `undefined`) {
        value = inverse ? !esgst.settings[oldKey] : esgst.settings[oldKey];
      }
      if (typeof value === `undefined`) {
        value = defaultValue;
      }
    }
    return value;
  }

  function getOldValues(id, name, setting) {
    switch (id) {
      case `at`:
        if (name !== `sg`) return;
        setting.exclude = [
          {enabled: validateValue(esgst.settings.at_g_sg) ? 0 : 1, pattern: `^/($|giveaways(?!/(new|wishlist|created|entered|won)))`}
        ];
        return;
      case `egh`:
        if (name !== `sg`) return;
        setting.exclude = [
          {enabled: validateValue(esgst.settings.egh_t_sg) ? 0 : 1, pattern: `^/discussion/`}
        ];
        return;
      case `es_pd`:
        setting.enabled = name === `sg` ? esgst.settings.es_l_d_sg || esgst.settings.es_c_d_sg || esgst.settings.es_d_d_sg || esgst.settings.es_g_d_sg : esgst.settings.es_l_d_st || esgst.settings.es_c_d_st || esgst.settings.es_t_d_st;
        setting.enabled = setting.enabled ? 1 : 0;
      case `es`:
        if (name === `sg`) {
          if (validateValue(esgst.settings[id === `es` ? `es_l_sg` : `es_l_d_sg`])) {
            setting.exclude = [
              {enabled: validateValue(esgst.settings[id === `es` ? `es_c_sg` : `es_c_d_sg`]) ? 0 : 1, pattern: `^/(giveaway/(?!.*/(entries|winners|groups|region-restrictions))|discussion/|support/ticket/)`},
              {enabled: validateValue(esgst.settings[id === `es` ? `es_d_sg` : `es_d_d_sg`]) ? 0 : 1, pattern: `^/(discussions|support/tickets)`},
              {enabled: validateValue(esgst.settings[id === `es` ? `es_g_sg` : `es_g_d_sg`]) ? 0 : 1, pattern: `^/($|giveaways(?!/(new|wishlist|created|entered|won)))`}
            ];
          } else {
            setting.include = [
              {enabled: validateValue(esgst.settings[id === `es` ? `es_c_sg` : `es_c_d_sg`]) ? 1 : 0, pattern: `^/(giveaway/(?!.*/(entries|winners|groups|region-restrictions))|discussion/|support/ticket/)`},
              {enabled: validateValue(esgst.settings[id === `es` ? `es_d_sg` : `es_d_d_sg`]) ? 1 : 0, pattern: `^/(discussions|support/tickets)`},
              {enabled: validateValue(esgst.settings[id === `es` ? `es_g_sg` : `es_g_d_sg`]) ? 1 : 0, pattern: `^/($|giveaways(?!/(new|wishlist|created|entered|won)))`}
            ];
          }
        } else {
          if (validateValue(esgst.settings[id === `es` ? `es_l_st` : `es_l_d_st`])) {
            setting.exclude = [
              {enabled: validateValue(esgst.settings[id === `es` ? `es_c_st` : `es_c_d_st`]) ? 0 : 1, pattern: `^/trade/`},
              {enabled: validateValue(esgst.settings[id === `es` ? `es_t_st` : `es_t_d_st`]) ? 0 : 1, pattern: `^/($|trades)`}
            ];
          } else {
            setting.include = [
              {enabled: validateValue(esgst.settings[id === `es` ? `es_c_st` : `es_c_d_st`]) ? 1 : 0, pattern: `^/trade/`},
              {enabled: validateValue(esgst.settings[id === `es` ? `es_t_st` : `es_t_d_st`]) ? 1 : 0, pattern: `^/($|trades)`}
            ];
          }
        }
        return;
      case `gc`:
        if (name !== `sg`) return;
        setting.exclude = [
          {enabled: validateValue(esgst.settings.gc_t_sg) ? 0 : 1, pattern: `^/discussion/`}
        ];
        return;
      case `gc_gi`:
        if (name !== `sg`) return;
        if (validateValue(esgst.settings.gc_gi_t_sg)) {
          setting.include = [
            {enabled: 1, pattern: `^/discussion`}
          ];
        } else if (validateValue(esgst.settings.gc_gi_cew_sg)) {
          setting.include = [
            {enabled: 1, pattern: `^/giveaways/(created|entered|won)/`}
          ];
        }
        return;
      case `gc_o_a`:
        if (name !== `sg`) return;
        setting.enabled = esgst.settings.gc_o_altAccounts && esgst.settings.gc_o_altAccounts.length > 0 ? 1 : 0;
        if (validateValue(esgst.settings.gc_o_t_sg)) {
          setting.include = [
            {enabled: 1, pattern: `^/discussion`}
          ];
        }
        return;
      case `gt`:
        if (name !== `sg`) return;
        setting.exclude = [
          {enabled: validateValue(esgst.settings.gt_t_sg) ? 0 : 1, pattern: `^/discussion/`}
        ];
        return;
      case `vai`:
        setting.exclude = [
          {enabled: validateValue(esgst.settings[`vai_i_${name}`]) ? 1 : 0, pattern: `^/messages`}
        ];
        return;
      default:
        return;
    }
  }

  function getFeaturePath(feature, id, name) {
    let key = `${id}_${name}`;
    let setting = esgst.settings[key];
    if (typeof setting === `undefined` || !setting.include || !Array.isArray(setting.include)) {
      setting = {
        enabled: getSetting(key, key.match(/^(wbc_checkBlacklist|wbc_hb_sg)$/)) ? 1 : 0,
        include: [],
        exclude: [],
        new: typeof setting === `undefined`
      };
      if (feature[name].include) {
        setting.include = feature[name].include;
        if (feature[name].exclude) {
          setting.exclude = feature[name].exclude;
        }
      } else {
        setting.include = [{enabled: setting.enabled, pattern: `.*`}];
      }
      if (setting.new) {
        getOldValues(id, name, setting);
      }
    }
    return setting;
  }

  function getFeatureSetting(feature, id) {
    esgst[id] = false;
    if (feature[esgst.name]) {
      let setting = getFeaturePath(feature, id, esgst.name);
      if (!setting.enabled) return;
      let check = false;
      let path = `${location.pathname}${location.search}`;
      let i = setting.include.length - 1;
      while (i > -1 && (!setting.include[i].enabled || !path.match(new RegExp(setting.include[i].pattern)))) i--;
      if (i > -1) {
        check = true;
      }
      i = setting.exclude.length - 1;
      while (i > -1 && (!setting.exclude[i].enabled || !path.match(new RegExp(setting.exclude[i].pattern)))) i--;
      if (i > -1) {
        check = false;
      }
      esgst[id] = check;
    }
    if (!esgst[id]) return;
    if (feature.features) {
      for (id in feature.features) {
        getFeatureSetting(feature.features[id], id);
      }
    }
  }

  function toggleHeaderMenu(arrow, dropdown) {
    if (esgst.sg) {
      let buttons = document.querySelectorAll(`nav .nav__button`);
      for (let button of buttons) {
        button.classList.remove(`is-selected`);
      }
      let dropdowns = document.querySelectorAll(`nav .nav__relative-dropdown`);
      for (let dropdown of dropdowns) {
        dropdown.classList.add(`is-hidden`);
      }
    } else {
      let buttons = document.querySelectorAll(`.nav_btn_dropdown, .page_heading_btn_dropdown`);
      for (let button of buttons) {
        button.classList.remove(`is_selected`);
      }
      let dropdowns = document.querySelectorAll(`.dropdown`);
      for (let dropdown of dropdowns) {
        dropdown.classList.add(`is_hidden`);
      }
    }
    arrow.classList.toggle(`selected`);
    dropdown.classList.toggle(`esgst-hidden`);
  }

  function getFeatureTooltip(id, title = ``) {
    if (esgst.showFeatureNumber) {
      if (title) {
        return `${title}\n\nThis element was added by ESGST${id ? ` (${getFeatureNumber(id).number})` : ``}`;
      }
      return `This element was added by ESGST${id ? ` (${getFeatureNumber(id).number})` : ``}`;
    }
    return title;
  }

  function getFeatureName(fullMatch, match) {
    let feature = getFeatureNumber(match);
    return `${feature.number} "${feature.name}"`;
  }

  function getFeatureNumber(queryId) {
    let n = 1;
    for (let type in esgst.features) {
      let i = 1;
      for (let id in esgst.features[type].features) {
        let feature = esgst.features[type].features[id];
        let result = getFeatureNumber_2(feature, id, i, n, queryId);
        if (result) {
          return result;
        }
        if (feature.sg || esgst.settings.esgst_st) {
          i += 1;
        }
      }
      if (type !== `trades` || esgst.settings.esgst_st) {
        n += 1;
      }
    }
    return {
      name: ``,
      number: ``
    };
  }

  function getFeatureNumber_2(feature, id, i, n, queryId) {
    if (id === queryId) {
      return {
        name: feature.name,
        number: `${n}.${i}`
      };
    }
    if (feature.features) {
      let j = 1;
      for (let id in feature.features) {
        let subFeature = feature.features[id];
        let result = getFeatureNumber_2(subFeature, id, j, `${n}.${i}`, queryId);
        if (result) {
          return result;
        }
        if (subFeature.sg || esgst.settings.esgst_st) {
          j += 1;
        }
      }
    }
    return null;
  }

  async function getUser(savedUsers, user) {
    let savedUser = null;
    if (!savedUsers) {
      savedUsers = JSON.parse(await getValue(`users`));
    }
    if (user.steamId) {
      savedUser = savedUsers.users[user.steamId];
      if (savedUser) {
        if (!user.id) {
          user.id = savedUser.id;
        }
        if (!user.username) {
          user.username = savedUser.username;
        }
      }
    } else if (user.username) {
      let steamId = savedUsers.steamIds[user.username];
      if (steamId) {
        user.steamId = steamId;
        savedUser = savedUsers.users[steamId];
      }
    }
    return savedUser;
  }

  async function saveUser(list, savedUsers, user) {
    if (!savedUsers) {
      savedUsers = JSON.parse(await getValue(`users`));
    }
    let savedUser = await getUser(savedUsers, user);
    if (savedUser) {
      if (list) {
        if (!user.steamId) {
          user.steamId = savedUsers.steamIds[user.username];
        }
        list.existing.push(user);
      } else {
        let deleteLock = await createLock(`userLock`, 300);
        checkUsernameChange(savedUsers, user);
        for (let key in user.values) {
          if (key !== `tags`) {
            if (user.values[key] === null) {
              delete savedUsers.users[user.steamId][key];
            } else {
              savedUsers.users[user.steamId][key] = user.values[key];
            }
          }
        }
        await setValue(`users`, JSON.stringify(savedUsers));
        deleteLock();
      }
    } else {
      if (user.steamId && user.username) {
        if (list) {
          list.new.push(user);
        } else {
          await addUser(user);
        }
      } else if (user.steamId) {
        await getUsername(list, true, user);
      } else {
        await getSteamId(list, true, null, user);
      }
    }
  }

  function checkUsernameChange(savedUsers, user) {
    let i, n;
    if (typeof savedUsers.users[user.steamId].username !== `undefined` && savedUsers.users[user.steamId].username !== user.username) {
      delete savedUsers.steamIds[savedUsers.users[user.steamId].username];
      savedUsers.users[user.steamId].username = user.username;
      savedUsers.steamIds[user.username] = user.steamId;
      if (user.values.tags) {
        if (!savedUsers.users[user.steamId].tags) {
          savedUsers.users[user.steamId].tags = [];
        }
        for (i = 0, n = user.values.tags.length; i < n; ++i) {
          if (savedUsers.users[user.steamId].tags.indexOf(user.values.tags[i]) < 0) {
            savedUsers.users[user.steamId].tags.push(user.values.tags[i]);
          }
        }
      }
      return true;
    } else if (typeof user.values.tags !== `undefined`) {
      savedUsers.users[user.steamId].tags = user.values.tags;
    }
    if (!savedUsers.users[user.steamId].tags) {
      delete savedUsers.users[user.steamId].tags;
    }
  }

  async function addUser(user) {
    let deleteLock, savedUser, savedUsers;
    deleteLock = await createLock(`userLock`, 300);
    savedUsers = JSON.parse(await getValue(`users`));
    savedUser = await getUser(savedUsers, user);
    if (!savedUser) {
      savedUsers.users[user.steamId] = {};
    }
    if (user.id) {
      savedUsers.users[user.steamId].id = user.id;
    }
    checkUsernameChange(savedUsers, user);
    if (user.username) {
      savedUsers.users[user.steamId].username = user.username;
      savedUsers.steamIds[user.username] = user.steamId;
    }
    for (let key in user.values) {
      if (key !== `tags`) {
        if (user.values[key] === null) {
          delete savedUsers.users[user.steamId][key];
        } else {
          savedUsers.users[user.steamId][key] = user.values[key];
        }
      }
    }
    await setValue(`users`, JSON.stringify(savedUsers));
    deleteLock();
  }

  async function getUsername(list, save, user) {
    let match, response, responseHtml;
    response = await request({method: `GET`, url: `https://www.steamgifts.com/go/user/${user.steamId}`});
    match = response.finalUrl.match(/\/user\/(.+)/);
    responseHtml = parseHtml(response.responseText);
    if (match) {
      user.username = match[1];
      let input = responseHtml.querySelector(`[name="child_user_id"]`);
      if (input) {
        user.id = input.value;
      }
    }
    if (save) {
      if (list) {
        list.new.push(user);
      } else {
        await addUser(user);
      }
    }
  }

  async function getSteamId(list, save, savedUsers, user) {
    let input, responseHtml;
    if (!save) {
      if (!savedUsers) {
        savedUsers = JSON.parse(await getValue(`users`));
      }
      let steamId = savedUsers.steamIds[user.username];
      if (steamId) {
        user.steamId = steamId;
        user.id = savedUsers.users[steamId].id;
        return;
      }
    }
    responseHtml = parseHtml((await request({method: `GET`, url: `https://www.steamgifts.com/user/${user.username}`})).responseText);
    user.steamId = responseHtml.querySelector(`[href*="/profiles/"]`).getAttribute(`href`).match(/\d+/)[0];
    input = responseHtml.querySelector(`[name="child_user_id"]`);
    if (input) {
      user.id = input.value;
    }
    if (save) {
      if (list) {
        list.new.push(user);
      } else {
        await addUser(user);
      }
    }
  }

  async function saveUsers(users) {
    let list, promises, savedUsers;
    list = {
      existing: [],
      new: []
    };
    promises = [];
    savedUsers = JSON.parse(await getValue(`users`));
    for (let i = 0, n = users.length; i < n; i++) {
      promises.push(saveUser(list, savedUsers, users[i]));
    }
    await Promise.all(promises);
    let deleteLock = await createLock(`userLock`, 300);
    savedUsers = JSON.parse(await getValue(`users`));
    for (let i = 0, n = list.new.length; i < n; ++i) {
      let savedUser, user;
      user = list.new[i];
      savedUser = await getUser(savedUsers, user);
      if (!savedUser) {
        savedUsers.users[user.steamId] = {};
      }
      if (user.id) {
        savedUsers.users[user.steamId].id = user.id;
      }
      checkUsernameChange(savedUsers, user);
      if (user.username) {
        savedUsers.users[user.steamId].username = user.username;
        savedUsers.steamIds[user.username] = user.steamId;
      }
      for (let key in user.values) {
        if (key !== `tags`) {
          if (user.values[key] === null) {
            delete savedUsers.users[user.steamId][key];
          } else {
            savedUsers.users[user.steamId][key] = user.values[key];
          }
        }
      }
    }
    for (let i = 0, n = list.existing.length; i < n; ++i) {
      let user = list.existing[i];
      checkUsernameChange(savedUsers, user);
      for (let key in user.values) {
        if (key !== `tags`) {
          if (user.values[key] === null) {
            delete savedUsers.users[user.steamId][key];
          } else {
            savedUsers.users[user.steamId][key] = user.values[key];
          }
        }
      }
    }
    await setValue(`users`, JSON.stringify(savedUsers));
    deleteLock();
  }

  async function deleteUserValues(values) {
    let deleteLock, savedUsers;
    deleteLock = await createLock(`userLock`, 300);
    savedUsers = JSON.parse(await getValue(`users`));
    for (let key in savedUsers.users) {
      for (let i = 0, n = values.length; i < n; ++i) {
        delete savedUsers.users[key][values[i]];
      }
    }
    await setValue(`users`, JSON.stringify(savedUsers));
    deleteLock();
  }

  async function getUserId(user) {
    if (user.username) {
      await getSteamId(null, false, null, user);
    } else {
      await getUsername(null, false, user);
    }
  }

  async function checkSync(menu, callback) {
    let currentDate = Date.now();
    let isSyncing = getLocalValue(`isSyncing`);
    if (menu) {
      await setSync(false, callback);
    } else if (!isSyncing || currentDate - isSyncing > 1800000) {
      if (esgst.openSyncInTab) {
        let parameters = ``;
        setLocalValue(`isSyncing`, currentDate);
        [`Groups`, `Whitelist`, `Blacklist`, `HiddenGames`, `Games`, `WonGames`, `ReducedCvGames`, `NoCvGames`, `Giveaways`].forEach(key => {
          if (esgst[`autoSync${key}`] && currentDate - esgst[`lastSync${key}`] > esgst[`autoSync${key}`] * 86400000) {
            parameters += `${key}=1&`;
          }
        });
        if (parameters) {
          if (esgst.sg) {
            open(`/esgst/sync?${parameters.replace(/&$/, ``)}`);
          } else {
            open(`/esgst/sync?${parameters.replace(/&$/, ``)}`);
          }
        } else {
          delLocalValue(`isSyncing`);
        }
      } else {
        let parameters = {};
        setLocalValue(`isSyncing`, currentDate);
        [`Groups`, `Whitelist`, `Blacklist`, `HiddenGames`, `Games`, `WonGames`, `ReducedCvGames`, `NoCvGames`, `Giveaways`].forEach(key => {
          if (esgst[`autoSync${key}`] && currentDate - esgst[`lastSync${key}`] > esgst[`autoSync${key}`] * 86400000) {
            parameters[key] = 1;
          }
        });
        if (Object.keys(parameters).length > 0) {
          await setSync(false, null, parameters);
        } else {
          delLocalValue(`isSyncing`);
        }
      }
    }
  }

  async function setSync(autoSync, mainCallback, parameters) {
    let syncer = {
      autoSync: autoSync,
      canceled: false
    };
    if (esgst.firstInstall) {
      await sync(syncer);
    } else if (syncer.autoSync || mainCallback || parameters) {
      syncer.popup = new Popup(parameters ? `fa-circle-o-notch fa-spin` : `fa-refresh`, parameters ? `ESGST is syncing your data... ${esgst.minimizePanel ? `You can close this popup, ESGST will notify you when it is done through the minimize panel.` : `Please do not close this popup until it is done.`}` : `Sync`, !esgst.minimizePanel);
      if (!syncer.autoSync && !parameters) {
        syncer.popup.description.insertAdjacentHTML(`afterBegin`, `<div class="esgst-description">By selecting a number X in the dropdown menu next to each data other than 0, you are enabling automatic sync for that data (which means the data will be synced every X days).</div>`);
        syncer.switches = {
          syncGroups: new ToggleSwitch(syncer.popup.scrollable, `syncGroups`, false, `Steam Groups`, false, false, null, esgst.syncGroups),
          syncWhitelist: new ToggleSwitch(syncer.popup.scrollable, `syncWhitelist`, false, `Whitelist`, false, false, null, esgst.syncWhitelist),
          syncBlacklist: new ToggleSwitch(syncer.popup.scrollable, `syncBlacklist`, false, `Blacklist`, false, false, null, esgst.syncBlacklist),
          syncHiddenGames: new ToggleSwitch(syncer.popup.scrollable, `syncHiddenGames`, false, `Hidden Games`, false, false, null, esgst.syncHiddenGames),
          syncGames: new ToggleSwitch(syncer.popup.scrollable, `syncGames`, false, `Owned/Wishlisted/Ignored Games`, false, false, null, esgst.syncGames),
          syncWonGames: new ToggleSwitch(syncer.popup.scrollable, `syncWonGames`, false, `Won Games`, false, false, null, esgst.syncWonGames),
          syncReducedCvGames: new ToggleSwitch(syncer.popup.scrollable, `syncReducedCvGames`, false, `Reduced CV Games`, false, false, null, esgst.syncReducedCvGames),
          syncNoCvGames: new ToggleSwitch(syncer.popup.scrollable, `syncNoCvGames`, false, `No CV Games`, false, false, null, esgst.syncNoCvGames),
          syncGiveaways: new ToggleSwitch(syncer.popup.scrollable, `syncGiveaways`, false, `Giveaways`, false, false, null, esgst.syncGiveaways)
        };
        for (let id in syncer.switches) {
          setAutoSync(id, syncer.switches);
        }
        let group = insertHtml(syncer.popup.description, `beforeEnd`, `<div class="esgst-button-group"><span>Select:</span></div>`);
        group.appendChild(new ButtonSet(`grey`, `grey`, `fa-square`, `fa-circle-o-notch fa-spin`, `All`, ``, selectSwitches.bind(null, syncer.switches, `enable`, group)).set);
        group.appendChild(new ButtonSet(`grey`, `grey`, `fa-square-o`, `fa-circle-o-notch fa-spin`, `None`, ``, selectSwitches.bind(null, syncer.switches, `disable`, group)).set);
        group.appendChild(new ButtonSet(`grey`, `grey`, `fa-plus-square-o`, `fa-circle-o-notch fa-spin`, `Inverse`, ``, selectSwitches.bind(null, syncer.switches, `toggle`, group)).set);
      }
      syncer.progress = insertHtml(syncer.popup.description, `beforeEnd`, `
        <div class="esgst-hidden esgst-popup-progress"></div>
      `);
      syncer.results = insertHtml(syncer.popup.scrollable, `afterBegin`, `<div></div>`);
      if (!parameters) {
        syncer.set = new ButtonSet_v2({color1: `green`, color2: `grey`, icon1: `fa-refresh`, icon2: `fa-times`, title1: `Sync`, title2: `Cancel`, callback1: sync.bind(null, syncer), callback2: cancelSync.bind(null, syncer)});
        syncer.popup.description.appendChild(syncer.set.set);
      }
      syncer.popup.open();
      if (syncer.autoSync) {
        syncer.set.trigger();
      } else if (parameters) {
        syncer.parameters = parameters;
        await sync(syncer);
      }
    } else {
      esgst.mainContext.innerHTML = ``;
      let description = insertHtml(esgst.mainContext, `beforeEnd`, `
        <div class="description">
          <div></div>
          <div class="esgst-hidden esgst-popup-progress"></div>
        </div>
      `);
      syncer.results = description.firstElementChild;
      syncer.progress = description.lastElementChild;
      syncer.parameters = getParameters();
      await sync(syncer);
    }
  }

  function setAutoSync(id, switches) {
    let html, i, key, select, toggleSwitch;
    key = id.replace(/^sync/, ``);
    toggleSwitch = switches[id];
    html = `<select class="esgst-auto-sync">`;
    for (i = 0; i < 31; ++i) {
      html += `<option>${i}</option>`;
    }
    html += `</select>`;
    select = insertHtml(toggleSwitch.name, `beforeEnd`, html);
    select.selectedIndex = esgst[`autoSync${key}`];
    observeNumChange(select, `autoSync${key}`);
    if (esgst[`lastSync${key}`]) {
      toggleSwitch.date = insertHtml(toggleSwitch.name, `beforeEnd`, `<span><i class="fa fa-check-circle"></i> Last synced ${new Date(esgst[`lastSync${key}`]).toLocaleString()}</span>`);
    } else {
      toggleSwitch.date = insertHtml(toggleSwitch.name, `beforeEnd`, `<span><i class="fa fa-times"></i> Never synced.</span>`);
    }
  }

  function cancelSync(syncer) {
    if (syncer.process) {
      syncer.process.stop();
    }
    syncer.canceled = true;
  }

  async function sync(syncer) {
    if (!esgst.firstInstall) {
      await setSetting(`lastSync`, Date.now());
      syncer.results.innerHTML = ``;
      syncer.progress.classList.remove(`esgst-hidden`);
      syncer.progress.innerHTML = `
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <span></span>
      `;
    }

    // if this is the user's fist time using the script, only sync steam id and stop
    if (esgst.firstInstall) {
      return;
    }

    // if sync has been canceled stop
    if (syncer.canceled) {
      return;
    }

    // sync groups
    if (esgst.sg && ((syncer.parameters && syncer.parameters.Groups) || (!syncer.parameters && (esgst.settings.syncGroups || syncer.autoSync)))) {
      syncer.progress.lastElementChild.textContent = `Syncing your Steam groups...`;
      syncer.groups = {};
      let savedGroups = JSON.parse(await getValue(`groups`));
      if (!Array.isArray(savedGroups)) {
        let newGroups, savedGiveaways;
        newGroups = [];
        for (let key in savedGroups) {
          newGroups.push(savedGroups[key]);
        }
        savedGroups = newGroups;
        await setValue(`groups`, JSON.stringify(savedGroups));
        savedGiveaways = JSON.parse(await getValue(`giveaways`));
        for (let key in savedGiveaways) {
          delete savedGiveaways[key].groups;
        }
        await setValue(`giveaways`, JSON.stringify(savedGiveaways));
      }
      syncer.currentGroups = {};
      for (let i = 0, n = savedGroups.length; i < n; ++i) {
        if (savedGroups[i] && savedGroups[i].member && savedGroups[i].steamId) {
          syncer.currentGroups[savedGroups[i].steamId] = savedGroups[i].name;
        }
      }
      syncer.newGroups = {};
      syncer.savedGroups = savedGroups;
      let nextPage = 1;
      let pagination = null;
      do {
        let elements, responseHtml;
        responseHtml = parseHtml((await request({method: `GET`, url: `https://www.steamgifts.com/account/steam/groups/search?page=${nextPage}`})).responseText);
        elements = responseHtml.getElementsByClassName(`table__row-outer-wrap`);
        for (let i = 0, n = elements.length; !syncer.canceled && i < n; i++) {
          let code, element, heading, name;
          element = elements[i];
          heading = element.getElementsByClassName(`table__column__heading`)[0];
          code = heading.getAttribute(`href`).match(/\/group\/(.+?)\/(.+)/)[1];
          name = heading.textContent;
          let j;
          for (j = syncer.savedGroups.length - 1; j >= 0 && syncer.savedGroups[j].code !== code; --j);
          if (j >= 0 && syncer.savedGroups[j].steamId) {
            syncer.groups[code] = {
              member: true
            };
            syncer.newGroups[syncer.savedGroups[j].steamId] = name;
          } else {
            let avatar, steamId;
            avatar = element.getElementsByClassName(`table_image_avatar`)[0].style.backgroundImage.match(/\/avatars\/(.+)_medium/)[1];
            steamId = parseHtml((await request({method: `GET`, url: `/group/${code}/`})).responseText).getElementsByClassName(`sidebar__shortcut-inner-wrap`)[0].firstElementChild.getAttribute(`href`).match(/\d+/)[0];
            syncer.groups[code] = {
              avatar: avatar,
              code: code,
              member: true,
              name: name,
              steamId: steamId
            };
            syncer.newGroups[steamId] = name;
          }
        }
        pagination = responseHtml.getElementsByClassName(`pagination__navigation`)[0];
        nextPage += 1;
      } while (!syncer.canceled && pagination && !pagination.lastElementChild.classList.contains(`is-selected`));
      await lockAndSaveGroups(syncer.groups, true);
      let missing, neww;
      missing = [];
      neww = [];
      for (let id in syncer.currentGroups) {
        if (!syncer.newGroups[id]) {
          missing.push(`<a href="http://steamcommunity.com/gid/${id}">${syncer.currentGroups[id]}</a>`);
        }
      }
      for (let id in syncer.newGroups) {
        if (!syncer.currentGroups[id]) {
          neww.push(`<a href="http://steamcommunity.com/gid/${id}">${syncer.newGroups[id]}</a>`);
        }
      }
      syncer.html = ``;
      if (missing.length) {
        syncer.html += `
          <div>
            <span class="esgst-bold">Missing groups:</span> ${missing.join(`, `)}
          </div>
        `;
      }
      if (neww.length) {
        syncer.html += `
          <div>
            <span class="esgst-bold">New groups:</span> ${neww.join(`, `)}
          </div>
        `;
      }
      syncer.results.insertAdjacentHTML(`afterBegin`, syncer.html);
    }

    // if sync has been canceled stop
    if (syncer.canceled) {
      return;
    }

    // sync whitelist and blacklist
    if (!syncer.autoSync && ((syncer.parameters && (syncer.parameters.Whitelist || syncer.parameters.Blacklist)) || (!syncer.parameters && (esgst.settings.syncWhitelist || esgst.settings.syncBlacklist)))) {
      if ((syncer.parameters && syncer.parameters.Whitelist && syncer.parameters.Blacklist) || (!syncer.parameters && esgst.settings.syncWhitelist && esgst.settings.syncBlacklist)) {
        await deleteUserValues([`whitelisted`, `whitelistedDate`, `blacklisted`, `blacklistedDate`]);
        syncer.users = [];
        syncer.progress.lastElementChild.textContent = `Syncing your whitelist...`;
        await syncWhitelistBlacklist(`whitelisted`, syncer, `https://www.steamgifts.com/account/manage/whitelist/search?page=`);
        syncer.progress.lastElementChild.textContent = `Syncing your blacklist...`;
        await syncWhitelistBlacklist(`blacklisted`, syncer, `https://www.steamgifts.com/account/manage/blacklist/search?page=`);
      } else if ((syncer.parameters && syncer.parameters.Whitelist) || (!syncer.parameters && esgst.settings.syncWhitelist)) {
        await deleteUserValues([`whitelisted`, `whitelistedDate`]);
        syncer.users = [];
        syncer.progress.lastElementChild.textContent = `Syncing your whitelist...`;
        await syncWhitelistBlacklist(`whitelisted`, syncer, `https://www.steamgifts.com/account/manage/whitelist/search?page=`);
      } else {
        await deleteUserValues([`blacklisted`, `blacklistedDate`]);
        syncer.users = [];
        syncer.progress.lastElementChild.textContent = `Syncing your blacklist...`;
        await syncWhitelistBlacklist(`blacklisted`, syncer, `https://www.steamgifts.com/account/manage/blacklist/search?page=`);
      }
      syncer.progress.lastElementChild.textContent = `Saving your whitelist/blacklist (this may take a while)...`;
      await saveUsers(syncer.users);
    }

    // if sync has been canceled stop
    if (syncer.canceled) {
      return;
    }

    // sync hidden games
    if (!syncer.autoSync && ((syncer.parameters && syncer.parameters.HiddenGames) || (!syncer.parameters && esgst.settings.syncHiddenGames))) {
      syncer.progress.lastElementChild.textContent = `Syncing your hidden games...`;
      syncer.hiddenGames = {
        apps: [],
        subs: []
      };
      let nextPage = 1;
      let pagination = null;
      do {
        let elements, responseHtml;
        responseHtml = parseHtml((await request({method: `GET`, url: `https://www.steamgifts.com/account/settings/giveaways/filters/search?page=${nextPage}`})).responseText);
        elements = responseHtml.querySelectorAll(`.table__column__secondary-link[href*="store.steampowered.com"]`);
        for (let i = 0, n = elements.length; i < n; ++i) {
          let match = elements[i].getAttribute(`href`).match(/(app|sub)\/(\d+)/);
          if (match) {
            syncer.hiddenGames[`${match[1]}s`].push(match[2]);
          }
        }
        pagination = responseHtml.getElementsByClassName(`pagination__navigation`)[0];
        nextPage += 1;
      } while (!syncer.canceled && pagination && !pagination.lastElementChild.classList.contains(`is-selected`));
      let deleteLock = await createLock(`gameLock`, 300);
      let savedGames = JSON.parse(await getValue(`games`));
      for (let key in savedGames.apps) {
        delete savedGames.apps[key].hidden;
      }
      for (let key in savedGames.subs) {
        delete savedGames.subs[key].hidden;
      }
      for (let i = 0, n = syncer.hiddenGames.apps.length; i < n; ++i) {
        if (!savedGames.apps[syncer.hiddenGames.apps[i]]) {
          savedGames.apps[syncer.hiddenGames.apps[i]] = {};
        }
        savedGames.apps[syncer.hiddenGames.apps[i]].hidden = true;
      }
      for (let i = 0, n = syncer.hiddenGames.subs.length; i < n; ++i) {
        if (!savedGames.subs[syncer.hiddenGames.subs[i]]) {
          savedGames.subs[syncer.hiddenGames.subs[i]] = {};
        }
        savedGames.subs[syncer.hiddenGames.subs[i]].hidden = true;
      }
      await setValue(`games`, JSON.stringify(savedGames));
      deleteLock();
    }

    // if sync has been canceled stop
    if (syncer.canceled) {
      return;
    }

    // sync wishlisted/owned/ignored games
    if ((syncer.parameters && syncer.parameters.Games) || (!syncer.parameters && (syncer.autoSync || esgst.settings.syncGames))) {
      syncer.progress.lastElementChild.textContent = `Syncing your wishlisted/owned/ignored games...`;
      syncer.html = ``;
      let apiResponse = null;
      if (esgst.steamApiKey) {
        apiResponse = await request({method: `GET`, url: `http://api.steampowered.com/IPlayerService/GetOwnedGames/v0001/?key=${esgst.steamApiKey}&steamid=${esgst.steamId}&format=json`});
      }
      let storeResponse = await request({method: `GET`, url: `http://store.steampowered.com/dynamicstore/userdata?${Math.random().toString().split(`.`)[1]}`});
      let deleteLock = await createLock(`gameLock`, 300);
      await syncGames(null, syncer, apiResponse, storeResponse);
      deleteLock();
      if (esgst.settings.gc_o_altAccounts) {
        for (let i = 0, n = esgst.settings.gc_o_altAccounts.length; !syncer.canceled && i < n; i++) {
          let altAccount = esgst.settings.gc_o_altAccounts[i];
          apiResponse = await request({method: `GET`, url: `http://api.steampowered.com/IPlayerService/GetOwnedGames/v0001/?key=${esgst.steamApiKey}&steamid=${altAccount.steamId}&format=json`});
          await syncGames(altAccount, syncer, apiResponse);
        }
        await setSetting(`gc_o_altAccounts`, esgst.settings.gc_o_altAccounts);
      }
      if (syncer.html) {
        syncer.results.insertAdjacentHTML(`afterBegin`, syncer.html);
        if (esgst.getSyncGameNames) {
          getGameNames(syncer);
        }
      }
    }

    // if sync has been canceled stop
    if (syncer.canceled) {
      return;
    }

    // sync won games
    if (!syncer.autoSync && ((syncer.parameters && syncer.parameters.WonGames) || (!syncer.parameters && esgst.settings.syncWonGames))) {
      syncer.progress.lastElementChild.textContent = `Syncing your won games...`;
      await getWonGames(`0`, syncer);
    }

    // if sync has been canceled stop
    if (syncer.canceled) {
      return;
    }

    // sync reduced cv games
    if (!syncer.autoSync && ((syncer.parameters && syncer.parameters.ReducedCvGames) || (!syncer.parameters && esgst.settings.syncReducedCvGames))) {
      syncer.progress.lastElementChild.textContent = `Syncing reduced CV games...`;
      for (const id in esgst.games.apps) {
        esgst.games.apps[id].reducedCV = null;
      }
      for (const id in esgst.games.subs) {
        esgst.games.subs[id].reducedCV = null;
      }
      const result = JSON.parse((await request({method: `GET`, url: `https://script.google.com/macros/s/AKfycbwJK-7RBh5ghaKprEsmx4DQ6CyXc_3_9eYiOCu3yhI6W4B3W4YN/exec`})).responseText).success;
      for (const id in result.apps) {
        if (!esgst.games.apps[id]) {
          esgst.games.apps[id] = {};
        }
        esgst.games.apps[id].reducedCV = result.apps[id].reducedCV;
      }
      for (const id in result.subs) {
        if (!esgst.games.subs[id]) {
          esgst.games.subs[id] = {};
        }
        esgst.games.subs[id].reducedCV = result.subs[id].reducedCV;
      }
      await lockAndSaveGames(esgst.games);
    }

    // if sync has been canceled stop
    if (syncer.canceled) {
      return;
    }

    // sync no cv games
    if (!syncer.autoSync && ((syncer.parameters && syncer.parameters.NoCvGames) || (!syncer.parameters && esgst.settings.syncNoCvGames))) {
      syncer.progress.lastElementChild.textContent = `Syncing no CV games...`;
      await lockAndSaveGames(JSON.parse((await request({method: `GET`, url: `https://script.google.com/macros/s/AKfycbym0nzeyr3_b93ViuiZRivkBMl9PBI2dTHQxNC0rtgeQSlCTI-P/exec`})).responseText).success);
    }

    // if sync has been canceled stop
    if (syncer.canceled) {
      return;
    }

    // sync giveaways
    if (!syncer.autoSync && ((syncer.parameters && syncer.parameters.Giveaways) || (!syncer.parameters && esgst.settings.syncGiveaways)) && esgst.sg) {
      syncer.progress.lastElementChild.textContent = `Syncing your giveaways...`;
      const key = `sent`;
      const user = {
        steamId: esgst.steamId,
        username: esgst.username
      };
      syncer.process = ugd_add(null, key, user, syncer);
      await syncer.process.start();
    }

    // finish sync
    if (!esgst.firstInstall) {
      syncer.progress.lastElementChild.textContent = `Updating last sync date...`;
      let currentDate = new Date();
      const currentTime = currentDate.getTime();
      if (syncer.autoSync) {
        await setSetting(`lastSyncGroups`, currentTime);
        await setSetting(`lastSyncGames`, currentTime);
        esgst.lastSyncGroups = currentTime;
        esgst.lastSyncGames = currentTime;
      } else {
        let string = currentDate.toLocaleString();
        let keys = [`Groups`, `Whitelist`, `Blacklist`, `HiddenGames`, `Games`, `WonGames`, `ReducedCvGames`, `NoCvGames`, `Giveaways`];
        for (let i = keys.length - 1; i > -1; i--) {
          let key = keys[i];
          let id = `sync${key}`;
          if ((syncer.parameters && syncer.parameters[key]) || (!syncer.parameters && esgst.settings[id])) {
            await setSetting(`lastSync${key}`, currentTime);
            esgst[`lastSync${key}`] = currentTime;
            if (syncer.switches && syncer.switches[id]) {
              syncer.switches[id].date.innerHTML = `<i class="fa fa-check-circle"></i> Last synced ${string}`;
            }
          }
        }
      }
      syncer.progress.innerHTML = `Synced!`;
      delLocalValue(`isSyncing`);
    }
    if (syncer.set && syncer.autoSync) {
      syncer.set.set.remove();
    }
    if (syncer.parameters && syncer.popup) {
      syncer.popup.icon.classList.remove(`fa-circle-o-notch`, `fa-spin`);
      syncer.popup.icon.classList.add(`fa-check`);
      syncer.popup.setTitle(`Sync done! You can close this popup now.`);
      syncer.popup.setDone(true);
    }
  }

  async function syncWhitelistBlacklist(key, syncer, url) {
    let nextPage = 1;
    let pagination = null;
    do {
      let elements, responseHtml;
      responseHtml = parseHtml((await request({method: `GET`, url: `${url}${nextPage}`})).responseText);
      elements = responseHtml.getElementsByClassName(`table__row-outer-wrap`);
      for (let i = 0, n = elements.length; i < n; ++i) {
        let element, user;
        element = elements[i];
        user = {
          id: element.querySelector(`[name="child_user_id"]`).value,
          username: element.getElementsByClassName(`table__column__heading`)[0].textContent,
          values: {}
        };
        user.values[key] = true;
        user.values[`${key}Date`] = parseInt(element.querySelector(`[data-timestamp]`).getAttribute(`data-timestamp`)) * 1e3;
        syncer.users.push(user);
      }
      pagination = responseHtml.getElementsByClassName(`pagination__navigation`)[0];
      nextPage += 1;
    } while (!syncer.canceled && pagination && !pagination.lastElementChild.classList.contains(`is-selected`));
  }

  async function syncGames(altAccount, syncer, apiResponse, storeResponse) {
    let apiJson = null,
      storeJson = null;
    try {
      apiJson = JSON.parse(apiResponse.responseText);
    } catch (e) { /**/ }
    try {
      storeJson = JSON.parse(storeResponse.responseText);
    } catch (e) { /**/ }
    const hasApi = apiJson && apiJson.response && apiJson.response.games &&
          apiJson.response.games.length,
        hasStore = storeJson && storeJson.rgOwnedApps && storeJson.rgOwnedApps.length;
    if (((altAccount && !esgst.steamApiKey) || (!altAccount && esgst.steamApiKey)) && !hasApi) {
      syncer.html += `
        <div>${altAccount ? `<span class="esgst-bold">${altAccount.name}:</span> ` : ``}Unable to sync through the Steam API. Check if you have a valid Steam API key set in the settings menu.${altAccount ? ` Also check the privacy settings of your alt account.` : ``}</div>
      `;
    }
    if (!altAccount && !hasStore) {
      syncer.html += `
        Unable to sync through the Steam store. Check if you are logged in to Steam on your current browser session. If you are, try again later. Some games may not be available through the Steam API (if you have a Steam API key set).
      `;
    }
    console.log(hasApi, hasStore);
    if (!hasApi && !hasStore) return;

    // delete old data
    const savedGames = (altAccount && altAccount.games) || JSON.parse(await getValue(`games`)),
        oldOwned = {
      apps: [],
      subs: []
    };
    for (const id in savedGames.apps) {
      if (savedGames.apps[id].owned) {
        oldOwned.apps.push(id);
        delete savedGames.apps[id].owned;
      }
      if (hasStore) {
        delete savedGames.apps[id].wishlisted;
        delete savedGames.apps[id].ignored;
      }
      if (Object.keys(savedGames.apps[id]).length === 0) {
        delete savedGames.apps[id];
      }
    }
    if (hasStore) {
      for (const id in savedGames.subs) {
        if (savedGames.subs[id].owned) {
          oldOwned.subs.push(id);
          delete savedGames.subs[id].owned;
        }
        delete savedGames.subs[id].wishlisted;
        delete savedGames.subs[id].ignored;
        if (Object.keys(savedGames.subs[id]).length === 0) {
          delete savedGames.subs[id];
        }
      }
    }

    // add new data
    let newOwned = {
        apps: [],
        subs: []
      },
      numOwned = 0;
    if (hasApi) {
      apiJson.response.games.forEach(game => {
        const id = game.appid;
        if (!savedGames.apps[id]) {
          savedGames.apps[id] = {};
        }
        savedGames.apps[id].owned = true;
        newOwned.apps.push(id.toString());
        numOwned += 1;
      });
    }
    if (!altAccount) {
      if (hasStore) {
        [
          {
            jsonKey: `rgWishlist`,
            key: `wishlisted`,
            type: `apps`
          },
          {
            jsonKey: `rgOwnedApps`,
            key: `owned`,
            type: `apps`
          },
          {
            jsonKey: `rgOwnedPackages`,
            key: `owned`,
            type: `subs`
          },
          {
            jsonKey: `rgIgnoredApps`,
            key: `ignored`,
            type: `apps`
          },
          {
            jsonKey: `rgIgnoredPackages`,
            key: `ignored`,
            type: `subs`
          }
        ].forEach(item => {
          const key = item.key,
              type = item.type;
          storeJson[item.jsonKey].forEach(id => {
            if (!savedGames[type][id]) {
              savedGames[type][id] = {};
            }
            const value = savedGames[type][id][key];
            savedGames[type][id][key] = true;
            if (key === `owned` && !value) {
              newOwned[type].push(id.toString());
              numOwned += 1;
            }
          });
        });
      }

      if (numOwned !== (await getValue(`ownedGames`, 0))) {
        await setValue(`ownedGames`, numOwned);
      }

      // get the wishlisted dates
      try {
        const responseText = (await request({method: `GET`, url: `http://store.steampowered.com/wishlist/profiles/${esgst.steamId}?l=en`})).responseText,
            match = responseText.match(/g_rgWishlistData\s=\s(\[(.+?)\]);/);
        if (match) {
          JSON.parse(match[1]).forEach(item => {
            const id = item.appid;
            if (!savedGames.apps[id]) {
              savedGames.apps[id] = {};
            }
            savedGames.apps[id].wishlisted = item.added;
          });
        }
      } catch (e) { /**/ }

      await setValue(`games`, JSON.stringify(savedGames));
    }

    const removedOwned = {
      apps: [],
      subs: []
        },
        addedOwned = {
      apps: [],
      subs: []
    };
    oldOwned.apps.forEach(id => {
      if (newOwned.apps.indexOf(id) < 0) {
        removedOwned.apps.push(`<a href="http://store.steampowered.com/app/${id}">${id}</a>`);
      }
    });
    oldOwned.subs.forEach(id => {
      if (newOwned.subs.indexOf(id) < 0) {
        removedOwned.subs.push(`<a href="http://store.steampowered.com/sub/${id}">${id}</a>`);
      }
    });
    newOwned.apps.forEach(id => {
      if (oldOwned.apps.indexOf(id) < 0) {
        addedOwned.apps.push(`<a href="http://store.steampowered.com/app/${id}">${id}</a>`);
      }
    });
    newOwned.subs.forEach(id => {
      if (oldOwned.subs.indexOf(id) < 0) {
        addedOwned.subs.push(`<a href="http://store.steampowered.com/sub/${id}">${id}</a>`);
      }
    });
    if (altAccount && (removedOwned.apps.length > 0 || removedOwned.subs.length > 0 || addedOwned.apps.length > 0 || addedOwned.subs.length > 0)) {
      syncer.html += `
        <br>
        <div class="esgst-bold">Alt Account - ${altAccount.name}</div>
        <br>
      `;
    }
    if (removedOwned.apps.length > 0) {
      syncer.html += `
        <div>
          <span class="esgst-bold">Removed apps:</span> ${removedOwned.apps.join(`, `)}
        </div>
      `;
    }
    if (removedOwned.subs.length > 0) {
      syncer.html += `
        <div>
          <span class="esgst-bold">Removed packages:</span> ${removedOwned.subs.join(`, `)}
        </div>
      `;
    }
    if (addedOwned.apps.length > 0) {
      syncer.html += `
        <div>
          <span class="esgst-bold">Added apps:</span> ${addedOwned.apps.join(`, `)}
        </div>
      `;
    }
    if (addedOwned.subs.length > 0) {
      syncer.html += `
        <div>
          <span class="esgst-bold">Added packages:</span> ${addedOwned.subs.join(`, `)}
        </div>
      `;
    }
  }

  async function getGameNames(syncer) {
    const elements = syncer.results.getElementsByTagName(`a`);
    for (let i = elements.length - 1; i > -1; --i) {
      const element = elements[i],
          match = element.getAttribute(`href`).match(/\/(app|sub)\/(.+)/);
      if (!match) continue;
      const id = match[2],
          response = await request({method: `GET`, url: `http://store.steampowered.com/api/${match[1] === `app` ? `appdetails?appids` : `packagedetails?packageids`}=${id}&filters=basic`});
      try {
        element.textContent = JSON.parse(response.responseText)[id].data.name;
      } catch (e) {
        element.classList.add(`esgst-red`);
        element.title = `Unable to retrieve name for this game`;
      }
      await timeout(1000);
    }
  }

  async function lockAndSaveGiveaways(giveaways, firstRun) {
    if (!Object.keys(giveaways).length) return;

    let deleteLock;
    let savedGiveaways;
    if (firstRun) {
      savedGiveaways = esgst.giveaways;
    } else {
      deleteLock = await createLock(`giveawayLock`, 300),
      savedGiveaways = JSON.parse(await getValue(`giveaways`, `{}`));
    }
    for (let key in giveaways) {
      if (savedGiveaways[key]) {
        for (let subKey in giveaways[key]) {
          savedGiveaways[key][subKey] = giveaways[key][subKey];
          esgst.edited.giveaways = true;
        }
      } else {
        savedGiveaways[key] = giveaways[key];
        esgst.edited.giveaways = true;
      }
    }
    if (!firstRun) {
      await setValue(`giveaways`, JSON.stringify(savedGiveaways));
      deleteLock();
    }
  }

  async function lockAndSaveDiscussions(discussions) {
    let deleteLock = await createLock(`discussionLock`, 300),
      savedDiscussions = JSON.parse(await getValue(`discussions`, `{}`));
    for (let key in discussions) {
      if (savedDiscussions[key]) {
        for (let subKey in discussions[key]) {
          savedDiscussions[key][subKey] = discussions[key][subKey];
        }
      } else {
        savedDiscussions[key] = discussions[key];
      }
      if (!savedDiscussions[key].readComments) {
        savedDiscussions[key].readComments = {};
      }
    }
    await setValue(`discussions`, JSON.stringify(savedDiscussions));
    deleteLock();
  }

  async function lockAndSaveGroups(groups, sync) {
    let deleteLock, savedGroups;
    deleteLock = await createLock(`groupLock`, 300);
    savedGroups = JSON.parse(await getValue(`groups`, `[]`));
    if (!Array.isArray(savedGroups)) {
      let newGroups = [];
      for (const key in savedGroups) {
        newGroups.push(savedGroups[key]);
      }
      savedGroups = newGroups;
    }
    if (sync) {
      for (let i = 0, n = savedGroups.length; i < n; ++i) {
        if (savedGroups[i]) {
          delete savedGroups[i].member;
        }
      }
    }
    for (let code in groups) {
      let i, n;
      for (i = 0, n = savedGroups.length; i < n && savedGroups[i].code !== code; ++i);
      if (i < n) {
        for (let key in groups[code]) {
          if (savedGroups[i]) {
            savedGroups[i][key] = groups[code][key];
          }
        }
      } else {
        savedGroups.push(groups[code]);
      }
    }
    await setValue(`groups`, JSON.stringify(savedGroups));
    deleteLock();
  }

  function lookForPopups(response) {
    const popup = parseHtml(response.responseText).querySelector(`.popup--gift-sent, .popup--gift-received`);
    if (!popup) {
      return;
    }
    document.body.appendChild(popup);
    new Popup(null, null, true, false, popup).open();
    if (!esgst.st) {
      return;
    }
    const links = popup.querySelectorAll(`a`);
    for (const link of links) {
      const url = link.getAttribute(`href`);
      if (!url) {
        continue;
      }
      link.setAttribute(`href`, url.replace(/^\//, `https://www.steamgifts.com/`));
    }
  }

  async function getWonGames(count, syncer) {
    const savedGames = JSON.parse(await getValue(`games`));
    if (syncer) {
      for (const id in savedGames.apps) {
        if (savedGames.apps[id].won) {
          savedGames.apps[id].won = null;
        }
      }
      for (const id in savedGames.subs) {
        if (savedGames.subs[id].won) {
          savedGames.subs[id].won = null;
        }
      }
    }
    let lastPage = null,
      nextPage = 1,
      pagination = null;
    do {
      if (syncer) {
        syncer.progress.lastElementChild.textContent = `Syncing your won games (page ${nextPage}${lastPage ? ` of ${lastPage}` : ``})...`;
      }
      const responseHtml = parseHtml((await request({
            method: `GET`,
            url: `/giveaways/won/search?page=${nextPage}`
          })).responseText),
          elements = responseHtml.getElementsByClassName(`table__row-outer-wrap`);
      if (!lastPage) {
        lastPage = lpl_getLastPage(responseHtml);
      }
      for (const element of elements) {
        if (element.querySelector(`.table__gift-feedback-not-received:not(.is-hidden), .table__column--gift-feedback .trigger-popup .icon-red`)) continue;
        const info = games_getInfo(element);
        if (!info) continue;
        if (!savedGames[info.type][info.id]) {
          savedGames[info.type][info.id] = {};
        }
        savedGames[info.type][info.id].won = 1;
      }
      nextPage += 1;
      pagination = responseHtml.getElementsByClassName(`pagination__navigation`)[0];
    } while (syncer && pagination && !pagination.lastElementChild.classList.contains(`is-selected`));
    await lockAndSaveGames(savedGames);
    setLocalValue(`wonCount`, count);
  }

  function saveAndSortContent(key, mainKey, options, callback) {
    if (callback) {
      callback();
    }
    sortContent(esgst[mainKey], mainKey, options.value);
    setSetting(key, options.value);
  }

  function observeChange(context, id, key = `value`, event = `change`) {
    context.addEventListener(event, () => {
      let value = context[key];
      setSetting(id, value);
      esgst[id] = value;
    });
  }

  function observeNumChange(context, id, key = `value`) {
    esgst[id] = parseFloat(esgst[id]);
    context.addEventListener(`change`, () => {
      let value = parseFloat(context[key]);
      setSetting(id, value);
      esgst[id] = value;
    });
  }

  async function checkMissingDiscussions(refresh, callback) {
    let savedDiscussions = JSON.parse(await getValue(`discussions`, `{}`));
    let rows = document.getElementsByClassName(`table__rows`);
    let numDiscussions = 0;
    let numDeals = 0;
    let filteredDiscussions = 0;
    let filteredDeals = 0;
    if (refresh) {
      rows[0].innerHTML = ``;
      rows[1].innerHTML = ``;
    } else {
      let preset = null;
      if (esgst.df && esgst.df_m && esgst.df_enable) {
        let name = esgst.df_preset;
        if (name) {
          let i;
          for (i = esgst.df_presets.length - 1; i > -1 && esgst.df_presets[i].name !== name; i--);
          if (i > -1) {
            preset = esgst.df_presets[i];
          }
        }
      }
      if (preset) {
        const filters = df_getFilters();
        (await discussions_get(rows[0], true)).forEach(discussion => {
          if (!filters_filterItem(`df`, filters, discussion, preset.rules)) {
            discussion.outerWrap.remove();
            filteredDiscussions += 1;
          } else {
            numDiscussions += 1;
          }
        });
        (await discussions_get(rows[1], true)).forEach(deal => {
          if (!filters_filterItem(`df`, filters, deal, preset.rules)) {
            deal.outerWrap.remove();
            filteredDeals += 1;
          } else {
            numDeals += 1;
          }
        });
      } else {
        numDiscussions = (await discussions_get(rows[0], true)).length;
        numDeals = (await discussions_get(rows[1], true)).length;
      }
    }
    if (numDiscussions < 5 || numDeals < 5) {
      let [response1, response2] = await Promise.all([request({method: `GET`, url: `/discussions`}), request({method: `GET`, url: `/discussions/deals`})]);
      let response1Html = parseHtml(response1.responseText);
      let response2Html = parseHtml(response2.responseText);
      let revisedElements = [];
      let preset = null;
      if (esgst.df && esgst.df_m && esgst.df_enable) {
        let name = esgst.df_preset;
        if (name) {
          let i;
          for (i = esgst.df_presets.length - 1; i > -1 && esgst.df_presets[i].name !== name; i--);
          if (i > -1) {
            preset = esgst.df_presets[i];
          }
        }
      }
      (await discussions_get(response1Html, true)).forEach(element => {
        if (element.category !== `Deals`) {
          revisedElements.push(element);
        }
      });
      const filters = df_getFilters();
      let i = revisedElements.length - (numDiscussions + filteredDiscussions + 1);
      while (numDiscussions < 5 && i > -1) {
        if (!preset || filters_filterItem(`df`, filters, revisedElements[i], preset.rules)) {
          setMissingDiscussion(revisedElements[i]);
          rows[0].appendChild(revisedElements[i].outerWrap);
          numDiscussions += 1;
        }
        i -= 1;
      }
      let elements = await discussions_get(response2Html, true);
      i = elements.length - (numDeals + filteredDeals + 1);
      while (numDeals < 5 && i > -1) {
        if (!preset || filters_filterItem(`df`, filters, elements[i], preset.rules)) {
          setMissingDiscussion(elements[i]);
          rows[1].appendChild(elements[i].outerWrap);
          numDeals += 1;
        }
        i -= 1;
      }
      if (esgst.adots) {
        adots_load(refresh);
      } else if (esgst.radb && !refresh) {
        radb_addButtons();
      }
      if (refresh) {
        await endless_load(esgst.activeDiscussions);
      }
      if (callback) {
        callback();
      }
    } else {
      if (esgst.adots) {
        adots_load();
      } else if (esgst.radb && !refresh) {
        radb_addButtons();
      }
      if (callback) {
        callback();
      }
    }
  }

  function loadMenu(tab) {
    let Container, SMManageFilteredUsers, SMAPIKey, popup, fixed;
    if (tab) {
      esgst.mainContext.innerHTML = `
        <div></div>
        <div class="esgst-popup-scrollable"></div>
      `;
      fixed = esgst.mainContext.firstElementChild;
      Container = fixed.nextElementSibling;
    } else {
      popup = new Popup(`fa-gear`, `Settings`, true, true);
      popup.description.classList.add(`esgst-text-left`);
      fixed = popup.description;
      Container = popup.scrollable;
    }
    fixed.insertAdjacentHTML(`afterBegin`, `
      <div class="esgst-page-heading"></div>
      <div class="esgst-clear-container">
        <input placeholder="Filter features..." type="text">
        <span class="esgst-clear-button esgst-hidden" title="Clear">X</span>
      </div>
    `);
    Container.innerHTML = `
      <div class="esgst-settings-menu"></div>
    `;
    const input = fixed.firstElementChild.nextElementSibling.firstElementChild;
    input.addEventListener(`input`, filterSm);
    input.addEventListener(`change`, filterSm);
    setClearButton(input);
    let heading = fixed.getElementsByClassName(`esgst-page-heading`)[0];
    createSMButtons(heading, [{
      Check: true,
      Icons: [`fa-refresh`],
      Name: `esgst-heading-button`,
      Title: `Sync data`
    }, {
      Check: true,
      Icons: [`fa-sign-in esgst-rotate-90`],
      Name: `esgst-heading-button`,
      Title: `Restore data`
    }, {
      Check: true,
      Icons: [`fa-sign-out esgst-rotate-270`],
      Name: `esgst-heading-button`,
      Title: `Backup data`
    }, {
      Check: true,
      Icons: [`fa-trash`],
      Name: `esgst-heading-button`,
      Title: `Delete data`
    }, {
      Check: true,
      Icons: [`fa-gear`, `fa-arrow-circle-down`],
      Name: `esgst-heading-button`,
      Title: `Download settings (downloads your settings to your computer without your personal data so you can easily share them with other users)`
    }, {
      Check: true,
      Icons: [`fa-paint-brush`],
      Name: `esgst-heading-button`,
      Title: `Clean old data`
    }, {
      Check: true,
      Icons: [`fa-user`, `fa-history`],
      Name: `SMViewUsernameChanges esgst-heading-button`,
      Title: `View recent username changes`
    }, {
      Check: esgst.uf,
      Icons: [`fa-user`, `fa-eye-slash`],
      Name: `SMManageFilteredUsers esgst-heading-button`,
      Title: `See list of filtered users`
    }, {
      Check: esgst.sg && esgst.gf && esgst.gf_s,
      Icons: [`fa-gift`, `fa-eye-slash`],
      Name: `SMManageFilteredGiveaways esgst-heading-button`,
      Title: `Manage hidden giveaways`
    }, {
      Check: esgst.sg && esgst.df && esgst.df_s,
      Icons: [`fa-comments`, `fa-eye-slash`],
      Name: `SMManageFilteredDiscussions esgst-heading-button`,
      Title: `Manage hidden discussions`
    }, {
      Check: esgst.sg && esgst.ut,
      Icons: [`fa-user`, `fa-tags`],
      Name: `SMManageUserTags esgst-heading-button`,
      Title: `Manage user tags`
    }, {
      Check: esgst.gt,
      Icons: [`fa-gamepad`, `fa-tags`],
      Name: `SMManageGameTags esgst-heading-button`,
      Title: `Manage game tags`
    }, {
      Check: esgst.wbc,
      Icons: [`fa-heart`, `fa-ban`, `fa-cog`],
      Name: `esgst-wbc-button esgst-heading-button`,
      Title: `Manage Whitelist / Blacklist Checker caches`
    }, {
      Check: esgst.namwc,
      Icons: [`fa-trophy`, `fa-cog`],
      Name: `esgst-namwc-button esgst-heading-button`,
      Title: `Manage Not Activated / Multiple Wins Checker caches`
    }, {
      Check: true,
      Icons: [`fa-bug`],
      Name: `esgst-heading-button`,
      Title: `Debug`
    }, {
      Check: true,
      Icons: [`fa-steam`],
      Name: `esgst-heading-button`,
      Title: `Request access to the Steam group`
    }]);
    Container.style.maxHeight = `${innerHeight - (Container.offsetTop + (esgst.ff ? 44 : 0) + 25)}px`;
    let SMMenu = Container.getElementsByClassName(`esgst-settings-menu`)[0];
    let i, type;
    i = 1;
    for (type in esgst.features) {
      if (type !== `trades` || esgst.settings.esgst_st) {
        let id, j, section, title, isNew = false;
        title = type.replace(/^./, m => { return m.toUpperCase() });
        section = createMenuSection(SMMenu, null, i, title, type);
        j = 1;
        for (id in esgst.features[type].features) {
          let feature, ft;
          feature = esgst.features[type].features[id];
          if (!feature.extensionOnly || _USER_INFO.extension) {
            ft = getSMFeature(feature, id, j);
            if (ft) {
              if (ft.isNew) {
                isNew = true;
              }
              section.lastElementChild.appendChild(ft.menu);
              j += 1;
            }
          }
        }
        if (isNew) {
          section.firstElementChild.lastElementChild.insertAdjacentHTML(`afterBegin`, `
            <span class="esgst-bold esgst-red" title="There is a new feature/option in this section">
              <i class="fa fa-star"></i>
            </span>
          `);
        }
        i += 1;
      }
    }
    createMenuSection(SMMenu, `
      <input class="esgst-steam-api-key" type="text"/>
      <div class="esgst-description">This is optional for syncing owned games faster and required for syncing alt accounts. Get a Steam API Key <a class="esgst-bold" href="https://steamcommunity.com/dev/apikey" target="_blank">here</a>. You can enter any domain in there, it is irrelevant, for example, "https://www.steamgifts.com".</div>
    `, i, `Steam API Key`);
    SMManageFilteredUsers = fixed.getElementsByClassName(`SMManageFilteredUsers`)[0];
    let SMManageFilteredGiveaways = fixed.getElementsByClassName(`SMManageFilteredGiveaways`)[0];
    let SMManageFilteredDiscussions = fixed.getElementsByClassName(`SMManageFilteredDiscussions`)[0];
    let SMManageUserTags = fixed.getElementsByClassName(`SMManageUserTags`)[0];
    let SMManageGameTags = fixed.getElementsByClassName(`SMManageGameTags`)[0];
    let SMViewUsernameChanges = fixed.getElementsByClassName(`SMViewUsernameChanges`)[0];
    if (esgst.wbc) {
      wbc_addButton(null, fixed.getElementsByClassName(`esgst-wbc-button`)[0]);
    }
    if (esgst.namwc) {
      namwc_setPopup({
        button: fixed.getElementsByClassName(`esgst-namwc-button`)[0],
        isMenu: true
      });
    }
    SMAPIKey = Container.getElementsByClassName(`esgst-steam-api-key`)[0];
    let key = esgst.steamApiKey;
    if (key) {
      SMAPIKey.value = key;
    }
    heading.firstElementChild.addEventListener(`click`, async () => {
      heading.firstElementChild.classList.add(`esgst-busy`);
      await checkSync(true, true);
      heading.firstElementChild.classList.remove(`esgst-busy`);
    });
    heading.firstElementChild.nextElementSibling.addEventListener(`click`, loadDataManagement.bind(null, false, `import`, null));
    heading.firstElementChild.nextElementSibling.nextElementSibling.addEventListener(`click`, loadDataManagement.bind(null, false, `export`, null));
    heading.firstElementChild.nextElementSibling.nextElementSibling.nextElementSibling.addEventListener(`click`, loadDataManagement.bind(null, false, `delete`, null));
    heading.firstElementChild.nextElementSibling.nextElementSibling.nextElementSibling.nextElementSibling.addEventListener(`click`, exportSettings);
    heading.firstElementChild.nextElementSibling.nextElementSibling.nextElementSibling.nextElementSibling.nextElementSibling.addEventListener(`click`, loadDataCleaner);
    heading.lastElementChild.previousElementSibling.addEventListener(`click`, debug);
    if (esgst.groups) {
      for (i = esgst.groups.length - 1; i > -1 && esgst.groups[i].steamId !== `103582791461018688`; i--);
      if (i < 0 || !esgst.groups[i] || !esgst.groups[i].member) {
        heading.lastElementChild.addEventListener(`click`, requestGroupInvite);
      } else {
        heading.lastElementChild.classList.add(`esgst-hidden`);
      }
    } else {
      heading.lastElementChild.classList.add(`esgst-hidden`);
    }
    if (SMManageUserTags) {
      SMManageUserTags.addEventListener(`click`, openManageUserTagsPopup);
    }
    if (SMManageGameTags) {
      SMManageGameTags.addEventListener(`click`, openManageGameTagsPopup);
    }
    if (SMManageFilteredUsers) {
      setSMManageFilteredUsers(SMManageFilteredUsers);
    }
    if (SMManageFilteredGiveaways) {
      setSMManageFilteredGiveaways(SMManageFilteredGiveaways);
    }
    if (SMManageFilteredDiscussions) {
      SMManageFilteredDiscussions.addEventListener(`click`, df_menu.bind(null, {}));
    }
    if (SMViewUsernameChanges) {
      setSMRecentUsernameChanges(SMViewUsernameChanges);
    }
    SMAPIKey.addEventListener(`input`, () => {
      setSetting(`steamApiKey`, SMAPIKey.value);
    });
    if (!tab) {
      popup.open();
      if (esgst.firstInstall) {
        let pp = new Popup(`fa-check`, `Getting Started`, true);
        pp.scrollable.innerHTML = `
          <div class="esgst-bold">Here are some things you should know to help you get started:</div>
          <br/>
          <div class="markdown">
            <ul>
              <li>Bugs and suggestions should be reported on the <a href="https://github.com/revilheart/ESGST/issues">GitHub page</a>.</li>
              <li>Make sure you backup your data using the backup button at the top of the menu every once in a while to prevent any data loss that might occur. It's also probably a good idea to disable automatic updates, since ESGST is in constant development.</li>
              <li>Hover over the <i class="fa fa-question-circle"></i> icon next to each option that has it to learn more about it and how to use it. Some options are currently missing documentation, so feel free to ask about them in the official ESGST thread.</li>
              <li>Some features rely on sync to work properly. These features have a <i class="fa fa-refresh esgst-negative"></i> icon next to their names, and when you hover over the icon you can see what type of data you have to sync. You should sync often to keep your data up-to-date. ESGST offers an option to automatically sync your data for you every amount of days so you don't have to do it manually. To enable the automatic sync, simply go to the sync section of the menu (section 1) and select the number of days in the dropdown.</li>
              <li>ESGST uses 2 terms to define a window opened in the same page: <strong>popout</strong> is when the window opens up, down, left or right from the element you clicked/hovered over (like the one you get with the description of the features) and <strong>popup</strong> is when the window opens in the center of the screen with a modal background behind it (like this one).</li>
              <li>That's all for now, you can close this.</li>
            </ul>
          </div>
        `;
        pp.open();
        esgst.firstInstall = false;
      }
    }
  }

  function openPathsPopup(feature, id, name) {
    let obj = {
      excludeItems: [],
      includeItems: [],
      name: name,
      popup: new Popup(`fa-gear`, `[${name.toUpperCase()}] ${feature.name}`)
    };
    obj.popup.description.classList.add(`esgst-text-left`);
    obj.include = insertHtml(obj.popup.scrollable, `beforeEnd`, `
      <div class="esgst-bold">Include: <i class="fa fa-question-circle" title="Enter the paths where you want the feature to run here. You need to use regular expressions, so if you are not familiar with them, just to go to the page where you want the feature to run and click 'Add Current'. '.*' means that the feature runs everywhere possible."></i></div>
      <div></div>
    `);
    let group = insertHtml(obj.popup.scrollable, `beforeEnd`, `<div class="esgst-button-group"></div>`);
    group.appendChild(new ButtonSet_v2({color1: `grey`, color2: ``, icon1: `fa-plus-circle`, icon2: ``, title1: `Add New`, title2: ``, callback1: addPath.bind(null, `include`, obj, {enabled: 1, pattern: ``})}).set);
    group.appendChild(new ButtonSet_v2({color1: `grey`, color2: ``, icon1: `fa-plus-circle`, icon2: ``, title1: `Add Current`, title2: ``, callback1: addPath.bind(null, `include`, obj, {enabled: 1, pattern: `^${escapeRegExp(location.pathname)}${escapeRegExp(location.search)}`})}).set);
    obj.exclude = insertHtml(obj.popup.scrollable, `beforeEnd`, `
      <div class="esgst-bold">Exclude: <i class="fa fa-question-circle" title="Enter the paths where you do not want the feature to run here. This acts as an exception to the included paths, as in, the feature will run in every included path, except for the excluded paths. You need to use regular expressions, so if you are not familiar with them, just to go to the page where you do not want the feature to run and click 'Add Current'."></i></div>
      <div></div>
    `);
    group = insertHtml(obj.popup.scrollable, `beforeEnd`, `<div class="esgst-button-group"></div>`);
    group.appendChild(new ButtonSet_v2({color1: `grey`, color2: ``, icon1: `fa-plus-circle`, icon2: ``, title1: `Add New`, title2: ``, callback1: addPath.bind(null, `exclude`, obj, {enabled: 1, pattern: ``})}).set);
    group.appendChild(new ButtonSet_v2({color1: `grey`, color2: ``, icon1: `fa-plus-circle`, icon2: ``, title1: `Add Current`, title2: ``, callback1: addPath.bind(null, `exclude`, obj, {enabled: 1, pattern: `^${escapeRegExp(location.pathname)}${escapeRegExp(location.search)}`})}).set);
    obj.popup.description.appendChild(new ButtonSet_v2({color1: `green`, color2: `grey`, icon1: `fa-check-circle`, icon2: `fa-circle-o-notch fa-spin`, title1: `Save`, title2: `Saving...`, callback1: savePaths.bind(null, id, obj)}).set);
    obj.setting = getFeaturePath(feature, id, obj.name);
    obj.setting.include.forEach(path => addPath(`include`, obj, path));
    obj.setting.exclude.forEach(path => addPath(`exclude`, obj, path));
    obj.popup.open();
  }

  function addPath(key, obj, path) {
    let item = {};
    item.container = insertHtml(obj[key], `beforeEnd`, `<div></div>`);
    item.switch = new ToggleSwitch(item.container, null, true, ``, false, false, null, path.enabled);
    item.input = insertHtml(item.container, `beforeEnd`, `
      <input class="esgst-switch-input esgst-switch-input-large" type="text">
    `);
    item.input.value = path.pattern;
    item.input.addEventListener(`input`, validatePathRegex.bind(null, item));
    insertHtml(item.container, `beforeEnd`, `
      <i class="fa fa-times-circle esgst-clickable" title="Remove"></i>
    `).addEventListener(`click`, removePath.bind(null, item, key, obj));
    item.invalid = insertHtml(item.container, `beforeEnd`, `
      <i class="fa fa-exclamation esgst-hidden esgst-red" title="Invalid Regular Expression"></i>
    `);
    obj[`${key}Items`].push(item);
    item.input.focus();
  }

  function removePath(item, key, obj) {
    let i = obj[`${key}Items`].length - 1;
    if (i === 0 && key === `include`) {
        alert(`At least 1 include path is required!`);
      return;
    }
    while (i > -1 && obj[`${key}Items`][i].input.value !== item.input.value) i--;
    if (i > -1) {
      obj[`${key}Items`].splice(i, 1);
    }
    item.container.remove();
  }

  function validatePathRegex(item) {
    item.invalid.classList.add(`esgst-hidden`);
    try {
      new RegExp(item.input.value);
    } catch (error) {
      console.log(error);
      item.invalid.classList.remove(`esgst-hidden`);
    }
  }

  function savePaths(id, obj) {
    obj.setting.include = [];
    obj.setting.exclude = [];
    for (let i = 0, n = obj.includeItems.length; i < n; i++) {
      obj.setting.include.push({enabled: obj.includeItems[i].switch.value ? 1 : 0, pattern: obj.includeItems[i].input.value});
    }
    for (let i = 0, n = obj.excludeItems.length; i < n; i++) {
      obj.setting.exclude.push({enabled: obj.excludeItems[i].switch.value ? 1 : 0, pattern: obj.excludeItems[i].input.value});
    }
    obj.popup.close();
    setSetting(`${id}_${obj.name}`, obj.setting);
  }

  function dismissNewOption(id, event) {
    event.currentTarget.remove();
    if (esgst.dismissedOptions.indexOf(id) < 0) {
      esgst.dismissedOptions.push(id);
      setSetting(`dismissedOptions`, esgst.dismissedOptions);
    }
  }

  function getSMFeature(Feature, ID, aaa) {
    let Menu, SMFeatures, isMainNew = false;
    Menu = document.createElement(`div`);
    Menu.id = `esgst_${ID}`;
    Menu.insertAdjacentHTML(`beforeEnd`, `
      <div class="esgst-sm-small-number esgst-form-heading-number">${aaa}.</div>
    `);
    let val, val1, val2;
    let siwtchSg, siwtchSt, set1, set2;
    if (Feature.sg) {
      set1 = getFeaturePath(Feature, ID, `sg`);
      val1 = set1.enabled;
      siwtchSg = new ToggleSwitch(Menu, ID, true, esgst.settings.esgst_st ? `[SG]` : ``, true, false, null, val1);
      insertHtml(Menu, `beforeEnd`, `<i class="fa fa-gear esgst-clickable" title="Customize where the feature runs"></i>`).addEventListener(`click`, openPathsPopup.bind(null, Feature, ID, `sg`));
      if (Feature.conflicts) {
        siwtchSg.onEnabled = () => {
          for (let ci = 0, cn = Feature.conflicts.length; ci < cn; ++ci) {
            let setting = esgst.settings[`${Feature.conflicts[ci].id}_sg`];
            if ((setting.include && setting.enabled) || (!setting.include && setting)) {
              siwtchSg.disable();
              new Popup(`fa-exclamation`, `This feature conflicts with ${Feature.conflicts[ci].name}. While that feature is enabled, this feature cannot be enabled.`, true).open();
              ci = cn;
            }
          }
          if (Feature.theme && SMFeatures) {
            if (ID === `customTheme`) {
              setTheme();
            } else {
              SMFeatures.firstElementChild.lastElementChild.previousElementSibling.click();
            }
          }
        }
      } else if (Feature.theme) {
        siwtchSg.onEnabled = () => {
          if (SMFeatures) {
            if (ID === `customTheme`) {
              setTheme();
            } else {
              SMFeatures.firstElementChild.lastElementChild.previousElementSibling.click();
            }
          }
        }
      }
      if (Feature.theme) {
        siwtchSg.onDisabled = () => {
          if (ID === `customTheme`) {
            delLocalValue(`customTheme`);
          } else {
            delLocalValue(`theme`);
            delValue(ID);
          }
          setTheme();
        };
      }
    }
    if (Feature.st && (esgst.settings.esgst_st || ID === `esgst`)) {
      set2 = getFeaturePath(Feature, ID, `st`);
      val2 = set2.enabled;
      siwtchSt = new ToggleSwitch(Menu, ID, true, `[ST]`, false, true, null, val2);
      insertHtml(Menu, `beforeEnd`, `<i class="fa fa-gear esgst-clickable" title="Customize where the feature runs"></i>`).addEventListener(`click`, openPathsPopup.bind(null, Feature, ID, `st`));
      if (Feature.conflicts) {
        siwtchSt.onEnabled = () => {
          for (let ci = 0, cn = Feature.conflicts.length; ci < cn; ++ci) {
            let setting = esgst.settings[`${Feature.conflicts[ci].id}_st`];
            if ((setting.include && setting.enabled) || (!setting.include && setting)) {
              siwtchSt.disable();
              new Popup(`fa-exclamation`, `This feature conflicts with ${Feature.conflicts[ci].name}. While that feature is enabled, this feature cannot be enabled.`, true).open();
              ci = cn;
            }
          }
          if (Feature.theme && SMFeatures) {
            if (ID === `customTheme`) {
              setTheme();
            } else {
              SMFeatures.firstElementChild.lastElementChild.previousElementSibling.click();
            }
          }
        }
      } else if (Feature.theme) {
        siwtchSt.onEnabled = () => {
          if (SMFeatures) {
            if (ID === `customTheme`) {
              setTheme();
            } else {
              SMFeatures.firstElementChild.lastElementChild.previousElementSibling.click();
            }
          }
        }
      }
      if (Feature.theme) {
        siwtchSt.onDisabled = () => {
          if (ID !== `customTheme`) {
            delValue(ID);
          }
          setTheme();
        };
      }
    }
    if (!siwtchSg && !siwtchSt) {
      Menu.lastElementChild.remove();
      return null;
    }
    isMainNew = esgst.dismissedOptions.indexOf(ID) < 0 && (!set1 || set1.new) && (!set2 || set2.new);
    if (isMainNew) {
      insertHtml(Menu.firstElementChild, `afterEnd`, `
        <span class="esgst-bold esgst-red esgst-clickable" title="This is a new feature/option. Click to dismiss.">[NEW]</span>
      `).addEventListener(`click`, dismissNewOption.bind(null, ID));
    }
    val = val1 || val2;
    Menu.insertAdjacentHTML(`beforeEnd`, `
      <span>${esgst.settings.esgst_st ? `- ` : ``}${Feature.name}</span> ${Feature.features ? `<i class="fa fa-ellipsis-h" title="This option has sub-options"></i>` : ``} ${Feature.sync ? `<i class="esgst-negative fa fa-refresh" title="This feature requires ${Feature.sync} data to be synced (section 1 of this menu)"></i>` : ``} ${Feature.description ? `<i class="fa fa-question-circle esgst-clickable"></i>` : ``}
      <div class="esgst-form-row-indent SMFeatures esgst-hidden"></div>
    `);
    SMFeatures = Menu.lastElementChild;
    if (Feature.description) {
      let popout = null;
      let tooltip = SMFeatures.previousElementSibling;
      tooltip.addEventListener(`mouseenter`, () => {
        if (popout) {
          popout.open(tooltip);
        } else {
          popout = new Popout(`esgst-feature-description markdown`, tooltip, 100);
          popout.popout.style.maxHeight = `300px`;
          popout.popout.style.overflow = `auto`;
          popout.popout.innerHTML = Feature.description.replace(/\[id=(.+?)\]/g, getFeatureName);
          popout.open(tooltip);
        }
      });
    }
    if (Feature.features) {
      let ft, i, id, isNew = false;
      i = 1;
      for (id in Feature.features) {
        if (!Feature.features[id].extensionOnly || _USER_INFO.extension) {
          ft = getSMFeature(Feature.features[id], id, i);
          if (ft) {
            if (ft.isNew) {
              isNew = true;
            }
            SMFeatures.appendChild(ft.menu);
            i += 1;
          }
        }
      }
      if (siwtchSg) {
        siwtchSg.dependencies.push(SMFeatures);
      }
      if (siwtchSt) {
        siwtchSt.dependencies.push(SMFeatures);
      }
      if (val) {
        SMFeatures.classList.remove(`esgst-hidden`);
      }
      isMainNew = isMainNew || isNew;
      if (isNew) {
        Menu.firstElementChild.insertAdjacentHTML(`afterEnd`, `
          <span class="esgst-bold esgst-red" title="There is a new feature/option in this section">
            <i class="fa fa-star"></i>
          </span>
        `);
      }
    }
    if (ID === `gc`) {
      addGcCategoryPanel(SMFeatures, `gc_categories`);
      if (esgst.gv) {
        addGcCategoryPanel(SMFeatures, `gc_categories_gv`);
      }
      SMFeatures.classList.remove(`esgst-hidden`);
    } else if (ID === `gch`) {
      addGwcrMenuPanel(SMFeatures, `gch_colors`, `copies`, true);
      SMFeatures.classList.remove(`esgst-hidden`);
    } else if (ID === `gwc`) {
      addGwcrMenuPanel(SMFeatures, `gwc_colors`, `chance`);
      SMFeatures.classList.remove(`esgst-hidden`);
    } else if (ID === `gwr`) {
      addGwcrMenuPanel(SMFeatures, `gwr_colors`, `ratio`);
      SMFeatures.classList.remove(`esgst-hidden`);
    } else if (ID === `geth`) {
      addGwcrMenuPanel(SMFeatures, `geth_colors`, `hours`);
      SMFeatures.classList.remove(`esgst-hidden`);
    } else if (ID === `gc_r`) {
      addGcRatingPanel(SMFeatures);
      SMFeatures.classList.remove(`esgst-hidden`);
    } else if (ID === `gc_o_a`) {
      addGcAltMenuPanel(SMFeatures);
      SMFeatures.classList.remove(`esgst-hidden`);
    } else if (ID === `lockGiveawayColumns`) {
      let select = insertHtml(SMFeatures, `beforeEnd`, `
        <div class="esgst-sm-colors">
          Select an option below and click on the button to reset the order:
          <br>
          <select>
            <option value="giveawayColumns">Giveaway Columns [${esgst.giveawayColumns.join(`, `)}]</option>
            <option value="giveawayPanel">Giveaway Panel [${esgst.giveawayPanel.join(`, `)}]</option>
            <option value="giveawayColumns_gv">Giveaway Columns (Grid View) [${esgst.giveawayColumns_gv.join(`, `)}]</option>
            <option value="giveawayPanel_gv">Giveaway Panel (Grid View) [${esgst.giveawayPanel_gv.join(`, `)}]</option>
          </select>
          <br>
          <div class="form__saving-button esgst-sm-colors-default">Reset Order</div>
        </div>
      `).firstElementChild.nextElementSibling;
      select.nextElementSibling.nextElementSibling.addEventListener(`click`, resetOrder.bind(null, select));
      SMFeatures.classList.remove(`esgst-hidden`);
    } else if (Feature.colors || Feature.background) {
      let color = esgst[`${ID}_color`];
      let bgColor = esgst[`${ID}_bgColor`];
      let html = `
        <div class="esgst-sm-colors">
          ${Feature.background ? `` : `Text: <input type="color" value="${color}">`}
          Background: <input type="color" value="${bgColor}">
          <div class="form__saving-button esgst-sm-colors-default">Use Default</div>
        </div>
      `;
      SMFeatures.insertAdjacentHTML(`beforeEnd`, html);
      let colorContext = SMFeatures.lastElementChild.firstElementChild;
      let bgColorContext = Feature.background ? colorContext : colorContext.nextElementSibling;
      if (!Feature.background) {
        addColorObserver(colorContext, ID, `color`);
      }
      addColorObserver(bgColorContext, ID, `bgColor`);
      bgColorContext.nextElementSibling.addEventListener(`click`, resetColor.bind(null, bgColorContext, Feature.background ? null : colorContext, ID));
      if (ID === `gc_g`) {
        let input = insertHtml(SMFeatures, `beforeEnd`, `
          <div class="esgst-sm-colors">
            Only show the following genres: <input type="text" value="${esgst.gc_g_filters}">
            <i class="fa fa-question-circle" title="If you enter genres here, a genre category will only appear if the game has the listed genre. Separate genres with a comma, for example: Genre1, Genre2"></i>
          </div>
        `);
        observeChange(input.firstElementChild, `gc_g_filters`);
        addGcMenuPanel(SMFeatures);
      }
      if (Feature.input) {
        let input = insertHtml(SMFeatures, `beforeEnd`, `
          <div class="esgst-sm-colors">
            Icon: <input type="text" value="${esgst[`${ID}Icon`]}"> <i class="esgst-clickable fa fa-question-circle"></i>
            <br/>
            Label: <input type="text" value="${esgst[`${ID}Label`]}">
          </div>
        `);
        createTooltip(input.firstElementChild.nextElementSibling, `The name of the icon must be any name in this page: <a href="https://fontawesome.com/v4.7.0/icons/">https://fontawesome.com/v4.7.0/icons/</a>`);
        let icon = input.firstElementChild;
        let label = input.lastElementChild;
        observeChange(icon, `${ID}Icon`);
        observeChange(label, `${ID}Label`);
        if (ID === `gc_rd`) {
          input.insertAdjacentHTML(`beforeEnd`, `<i class="fa fa-question-circle" title="Enter the date format here, using the following keywords:\n\nDD - Day\nMM - Month in numbers (i.e. 1)\nMon - Month in short name (i.e. Jan)\nMonth - Month in full name (i.e. January)\nYYYY - Year"></i>`)
        }
      }
      if (siwtchSg) {
        siwtchSg.dependencies.push(SMFeatures);
      }
      if (siwtchSt) {
        siwtchSt.dependencies.push(SMFeatures);
      }
      if (val) {
        SMFeatures.classList.remove(`esgst-hidden`);
      }
    } else if (Feature.inputItems) {
      let container = insertHtml(SMFeatures, `beforeEnd`, `
        <div class="esgst-sm-colors"></div>
      `);
      if (ID.match(/^(chfl|sk_)/)) {
        Feature.inputItems = [
          {
            event: `keydown`,
            id: Feature.inputItems,
            shortcutKey: true,
            prefix: `Enter the key combo you want to use for this task: `
          }
        ]
      } else if (ID.match(/^hr_.+_s$/)) {
        Feature.inputItems = [
          {
            id: `${ID}_sound`,
            play: true
          }
        ];
      }
      Feature.inputItems.forEach(item => {
        let input,
          value = ``,
          context = insertHtml(container, `beforeEnd`, `
            <div>${item.play ? `
              <input type="file" style="width: 200px;">
              <i class="fa fa-play-circle esgst-clickable"></i>
            ` : `
              ${item.prefix || ``}<input class="esgst-switch-input esgst-switch-input-large" type="text" value="${esgst[item.id]}">${item.suffix || ``}${item.tooltip ? ` <i class="fa fa-question-circle" title="${item.tooltip}"></i>` : ``}
            `}</div>
          `);
        input = context.firstElementChild;
        if (item.play) {
          input.nextElementSibling.addEventListener(`click`, async () => (await hr_createPlayer(esgst.settings[item.id] || hr_getDefaultSound())).play());
        }
        if (typeof esgst.settings[item.id] === `undefined` && esgst.dismissedOptions.indexOf(item.id) < 0) {
          isMainNew = true;
          insertHtml(context, `afterBegin`, `
            <span class="esgst-bold esgst-red esgst-clickable" title="This is a new feature/option. Click to dismiss.">[NEW]</span>
          `).addEventListener(`click`, dismissNewOption.bind(null, item.id));
        }
        input.addEventListener(item.event || `change`, event => {
          if (item.shortcutKey) {
            event.preventDefault();
            event.stopPropagation();
            if (!event.repeat) {
              value = ``;
              if (event.ctrlKey) {
                value += `ctrlKey + `;
              } else if (event.shiftKey) {
                value += `shiftKey + `;
              } else if (event.altKey) {
                value += `altKey + `;
              }
              value += event.key.toLowerCase();
            }
          } else if (item.play) {
            readHrAudioFile(ID, event);
          } else if (item.event === `keydown`) {
            event.preventDefault();
            setSetting(item.id, event.key);
            esgst[item.id] = event.key;
            input.value = event.key;
          } else {
            setSetting(item.id, input.value);
            esgst[item.id] = input.value;
          }
        }, item.shortcutKey || false);
        if (item.shortcutKey) {
          input.addEventListener(`keyup`, () => {
            setSetting(item.id, value);
            esgst[item.id] = value;
            input.value = value;
          });
        }
      });
      if (siwtchSg) {
        siwtchSg.dependencies.push(SMFeatures);
      }
      if (siwtchSt) {
        siwtchSt.dependencies.push(SMFeatures);
      }
      if (val) {
        SMFeatures.classList.remove(`esgst-hidden`);
      }
    } else if (Feature.theme) {
      let container = insertHtml(SMFeatures, `beforeEnd`, `
          <div class="esgst-sm-colors">
            Enabled from <input type="text" value="${esgst[`${ID}_startTime`]}"> to <input type="text" value="${esgst[`${ID}_endTime`]}"> <i class="fa fa-question-circle" title="You can specify here what time of the day you want the theme to be enabled. Use the HH:MM format."></i>
            <br/>
            ${ID === `customTheme` ? `
              <textarea></textarea>
            ` : `
              <div class="form__saving-button esgst-sm-colors-default">Update</div>
              <span></span>
            `}
          </div>
        `),
        startTime = container.firstElementChild,
        endTime = startTime.nextElementSibling;
      observeChange(startTime, `${ID}_startTime`);
      observeChange(endTime, `${ID}_endTime`);
      if (ID === `customTheme`) {
        let textArea = container.lastElementChild;
        getValue(ID).then(value => {
          if (!value) return;
          textArea.value = JSON.parse(value);
        });
        textArea.addEventListener(`change`, async () => {
          await setValue(ID, JSON.stringify(textArea.value));
          setTheme();
        });
      } else {
        let version = container.lastElementChild,
          button = version.previousElementSibling;
        setThemeVersion(ID, version);
        button.addEventListener(`click`, async () => {
          let url = await getThemeUrl(ID, Feature.theme);
          button.innerHTML = `
            <i class="fa fa-circle-o-notch fa-spin"></i> Updating...
          `;
          let theme = JSON.stringify((await request({method: `GET`, url})).responseText);
          await setValue(ID, theme);
          button.innerHTML = `Update`;
          setThemeVersion(ID, version, theme);
          setTheme();
        });
      }
      if (siwtchSg) {
        siwtchSg.dependencies.push(SMFeatures);
      }
      if (siwtchSt) {
        siwtchSt.dependencies.push(SMFeatures);
      }
      if (val) {
        SMFeatures.classList.remove(`esgst-hidden`);
      }
    }
    if (Feature.options) {
      let index = esgst[`${ID}_index`];
      let options = ``;
      for (let j = 0, jj = Feature.options.values.length; j < jj; ++j) {
        options += `<option>${Feature.options.values[j]}</option>`;
      }
      let select = insertHtml(SMFeatures, `beforeEnd`, `
        <div class="esgst-sm-colors">
          ${Feature.options.title}
          <select>
            ${options}
          </select>
        </div>
      `);
      select.firstElementChild.selectedIndex = index;
      observeNumChange(select.firstElementChild, `${ID}_index`, `selectedIndex`);
      if (siwtchSg) {
        siwtchSg.dependencies.push(SMFeatures);
      }
      if (siwtchSt) {
        siwtchSt.dependencies.push(SMFeatures);
      }
      if (val) {
        SMFeatures.classList.remove(`esgst-hidden`);
      }
    }
    return {
      isNew: isMainNew,
      menu: Menu
    };
  }

  function addGcCategoryPanel(context, categoryKey) {
    let elements = [];
    for (let i = 0, n = esgst[categoryKey].length; i < n; i++) {
      switch (esgst[categoryKey][i]) {
        case `gc_fcv`:
          elements.push(`
            <div class="esgst-clickable esgst-gc esgst-gc-fullCV ${esgst.gc_fcv ? `` : `esgst-hidden`}" draggable="true" id="gc_fcv" title="Full CV">${esgst.gc_fcv_s ? (esgst.gc_fcv_s_i ? `<i class="fa fa-${esgst.gc_fcvIcon}"></i>` : `FCV`) : esgst.gc_fcvLabel}</div>
          `);
          break;
        case `gc_rcv`:
          elements.push(`
            <div class="esgst-clickable esgst-gc esgst-gc-reducedCV ${esgst.gc_rcv ? `` : `esgst-hidden`}" draggable="true" id="gc_rcv" title="Reduced CV">${esgst.gc_rcv_s ? (esgst.gc_rcv_s_i ? `<i class="fa fa-${esgst.gc_rcvIcon}"></i>` : `RCV`) : esgst.gc_rcvLabel}</div>
          `);
          break;
        case `gc_ncv`:
          elements.push(`
            <div class="esgst-clickable esgst-gc esgst-gc-noCV ${esgst.gc_ncv ? `` : `esgst-hidden`}" draggable="true" id="gc_ncv" title="No CV">${esgst.gc_ncv_s ? (esgst.gc_ncv_s_i ? `<i class="fa fa-${esgst.gc_ncvIcon}"></i>` : `NCV`) : esgst.gc_ncvLabel}</div>
          `);
          break;
        case `gc_h`:
          elements.push(`
            <div class="esgst-clickable esgst-gc esgst-gc-hidden ${esgst.gc_h ? `` : `esgst-hidden`}" draggable="true" id="gc_h" title="Hidden">${esgst.gc_h_s ? (esgst.gc_h_s_i ? `<i class="fa fa-${esgst.gc_hIcon}"></i>` : `H`) : esgst.gc_hLabel}</div>
          `);
          break;
        case `gc_i`:
          elements.push(`
            <div class="esgst-clickable esgst-gc esgst-gc-ignored ${esgst.gc_i ? `` : `esgst-hidden`}" draggable="true" id="gc_i" title="Ignored">${esgst.gc_i_s ? (esgst.gc_i_s_i ? `<i class="fa fa-${esgst.gc_iIcon}"></i>` : `I`) : esgst.gc_iLabel}</div>
          `);
          break;
        case `gc_o`:
          elements.push(`
            <div class="esgst-clickable esgst-gc esgst-gc-owned ${esgst.gc_o ? `` : `esgst-hidden`}" draggable="true" id="gc_o" title="Owned">${esgst.gc_o_s ? (esgst.gc_o_s_i ? `<i class="fa fa-${esgst.gc_oIcon}"></i>` : `O`) : esgst.gc_oLabel}</div>
          `);
          esgst.gc_o_altAccounts.forEach(account => {
            elements.push(`
              <div class="esgst-clickable esgst-gc esgst-gc-owned ${esgst.gc_o_a ? `` : `esgst-hidden`}" draggable="true" id="gc_o" style="background-color: ${account.bgColor}; color: ${account.color};" title="Owned by ${account.name}">${esgst.gc_o_s ? (esgst.gc_o_s_i ? `<i class="fa fa-${account.icon}"></i>` : `O`) : account.label}</div>
            `);
          });
          break;
        case `gc_w`:
          elements.push(`
            <div class="esgst-clickable esgst-gc esgst-gc-wishlisted ${esgst.gc_w ? `` : `esgst-hidden`}" draggable="true" id="gc_w" title="Wishlisted">${esgst.gc_w_s ? (esgst.gc_w_s_i ? `<i class="fa fa-${esgst.gc_wIcon}"></i>` : `W`) : esgst.gc_wLabel}</div>
          `);
          break;
        case `gc_pw`:
          elements.push(`
            <div class="esgst-clickable esgst-gc esgst-gc-won ${esgst.gc_pw ? `` : `esgst-hidden`}" draggable="true" id="gc_pw" title="Previously Won">${esgst.gc_pw_s ? (esgst.gc_pw_s_i ? `<i class="fa fa-${esgst.gc_pwIcon}"></i>` : `PW`) : esgst.gc_pwLabel}</div>
          `);
          break;
        case `gc_gi`:
          elements.push(`
            <div class="esgst-clickable esgst-gc esgst-gc-giveawayInfo ${esgst.gc_gi ? `` : `esgst-hidden`}" draggable="true" id="gc_gi" title="Giveaway Info"><i class="fa fa-info"></i> 0 <i class="fa fa-dollar"></i> 0</div>
          `);
          break;
        case `gc_r`:
          elements.push(`
            <div class="esgst-clickable esgst-gc esgst-gc-rating esgst-gc-rating-positive ${esgst.gc_r ? `` : `esgst-hidden`}" draggable="true" id="gc_r" title="Rating"><i class="fa fa-thumbs-up"></i>${esgst.gc_r_s ? ` 0% (0)` : ``}</div>
          `);
          break;
        case `gc_a`:
          elements.push(`
            <div class="esgst-clickable esgst-gc esgst-gc-achievements ${esgst.gc_a ? `` : `esgst-hidden`}" draggable="true" id="gc_a" title="Achievements">${esgst.gc_a_s ? (esgst.gc_a_s_i ? `<i class="fa fa-${esgst.gc_aIcon}"></i>` : `A`) : esgst.gc_aLabel}</div>
          `);
          break;
        case `gc_mp`:
          elements.push(`
            <div class="esgst-clickable esgst-gc esgst-gc-multiplayer ${esgst.gc_mp ? `` : `esgst-hidden`}" draggable="true" id="gc_mp" title="Multiplayer">${esgst.gc_mp_s ? (esgst.gc_mp_s_i ? `<i class="fa fa-${esgst.gc_mpIcon}"></i>` : `MP`) : esgst.gc_mpLabel}</div>
          `);
          break;
        case `gc_sc`:
          elements.push(`
            <div class="esgst-clickable esgst-gc esgst-gc-steamCloud ${esgst.gc_sc ? `` : `esgst-hidden`}" draggable="true" id="gc_sc" title="Steam Cloud">${esgst.gc_sc_s ? (esgst.gc_sc_s_i ? `<i class="fa fa-${esgst.gc_scIcon}"></i>` : `SC`) : esgst.gc_scLabel}</div>
          `);
          break;
        case `gc_tc`:
          elements.push(`
            <div class="esgst-clickable esgst-gc esgst-gc-tradingCards ${esgst.gc_tc ? `` : `esgst-hidden`}" draggable="true" id="gc_tc" title="Trading Cards">${esgst.gc_tc_s ? (esgst.gc_tc_s_i ? `<i class="fa fa-${esgst.gc_tcIcon}"></i>` : `TC`) : esgst.gc_tcLabel}</div>
          `);
          break;
        case `gc_l`:
          elements.push(`
            <div class="esgst-clickable esgst-gc esgst-gc-linux ${esgst.gc_l ? `` : `esgst-hidden`}" draggable="true" id="gc_l" title="Linux">${esgst.gc_l_s ? (esgst.gc_l_s_i ? `<i class="fa fa-${esgst.gc_lIcon}"></i>` : `L`) : esgst.gc_lLabel}</div>
          `);
          break;
        case `gc_m`:
          elements.push(`
            <div class="esgst-clickable esgst-gc esgst-gc-mac ${esgst.gc_m ? `` : `esgst-hidden`}" draggable="true" id="gc_m" title="Mac">${esgst.gc_m_s ? (esgst.gc_m_s_i ? `<i class="fa fa-${esgst.gc_mIcon}"></i>` : `M`) : esgst.gc_mLabel}</div>
          `);
          break;
        case `gc_dlc`:
          elements.push(`
            <div class="esgst-clickable esgst-gc esgst-gc-dlc ${esgst.gc_dlc ? `` : `esgst-hidden`}" draggable="true" id="gc_dlc" title="DLC">${esgst.gc_dlc_s ? (esgst.gc_dlc_s_i ? `<i class="fa fa-${esgst.gc_dlcIcon}"></i>` : `DLC`) : esgst.gc_dlcLabel}</div>
          `);
          break;
        case `gc_p`:
          elements.push(`
            <div class="esgst-clickable esgst-gc esgst-gc-package ${esgst.gc_p ? `` : `esgst-hidden`}" draggable="true" id="gc_p" title="Package">${esgst.gc_p_s ? (esgst.gc_p_s_i ? `<i class="fa fa-${esgst.gc_pIcon}"></i>` : `P`) : esgst.gc_pLabel}</div>
          `);
          break;
        case `gc_ea`:
          elements.push(`
            <div class="esgst-clickable esgst-gc esgst-gc-earlyAccess ${esgst.gc_ea ? `` : `esgst-hidden`}" draggable="true" id="gc_ea" title="Early Access">${esgst.gc_ea_s ? (esgst.gc_ea_s_i ? `<i class="fa fa-${esgst.gc_eaIcon}"></i>` : `EA`) : esgst.gc_eaLabel}</div>
          `);
          break;
        case `gc_rm`:
          elements.push(`
            <div class="esgst-clickable esgst-gc esgst-gc-removed ${esgst.gc_rm ? `` : `esgst-hidden`}" draggable="true" id="gc_rm" title="Removed">${esgst.gc_rm_s ? (esgst.gc_rm_s_i ? `<i class="fa fa-${esgst.gc_rmIcon}"></i>` : `RM`) : esgst.gc_rmLabel}</div>
          `);
          break;
        case `gc_rd`:
          elements.push(`
            <div class="esgst-clickable esgst-gc esgst-gc-releaseDate ${esgst.gc_rd ? `` : `esgst-hidden`}" draggable="true" id="gc_rd" title="Release Date">
              <i class="fa fa-${esgst.gc_rdIcon}"></i> ${gc_formatDate(Date.now())}
            </div>
          `);
          break;
        case `gc_g`:
          elements.push(`
            <div class="esgst-clickable esgst-gc esgst-gc-genres ${esgst.gc_g ? `` : `esgst-hidden`}" draggable="true" id="gc_g" title="Genres">Genres</div>
          `);
          break;
      }
    }
    let sm = {
      categoryKey,
      panel: insertHtml(context, `beforeEnd`, `
        ${categoryKey === `gc_categories_gv` ? `<div class="esgst-description esgst-bold">Grid View</div>` : ``}
        <div class="esgst-description">Drag the categories to sort them.</div>
        <div class="esgst-gc-panel">${elements.join(``)}</div>
      `)
    };
    for (let i = 0, n = sm.panel.children.length; i < n; i++) {
      let child = sm.panel.children[i];
      child.addEventListener(`dragstart`, setSmSource.bind(null, child, sm));
      child.addEventListener(`dragenter`, getSmSource.bind(null, child, sm));
      child.addEventListener(`dragend`, saveSmSource.bind(null, sm));
    }
  }

  function readHrAudioFile(id, event) {
    let popup = new Popup(`fa-circle-o-notch fa-spin`, `Uploading...`);
    popup.open();
    try {
      let reader = new FileReader();
      reader.onload = saveHrFile.bind(null, id, popup, reader);
      reader.readAsArrayBuffer(event.currentTarget.files[0]);
    } catch (e) {
      console.log(e);
      popup.icon.classList.remove(`fa-circle-o-notch`);
      popup.icon.classList.remove(`fa-spin`);
      popup.icon.classList.add(`fa-times`);
      popup.title.textContent = `An error happened.`;
    }
  }

  async function saveHrFile(id, popup, reader) {
    try {
      let bytes = new Uint8Array(reader.result);
      let binary = ``;
      for (let i = 0, n = reader.result.byteLength; i < n; i++) {
        binary += String.fromCharCode(bytes[i]);
      }
      let string = btoa(binary);
      (await hr_createPlayer(string)).play();
      setSetting(`${id}_sound`, string);
      popup.close();
    } catch (e) {
      console.log(e);
      popup.icon.classList.remove(`fa-circle-o-notch`);
      popup.icon.classList.remove(`fa-spin`);
      popup.icon.classList.add(`fa-times`);
      popup.title.textContent = `An error happened.`;
    }
  }

  function setSmSource(child, sm, event) {
    event.dataTransfer.setData(`text/plain`, ``);
    sm.source = child;
  }

  function getSmSource(child, sm) {
    let current = sm.source;
    if (!current) return;
    do {
      current = current.previousElementSibling;
      if (current && current === child) {
        sm.panel.insertBefore(sm.source, child);
        return;
      }
    } while (current);
    sm.panel.insertBefore(sm.source, child.nextElementSibling);
  }

  function saveSmSource(sm) {
    sm.source = null;
    esgst[sm.categoryKey] = [];
    for (let i = 0, n = sm.panel.children.length; i < n; i++) {
      esgst[sm.categoryKey].push(sm.panel.children[i].id);
    }
    setSetting(sm.categoryKey, esgst[sm.categoryKey]);
  }

  function addGwcrMenuPanel(context, id, key, background) {
    let button, colors, i, n, panel;
    panel = insertHtml(context, `beforeEnd`, `
      <div class="esgst-sm-colors">
        <div class="form__saving-button esgst-sm-colors-default">
          <span>Add Color Setting</span>
        </div>
        <i class="fa fa-question-circle" title="Allows you to set different colors for different ${key} ranges."></i>
      </div>
    `);
    button = panel.firstElementChild;
    for (i = 0, n = esgst[id].length; i < n; ++i) {
      addGwcColorSetting(esgst[id][i], id, key, panel, background);
    }
    button.addEventListener(`click`, () => {
      colors = {
        color: `#ffffff`,
        lower: `0`,
        upper: `100`
      };
      if (background) {
        colors.bgColor = ``;
      }
      esgst[id].push(colors);
      addGwcColorSetting(colors, id, key, panel, background);
    });
  }

  function addGwcColorSetting(colors, id, key, panel, background) {
    let bgColor, color, i, lower, n, remove, setting, upper;
    setting = insertHtml(panel, `beforeEnd`, `
      <div>
        From <input step="0.01" type="number" value="${colors.lower}"/> to <input step="0.01" type="number" value="${colors.upper}"/> ${key}, color it as <input type="color" value="${colors.color}"/>${background ? ` with background <input type="color" value="${colors.bgColor}"/>` : ``}. <i class="esgst-clickable fa fa-times" title="Delete this setting"></i>
      </div>
    `);
    lower = setting.firstElementChild;
    upper = lower.nextElementSibling;
    color = upper.nextElementSibling;
    if (background) {
      bgColor = color.nextElementSibling;
      remove = bgColor.nextElementSibling;
    } else {
      remove = color.nextElementSibling;
    }
    lower.addEventListener(`change`, () => {
      colors.lower = lower.value;
      setSetting(id, esgst[id]);
    });
    upper.addEventListener(`change`, () => {
      colors.upper = upper.value;
      setSetting(id, esgst[id]);
    });
    color.addEventListener(`change`, () => {
      colors.color = color.value;
      setSetting(id, esgst[id]);
    });
    if (bgColor) {
        bgColor.addEventListener(`change`, () => {
        colors.bgColor = bgColor.value;
        setSetting(id, esgst[id]);
      });
    }
    remove.addEventListener(`click`, () => {
      if (confirm(`Are you sure you want to delete this setting?`)) {
        for (i = 0, n = esgst[id].length; i < n && esgst[id][i] !== colors; ++i);
        if (i < n) {
          esgst[id].splice(i, 1);
          setSetting(id, esgst[id]);
          setting.remove();
        }
      }
    });
  }

  function addGcRatingPanel(context) {
    let panel = insertHtml(context, `beforeEnd`, `
      <div class="esgst-sm-colors">
        <div class="form__saving-button esgst-sm-colors-default">
          <span>Add Rating Setting</span>
        </div>
        <i class="fa fa-question-circle" title="Allows you to set different colors/icons for different rating ranges."></i>
      </div>
    `);
    let button = panel.firstElementChild;
    for (let i = 0, n = esgst.gc_r_colors.length; i < n; ++i) {
      addGcRatingColorSetting(esgst.gc_r_colors[i], panel);
    }
    button.addEventListener(`click`, () => {
      let colors = {
        color: ``,
        bgColor: ``,
        icon: ``,
        lower: ``,
        upper: ``
      };
      esgst.gc_r_colors.push(colors);
      addGcRatingColorSetting(colors, panel);
    });
  }

  function addGcRatingColorSetting(colors, panel) {
    let setting = insertHtml(panel, `beforeEnd`, `
      <div>
        From <input type="number" value="${colors.lower}"/>% to <input type="number" value="${colors.upper}"/>% rating, color it as <input type="color" value="${colors.color}"/> with the background <input type="color" value="${colors.bgColor}"/> and the icon <input type="text" value="${colors.icon}"/> <i class="fa fa-question-circle"></i>. <i class="esgst-clickable fa fa-times" title="Delete this setting"></i>
      </div>
    `);
    let lower = setting.firstElementChild;
    let upper = lower.nextElementSibling;
    let color = upper.nextElementSibling;
    let bgColor = color.nextElementSibling
    let icon = bgColor.nextElementSibling;
    let tooltip = icon.nextElementSibling;
    createTooltip(tooltip, `The name of the icon can be any name from <a href="https://fontawesome.com/v4.7.0/icons/">FontAwesome</a> or any text. For example, if you want to use alt symbols like ▲ (Alt + 3 + 0) and ▼ (Alt + 3 + 1), you can.`);
    let remove = tooltip.nextElementSibling;
    lower.addEventListener(`change`, () => {
      colors.lower = lower.value;
      setSetting(`gc_r_colors`, esgst.gc_r_colors);
    });
    upper.addEventListener(`change`, () => {
      colors.upper = upper.value;
      setSetting(`gc_r_colors`, esgst.gc_r_colors);
    });
    color.addEventListener(`change`, () => {
      colors.color = color.value;
      setSetting(`gc_r_colors`, esgst.gc_r_colors);
    });
    bgColor.addEventListener(`change`, () => {
      colors.bgColor = bgColor.value;
      setSetting(`gc_r_colors`, esgst.gc_r_colors);
    });
    icon.addEventListener(`change`, () => {
      colors.icon = icon.value;
      setSetting(`gc_r_colors`, esgst.gc_r_colors);
    });
    remove.addEventListener(`click`, () => {
      if (confirm(`Are you sure you want to delete this setting?`)) {
        let i, n;
        for (i = 0, n = esgst.gc_r_colors.length; i < n && esgst.gc_r_colors[i] !== colors; ++i);
        if (i < n) {
          esgst.gc_r_colors.splice(i, 1);
          setSetting(`gc_r_colors`, esgst.gc_r_colors);
          setting.remove();
        }
      }
    });
  }

  function addGcMenuPanel(context) {
    let button, colorSetting, i, n, panel;
    panel = insertHtml(context, `beforeEnd`, `
      <div class="esgst-sm-colors">
        <div class="form__saving-button esgst-sm-colors-default">
          <span>Add Custom Genre Color</span>
        </div>
        <i class="fa fa-question-circle" title="Allows you to color genres (colored genres will appear at the beginning of the list)."></i>
      </div>
    `);
    button = panel.firstElementChild;
    for (i = 0, n = esgst.gc_g_colors.length; i < n; ++i) {
      addGcColorSetting(esgst.gc_g_colors[i], panel);
    }
    button.addEventListener(`click`, () => {
      colorSetting = {
        bgColor: `#7f8c8d`,
        color: `#ffffff`,
        genre: ``
      };
      esgst.gc_g_colors.push(colorSetting);
      addGcColorSetting(colorSetting, panel);
    });
  }

  function addGcColorSetting(colorSetting, panel) {
    let bgColor, color, genre, i, n, remove, setting;
    setting = insertHtml(panel, `beforeEnd`, `
      <div>
        For genre <input type="text" value="${colorSetting.genre}"/>, color it as <input type="color" value="${colorSetting.color}"> with background <input type="color" value="${colorSetting.bgColor}">. <i class="esgst-clickable fa fa-times" title="Delete this setting"></i>
      </div>
    `);
    genre = setting.firstElementChild;
    color = genre.nextElementSibling;
    bgColor = color.nextElementSibling;
    remove = bgColor.nextElementSibling;
    genre.addEventListener(`change`, () => {
      colorSetting.genre = genre.value;
      setSetting(`gc_g_colors`, esgst.gc_g_colors);
    });
    color.addEventListener(`change`, () => {
      colorSetting.color = color.value;
      setSetting(`gc_g_colors`, esgst.gc_g_colors);
    });
    bgColor.addEventListener(`change`, () => {
      colorSetting.bgColor = bgColor.value;
      setSetting(`gc_g_colors`, esgst.gc_g_colors);
    });
    remove.addEventListener(`click`, () => {
      if (confirm(`Are you sure you want to delete this setting?`)) {
        for (i = 0, n = esgst.gc_g_colors.length; i < n && esgst.gc_g_colors[i] !== colorSetting; ++i);
        if (i < n) {
          esgst.gc_g_colors.splice(i, 1);
          setSetting(`gc_g_colors`, esgst.gc_g_colors);
          setting.remove();
        }
      }
    });
  }

  function addGcAltMenuPanel(context) {
    let altSetting, button, i, n, panel;
    panel = insertHtml(context, `beforeEnd`, `
      <div class="esgst-sm-colors">
        <div class="form__saving-button esgst-sm-colors-default">
          <span>Add Alt Account</span>
        </div>
      </div>
    `);
    button = panel.firstElementChild;
    createTooltip(insertHtml(panel, `beforeEnd`, `<i class="fa fa-question-circle"></i>`), `
      <div>You must sync your owned games normally for the script to pick up the games owned by your alt accounts. Syncing with alt accounts only works with a Steam API Key though, so make sure one is set at the last section of this menu.</div>
      <br/>
      <div>Steam ID is the number that comes after "steamcommunity.com/profiles/" in your alt account's URL. If your alt account has a URL in the format "steamcommunity.com/id/" though, you can get your Steam ID <a href="https://steamid.io/">here</a> by entering your URL in the input (you want the steamID64 one).</div>
      <br/>
      <div>You must fill the fields relative to your settings. For example, if you have simplified version enabled with icons, you must fill the "icon" field. If you don't have simplified version enabled, you must fill the "label" field. The current text in the fields are simply placeholders.</div>
    `);
    for (i = 0, n = esgst.gc_o_altAccounts.length; i < n; ++i) {
      addGcAltSetting(esgst.gc_o_altAccounts[i], panel);
    }
    button.addEventListener(`click`, () => {
      altSetting = {
        bgColor: `#000000`,
        color: `#ffffff`,
        games: {
          apps: {},
          subs: {}
        },
        icon: ``,
        label: ``,
        name: ``,
        steamId: ``
      };
      esgst.gc_o_altAccounts.push(altSetting);
      addGcAltSetting(altSetting, panel);
    });
  }

  function addGcAltSetting(altSetting, panel) {
    let color, bgColor, i, icon, label, n, name, remove, setting, steamId;
    setting = insertHtml(panel, `beforeEnd`, `
      <div>
        For account with Steam ID <input placeholder="0000000000000000" type="text" value="${altSetting.steamId}"/>, using the nickname <input placeholder="alt1" type="text" value="${altSetting.name}"/>, <br/>color it as <input type="color" value="${altSetting.color}"/> with background <input type="color" value="${altSetting.bgColor}"/>, icon <input placeholder="folder" type="text" value="${altSetting.icon}"/> and label <input placeholder="Owned by alt1" type="text" value="${altSetting.label}"/>. <i class="esgst-clickable fa fa-times" title="Delete this setting"></i>
      </div>
    `);
    steamId = setting.firstElementChild;
    name = steamId.nextElementSibling;
    color = name.nextElementSibling.nextElementSibling;
    bgColor = color.nextElementSibling;
    icon = bgColor.nextElementSibling;
    label = icon.nextElementSibling;
    remove = label.nextElementSibling;
    steamId.addEventListener(`change`, () => {
      altSetting.steamId = steamId.value;
      setSetting(`gc_o_altAccounts`, esgst.gc_o_altAccounts);
    });
    name.addEventListener(`change`, () => {
      altSetting.name = name.value;
      setSetting(`gc_o_altAccounts`, esgst.gc_o_altAccounts);
    });
    color.addEventListener(`change`, () => {
      altSetting.color = color.value;
      setSetting(`gc_o_altAccounts`, esgst.gc_o_altAccounts);
    });
    bgColor.addEventListener(`change`, () => {
      altSetting.bgColor = bgColor.value;
      setSetting(`gc_o_altAccounts`, esgst.gc_o_altAccounts);
    });
    icon.addEventListener(`change`, () => {
      altSetting.icon = icon.value;
      setSetting(`gc_o_altAccounts`, esgst.gc_o_altAccounts);
    });
    label.addEventListener(`change`, () => {
      altSetting.label = label.value;
      setSetting(`gc_o_altAccounts`, esgst.gc_o_altAccounts);
    });
    remove.addEventListener(`click`, () => {
      if (confirm(`Are you sure you want to delete this setting?`)) {
        for (i = 0, n = esgst.gc_o_altAccounts.length; i < n && esgst.gc_o_altAccounts[i] !== altSetting; ++i);
        if (i < n) {
          esgst.gc_o_altAccounts.splice(i, 1);
          setSetting(`gc_o_altAccounts`, esgst.gc_o_altAccounts);
          setting.remove();
        }
      }
    });
  }

  function addColorObserver(context, id, key) {
    context.addEventListener(`change`, () => {
      setSetting(`${id}_${key}`, context.value);
    });
  }

  function setSMManageFilteredGiveaways(SMManageFilteredGiveaways) {
    let gfGiveaways, giveaway, hidden, i, key, n, popup, set;
    SMManageFilteredGiveaways.addEventListener(`click`, () => {
      popup = new Popup(`fa-gift`, `Hidden Giveaways`, true);
      hidden = [];
      for (key in esgst.giveaways) {
        giveaway = esgst.giveaways[key];
        if (giveaway.hidden && giveaway.code && giveaway.endTime) {
          if (Date.now() >= giveaway.endTime) {
            delete giveaway.hidden;
          } else {
            hidden.push(giveaway);
          }
        } else {
          delete giveaway.hidden;
        }
      }
      hidden = hidden.sort((a, b) => {
        if (a.hidden > b.hidden) {
          return -1;
        } else if (a.hidden < b.hidden) {
          return 1;
        } else {
          return 0;
        }
      });
      setValue(`giveaways`, JSON.stringify(esgst.giveaways));
      i = 0;
      n = hidden.length;
      gfGiveaways = insertHtml(popup.scrollable, `beforeEnd`, `<div class="esgst-text-left"></div>`);
      if (n > 0) {
        set = new ButtonSet(`green`, `grey`, `fa-plus`, `fa-circle-o-notch fa-spin`, `Load more...`, `Loading more...`, callback => {
          loadGfGiveaways(i, i + 5, hidden, gfGiveaways, popup, value => {
            i = value;
            if (i > n) {
              set.set.remove();
            } else if (esgst.es_gf && popup.scrollable.scrollHeight <= popup.scrollable.offsetHeight) {
              set.trigger();
            }
            callback();
          });
        });
        popup.description.appendChild(set.set);
        popup.open();
        set.trigger();
        if (esgst.es_gf) {
          popup.scrollable.addEventListener(`scroll`, () => {
            if ((popup.scrollable.scrollTop + popup.scrollable.offsetHeight) >= popup.scrollable.scrollHeight && !set.busy) {
              set.trigger();
            }
          });
        }
      } else {
        gfGiveaways.textContent = `No hidden giveaways found.`;
        popup.open();
      }
    });
  }

  async function loadGfGiveaways(i, n, hidden, gfGiveaways, popup, callback) {
    let giveaway;
    if (i < n) {
      if (hidden[i]) {
        let response = await request({method: `GET`, queue: true, url: `https://www.steamgifts.com/giveaway/${hidden[i].code}/`});
        giveaway = buildGiveaway(parseHtml(response.responseText), response.finalUrl);
        if (giveaway) {
          gfGiveaways.insertAdjacentHTML(`beforeEnd`, giveaway.html);
          await endless_load(gfGiveaways.lastElementChild, false, `gf`);
          setTimeout(() => loadGfGiveaways(++i, n, hidden, gfGiveaways, popup, callback), 0);
        } else {
          setTimeout(() => loadGfGiveaways(++i, n, hidden, gfGiveaways, popup, callback), 0);
        }
      } else {
        callback(i + 1);
      }
    } else {
      callback(i);
    }
  }

  async function openManageUserTagsPopup() {
    let context, current, input, popup, savedUser, savedUsers, users;
    popup = new Popup(`fa-tags`, `Manage user tags:`, true);
    input = insertHtml(popup.description, `afterBegin`, `<input type="text"/>`);
    popup.description.insertAdjacentHTML(`afterBegin`, `<div class="esgst-description">Type tags below to filter the users by.</div>`);
    let heading = insertHtml(popup.description, `beforeBegin`, `
      <div class="page__heading"></div>
    `);
    if (esgst.mm) {
      mm(heading);
    }
    savedUsers = JSON.parse(await getValue(`users`));
    current = {};
    users = {};
    for (const steamId in savedUsers.users) {
      savedUser = savedUsers.users[steamId];
      if (savedUser.tags && (savedUser.tags.length > 1 || (savedUser.tags[0] && savedUser.tags[0].trim()))) {
        context = insertHtml(popup.scrollable, `beforeEnd`, `
          <div>
            <a ${savedUser.username ? `data-sg="true" href="https://www.steamgifts.com` : `data-st="true" href="https://www.steamtrades.com`}/user/${savedUser.username || steamId}">${savedUser.username || steamId}</a>
          </div>
        `);
        current[savedUser.username || steamId] = {
          elements: [context.firstElementChild]
        };
        users[savedUser.username || steamId] = {
          context: context
        };
      }
    }
    await endless_load(popup.scrollable);
    input.addEventListener(`input`, filterUserTags.bind(null, current, popup, users));
    popup.open();
  }

  function filterUserTags(current, popup, users, event) {
    let i, tags, username, userTags;
    if (event.currentTarget.value) {
      tags = event.currentTarget.value.replace(/,\s+/g, ``).split(/,\s/);
      for (username in users) {
        userTags = users[username].context.getElementsByClassName(`esgst-ut-tags`)[0];
        for (i = tags.length - 1; i >= 0 && !userTags.innerHTML.match(new RegExp(`>${tags[i]}<`)); --i);
        if (i < 0) {
          users[username].context.classList.add(`esgst-hidden`);
        } else {
          users[username].context.classList.remove(`esgst-hidden`);
        }
      }
    } else {
      for (username in users) {
        users[username].context.classList.remove(`esgst-hidden`);
      }
    }
  }

  async function openManageGameTagsPopup() {
    let context, current, games, input, popup, savedGame, savedGames;
    popup = new Popup(`fa-tags`, `Manage game tags:`, true);
    input = insertHtml(popup.description, `afterBegin`, `<input type="text"/>`);
    popup.description.insertAdjacentHTML(`afterBegin`, `<div class="esgst-description">Type tags below to filter the games by.</div>`);
    let heading = insertHtml(popup.description, `beforeBegin`, `
      <div class="page__heading"></div>
    `);
    if (esgst.mm) {
      mm(heading);
    }
    savedGames = JSON.parse(await getValue(`games`));
    current = {
      apps: {},
      subs: {}
    };
    games = {
      apps: {},
      subs: {}
    };
    for (const id in savedGames.apps) {
      savedGame = savedGames.apps[id];
      if (savedGame.tags && (savedGame.tags.length > 1 || savedGame.tags[0].trim())) {
        context = insertHtml(popup.scrollable, `beforeEnd`, `
          <div class="table__row-outer-wrap">
            <a class="table__column__heading" href="http://store.steampowered.com/app/${id}">App - ${id}</a>
          </div>
        `);
        current.apps[id] = [{
          heading: context
        }];
        games.apps[id] = {
          context: context
        };
      }
    }
    for (const id in savedGames.subs) {
      savedGame = savedGames.subs[id];
      if (savedGame.tags && (savedGame.tags.length > 1 || savedGame.tags[0].trim())) {
        context = insertHtml(popup.scrollable, `beforeEnd`, `
          <div class="table__row-outer-wrap">
            <a class="table__column__heading" href="http://store.steampowered.com/sub/${id}">Sub - ${id}</a>
          </div>
        `);
        current.subs[id] = [{
          heading: context
        }];
        games.subs[id] = {
          context: context
        };
      }
    }
    await endless_load(popup.scrollable);
    input.addEventListener(`input`, filterGameTags.bind(null, current, games, popup));
    popup.open();
  }

  function filterGameTags(current, games, popup, event) {
    let gameTags, i, id, tags;
    if (event.currentTarget.value) {
      tags = event.currentTarget.value.replace(/,\s+/g, ``).split(/,\s/);
      for (id in games.apps) {
        gameTags = games.apps[id].context.getElementsByClassName(`esgst-gt-tags`)[0];
        for (i = tags.length - 1; i >= 0 && !gameTags.innerHTML.match(new RegExp(`>${tags[i]}<`)); --i);
        if (i < 0) {
          games.apps[id].context.classList.add(`esgst-hidden`);
        } else {
          games.apps[id].context.classList.remove(`esgst-hidden`);
        }
      }
      for (id in games.subs) {
        gameTags = games.subs[id].context.getElementsByClassName(`esgst-gt-tags`)[0];
        for (i = tags.length - 1; i >= 0 && !gameTags.innerHTML.match(new RegExp(`>${tags[i]}<`)); --i);
        if (i < 0) {
          games.subs[id].context.classList.add(`esgst-hidden`);
        } else {
          games.subs[id].context.classList.remove(`esgst-hidden`);
        }
      }
    } else {
      for (id in games.apps) {
        games.apps[id].context.classList.remove(`esgst-hidden`);
      }
      for (id in games.subs) {
        games.subs[id].context.classList.remove(`esgst-hidden`);
      }
    }
  }

  function setSMRecentUsernameChanges(SMRecentUsernameChanges) {
    SMRecentUsernameChanges.addEventListener(`click`, async () => {
      let popup;
      popup = new Popup(`fa-comments`, `Recent Username Changes`);
      popup.Progress = insertHtml(popup.description, `beforeEnd`, `
        <div>
          <i class="fa fa-circle-o-notch fa-spin"></i>
          <span>Loading recent username changes...</span>
        </div>
      `);
      popup.Results = insertHtml(popup.scrollable, `beforeEnd`, `
        <div class="esgst-uh-popup"></div>
      `);
      popup.open();
      let RecentChanges, HTML, I, N;
      RecentChanges = JSON.parse((await request({method: `GET`, url: `https://script.google.com/macros/s/AKfycbzvOuHG913mRIXOsqHIeAuQUkLYyxTHOZim5n8iP-k80iza6g0/exec?Action=2`})).responseText).RecentChanges;
      popup.Progress.innerHTML = ``;
      HTML = ``;
      for (I = 0, N = RecentChanges.length; I < N; ++I) {
        HTML += `<div>${RecentChanges[I][0]} changed to <a class="esgst-bold" href="/user/${RecentChanges[I][1]}">${RecentChanges[I][1]}</a></div>`;
      }
      popup.Results.innerHTML = HTML;
      if (esgst.sg) {
        endless_load(popup.Results);
      }
    });
  }

  function updateWhitelistBlacklist(key, profile, event) {
    let user;
    user = {
      steamId: profile.steamId,
      id: profile.id,
      username: profile.username,
      values: {}
    };
    if (event.currentTarget.classList.contains(`is-selected`)) {
      user.values[key] = false;
    } else {
      user.values[key] = true;
      user.values[`${key}Date`] = Date.now();
    }
    saveUser(null, null, user);
  }  

  async function updateHiddenGames(id, type, unhide) {
    if (!esgst.updateHiddenGames) {
      return;
    }
    const games = {
      apps: {},
      subs: {}
    };
    games[type][id] = {
      hidden: unhide ? null : true
    };
    await lockAndSaveGames(games);
  }

  function checkBackup() {
    let currentDate = Date.now();
    let isBackingUp = getLocalValue(`isBackingUp`);
    if ((!isBackingUp || currentDate - isBackingUp > 1800000) && currentDate - esgst.lastBackup > esgst.autoBackup_days * 86400000) {
      setLocalValue(`isBackingUp`, currentDate);
      loadDataManagement(false, `export`, true);
    }
  }

  function loadDataManagement(openInTab, type, autoBackup) {
    let container, context, group1, group2, i, icon, n, onClick, option, prep, popup, section, title1, title2;
    let dm = {
      autoBackup: autoBackup,
      type: type
    };
    dm[type] = true;
    switch (type) {
      case `import`:
        icon = `fa-sign-in esgst-rotate-90`;
        onClick = loadImportFile;
        prep = `from`;
        title1 = `Restore`;
        title2 = `Restoring`;
        dm.pastTense = `restored`;
        break;
      case `export`:
        icon = `fa-sign-out esgst-rotate-270`;
        onClick = manageData;
        prep = `to`;
        title1 = `Backup`;
        title2 = `Backing up`;
        dm.pastTense = `backed up`;
        break;
      case `delete`:
        icon = `fa-trash`;
        onClick = confirmDataDeletion;
        prep = `from`;
        title1 = `Delete`;
        title2 = `Deleting`;
        dm.pastTense = `deleted`;
        break;
    }
    if (openInTab) {
      context = container = esgst.mainContext;
      context.innerHTML = ``;
    } else {
      if (dm.autoBackup) {
        popup = new Popup(`fa-circle-o-notch fa-spin`, `ESGST is backing up your data... ${esgst.minimizePanel ? `You can close this popup, ESGST will notify you when it is done through the minimize panel.` : `Please do not close this popup until it is done.`}`, !esgst.minimizePanel, true);
      } else {
        popup = new Popup(icon, title1, true, true);
      }
      popup.description.classList.add(`esgst-text-left`);
      context = popup.scrollable;
      container = popup.description;
    }
    if (!dm.autoBackup) {
      dm.computerSpace = insertHtml(container, `afterBegin`, `
        <div>Total: <span class="esgst-bold"></span> <i class="esgst-clickable fa fa-refresh" title="Calculate/refresh data sizes"></i></div>
      `);
      dm.computerSpaceCount = dm.computerSpace.firstElementChild;
      dm.computerSpaceCount.nextElementSibling.addEventListener(`click`, getDataSizes.bind(null, dm));
      section = createMenuSection(context, null, 1, title1);
    }
    dm.switches = {};
    dm.options = [
      {
        check: true,
        key: `decryptedGiveaways`,
        name: `Decrypted Giveaways`
      },
      {
        check: esgst.sg,
        key: `discussions`,
        name: `Discussions`,
        options: [
          {
            key: `discussions_main`,
            name: `Main`
          },
          {
            key: `discussions_ct`,
            name: `Comment Tracker`
          },
          {
            key: `discussions_df`,
            name: `Discussion Filters`
          },
          {
            key: `discussions_dh`,
            name: `Discussion Highlighter`
          },
          {
            key: `discussions_gdttt`,
            name: `Giveaway/Discussion/Ticket/Trade Tracker`
          },
          {
            key: `discussions_pm`,
            name: `Puzzle Marker`
          }
        ]
      },
      {
        check: true,
        key: `emojis`,
        name: `Emojis`
      },
      {
        check: esgst.sg,
        key: `entries`,
        name: `Entries`
      },
      {
        check: true,
        key: `games`,
        name: `Games`,
        options: [
          {
            key: `games_main`,
            name: `Main`
          },
          {
            key: `games_egh`,
            name: `Entered Game Highlighter`
          },
          {
            key: `games_gt`,
            name: `Game Tags`
          },
          {
            key: `games_itadi`,
            name: `IsThereAnyDeal Info`
          }
        ]
      },
      {
        check: esgst.sg,
        key: `giveaways`,
        name: `Giveaways`,
        options: [
          {
            key: `giveaways_main`,
            name: `Main`
          },
          {
            key: `giveaways_ct`,
            name: `Comment Tracker`
          },
          {
            key: `giveaways_gb`,
            name: `Giveaway Bookmarks`
          },
          {
            key: `giveaways_gdttt`,
            name: `Giveaway/Discussion/Ticket/Trade Tracker`
          },
          {
            key: `giveaways_gf`,
            name: `Giveaway Filters`
          },
          {
            key: `giveaways_ggl`,
            name: `Giveaway Group Loader`
          }
        ]
      },
      {
        check: esgst.sg,
        key: `groups`,
        name: `Groups`,
        options: [
          {
            key: `groups_main`,
            name: `Main`
          },
          {
            key: `groups_sgg`,
            name: `Stickied Giveaway Groups`
          }
        ]
      },
      {
        check: esgst.sg,
        key: `rerolls`,
        name: `Rerolls`
      },
      {
        check: true,
        key: `savedReplies`,
        name: `Saved Replies`
      },
      {
        check: true,
        key: `settings`,
        name: `Settings`
      },
      {
        check: true,
        key: `sgCommentHistory`,
        name: `SG Comment History`
      },
      {
        check: esgst.sg,
        key: `stickiedCountries`,
        name: `Stickied Giveaway Countries`
      },
      {
        check: esgst.sg,
        key: `templates`,
        name: `Templates`
      },
      {
        check: esgst.sg,
        key: `tickets`,
        name: `Tickets`,
        options: [
          {
            key: `tickets_main`,
            name: `Main`
          },
          {
            key: `tickets_ct`,
            name: `Comment Tracker`
          },
          {
            key: `tickets_gdttt`,
            name: `Giveaway/Discussion/Ticket/Trade Tracker`
          },
          {
            key: `tickets_ust`,
            name: `User Suspension Tracker`
          }
        ]
      },
      {
        check: esgst.st,
        key: `trades`,
        name: `Trades`,
        options: [
          {
            key: `trades_main`,
            name: `Main`
          },
          {
            key: `trades_ct`,
            name: `Comment Tracker`
          },
          {
            key: `trades_gdttt`,
            name: `Giveaway/Discussion/Ticket/Trade Tracker`
          }
        ]
      },
      {
        check: true,
        key: `users`,
        name: `Users`,
        options: [
          {
            key: `users_main`,
            name: `Main`
          },
          {
            key: `users_namwc`,
            name: `Not Activated/Multiple Win  Checker`
          },
          {
            key: `users_nrf`,
            name: `Not Received Finder`
          },
          {
            key: `users_uf`,
            name: `User Filters`
          },
          {
            key: `users_giveaways`,
            name: `Giveaways Data`
          },
          {
            key: `users_notes`,
            name: `User Notes`
          },
          {
            key: `users_tags`,
            name: `User Tags`
          },
          {
            key: `users_wbc`,
            name: `Whitelist/Blacklist Checker`
          }
        ]
      },
      {
        check: esgst.sg,
        key: `winners`,
        name: `Winners`
      }
    ];
    if (dm.autoBackup) {
      let dropbox, googleDrive, oneDrive;
      switch (esgst.autoBackup_index) {
        case 0:
          break;
        case 1:
          dropbox = true;
          break;
        case 2:
          googleDrive = true;
          break;
        case 3:
          oneDrive = true;
          break;
      }
      popup.open();
      manageData(dm, dropbox, googleDrive, oneDrive, false, async () => {
        delLocalValue(`isBackingUp`);
        await setSetting(`lastBackup`, Date.now());
        popup.icon.classList.remove(`fa-circle-o-notch`, `fa-spin`);
        popup.icon.classList.add(`fa-check`);
        popup.setTitle(`Backup done! You can close this popup now.`);
        popup.setDone(true);
      });
    } else {
      for (i = 0, n = dm.options.length; i < n; ++i) {
        option = dm.options[i];
        if (option.check) {
          section.lastElementChild.appendChild(getDataMenu(option, dm.switches, type));
        }
      }
      if (type === `import` || type === `delete`) {
        if (type === `import`) {
          dm.input = insertHtml(container, `beforeEnd`, `<input type="file"/>`);
          new ToggleSwitch(container, `importAndMerge`, false, `Merge`, false, false, `Merges the current data with the backup instead of replacing it.`, esgst.settings.importAndMerge);
        }
        let select = new ToggleSwitch(container, `exportBackup`, false, `Backup to <select><option>Computer</option><option>Dropbox</option><option>Google Drive</option><option>OneDrive</option></select>`, false, false, `Backs up the current data to one of the selected places before restoring another backup.`, esgst.settings.exportBackup).name.firstElementChild;
        select.selectedIndex = esgst.settings.exportBackupIndex;
        select.addEventListener(`change`, () => {
          setSetting(`exportBackupIndex`, select.selectedIndex);
        });
      }
      dm.message = insertHtml(container, `beforeEnd`, `<div class="esgst-description"></div>`);
      dm.warning = insertHtml(container, `beforeEnd`, `<div class="esgst-description esgst-warning"></div>`);
      group1 = insertHtml(container, `beforeEnd`, `<div class="esgst-button-group"><span>Select:</span></div>`);
      group1.appendChild(new ButtonSet(`grey`, `grey`, `fa-square`, `fa-circle-o-notch fa-spin`, `All`, ``, selectSwitches.bind(null, dm.switches, `enable`, group1)).set);
      group1.appendChild(new ButtonSet(`grey`, `grey`, `fa-square-o`, `fa-circle-o-notch fa-spin`, `None`, ``, selectSwitches.bind(null, dm.switches, `disable`, group1)).set);
      group1.appendChild(new ButtonSet(`grey`, `grey`, `fa-plus-square-o`, `fa-circle-o-notch fa-spin`, `Inverse`, ``, selectSwitches.bind(null, dm.switches, `toggle`, group1)).set);
      group2 = insertHtml(container, `beforeEnd`, `<div class="esgst-button-group"><span>${title1} ${prep}:</span></div>`);
      group2.appendChild(new ButtonSet(`green`, `grey`, `fa-desktop`, `fa-circle-o-notch fa-spin`, `Computer`, title2, callback => {
        onClick(dm, false, false, false, false, () => {
          manageData(dm, false, false, false, true);
          callback();
        });
      }).set);
      if (type !== `delete`) {
        group2.appendChild(new ButtonSet(`green`, `grey`, `fa-dropbox`, `fa-circle-o-notch fa-spin`, `Dropbox`, title2, callback => {
          onClick(dm, true, false, false, false, () => {
            manageData(dm, false, false, false, true);
            callback();
          });
        }).set);
        group2.appendChild(new ButtonSet(`green`, `grey`, `fa-google`, `fa-circle-o-notch fa-spin`, `Google Drive`, title2, callback => {
          onClick(dm, false, true, false, false, () => {
            manageData(dm, false, false, false, true);
            callback();
          });
        }).set);
        group2.appendChild(new ButtonSet(`green`, `grey`, `fa-windows`, `fa-circle-o-notch fa-spin`, `OneDrive`, title2, callback => {
          onClick(dm, false, false, true, false, () => {
            manageData(dm, false, false, false, true);
            callback();
          });
        }).set);
      }
      if (!openInTab) {
        popup.open();
      }
      if (esgst[`calculate${capitalizeFirstLetter(type)}`]) {
        getDataSizes(dm);
      }
    }
  }

  function loadDataCleaner() {
    let popup = new Popup(`fa-paint-brush`, `Clean old data:`);
    popup.description.insertAdjacentHTML(`afterBegin`, `<div class="esgst-bold esgst-description esgst-red">Make sure to backup your data before using the cleaner.</div>`);
    observeNumChange(new ToggleSwitch(popup.description, `cleanDiscussions`, false, `Discussions data older than <input class="esgst-switch-input" type="text" value="${esgst.cleanDiscussions_days}"> days.`, false, false, `Discussions data only started being date-tracked since v7.11.0, so not all old data may be cleaned.`, esgst.cleanDiscussions).name.firstElementChild, `cleanDiscussions_days`);
    observeNumChange(new ToggleSwitch(popup.description, `cleanEntries`, false, `Entries data older than <input class="esgst-switch-input" type="text" value="${esgst.cleanEntries_days}"> days.`, false, false, ``, esgst.cleanEntries).name.firstElementChild, `cleanEntries_days`);
    observeNumChange(new ToggleSwitch(popup.description, `cleanGiveaways`, false, `Giveaways data older than <input class="esgst-switch-input" type="text" value="${esgst.cleanGiveaways_days}"> days.`, false, false, `Some giveaways data only started being date-tracked since v7.11.0, so not all old data may be cleaned.`, esgst.cleanGiveaways).name.firstElementChild, `cleanGiveaways_days`);
    observeNumChange(new ToggleSwitch(popup.description, `cleanSgCommentHistory`, false, `SteamGifts comment history data older than <input class="esgst-switch-input" type="text" value="${esgst.cleanSgCommentHistory_days}"> days.`, false, false, ``, esgst.cleanSgCommentHistory).name.firstElementChild, `cleanSgCommentHistory_days`);
    observeNumChange(new ToggleSwitch(popup.description, `cleanTickets`, false, `Tickets data older than <input class="esgst-switch-input" type="text" value="${esgst.cleanTickets_days}"> days.`, false, false, `Tickets data only started being date-tracked since v7.11.0, so not all old data may be cleaned.`, esgst.cleanTickets).name.firstElementChild, `cleanTickets_days`);
    observeNumChange(new ToggleSwitch(popup.description, `cleanTrades`, false, `Trades data older than <input class="esgst-switch-input" type="text" value="${esgst.cleanTrades_days}"> days.`, false, false, `Trades data only started being date-tracked since v7.11.0, so not all old data may be cleaned.`, esgst.cleanTrades).name.firstElementChild, `cleanTrades_days`);
    new ToggleSwitch(popup.description, `cleanDuplicates`, false, `Duplicate data.`, false, false, `Cleans up any duplicate data it finds.`, esgst.cleanDuplicates);
    popup.description.appendChild(new ButtonSet_v2({color1: `green`, color2: `grey`, icon1: `fa-check`, icon2: `fa-circle-o-notch fa-spin`, title1: `Clean`, title2: `Cleaning...`, callback1: async () => {
      const dm = {};
      dm.options = [
        {
          check: true,
          key: `decryptedGiveaways`,
          name: `Decrypted Giveaways`
        },
        {
          check: esgst.sg,
          key: `discussions`,
          name: `Discussions`,
          options: [
            {
              key: `discussions_main`,
              name: `Main`
            },
            {
              key: `discussions_ct`,
              name: `Comment Tracker`
            },
            {
              key: `discussions_df`,
              name: `Discussion Filters`
            },
            {
              key: `discussions_dh`,
              name: `Discussion Highlighter`
            },
            {
              key: `discussions_gdttt`,
              name: `Giveaway/Discussion/Ticket/Trade Tracker`
            },
            {
              key: `discussions_pm`,
              name: `Puzzle Marker`
            }
          ]
        },
        {
          check: true,
          key: `emojis`,
          name: `Emojis`
        },
        {
          check: esgst.sg,
          key: `entries`,
          name: `Entries`
        },
        {
          check: true,
          key: `games`,
          name: `Games`,
          options: [
            {
              key: `games_main`,
              name: `Main`
            },
            {
              key: `games_egh`,
              name: `Entered Game Highlighter`
            },
            {
              key: `games_gt`,
              name: `Game Tags`
            },
            {
              key: `games_itadi`,
              name: `IsThereAnyDeal Info`
            }
          ]
        },
        {
          check: esgst.sg,
          key: `giveaways`,
          name: `Giveaways`,
          options: [
            {
              key: `giveaways_main`,
              name: `Main`
            },
            {
              key: `giveaways_ct`,
              name: `Comment Tracker`
            },
            {
              key: `giveaways_gb`,
              name: `Giveaway Bookmarks`
            },
            {
              key: `giveaways_gdttt`,
              name: `Giveaway/Discussion/Ticket/Trade Tracker`
            },
            {
              key: `giveaways_gf`,
              name: `Giveaway Filters`
            },
            {
              key: `giveaways_ggl`,
              name: `Giveaway Group Loader`
            }
          ]
        },
        {
          check: esgst.sg,
          key: `groups`,
          name: `Groups`,
          options: [
            {
              key: `groups_main`,
              name: `Main`
            },
            {
              key: `groups_sgg`,
              name: `Stickied Giveaway Groups`
            }
          ]
        },
        {
          check: esgst.sg,
          key: `rerolls`,
          name: `Rerolls`
        },
        {
          check: true,
          key: `savedReplies`,
          name: `Saved Replies`
        },
        {
          check: true,
          key: `settings`,
          name: `Settings`
        },
        {
          check: true,
          key: `sgCommentHistory`,
          name: `SG Comment History`
        },
        {
          check: esgst.sg,
          key: `stickiedCountries`,
          name: `Stickied Giveaway Countries`
        },
        {
          check: esgst.sg,
          key: `templates`,
          name: `Templates`
        },
        {
          check: esgst.sg,
          key: `tickets`,
          name: `Tickets`,
          options: [
            {
              key: `tickets_main`,
              name: `Main`
            },
            {
              key: `tickets_ct`,
              name: `Comment Tracker`
            },
            {
              key: `tickets_gdttt`,
              name: `Giveaway/Discussion/Ticket/Trade Tracker`
            },
            {
              key: `tickets_ust`,
              name: `User Suspension Tracker`
            }
          ]
        },
        {
          check: esgst.st,
          key: `trades`,
          name: `Trades`,
          options: [
            {
              key: `trades_main`,
              name: `Main`
            },
            {
              key: `trades_ct`,
              name: `Comment Tracker`
            },
            {
              key: `trades_gdttt`,
              name: `Giveaway/Discussion/Ticket/Trade Tracker`
            }
          ]
        },
        {
          check: true,
          key: `users`,
          name: `Users`,
          options: [
            {
              key: `users_main`,
              name: `Main`
            },
            {
              key: `users_namwc`,
              name: `Not Activated/Multiple Win  Checker`
            },
            {
              key: `users_nrf`,
              name: `Not Received Finder`
            },
            {
              key: `users_uf`,
              name: `User Filters`
            },
            {
              key: `users_giveaways`,
              name: `Giveaways Data`
            },
            {
              key: `users_notes`,
              name: `User Notes`
            },
            {
              key: `users_tags`,
              name: `User Tags`
            },
            {
              key: `users_wbc`,
              name: `Whitelist/Blacklist Checker`
            }
          ]
        },
        {
          check: esgst.sg,
          key: `winners`,
          name: `Winners`
        }
      ];
      const oldSize = await manageData(dm, false, false, false, true);
      let currentTime = Date.now();
      let toSave = {};
      if (esgst.cleanDiscussions) {
        let days = esgst.cleanDiscussions_days * 86400000;
        toSave.discussions = JSON.parse(await getValue(`discussions`, `{}`));
        for (let code in toSave.discussions) {
          let item = toSave.discussions[code];
          if (item.author !== esgst.username && item.lastUsed && currentTime - item.lastUsed > days) {
            delete toSave.discussions[code];
          }
        }
      }
      if (esgst.cleanEntries) {
        let days = esgst.cleanEntries_days * 86400000;
        let items = JSON.parse(await getValue(`entries`, `[]`));
        toSave.entries = [];
        items.forEach(item => {
          if (currentTime - item.timestamp <= days) {
            toSave.entries.push(item);
          }
        });
      }
      if (esgst.cleanGiveaways) {
        let days = esgst.cleanGiveaways_days * 86400000;
        toSave.giveaways = JSON.parse(await getValue(`giveaways`, `{}`));
        for (let code in toSave.giveaways) {
          let item = toSave.giveaways[code];
          if (item.creator !== esgst.username && ((item.endTime && currentTime - item.endTime > days) || (item.lastUsed && currentTime - item.lastUsed > days))) {
            delete toSave.giveaways[code];
          }
        }
      }
      if (esgst.cleanSgCommentHistory) {
        let days = esgst.cleanSgCommentHistory_days * 86400000;
        let items = JSON.parse(await getValue(`sgCommentHistory`, `[]`));
        toSave.sgCommentHistory = [];
        items.forEach(item => {
          if (currentTime - item.timestamp <= days) {
            toSave.sgCommentHistory.push(item);
          }
        });
      }
      if (esgst.cleanTickets) {
        let days = esgst.cleanTickets_days * 86400000;
        toSave.tickets = JSON.parse(await getValue(`tickets`, `{}`));
        for (let code in toSave.tickets) {
          let item = toSave.tickets[code];
          if (item.author !== esgst.username && item.lastUsed && currentTime - item.lastUsed > days) {
            delete toSave.tickets[code];
          }
        }
      }
      if (esgst.cleanTrades) {
        let days = esgst.cleanTrades_days * 86400000;
        toSave.trades = JSON.parse(await getValue(`trades`, `{}`));
        for (let code in toSave.trades) {
          let item = toSave.trades[code];
          if (item.author !== esgst.username && item.lastUsed && currentTime - item.lastUsed > days) {
            delete toSave.trades[code];
          }
        }
      }
      if (esgst.cleanDuplicates) {
        toSave.users = JSON.parse(await getValue(`users`, `{"steamIds":{},"users":{}}`));
        for (let id in toSave.users.users) {
          let giveaways = toSave.users.users[id].giveaways;
          if (giveaways) {
            [`sent`, `won`].forEach(mainType => {
              [`apps`, `subs`].forEach(type => {
                for (let code in giveaways[mainType][type]) {
                  giveaways[mainType][type][code] = Array.from(new Set(giveaways[mainType][type][code]));
                }
              });
            });
          }
        }
      }
      for (let key in toSave) {
        toSave[key] = JSON.stringify(toSave[key]);
      }
      await setValues(toSave);
      const newSize = await manageData(dm, false, false, false, true);
      const successPopup = new Popup_v2({
        icon: `fa-check`,
        title: `Success! The selected data was cleaned.<br><br>Size before cleaning: <span class="esgst-bold">${convertBytes(oldSize)}</span><br>Size after cleaning: <span class="esgst-bold">${convertBytes(newSize)}</span><br><br>${Math.round((100 - (newSize / oldSize * 100)) * 100) / 100}% reduction`,
        temp: true
      });
      successPopup.open();
    }}).set);
    popup.open();
  }

  async function manageData(dm, dropbox, googleDrive, oneDrive, space, callback) {
    let data = {};
    let totalSize = 0;
    let mainUsernameFound;
    for (let i = 0, n = dm.options.length; i < n; i++) {
      let option = dm.options[i];
      let optionKey = option.key;
      if (!option.check || (!dm.autoBackup && !space && !esgst.settings[`${dm.type}_${optionKey}`])) {
        continue;
      }
      let values = null;
      let mainFound, mergedData, sizes;
      switch (optionKey) {
        case `decryptedGiveaways`:
        case `settings`:
          data[optionKey] = JSON.parse(await getValue(optionKey, `{}`));
          if (!space) {
            if (dm.import) {
              let newData = dm.data[optionKey];
              if (newData) {
                if (esgst.settings.importAndMerge) {
                  mergedData = data[optionKey];
                  for (let newDataKey in newData) {
                    mergedData[newDataKey] = newData[newDataKey];
                  }
                  await setValue(optionKey, JSON.stringify(mergedData));
                } else {
                  await setValue(optionKey, JSON.stringify(newData));
                }
              }
            } else if (dm.delete) {
              await delValue(optionKey);
            }
          }
          if (!dm.autoBackup) {
            let size = (new TextEncoder(`utf-8`).encode(`{"${optionKey}":${await getValue(optionKey, `{}`)}}`)).length;
            totalSize += size;
            if (dm.switches) {
              dm.switches[optionKey].size.textContent = convertBytes(size);
            }
          }
          break;
        case `discussions`:
          if (!values) {
            values = {
              main: [`lastUsed`],
              ct: [`count`, `readComments`],
              df: [`hidden`],
              dh: [`highlighted`],
              gdttt: [`visited`],
              pm: [`status`]
            };
          }
        case `giveaways`:
          if (!values) {
            values = {
              main: [`code`, `comments`, `copies`, `creator`, `endTime`, `entries`, `gameId`, `gameName`, `gameSteamId`, `gameType`, `group`, `inviteOnly`, `lastUsed`, `level`, `points`, `regionRestricted`, `started`, `startTime`, `whitelist`, `winners`],
              ct: [`count`, `readComments`],
              gb: [`bookmarked`],
              gdttt: [`visited`],
              gf: [`hidden`],
              ggl: [`groups`]
            };
          }
        case `tickets`:
          if (!values) {
            values = {
              main: [`lastUsed`],
              ct: [`count`, `readComments`],
              gdttt: [`visited`],
              ust: [`sent`]
            };
          }
        case `trades`:
          if (!values) {
            values = {
              main: [`lastUsed`],
              ct: [`count`, `readComments`],
              gdttt: [`visited`]
            };
          }
          data[optionKey] = {};
          mergedData = JSON.parse(await getValue(optionKey, `{}`));
          sizes = {
            ct: 0,
            df: 0,
            dh: 0,
            gb: 0,
            gdttt: 0,
            gf: 0,
            ggl: 0,
            main: 0,
            pm: 0,
            total: 0,
            ust: 0
          };
          mainFound = false;
          for (let mergedDataKey in mergedData) {
            let newData = {};
            let toDelete = 0;
            let foundSub = 0;
            let deletedSub = 0;
            let found = null;
            let toExport = false;
            for (let value in values) {
              if (esgst.settings[`${dm.type}_${optionKey}_${value}`]) {
                toDelete += 1;
              }
              for (let j = 0, numValues = values[value].length; j < numValues; ++j) {
                let valueKey = values[value][j];
                let mergedDataValue = mergedData[mergedDataKey][valueKey];
                if (typeof mergedDataValue !== `undefined`) {
                  if (value !== `main`) {
                    foundSub += 1;
                  }
                  if (dm.autoBackup || esgst.settings[`${dm.type}_${optionKey}_${value}`] || value === `main`) {
                    newData[valueKey] = mergedDataValue;
                    if (value !== `main`) {
                      toExport = true;
                    }
                  }
                  let size = (new TextEncoder(`utf-8`).encode(`"${valueKey}":${JSON.stringify(mergedDataValue)},`)).length;
                  sizes[value] += size;
                  sizes.total += size;
                  found = value;
                  if (!space && dm.delete && esgst.settings[`${dm.type}_${optionKey}_${value}`] && value !== `main`) {
                    deletedSub += 1;
                    delete mergedData[mergedDataKey][valueKey];
                  }
                }
              }
            }
            if (found) {
              sizes[found] -= 1;
              sizes.total -= 1;
            }
            if (dm.autoBackup || toExport || esgst.settings[`${dm.type}_${optionKey}_main`]) {
              data[optionKey][mergedDataKey] = newData;
              mainFound = true;
            }
            let size = (new TextEncoder(`utf-8`).encode(`"${mergedDataKey}":{},`)).length;
            sizes.main += size;
            sizes.total += size;
            if (!space && dm.delete && ((esgst.settings[`${dm.type}_${optionKey}_main`] && foundSub === deletedSub) || toDelete === Object.keys(values).length)) {
              delete mergedData[mergedDataKey];
            }
          }
          if (!space) {
            if (dm.import) {
              let newData = dm.data[optionKey];
              if (newData) {
                for (let newDataKey in newData) {
                  if (!mergedData[newDataKey]) {
                    mergedData[newDataKey] = {};
                  }
                  for (let value in values) {
                    if (esgst.settings[`${dm.type}_${optionKey}_${value}`]) {
                      if (esgst.settings.importAndMerge) {
                        for (let j = 0, numValues = values[value].length; j < numValues; ++j) {
                          let valueKey = values[value][j];
                          if (valueKey === `readComments`) {
                            if (mergedData[newDataKey].readComments) {
                              for (let id in mergedData[newDataKey].readComments) {
                                if (newData[newDataKey].readComments[id] > mergedData[newDataKey].readComments[id]) {
                                  mergedData[newDataKey].readComments[id] = newData[newDataKey].readComments[id];
                                }
                              }
                            } else {
                              mergedData[newDataKey].readComments = newData[newDataKey].readComments;
                            }
                          } else {
                            mergedData[newDataKey][valueKey] = newData[newDataKey][valueKey];
                          }
                        }
                      } else {
                        for (let j = 0, numValues = values[value].length; j < numValues; ++j) {
                          let valueKey = values[value][j];
                          mergedData[newDataKey][valueKey] = newData[newDataKey][valueKey];
                        }
                      }
                    }
                  }
                }
                await setValue(optionKey, JSON.stringify(mergedData));
              }
            } else if (dm.delete) {
              await setValue(optionKey, JSON.stringify(mergedData));
            }
          }
          if (mainFound) {
            sizes.main -= 1;
            sizes.total -= 1;
          }
          if (!dm.autoBackup) {
            let size = (new TextEncoder(`utf-8`).encode(`{"${optionKey}":{}}`)).length;
            sizes.main += size;
            sizes.total += size;
            if (dm.switches) {
              for (let value in values) {
                if (dm.switches[`${optionKey}_${value}`]) {
                  dm.switches[`${optionKey}_${value}`].size.textContent = convertBytes(sizes[value]);
                }
              }
              dm.switches[optionKey].size.textContent = convertBytes(sizes.total);
            }
            totalSize += sizes.total;
          }
          break;
        case `emojis`:
          data.emojis = JSON.parse(await getValue(`emojis`, `[]`));
          if (!space) {
            if (dm.import) {
              let newData = JSON.stringify(dm.data.emojis);
              if (newData) {
                if (esgst.settings.importAndMerge) {
                  await setValue(`emojis`, JSON.stringify(
                    Array.from(
                      new Set(
                        data.emojis.concat(
                          JSON.parse(fixEmojis(newData))
                        )
                      )
                    )
                  ));
                } else {
                  await setValue(`emojis`, fixEmojis(newData));
                }
              }
            } else if (dm.delete) {
              await delValue(`emojis`);
            }
          }
          if (!dm.autoBackup) {
            let size = (new TextEncoder(`utf-8`).encode(`{"${optionKey}":${await getValue(optionKey, `"[]"`)}}`)).length;
            totalSize += size;
            if (dm.switches) {
              dm.switches[optionKey].size.textContent = convertBytes(size);
            }
          }
          break;
        case `entries`:
        case `templates`:
        case `savedReplies`:
          data[optionKey] = JSON.parse(await getValue(optionKey, `[]`));
          if (!space) {
            if (dm.import) {
              let newData = dm.data[optionKey];
              if (newData) {
                if (esgst.settings.importAndMerge) {
                  let dataKey = optionKey === `entries` ? `timestamp` : `name`;
                  mergedData = data[optionKey];
                  for (let j = 0, numNew = newData.length; j < numNew; ++j) {
                    let newDataValue = newData[j];
                    let k, numMerged;
                    for (k = 0, numMerged = mergedData.length; k < numMerged && mergedData[k][dataKey] !== newDataValue[dataKey]; ++k);
                    if (k < numMerged) {
                      mergedData[k] = newDataValue;
                    } else {
                      mergedData.push(newDataValue);
                    }
                  }
                  if (optionKey === `entries`) {
                    mergedData = sortArrayByNumberKey(mergedData, `timestamp`);
                  }
                  await setValue(optionKey, JSON.stringify(mergedData));
                } else {
                  await setValue(optionKey, JSON.stringify(newData));
                }
              }
            } else if (dm.delete) {
              await delValue(optionKey);
            }
          }
          if (!dm.autoBackup) {
            let size = (new TextEncoder(`utf-8`).encode(`{"${optionKey}":${await getValue(optionKey, `[]`)}}`)).length;
            totalSize += size;
            if (dm.switches) {
              dm.switches[optionKey].size.textContent = convertBytes(size);
            }
          }
          break;
        case `games`:
          values = {
            main: [`reducedCV`, `noCV`, `hidden`, `ignored`, `owned`, `wishlisted`],
            gt: [`tags`],
            egh: [`entered`],
            itadi: [`itadi`]
          };
          data.games = {
            apps: {},
            subs: {}
          };
          mergedData = JSON.parse(await getValue(`games`, `{"apps":{},"subs":{}}`));
          sizes = {
            egh: 0,
            gt: 0,
            itadi: 0,
            main: 0,
            total: 0
          };
          mainFound = false;
          for (let mergedDataKey in mergedData.apps) {
            let mergedDataValue = mergedData.apps[mergedDataKey];
            let newData = {};
            let toDelete = 0;
            let foundSub = 0;
            let deletedSub = 0;
            let found = null;
            let toExport = false;
            for (let value in values) {
              if (esgst.settings[`${dm.type}_games_${value}`]) {
                toDelete += 1;
              }
              for (let j = 0, numValues = values[value].length; j < numValues; ++j) {
                let valueKey = values[value][j];
                let newDataValue = mergedDataValue[valueKey];
                if (typeof newDataValue !== `undefined`) {
                  if (value !== `main`) {
                    foundSub += 1;
                  }
                  if (dm.autoBackup || esgst.settings[`${dm.type}_games_${value}`] || value === `main`) {
                    newData[valueKey] = newDataValue;
                    if (value !== `main`) {
                      toExport = true;
                    }
                  }
                  let size = (new TextEncoder(`utf-8`).encode(`"${valueKey}":${JSON.stringify(newDataValue)},`)).length;
                  sizes[value] += size;
                  sizes.total += size;
                  found = value;
                  if (!space && dm.delete && esgst.settings[`${dm.type}_games_${value}`] && value !== `main`) {
                    deletedSub += 1;
                    delete mergedDataValue[valueKey];
                  }
                }
              }
            }
            if (found) {
              sizes[found] -= 1;
              sizes.total -= 1;
            }
            if (dm.autoBackup || toExport || esgst.settings[`${dm.type}_${optionKey}_main`]) {
              data.games.apps[mergedDataKey] = newData;
              mainFound = true;
            }
            let size = (new TextEncoder(`utf-8`).encode(`"${mergedDataKey}":{},`)).length;
            sizes.main += size;
            sizes.total += size;
            if (!space && dm.delete && ((esgst.settings[`${dm.type}_${optionKey}_main`] && foundSub === deletedSub) || toDelete === Object.keys(values).length)) {
              delete mergedData.apps[mergedDataKey];
            }
          }
          if (mainFound) {
            sizes.main -= 1;
            sizes.total -= 1;
          }
          mainFound = false;
          for (let mergedDataKey in mergedData.subs) {
            let mergedDataValue = mergedData.subs[mergedDataKey];
            let newData = {};
            let toDelete = 0;
            let foundSub = 0;
            let deletedSub = 0;
            let found = null;
            let toExport = false;
            for (let value in values) {
              if (esgst.settings[`${dm.type}_games_${value}`]) {
                toDelete += 1;
              }
              for (let j = 0, numValues = values[value].length; j < numValues; ++j) {
                let valueKey = values[value][j];
                let newDataValue = mergedDataValue[valueKey];
                if (typeof newDataValue !== `undefined`) {
                  if (value !== `main`) {
                    foundSub += 1;
                  }
                  if (dm.autoBackup || esgst.settings[`${dm.type}_games_${value}`] || value === `main`) {
                    newData[valueKey] = newDataValue;
                    if (value !== `main`) {
                      toExport = true;
                    }
                  }
                  let size = (new TextEncoder(`utf-8`).encode(`"${valueKey}":${JSON.stringify(newDataValue)},`)).length;
                  sizes[value] += size;
                  sizes.total += size;
                  found = value;
                  if (!space && dm.delete && esgst.settings[`${dm.type}_games_${value}`] && value !== `main`) {
                    deletedSub += 1;
                    delete mergedDataValue[valueKey];
                  }
                }
              }
            }
            if (found) {
              sizes[found] -= 1;
              sizes.total -= 1;
            }
            if (dm.autoBackup || toExport || esgst.settings[`${dm.type}_${optionKey}_main`]) {
              data.games.subs[mergedDataKey] = newData;
              mainFound = true;
            }
            let size = (new TextEncoder(`utf-8`).encode(`"${mergedDataKey}":{},`)).length;
            sizes.main += size;
            sizes.total += size;
            if (!space && dm.delete && ((esgst.settings[`${dm.type}_${optionKey}_main`] && foundSub === deletedSub) || toDelete === Object.keys(values).length)) {
              delete mergedData.subs[mergedDataKey];
            }
          }
          if (mainFound) {
            sizes.main -= 1;
            sizes.total -= 1;
          }
          if (!space) {
            if (dm.import) {
              let newData = dm.data.games;
              if (newData) {
                for (let newDataKey in newData.apps) {
                  let newDataValue = newData.apps[newDataKey];
                  if (!mergedData.apps[newDataKey]) {
                    mergedData.apps[newDataKey] = {};
                  }
                  let mergedDataValue = mergedData.apps[newDataKey];
                  for (let value in values) {
                    if (esgst.settings[`${dm.type}_games_${value}`]) {
                      for (let j = 0, numValues = values[value].length; j < numValues; ++j) {
                        let valueKey = values[value][j];
                        if (typeof newDataValue[valueKey] !== `undefined`) {
                          if (esgst.settings.importAndMerge) {
                            switch (valueKey) {
                              case `entered`:
                                mergedDataValue.entered = true;
                                break;
                              case `itadi`:
                                if (mergedDataValue.itadi) {
                                  if (newDataValue.itadi.lastCheck > mergedDataValue.itadi.lastCheck) {
                                    mergedDataValue.itadi = newDataValue.itadi;
                                  }
                                } else {
                                  mergedDataValue.itadi = newDataValue.itadi;
                                }
                                break;
                              case `tags`:
                                if (mergedDataValue.tags) {
                                  let tags = newDataValue.tags;
                                  for (let k = 0, numTags = tags.length; k < numTags; ++k) {
                                    let tag = tags[k];
                                    if (mergedDataValue.tags.indexOf(tag) < 0) {
                                      mergedDataValue.tags.push(tag);
                                    }
                                  }
                                } else {
                                  mergedDataValue.tags = newDataValue.tags;
                                }
                                break;
                              default:
                                mergedDataValue[valueKey] = newDataValue[valueKey];
                                break;
                            }
                          } else {
                            mergedDataValue[valueKey] = newDataValue[valueKey];
                          }
                        }
                      }
                    }
                  }
                }
                for (let newDataKey in newData.subs) {
                  let newDataValue = newData.subs[newDataKey];
                  if (!mergedData.subs[newDataKey]) {
                    mergedData.subs[newDataKey] = {};
                  }
                  let mergedDataValue = mergedData.subs[newDataKey];
                  for (let value in values) {
                    if (esgst.settings[`${dm.type}_games_${value}`]) {
                      for (let j = 0, numValues = values[value].length; j < numValues; ++j) {
                        let valueKey = values[value][j];
                        if (typeof newDataValue[valueKey] !== `undefined`) {
                          if (esgst.settings.importAndMerge) {
                            switch (valueKey) {
                              case `entered`:
                                mergedDataValue.entered = true;
                                break;
                              case `itadi`:
                                if (mergedDataValue.itadi) {
                                  if (newDataValue.itadi.lastCheck > mergedDataValue.itadi.lastCheck) {
                                    mergedDataValue.itadi = newDataValue.itadi;
                                  }
                                } else {
                                  mergedDataValue.itadi = newDataValue.itadi;
                                }
                                break;
                              case `tags`:
                                if (mergedDataValue.tags) {
                                  let tags = newDataValue.tags;
                                  for (let k = 0, numTags = tags.length; k < numTags; ++k) {
                                    let tag = tags[k];
                                    if (mergedDataValue.tags.indexOf(tag) < 0) {
                                      mergedDataValue.tags.push(tag);
                                    }
                                  }
                                } else {
                                  mergedDataValue.tags = newDataValue.tags;
                                }
                                break;
                              default:
                                mergedDataValue[valueKey] = newDataValue[valueKey];
                                break;
                            }
                          } else {
                            mergedDataValue[valueKey] = newDataValue[valueKey];
                          }
                        }
                      }
                    }
                  }
                }
                await setValue(`games`, JSON.stringify(mergedData));
              }
            } else if (dm.delete) {
              await setValue(`games`, JSON.stringify(mergedData));
            }
          }
          if (!dm.autoBackup) {
            let size = (new TextEncoder(`utf-8`).encode(`{"${optionKey}":{"apps":{},"subs":{}}}`)).length;
            sizes.main += size;
            sizes.total += size;
            if (dm.switches) {
              for (let value in values) {
                if (dm.switches[`${optionKey}_${value}`]) {
                  dm.switches[`${optionKey}_${value}`].size.textContent = convertBytes(sizes[value]);
                }
              }
              dm.switches[optionKey].size.textContent = convertBytes(sizes.total);
            }
            totalSize += sizes.total;
          }
          break;
        case `groups`:
          values = {
            main: [`avatar`, `code`, `member`, `name`],
            sgg: [`stickied`]
          };
          mergedData = JSON.parse(await getValue(optionKey, `[]`));
          if (!Array.isArray(mergedData)) {
            let temp = [];
            for (let key in mergedData) {
              temp.push(mergedData[key]);
            }
            mergedData = temp;
          }
          data[optionKey] = [];
          sizes = {
            main: 0,
            sgg: 0,
            total: 0
          };
          mainFound = false;
          for (let j = mergedData.length - 1; j > -1; --j) {
            let newData = {};
            let toDelete = 0;
            let foundSub = 0;
            let deletedSub = 0;
            let found = null;
            let toExport = false;
            for (let value in values) {
              if (esgst.settings[`${dm.type}_${optionKey}_${value}`]) {
                toDelete += 1;
              }
              for (let k = 0, numValues = values[value].length; k < numValues; ++k) {
                let valueKey = values[value][k];
                if (mergedData[j]) {
                  let mergedDataValue = mergedData[j][valueKey];
                  if (typeof mergedDataValue !== `undefined`) {
                    if (value !== `main`) {
                      foundSub += 1;
                    }
                    if (dm.autoBackup || esgst.settings[`${dm.type}_${optionKey}_${value}`] || value === `main`) {
                      newData[valueKey] = mergedDataValue;
                      if (value !== `main`) {
                        toExport = true;
                      }
                    }
                    let size = (new TextEncoder(`utf-8`).encode(`"${valueKey}":${JSON.stringify(mergedDataValue)},`)).length;
                    sizes[value] += size;
                    sizes.total += size;
                    found = value;
                    if (!space && dm.delete && esgst.settings[`${dm.type}_${optionKey}_${value}`] && value !== `main`) {
                      deletedSub += 1;
                      delete mergedData[j][valueKey];
                    }
                  }
                }
              }
            }
            if (found) {
              sizes[found] -= 1;
              sizes.total -= 1;
            }
            if (dm.autoBackup || toExport || esgst.settings[`${dm.type}_${optionKey}_main`]) {
              data[optionKey].push(newData);
              mainFound = true;
            }
            let size = (new TextEncoder(`utf-8`).encode(`{},`)).length;
            sizes.main += size;
            sizes.total += size;
            if (!space && dm.delete && ((esgst.settings[`${dm.type}_${optionKey}_main`] && foundSub === deletedSub) || toDelete === Object.keys(values).length)) {
              mergedData.pop();
            }
          }
          if (mainFound) {
            sizes.main -= 1;
            sizes.total -= 1;
          }
          if (!space) {
            if (dm.import) {
              let newData = dm.data[optionKey];
              if (!Array.isArray(newData)) {
                let temp = [];
                for (let key in newData) {
                  temp.push(newData[key]);
                }
                newData = temp;
              }
              if (newData) {
                for (let j = newData.length - 1; j > -1; --j) {
                  let code = newData[j].code;
                  let k, mergedDataValue;
                  for (k = mergedData.length - 1; k > -1 && mergedData[k].code !== code; --k);
                  if (k > -1) {
                    mergedDataValue = mergedData[k];
                  } else {
                    mergedDataValue = {};
                    mergedData.push(mergedDataValue);
                  }
                  for (let value in values) {
                    if (esgst.settings[`${dm.type}_${optionKey}_${value}`]) {
                      for (let k = 0, numValues = values[value].length; k < numValues; ++k) {
                        let valueKey = values[value][k];
                        mergedDataValue[valueKey] = newData[j][valueKey];
                      }
                    }
                  }
                }
                await setValue(optionKey, JSON.stringify(mergedData));
              }
            } else if (dm.delete) {
              await setValue(optionKey, JSON.stringify(mergedData));
            }
          }
          if (!dm.autoBackup) {
            let size = (new TextEncoder(`utf-8`).encode(`{"${optionKey}":[]}`)).length;
            sizes.main += size;
            sizes.total += size;
            if (dm.switches) {
              for (let value in values) {
                if (dm.switches[`${optionKey}_${value}`]) {
                  dm.switches[`${optionKey}_${value}`].size.textContent = convertBytes(sizes[value]);
                }
              }
              dm.switches[optionKey].size.textContent = convertBytes(sizes.total);
            }
            totalSize += sizes.total;
          }
          break;
        case `rerolls`:
        case `stickiedCountries`:
          data[optionKey] = JSON.parse(await getValue(optionKey, `[]`));
          if (!space) {
            if (dm.import) {
              let newData = dm.data[optionKey];
              if (newData) {
                if (esgst.settings.importAndMerge) {
                  mergedData = data[optionKey];
                  for (let j = 0, numNew = newData.length; j < numNew; ++j) {
                    let newDataValue = newData[j];
                    if (mergedData.indexOf(newDataValue) < 0) {
                      mergedData.push(newDataValue);
                    }
                  }
                  await setValue(optionKey, JSON.stringify(mergedData));
                } else {
                  await setValue(optionKey, JSON.stringify(newData));
                }
              }
            } else if (dm.delete) {
              await delValue(optionKey);
            }
          }
          if (!dm.autoBackup) {
            let size = (new TextEncoder(`utf-8`).encode(`{"${optionKey}":${await getValue(optionKey, `[]`)}}`)).length;
            totalSize += size;
            if (dm.switches) {
              dm.switches[optionKey].size.textContent = convertBytes(size);
            }
          }
          break;
        case `sgCommentHistory`:
          data[optionKey] = JSON.parse(await getValue(optionKey, `[]`));
          if (!space) {
            if (dm.import) {
              let newData = dm.data[optionKey];
              if (newData) {
                if (esgst.settings.importAndMerge) {
                  mergedData = [];
                  let oldData = data[optionKey];
                  let j = 0;
                  let k = 0;
                  let numNew = newData.length;
                  let numOld = oldData.length;
                  while (j < numOld && k < numNew) {
                    let oldDataValue = oldData[j];
                    let newDataValue = newData[k];
                    if (oldDataValue.timestamp > newDataValue.timestamp) {
                      mergedData.push(oldDataValue);
                      j += 1;
                    } else {
                      let l, numOld;
                      for (l = 0; l < numOld && oldData[l].id !== newDataValue.id; ++l);
                      if (l >= numOld) {
                        mergedData.push(newDataValue);
                      }
                      k += 1;
                    }
                  }
                  while (j < numOld) {
                    mergedData.push(oldData[j]);
                    j += 1;
                  }
                  while (k < numNew) {
                    let newDataValue = newData[k];
                    let l, numOld;
                    for (l = 0; l < numOld && oldData[l].id !== newDataValue.id; ++l);
                    if (l >= numOld) {
                      mergedData.push(newDataValue);
                    }
                    k += 1;
                  }
                  await setValue(optionKey, JSON.stringify(mergedData));
                } else {
                  await setValue(optionKey, JSON.stringify(newData));
                }
              }
            } else if (dm.delete) {
              await delValue(optionKey);
            }
          }
          if (!dm.autoBackup) {
            let size = (new TextEncoder(`utf-8`).encode(`{"${optionKey}":${await getValue(optionKey, `[]`)}}`)).length;
            totalSize += size;
            if (dm.switches) {
              dm.switches[optionKey].size.textContent = convertBytes(size);
            }
          }
          break;
        case `users`:
          values = {
            main: [`whitelisted`, `whitelistedDate`, `blacklisted`, `blacklistedDate`],
            giveaways: [`giveaways`],
            namwc: [`namwc`],
            notes: [`notes`],
            nrf: [`nrf`],
            tags: [`tags`],
            uf: [`uf`],
            wbc: [`wbc`]
          };
          data.users = {
            steamIds: {},
            users: {}
          };
          mergedData = JSON.parse(await getValue(`users`, `{"steamIds":{},"users":{}}`));
          sizes = {
            giveaways: 0,
            namwc: 0,
            notes: 0,
            nrf: 0,
            main: 0,
            tags: 0,
            total: 0,
            uf: 0,
            wbc: 0
          };
          mainFound = false;
          mainUsernameFound = false;
          for (let mergedDataKey in mergedData.users) {
            let mergedDataValue = mergedData.users[mergedDataKey];
            let newData = {};
            let toDelete = 0;
            let foundSub = 0;
            let deletedSub = 0;
            let found = null;
            let toExport = false;
            for (let value in values) {
              if (esgst.settings[`${dm.type}_users_${value}`]) {
                toDelete += 1;
              }
              for (let j = 0, numValues = values[value].length; j < numValues; ++j) {
                let valueKey = values[value][j];
                if (typeof mergedDataValue[valueKey] !== `undefined`) {
                  if (value !== `main`) {
                    foundSub += 1;
                  }
                  if (dm.autoBackup || esgst.settings[`${dm.type}_users_${value}`] || value === `main`) {
                    newData[valueKey] = mergedDataValue[valueKey];
                    if (value !== `main`) {
                      toExport = true;
                    }
                  }
                  let size = (new TextEncoder(`utf-8`).encode(`"${valueKey}":${JSON.stringify(mergedDataValue[valueKey])},`)).length;
                  sizes[value] += size;
                  sizes.total += size;
                  found = value;
                  if (!space && dm.delete && esgst.settings[`${dm.type}_users_${value}`] && value !== `main`) {
                    deletedSub += 1;
                    delete mergedDataValue[valueKey];
                  }
                }
              }
            }
            if (found) {
              sizes[found] -= 1;
              sizes.total -= 1;
            }
            let id = mergedDataValue.id;
            let username = mergedDataValue.username;
            let size = 0;
            if (id) {
              size += (new TextEncoder(`utf-8`).encode(`"id":"${id}",`)).length;
            }
            if (username) {
              size += (new TextEncoder(`utf-8`).encode(`"username":"${username}","${username}":"${mergedDataKey}",`)).length;
            }
            if (dm.autoBackup || toExport || esgst.settings[`${dm.type}_${optionKey}_main`]) {
              if (id) {
                newData.id = id;
              }
              if (username) {
                newData.username = username;
                data.users.steamIds[username] = mergedDataKey;
                mainUsernameFound = true;
              }
              data.users.users[mergedDataKey] = newData;
              mainFound = true;
            }
            size += (new TextEncoder(`utf-8`).encode(`"${mergedDataKey}":{},`)).length;
            sizes.main += size;
            sizes.total += size;
            if (!space && dm.delete && ((esgst.settings[`${dm.type}_${optionKey}_main`] && foundSub === deletedSub) || toDelete === Object.keys(values).length)) {
              delete mergedData.steamIds[mergedDataValue.username];
              delete mergedData.users[mergedDataKey];
            }
          }
          if (mainFound) {
            sizes.main -= 1;
            sizes.total -= 1;
          }
          if (mainUsernameFound) {
            sizes.main -= 1;
            sizes.total -= 1;
          }
          if (!space) {
            if (dm.import) {
              let newData = dm.data.users;
              if (newData) {
                for (let newDataKey in newData.users) {
                  let newDataValue = newData.users[newDataKey];
                  if (!mergedData.users[newDataKey]) {
                    mergedData.users[newDataKey] = {
                      id: newDataValue.id,
                      username: newDataValue.username
                    };
                    mergedData.steamIds[newDataValue.username] = newDataKey;
                  }
                  let mergedDataValue = mergedData.users[newDataKey];
                  for (let value in values) {
                    if (esgst.settings[`${dm.type}_users_${value}`]) {
                      for (let j = 0, numValues = values[value].length; j < numValues; ++j) {
                        let valueKey = values[value][j];
                        if (newDataValue[valueKey]) {
                          if (esgst.settings.importAndMerge) {
                            switch (valueKey) {
                              case `whitelisted`:
                              case `whitelistedDate`:
                              case `blacklisted`:
                              case `blacklistedDate`:
                                mergedDataValue[valueKey] = newDataValue[valueKey];
                                break;
                              case `notes`:
                                mergedDataValue.notes = removeDuplicateNotes(mergedDataValue.notes ? `${mergedDataValue.notes}\n\n${newDataValue.notes}` : newDataValue.notes);
                                break;
                              case `tags`:
                                if (mergedDataValue.tags) {
                                  let tags = newDataValue.tags;
                                  for (let k = 0, numTags = tags.length; k < numTags; ++k) {
                                    let tag = tags[k];
                                    if (mergedDataValue.tags.indexOf(tag) < 0) {
                                      mergedDataValue.tags.push(tag);
                                    }
                                  }
                                } else {
                                  mergedDataValue.tags = newDataValue.tags;
                                }
                                break;
                              case `giveaways`:
                                if (mergedDataValue.giveaways) {
                                  if (newDataValue.giveaways.wonTimestamp > mergedDataValue.giveaways.wonTimestamp) {
                                    mergedDataValue.giveaways.won = newDataValue.giveaways.won;
                                    mergedDataValue.giveaways.wonTimestamp = newDataValue.giveaways.wonTimestamp;
                                  }
                                  if (newDataValue.giveaways.sentTimestamp > mergedDataValue.giveaways.sentTimestamp) {
                                    mergedDataValue.giveaways.sent = newDataValue.giveaways.sent;
                                    mergedDataValue.giveaways.sentTimestamp = newDataValue.giveaways.sentTimestamp;
                                  }
                                } else {
                                  mergedDataValue.giveaways = newDataValue.giveaways;
                                }
                                break;
                              default:
                                if (mergedDataValue[valueKey]) {
                                  if (newDataValue[valueKey].lastCheck > mergedDataValue[valueKey].lastCheck) {
                                    mergedDataValue[valueKey] = newDataValue[valueKey];
                                  }
                                } else {
                                  mergedDataValue[valueKey] = newDataValue[valueKey];
                                }
                                break;
                            }
                          } else {
                            mergedDataValue[valueKey] = newDataValue[valueKey];
                          }
                        }
                      }
                    }
                  }
                }
                await setValue(`users`, JSON.stringify(mergedData));
              }
            } else if (dm.delete) {
              await setValue(`users`, JSON.stringify(mergedData));
            }
          }
          if (!dm.autoBackup) {
            let size = (new TextEncoder(`utf-8`).encode(`{"${optionKey}":{"steamIds":{},"users":{}}}`)).length;
            sizes.main += size;
            sizes.total += size;
            if (dm.switches) {
              for (const value in values) {
                if (dm.switches[`${optionKey}_${value}`]) {
                  dm.switches[`${optionKey}_${value}`].size.textContent = convertBytes(sizes[value]);
                }
              }
              dm.switches[optionKey].size.textContent = convertBytes(sizes.total);
            }
            totalSize += sizes.total;
          }
          break;
        case `winners`:
          data.winners = JSON.parse(await getValue(`winners`, `{}`));
          if (!space) {
            if (dm.import) {
              let newData = dm.data.winners;
              if (newData) {
                if (esgst.settings.importAndMerge) {
                  mergedData = data.winners;
                  for (let newDataKey in newData) {
                    if (!mergedData[newDataKey]) {
                      mergedData[newDataKey] = [];
                    }
                    for (let j = 0, numNew = newData[newDataKey].length; j < numNew; ++j) {
                      let newDataValue = newData[newDataKey][j];
                      if (mergedData[newDataKey].indexOf(newDataValue) < 0) {
                        mergedData[newDataKey].push(newDataValue);
                      }
                    }
                  }
                  await setValue(`winners`, JSON.stringify(mergedData));
                } else {
                  await setValue(`winners`, JSON.stringify(newData));
                }
              }
            } else if (dm.delete) {
              await delValue(`winners`);
            }
          }
          if (!dm.autoBackup) {
            let size = (new TextEncoder(`utf-8`).encode(`{"${optionKey}":${await getValue(optionKey, `{}`)}}`)).length;
            totalSize += size;
            if (dm.switches) {
              dm.switches[optionKey].size.textContent = convertBytes(size);
            }
          }
          break;
        default:
          break;
      }
    }
    if (!dm.autoBackup && dm.computerSpaceCount) {
      dm.computerSpaceCount.textContent = convertBytes(totalSize);
    }
    if (space) {
      if (space.close) {
        space.close();
      }
      return totalSize;
    } else {
      if (dm.type === `export` || esgst.settings.exportBackup) {
        if (dropbox || (dm.type !== `export` && esgst.settings.exportBackupIndex === 1)) {
          await delValue(`dropboxToken`);
          openSmallWindow(`https://www.dropbox.com/oauth2/authorize?redirect_uri=https://www.steamgifts.com/esgst/dropbox&response_type=token&client_id=nix7kvchwa8wdvj`);
          checkDropboxComplete(data, dm, callback);
        } else if (googleDrive || (dm.type !== `export` && esgst.settings.exportBackupIndex === 2)) {
          await delValue(`googleDriveToken`);
          openSmallWindow(`https://accounts.google.com/o/oauth2/v2/auth?redirect_uri=https://www.steamgifts.com/esgst/google-drive&response_type=token&client_id=102804278399-95kit5e09mdskdta7eq97ra7tuj20qps.apps.googleusercontent.com&scope=https://www.googleapis.com/auth/drive.appdata`);
          checkGoogleDriveComplete(data, dm, callback);
        } else if (oneDrive || (dm.type !== `export` && esgst.settings.exportBackupIndex === 3)) {
          await delValue(`oneDriveToken`);
          openSmallWindow(`https://login.microsoftonline.com/common/oauth2/v2.0/authorize?redirect_uri=https://www.steamgifts.com/esgst/onedrive&response_type=token&client_id=1781429b-289b-4e6e-877a-e50015c0af21&scope=files.readwrite`);
          checkOneDriveComplete(data, dm, callback);
        } else {
          const name = `${esgst.askFileName ?  prompt(`Enter the name of the file:`, `esgst_data_${new Date().toISOString().replace(/:/g, `_`)}`) : `esgst_data_${new Date().toISOString().replace(/:/g, `_`)}`}`;
          if (name === `null`) {
            callback();
            return;
          }
          await downloadZip(data, `${name}.json`, `${name}.zip`);
          if (!dm.autoBackup) {
            createFadeMessage(dm.message, `Data ${dm.pastTense} with success!`);
          }
          callback();
        }
      } else {
        createFadeMessage(dm.message, `Data ${dm.pastTense} with success!`);
        callback();
      }
    }
  }

  async function downloadZip(data, fileName, zipName) {
    downloadFile(null, zipName, await getZip(JSON.stringify(data), fileName));
  }

  async function getZip(data, fileName, type = `blob`) {
    const zip = new JSZip();
    zip.file(fileName, data);
    return (await zip.generateAsync({
      compression: `DEFLATE`,
      compressionOptions: {
        level: 9
      },
      type: type
    }));
  }

  async function readZip(data) {
    const zip = new JSZip(),
        contents = await zip.loadAsync(data),
        keys = Object.keys(contents.files),
        output = [];
    for (const key of keys) {
      output.push({
        name: key,
        value: await zip.file(key).async(`string`)
      });
    }
    return output;
  }

  function downloadFile(data, fileName, blob) {
    const url = URL.createObjectURL(blob || new Blob([data])),
        file = document.createElement(`a`);
    file.download = fileName;
    file.href = url;
    document.body.appendChild(file);
    file.click();
    file.remove();
    URL.revokeObjectURL(url);
  }

  function getDataSizes(dm) {
    let spacePopup = new Popup(`fa-circle-o-notch fa-spin`, `Calculating data sizes...`);
    spacePopup.open(manageData.bind(null, dm, false, false, false, spacePopup));
  }

  async function loadImportFile(dm, dropbox, googleDrive, oneDrive, space, callback) {
    let file;
    if (dropbox) {
      await delValue(`dropboxToken`);
      openSmallWindow(`https://www.dropbox.com/oauth2/authorize?redirect_uri=https://www.steamgifts.com/esgst/dropbox&response_type=token&client_id=nix7kvchwa8wdvj`);
      checkDropboxComplete(null, dm, callback);
    } else if (googleDrive) {
      await delValue(`googleDriveToken`);
      openSmallWindow(`https://accounts.google.com/o/oauth2/v2/auth?redirect_uri=https://www.steamgifts.com/esgst/google-drive&response_type=token&client_id=102804278399-95kit5e09mdskdta7eq97ra7tuj20qps.apps.googleusercontent.com&scope=https://www.googleapis.com/auth/drive.appdata`);
      checkGoogleDriveComplete(null, dm, callback);
    } else if (oneDrive) {
      await delValue(`oneDriveToken`);
      openSmallWindow(`https://login.microsoftonline.com/common/oauth2/v2.0/authorize?redirect_uri=https://www.steamgifts.com/esgst/onedrive&response_type=token&client_id=1781429b-289b-4e6e-877a-e50015c0af21&scope=files.readwrite`);
      checkOneDriveComplete(null, dm, callback);
    } else {
      file = dm.input.files[0];
      if (file) {
        dm.reader = new FileReader();
        const blob = file.name.match(/\.zip$/) && file;
        if (blob) {
          readImportFile(dm, dropbox, googleDrive, oneDrive, space, blob, callback);
        } else {
          dm.reader.readAsText(file);
          dm.reader.onload = readImportFile.bind(null, dm, dropbox, googleDrive, oneDrive, space, null, callback);
        }
      } else {
        createFadeMessage(dm.warning, `No file was loaded!`);
        callback();
      }
    }
  }

  async function readImportFile(dm, dropbox, googleDrive, oneDrive, space, blob, callback) {
    try {
      if (dm.reader) {
        dm.data = JSON.parse(blob
          ? (await readZip(blob))[0].value
          : dm.reader.result
        );
      }
      createConfirmation(`Are you sure you want to restore the selected data?`, manageData.bind(null, dm, dropbox, googleDrive, oneDrive, space, callback), callback);
    } catch (error) {
      createFadeMessage(dm.warning, `Cannot parse file!`);
      callback();
    }
  }

  function confirmDataDeletion(dm, dropbox, googleDrive, oneDrive, space, callback) {
    createConfirmation(`Are you sure you want to delete the selected data?`, manageData.bind(null, dm, dropbox, googleDrive, oneDrive, space, callback), callback);
  }

  async function checkDropboxComplete(data, dm, callback) {
    let value = await getValue(`dropboxToken`);
    if (value) {
      if (dm.type === `export` || (data && esgst.settings.exportBackup)) {
        const name = esgst.askFileName ?  prompt(`Enter the name of the file:`, `esgst_data_${new Date().toISOString().replace(/:/g, `_`)}`) : `esgst_data_${new Date().toISOString().replace(/:/g, `_`)}`;
        if (name === null) {
          callback();
          return;
        }
        let responseText = ``;
        try {
          const response = await request({
            data: JSON.stringify(data),
            fileName: `${name}.json`,
            headers: {
              authorization: `Bearer ${value}`,
              [`Dropbox-API-Arg`]: `{"path": "/${name}.zip"}`,
              [`Content-Type`]: `application/octet-stream`
            },
            method: `POST`,
            url: `https://content.dropboxapi.com/2/files/upload`
          });
          responseText = response.responseText;
          const responseJson = JSON.parse(responseText);
          if (!responseJson.id) {
            throw ``;
          }
          if (!dm.autoBackup) {
            createFadeMessage(dm.message, `Data ${dm.pastTense} with success!`);
          }
          callback();
        } catch (e) {
          callback();
          alert(`An error ocurred when uploading the file.\n\n${e}\n\n${responseText}`);
        }
      } else {
        let canceled = true;
        let popup = new Popup(`fa-dropbox`, `Select a file to restore:`, true);
        popup.onClose = () => {
          if (canceled) {
            callback();
          }
        };
        popup.open();
        let entries = insertHtml(popup.scrollable, `beforeEnd`, `<div class="popup__keys__list"></div>`);
        JSON.parse((await request({
          data: `{"path": ""}`,
          headers: {
            authorization: `Bearer ${value}`,
            [`Content-Type`]: `application/json`
          },
          method: `POST`,
          url: `https://api.dropboxapi.com/2/files/list_folder`
        })).responseText).entries.forEach(entry => {
          let item = insertHtml(entries, `beforeEnd`, `
            <div class="esgst-clickable">${entry.name} - ${convertBytes(entry.size)}</div>
          `);
          item.addEventListener(`click`, () => {
            createConfirmation(`Are you sure you want to restore the selected data?`, async () => {
              canceled = false;
              popup.close();
              dm.data = JSON.parse((await request({
                blob: entry.name.match(/\.zip$/),
                headers: {
                  authorization: `Bearer ${value}`,
                  [`Dropbox-API-Arg`]: `{"path": "/${entry.name}"}`,
                  [`Content-Type`]: `text/plain`
                },
                method: `GET`,
                url: `https://content.dropboxapi.com/2/files/download`
              })).responseText);
              manageData(dm, false, false, false, false, callback);
            });
          });
        });
      }
    } else {
      setTimeout(() => checkDropboxComplete(data, dm, callback), 250);
    }
  }

  async function checkGoogleDriveComplete(data, dm, callback) {
    let value = await getValue(`googleDriveToken`);
    if (value) {
      if (dm.type === `export` || (data && esgst.settings.exportBackup)) {
        const name = esgst.askFileName ?  prompt(`Enter the name of the file:`, `esgst_data_${new Date().toISOString().replace(/:/g, `_`)}`) : `esgst_data_${new Date().toISOString().replace(/:/g, `_`)}`;
        if (name === null) {
          callback();
          return;
        }
        let responseText = ``;
        try {
          const resourceResponse = await request({
            data: `{"name": "${name}.zip", "parents": ["appDataFolder"]}`,
            headers: {
              authorization: `Bearer ${value}`,
              [`Content-Type`]: `application/json`
            },
            method: `POST`,
            url: `https://www.googleapis.com/drive/v3/files`
          });
          const response = await request({
            data: JSON.stringify(data),
            fileName: `${name}.json`,
            headers: {
              authorization: `Bearer ${value}`,
              [`Content-Type`]: `application/zip`
            },
            method: `PATCH`,
            url: `https://www.googleapis.com/upload/drive/v3/files/${JSON.parse(resourceResponse.responseText).id}?uploadType=media`
          });
          responseText = response.responseText;
          const responseJson = JSON.parse(responseText);
          if (!responseJson.id) {
            throw ``;
          }
          if (!dm.autoBackup) {
            createFadeMessage(dm.message, `Data ${dm.pastTense} with success!`);
          }
          callback();
        } catch (e) {
          callback();
          alert(`An error ocurred when uploading the file.\n\n${e}\n\n${responseText}`);
        }
      } else {
        let canceled = true;
        let popup = new Popup(`fa-google`, `Select a file to restore:`, true);
        popup.onClose = () => {
          if (canceled) {
            callback();
          }
        };
        popup.open();
        let entries = insertHtml(popup.scrollable, `beforeEnd`, `<div class="popup__keys__list"></div>`);
        JSON.parse((await request({
          headers: {
            authorization: `Bearer ${value}`
          },
          method: `GET`,
          url: `https://www.googleapis.com/drive/v3/files?spaces=appDataFolder`
        })).responseText).files.forEach(file => {
          let item = insertHtml(entries, `beforeEnd`, `
            <div class="esgst-clickable">${file.name}</div>
          `);
          item.addEventListener(`click`, () => {
            createConfirmation(`Are you sure you want to restore the selected data?`, async () => {
              canceled = false;
              popup.close();
              dm.data = JSON.parse((await request({
                blob: file.name.match(/\.zip$/),
                headers: {
                  authorization: `Bearer ${value}`
                },
                method: `GET`,
                url: `https://www.googleapis.com/drive/v3/files/${file.id}?alt=media`
              })).responseText);
              manageData(dm, false, false, false, false, callback);
            });
          });
        });
      }
    } else {
      setTimeout(() => checkGoogleDriveComplete(data, dm, callback), 250);
    }
  }

  async function checkOneDriveComplete(data, dm, callback) {
    let value = await getValue(`oneDriveToken`);
    if (value) {
      if (dm.type === `export` || (data && esgst.settings.exportBackup)) {
        const name = esgst.askFileName ?  prompt(`Enter the name of the file:`, `esgst_data_${new Date().toISOString().replace(/:/g, `_`)}`) : `esgst_data_${new Date().toISOString().replace(/:/g, `_`)}`;
        if (name === null) {
          callback();
          return;
        }
        let responseText = ``;
        try {
          const response = await request({
            anon: true,
            data: JSON.stringify(data),
            fileName: `${name}.json`,
            headers: {
              Authorization: `bearer ${value}`,
              [`Content-Type`]: `application/zip`
            },
            method: `PUT`,
            url: `https://graph.microsoft.com/v1.0/me/drive/special/approot:/${name}.zip:/content`
          });
          responseText = response.responseText;
          const responseJson = JSON.parse(responseText);
          if (!responseJson.id) {
            throw ``;
          }
          if (!dm.autoBackup) {
            createFadeMessage(dm.message, `Data ${dm.pastTense} with success!`);
          }
          callback();
        } catch (e) {
          callback();
          alert(`An error ocurred when uploading the file.\n\n${e}\n\n${responseText}`);
        }
      } else {
        let canceled = true;
        let popup = new Popup(`fa-windows`, `Select a file to restore:`, true);
        let entries = insertHtml(popup.scrollable, `beforeEnd`, `<div class="popup__keys__list"></div>`);
        JSON.parse((await request({
          anon: true,
          headers: {
            Authorization: `bearer ${value}`
          },
          method: `GET`,
          url: `https://graph.microsoft.com/v1.0/me/drive/special/approot/children`
        })).responseText).value.forEach(file => {
          let item = insertHtml(entries, `beforeEnd`, `
            <div class="esgst-clickable">${file.name} - ${convertBytes(file.size)}</div>
          `);
          item.addEventListener(`click`, () => {
            createConfirmation(`Are you sure you want to restore the selected data?`, async () => {
              canceled = false;
              popup.close();
              dm.data = JSON.parse((await request({
                anon: true,
                blob: file.name.match(/\.zip$/),
                headers: {
                  authorization: `Bearer ${value}`
                },
                method: `GET`,
                url: `https://graph.microsoft.com/v1.0/me/drive/items/${file.id}/content`
              })).responseText);
              manageData(dm, false, false, false, false, callback);
            });
          });
        });
        popup.onClose = () => {
          if (canceled) {
            callback();
          }
        };
        popup.open();
      }
    } else {
      setTimeout(() => checkOneDriveComplete(data, dm, callback), 250);
    }
  }

  async function createLock(key, threshold) {
    let lock = {
      key: key,
      threshold: threshold,
      uuid: `xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx`.replace(/[xy]/g, createUuid)
    };
    await checkLock(lock);
    return setValue.bind(null, key, `{}`);
  }

  async function checkLock(lock) {
    let locked = JSON.parse(await getValue(lock.key, `{}`));
    if (!locked || !locked.uuid || locked.timestamp < Date.now() - (lock.threshold + 1000)) {
      await setValue(lock.key, JSON.stringify({
        timestamp: Date.now(),
        uuid: lock.uuid
      }));
      await timeout(lock.threshold / 2);
      locked = JSON.parse(await getValue(lock.key, `{}`));
      if (!locked || locked.uuid !== lock.uuid) {
        return checkLock(lock);
      }
    } else {
      await timeout(lock.threshold / 3);
      return checkLock(lock);
    }
  }

  async function lockAndSaveGames(games) {
    let deleteLock = await createLock(`gameLock`, 300);
    let saved = JSON.parse(await getValue(`games`));
    for (let key in games.apps) {
      if (saved.apps[key]) {
        for (let subKey in games.apps[key]) {
          if (games.apps[key][subKey] === null) {
            delete saved.apps[key][subKey];
          } else {
            saved.apps[key][subKey] = games.apps[key][subKey];
          }
        }
      } else {
        saved.apps[key] = games.apps[key];
      }
      if (!saved.apps[key].tags) {
        delete saved.apps[key].tags;
      }
    }
    for (let key in games.subs) {
      if (saved.subs[key]) {
        for (let subKey in games.subs[key]) {
          if (games.subs[key][subKey] === null) {
            delete saved.subs[key][subKey];
          } else {
            saved.subs[key][subKey] = games.subs[key][subKey];
          }
        }
      } else {
        saved.subs[key] = games.subs[key];
      }
      if (!saved.subs[key].tags) {
        delete saved.subs[key].tags;
      }
    }
    await setValue(`games`, JSON.stringify(saved));
    deleteLock();
  }

  async function setThemeVersion(id, version, theme) {
    if (!theme) {
      theme = await getValue(id);
    }
    let match = (theme || ``).match(/(v|black\s|blue\s|steamtrades\s)([.\d]+?)\*/);
    version.textContent = `v${(match && match[2]) || `Unknown`}`;
  }

  function resetColor(bgColorContext, colorContext, id) {
    if (colorContext) {
      colorContext.value = esgst.defaultValues[`${id}_color`];
      esgst.settings[`${id}_color`] = colorContext.value;
    }
    bgColorContext.value = esgst.defaultValues[`${id}_bgColor`];
    esgst.settings[`${id}_bgColor`] = bgColorContext.value;
    setValue(`settings`, JSON.stringify(esgst.settings));
  }

  async function resetOrder(select, event) {
    let message = insertHtml(event.currentTarget, `afterEnd`, `
      <div class="esgst-description esgst-bold">
        <i class="fa fa-circle-o-notch fa-spin"></i> Saving...
      </div>
    `);
    let key = select.value;
    esgst.settings[key] = esgst.defaultValues[key];
    await setValue(`settings`, JSON.stringify(esgst.settings));
    message.classList.add(`esgst-green`);
    message.innerHTML = `<i class="fa fa-check"></i> Saved!`;
    setTimeout(() => message.remove(), 2500);
  }

  function setSMManageFilteredUsers(SMManageFilteredUsers) {
    let popup;
    SMManageFilteredUsers.addEventListener(`click`, async () => {
      if (popup) {
        popup.open();
      } else {
        popup = new Popup(`fa-eye-slash`, `Filtered Users`);
        let users = JSON.parse(await getValue(`users`));
        let filtered = [];
        for (let key in users.users) {
          if (users.users[key].uf && (users.users[key].uf.posts || users.users[key].uf.giveaways || users.users[key].uf.discussions)) {
            filtered.push(users.users[key]);
          }
        }
        filtered.sort((a, b) => {
          if (a.username > b.username) {
            return -1;
          } else {
            return 1;
          }
        });
        let table = insertHtml(popup.scrollable, `beforeEnd`, `
          <div class="table">
            <div class="table__heading">
              <div class="table__column--width-fill">Username</div>
              <div class="table__column--width-small">Posts Hidden</div>
              <div class="table__column--width-small">Discussions Hidden</div>
              <div class="table__column--width-small">Giveaways Hidden</div>
            </div>
            <div class="table__rows"></div>
          </div>
        `);
        for (let i = 0, n = filtered.length; i < n; ++i) {
          let postsIcon = filtered[i].uf.posts ? `<i class="fa fa-check"></i>` : ``;
          let discussionsIcon = filtered[i].uf.discussions ? `<i class="fa fa-check"></i>` : ``;
          let giveawaysIcon = filtered[i].uf.giveaways ? `<i class="fa fa-check"></i>` : ``;
          table.lastElementChild.insertAdjacentHTML(`beforeEnd`, `
            <div class="table__row-outer-wrap">
              <div class="table__row-inner-wrap">
                <div class="table__column--width-fill"><a href="/user/${filtered[i].username}">${filtered[i].username}</a></div>
                <div class="table__column--width-small">${postsIcon}</div>
                <div class="table__column--width-small">${discussionsIcon}</div>
                <div class="table__column--width-small">${giveawaysIcon}</div>
              </div>
            </div>
          `);
        }
        popup.open();
      }
    });
  }

  function multiChoice(choice1Color, choice1Icon, choice1Title, choice2Color, choice2Icon, choice2Title, title, onChoice1, onChoice2) {
    if (esgst.settings.cfh_img_remember) {
      if (esgst.cfh_img_choice === 1) {
        onChoice1();
      } else {
        onChoice2();
      }
    } else {
      let popup = new Popup(`fa-list`, title, true);
      new ToggleSwitch(popup.description, `cfh_img_remember`, false, `Never ask again.`, false, false, `Remembers which option you choose forever.`, esgst.settings.cfh_img_remember);
      popup.description.appendChild(new ButtonSet(choice1Color, ``, choice1Icon, ``, choice1Title, ``, callback => {
        if (esgst.settings.cfh_img_remember) {
          setValue(`cfh_img_choice`, 1);
          esgst.cfh_img_choice = 1;
        }
        callback();
        popup.close();
        onChoice1();
      }).set);
      popup.description.appendChild(new ButtonSet(choice2Color, ``, choice2Icon, ``, choice2Title, ``, callback => {
        if (esgst.settings.cfh_img_remember) {
          setValue(`cfh_img_choice`, 2);
          esgst.cfh_img_choice = 2;
        }
        callback();
        popup.close();
        onChoice2();
      }).set);
      popup.open();
    }
  }

  async function exportSettings() {
    let data = {
      settings: JSON.parse(await getValue(`settings`, `{}`))
    };
    delete data.settings.avatar;
    delete data.settings.lastSync;
    delete data.settings.steamApiKey;
    delete data.settings.steamId;
    delete data.settings.syncFrequency;
    delete data.settings.username;
    const name = `${esgst.askFileName ?  prompt(`Enter the name of the file:`, `esgst_settings_${new Date().toISOString().replace(/:/g, `_`)}`) : `esgst_settings_${new Date().toISOString().replace(/:/g, `_`)}`}.json`;
    if (name === `null.json`) return;
    downloadFile(JSON.stringify(data), name);
  }

  async function selectSwitches(switches, type, settings, callback) {
    for (let key in switches) {
      let toggleSwitch = switches[key];
      if (Array.isArray(toggleSwitch)) {
        toggleSwitch[0][type](settings);
      } else if (!toggleSwitch.checkbox || toggleSwitch.checkbox.offsetParent) {
        toggleSwitch[type](settings);
      }
    }
    if (settings) {
      let message = insertHtml(settings, `beforeEnd`, `
        <div class="esgst-description esgst-bold">
          <i class="fa fa-circle-o-notch fa-spin" title="Saving..."></i>
        </div>
      `);
      await setValue(`settings`, JSON.stringify(esgst.settings));
      message.classList.add(`esgst-green`);
      message.innerHTML = `<i class="fa fa-check" title="Saved!"></i>`;
      setTimeout(() => message.remove(), 2500);
    }
    if (callback) {
      callback();
    }
  }

  function addStyle() {
    let backgroundColor, color, colors, i, n, style;
    style = `
      :root {
        --esgst-gwc-highlight-width: ${esgst.gwc_h_width};
        --esgst-gwr-highlight-width: ${esgst.gwr_h_width};
      }
    `;
    colors = [
      {
        id: `gc_h`,
        key: `hidden`,
        mainKey: `esgst-gc`
      },
      {
        id: `gc_gi`,
        key: `giveawayInfo`,
        mainKey: `esgst-gc`
      },
      {
        id: `gc_fcv`,
        key: `fullCV`,
        mainKey: `esgst-gc`
      },
      {
        id: `gc_rcv`,
        key: `reducedCV`,
        mainKey: `esgst-gc`
      },
      {
        id: `gc_ncv`,
        key: `noCV`,
        mainKey: `esgst-gc`
      },
      {
        id: `gc_w`,
        key: `wishlisted`,
        mainKey: `esgst-gc`
      },
      {
        id: `gc_o`,
        key: `owned`,
        mainKey: `esgst-gc`
      },
      {
        id: `gc_pw`,
        key: `won`,
        mainKey: `esgst-gc`
      },
      {
        id: `gc_i`,
        key: `ignored`,
        mainKey: `esgst-gc`
      },
      {
        id: `gc_rm`,
        key: `removed`,
        mainKey: `esgst-gc`
      },
      {
        id: `gc_ea`,
        key: `earlyAccess`,
        mainKey: `esgst-gc`
      },
      {
        id: `gc_tc`,
        key: `tradingCards`,
        mainKey: `esgst-gc`
      },
      {
        id: `gc_a`,
        key: `achievements`,
        mainKey: `esgst-gc`
      },
      {
        id: `gc_mp`,
        key: `multiplayer`,
        mainKey: `esgst-gc`
      },
      {
        id: `gc_sc`,
        key: `steamCloud`,
        mainKey: `esgst-gc`
      },
      {
        id: `gc_l`,
        key: `linux`,
        mainKey: `esgst-gc`
      },
      {
        id: `gc_m`,
        key: `mac`,
        mainKey: `esgst-gc`
      },
      {
        id: `gc_dlc`,
        key: `dlc`,
        mainKey: `esgst-gc`
      },
      {
        id: `gc_p`,
        key: `package`,
        mainKey: `esgst-gc`
      },
      {
        id: `gc_rd`,
        key: `releaseDate`,
        mainKey: `esgst-gc`
      },
      {
        id: `gc_g`,
        key: `genres`,
        mainKey: `esgst-gc`
      }
    ];
    for (i = 0, n = colors.length; i < n; ++i) {
      color = esgst[`${colors[i].id}_color`];
      backgroundColor = esgst[`${colors[i].id}_bgColor`];
      style += `
        ${colors[i].key === `genres` ? `a` : ``}.${colors[i].mainKey}-${colors[i].key}:not(.giveaway__column):not(.featured__column) {
          background-color: ${backgroundColor};
          ${color ? `color: ${color};` : ``}
        }
        .${colors[i].mainKey}-${colors[i].key}.giveaway__column, .${colors[i].mainKey}-${colors[i].key}.featured__column {
          color: ${backgroundColor};
        }
      `;
    }
    colors = [
      {
        id: `wbh_w`,
        key: `whitelisted`,
        mainKey: `esgst-wbh-highlight`
      },
      {
        id: `wbh_b`,
        key: `blacklisted`,
        mainKey: `esgst-wbh-highlight`
      },
      {
        id: `ge_p`,
        key: `public`,
        mainKey: `esgst-ge`
      },
      {
        id: `ge_g`,
        key: `group`,
        mainKey: `esgst-ge`
      },
      {
        id: `ge_b`,
        key: `blacklist`,
        mainKey: `esgst-ge`
      }
    ];
    for (i = 0, n = colors.length; i < n; ++i) {
      color = esgst[`${colors[i].id}_color`];
      backgroundColor = esgst[`${colors[i].id}_bgColor`];
      style += `
        .${colors[i].mainKey}-${colors[i].key} {
          background-color: ${backgroundColor} !important;
          ${color ? `color: ${color} !important;` : ``}
        }
      `;
    }
    style += `
      .esgst-hwlc-panel {
        display: flex;
        justify-items: space-between;
      }

      .esgst-hwlc-section {
        margin: 25px;
        width: 300px;
      }

      .esgst-hwlc-section textarea {
        min-height: 200px;
      }

      @keyframes border-blink {
        50% {
          border-color: transparent;
        }
      }

      .esgst-minimize-panel {
        left: -198px;
        position: fixed;
        top: 0;
        width: 200px;
        z-index: 999999999;
      }

      .esgst-minimize-panel:hover {
        padding-left: 198px;
      }

      .esgst-minimize-container {
        background-color: #fff;
        height: 100vh;
        overflow-y: auto;
        padding: 5px;
        width: 188px;
      }

      .esgst-minimize-panel.alert {
        animation: border-blink 1s ease-in-out infinite;
        border-right: 10px solid #ff0000;
        left: -200px;
      }

      .esgst-minimize-panel.alert:hover {
        border: none;
        left: -198px;
      }

      .esgst-minimize-item.alert {
        animation: border-blink 1s ease-in-out infinite;
        border: 2px solid #ff0000;
      }

      :root {
        --esgst-body-bg-color: #f0f2f5;
      }

      .sticky_sentinel {
        left: 0;
        position: absolute;
        right: 0;
        visibility: hidden;
      }

      .esgst-gf-basic-filters {
        display: flex;
        justify-content: space-between;
      }

      .esgst-gf-basic-filters input {
        display: inline-block;
        padding: 2px;
        width: 100px;
      }

      .esgst-gf-basic-filters >* {
        margin: 5px;
      }

      .esgst-gf-number-filters {
        flex: 1;
      }

      .esgst-gf-number-filters >*, .esgst-gf-string-filters >* {
        align-items: center;
        display: flex;
        justify-content: space-between;
      }

      .esgst-gf-boolean-filters {
        column-count: 2;
        flex: 1;
      }

      .esgst-gf-basic-filters + div {
        font-size: 14px;
        font-weight: bold;
      }

      .esgst-gf-legend-panel {
        display: block;
        float: right;
        text-align: right;
        margin-top: 50px;
      }

      .esgst-ns * {
        max-width: 206px;
      }

      .esgst-clear-container {
        display: flex;
      }

      .esgst-clear-button {
        align-self: center;
        cursor: pointer;
        padding: 5px 10px;
      }

      .esgst-draggable-trash {
        background-color: #C11B17;
        border-radius: 5px;
        color: #E77471;
        position: absolute;
        text-align: center;
        text-shadow: none;
      }

      .esgst-draggable-trash i {
        font-size: 25px;
        margin: 5px;
      }

      .esgst-qiv-new {
        float: right;
        font-weight: bold;
        margin-right: 10px;
      }

      .esgst-mm-checkbox {
        display: inline-block;
        margin-right: 5px;
      }

      .esgst-mm-checkbox i {
        margin: 0;
      }

      .esgst-mm-popout {
        width: 550px;
      }

      .esgst-mm-popout textarea {
        height: 150px !important;
        overflow-y: auto !important;
      }

      .esgst-mm-popout .esgst-button-set >* {
        line-height: 25px;
        margin: 2px;
        padding-bottom: 0;
        padding-top: 0;
        width: 100px;
      }

      .esgst-mm-headings {
        display: flex;
        font-size: 0;
      }

      .esgst-mm-headings >* {
        background-color: #eee;
        border: 1px solid #ccc;
        cursor: pointer;
        flex: 1;
        font-size: 12px;
        font-weight: bold;
        padding: 5px;
        width: 150px;
      }

      .esgst-mm-headings .esgst-selected {
        background-color: #fff;
        border-bottom: 0;
      }

      .esgst-mm-sections {
        border-bottom: 1px solid #ccc;
        border-left: 1px solid #ccc;
        border-right: 1px solid #ccc;
        padding: 5px;
      }

      .esgst-mm-sections >* {
        display: none;
      }

      .esgst-mm-sections .esgst-selected {
        display: block;
      }

      .esgst-rotate-90 {
        transform: rotate(90deg);
      }

      .esgst-rotate-270 {
        transform: rotate(270deg);
      }

      .esgst-chfl-compact {
        padding: 8px 15px !important;
      }

      .footer__outer-wrap .esgst-chfl-panel, footer .esgst-chfl-panel {
        position: static !important;
      }

      .esgst-chfl-panel {
        position: absolute;
        right: 10px;
      }

      .esgst-chfl-panel i {
        background-color: #fff;
        border: 1px solid #ccc;
        border-radius: 5px;
        color: #555 !important;
        cursor: pointer;
        font-size: 18px !important;
        margin: 0 !important;
        padding: 5px;
        width: auto !important;
      }

      .esgst-chfl-small i {
        font-size: 18px !important;
        width: 36px;
      }

      .esgst-mgc-table * {
        text-align: left;
      }

      .esgst-ochgb {
        display: inline-block;
      }

      .featured__heading .esgst-ochgb i, .featured__heading .esgst-gf-hide-button i, .featured__heading .esgst-gf-unhide-button i, .featured__heading .esgst-gb-button i {
        opacity: .6;
        transition: opacity .2s;
      }

      .featured__heading .esgst-ochgb i:hover, .featured__heading .esgst-gf-hide-button i:hover, .featured__heading .esgst-gf-unhide-button i:hover, .featured__heading .esgst-gb-button i:hover {
        opacity: 1;
      }

      @keyframes esgst-blinker {
        50% { opacity: 0; }
      }

      .esgst-blinking {
        animation: esgst-blinker 1s linear infinite;
      }

      .esgst-qiv-popout {
        max-height: 600px !important;
        overflow: hidden !important;
        width: 600px;
      }

      .esgst-qiv-comments {
        overflow-y: auto;
      }

      .esgst-giveaway-column-button {
        border: 0;
        padding: 0;
      }

      .esgst-giveaway-column-button >* {
        line-height: inherit;
      }

      .esgst-elgb-button .sidebar__error {
        margin-bottom: 0;
      }

      .esgst-mgc-preview {
        border: 1px solid #ccc;
        padding: 25px;
        width: 600px;
      }

      .esgst-mgc-input {
        display: inline-block;
        text-align: center;
        width: 75px;
      }

      .esgst-relative {
        position: relative;
      }

      .esgst-nm-icon {
        color: #ff0000 !important;
      }

      .esgst-disabled {
        cursor: default !important;
        opacity: 0.5;
      }

      .esgst-changelog img {
        max-width: 98%;
      }

      .esgst-debug {
        height: 300px;
        width: 600px;
      }

      .esgst-radb-button {
        cursor: pointer;
        display: inline-block;
      }

      .esgst-radb-button.homepage_heading {
        margin-right: 5px;
      }

      :not(.page__heading) > .esgst-radb-button:not(.homepage_heading) {
        margin-left: 5px;
      }

      .esgst-radb-button + .homepage_heading {
        display: inline-block;
        width: calc(100% - 80px);
      }

      .esgst-cfh-preview {
        margin: 5px 0;
        text-align: left;
      }

      .esgst-qgs-container i {
        color: #AAB5C6;
      }

      .esgst-qgs-container {
        align-items: center;
        background-color: #fff;
        border-color: #c5cad7 #dee0e8 #dee0e8 #d2d4e0;
        border-radius: 4px;
        border-style: solid;
        border-width: 1px;
        display: flex;
        margin-right: 5px;
        padding: 5px 10px;
      }

      .esgst-qgs-container-expanded {
        position: absolute;
      }

      .esgst-qgs-container-expanded .esgst-qgs-input {
        width: 300px;
      }

      .esgst-qgs-container-expanded + .nav__button-container {
        margin-left: 40px;
      }

      .esgst-qgs-input {
        border: 0 !important;
        height: 100%;
        line-height: normal !important;
        padding: 0 !important;
        width: 0;
      }

      .esgst-sgc-results .table__row-outer-wrap {
        padding: 10px 5px;
      }

      .esgst-glwc-results {
        display: flex;
      }

      .esgst-glwc-results >* {
        flex: 1;
        margin: 10px;
      }

      .esgst-glwc-heading {
        font-family: "Open Sans";
        font-size: 25px;
        margin: 5px;
        text-align: center;
      }

      .esgst-stbb-button, .esgst-sttb-button {
        cursor: pointer;
      }

      .esgst-stbb-button-fixed, .esgst-sttb-button-fixed {
        bottom: ${esgst.ff ? 49 : 5}px;
        background-color: #fff;
        border: 1px solid #d2d6e0;
        border-radius: 4px;
        color: #4B72D4;
        padding: 5px 15px;
        position: fixed;
        right: 5px;
      }

      .esgst-stbb-button:not(.esgst-hidden) + .esgst-sttb-button {
        bottom: 79px;
      }

      .esgst-bold {
        font-weight: bold;
      }

      .esgst-italic {
        font-style: italic;
      }

      .esgst-es-page-divisor {
        margin: 5px 0;
      }

      .comment__parent .esgst-cerb-reply-button {
        margin-top: 54px;
        position: absolute;
        text-align: center;
        width: 44px;
      }

      .comment_inner .esgst-cerb-reply-button {
        margin-left: 21px;
        margin-top: 34px;
        position: absolute;
        text-align: center;
        width: 24px;
      }

      .esgst-page-heading {
        display: flex;
        align-items: flex-start;
        word-wrap: break-word;
      }

      .esgst-page-heading >* {
        background-image: linear-gradient(#fff 0%, rgba(255,255,255,0.4) 100%);
        display: flex;
        padding: 5px 10px;
        border: 1px solid #d2d6e0;
        border-radius: 4px;
        color: #4B72D4;
        font: 700 14px/22px "Open Sans", sans-serif;
      }

      .esgst-page-heading i {
        line-height: 22px;
      }

      .esgst-page-heading >*:not(.page__heading__breadcrumbs) {
        align-items: center;
      }

      .esgst-page-heading >*:not(:last-child) {
        margin-right: 5px;
      }

      .esgst-form-row {
        margin-bottom: 20px;
      }

      .esgst-form-row:first-of-type {
        margin-top: 14px;
      }

      .esgst-form-heading {
        align-items: center;
        display: flex;
        margin-bottom: 5px;
      }

      .esgst-form-heading > div:not(:last-child) {
        margin-right: 10px;
      }

      .esgst-form-heading-number {
        font: 300 14px "Open Sans", sans-serif;
        color:#6b7a8c;
      }

      .esgst-form-heading-text {
        font: 700 14px "Open Sans", sans-serif;
        color: #4B72D4;
      }

      .esgst-form-row-indent {
        padding: 3px 0 3px 20px;
        margin-left: 5px;
        border-left: 1px solid #d2d6e0;
        box-shadow: 1px 0 0 rgba(255,255,255,0.3) inset;
      }

      .esgst-form-sync {
        display: flex;
      }

      .esgst-form-sync-data {
        flex: 1;
      }

      .esgst-notification {
        border: 1px solid;
        border-radius: 4px;
        padding: 0 15px;
        font-size: 11px;
        line-height: 32px;
        overflow: hidden;
      }

      .esgst-notification a {
        text-decoration: underline;
      }

      .esgst-notification-success {
        background-image: linear-gradient(#f7fcf2 0%, #e7f6da 100%);
        border-color: #C5E9A5;
        color:#8fa47b;
      }

      .esgst-notification-warning {
        background-image: linear-gradient(#F6F6E6 0px, #F5F5DF 20px);
        border-color: #EDE5B2;
        color: #a59d7c;
      }

      .esgst-user-icon {
        display: inline-block;
        line-height: normal;
        margin: 0 5px 0 0;
      }

      .esgst-user-icon i {
        border: 0;
        line-height: normal;
        margin: 0;
        text-shadow: none !important;
      }

      .esgst-whitelist {
        color: #556da9 !important;
      }

      .esgst-blacklist {
        color: #a95570 !important;
      }

      .esgst-positive {
        color: #96c468 !important;
      }

      .esgst-negative {
        color: #ec8583 !important;
      }

      .esgst-unknown {
        color: #77899a !important;
      }

      .esgst-ugd-table .table__rows .table__row-outer-wrap:hover {
        background-color: rgba(119, 137, 154, 0.1);
      }

      .esgst-ugd-table .table__column--width-small {
        min-width: 0;
        width: 12%;
      }

      .esgst-ugd-lists {
        display: flex;
        justify-content: center;
      }

      .markdown {
        word-break: break-word;
      }

      .esgst-busy >* {
        opacity: 0.2;
      }

      .comment__actions .esgst-rml-link {
        margin: 0 0 0 10px;
      }

      .esgst-settings-menu .form__sync-default {
        margin: 0 5px;
      }

      .esgst-uh-popup a {
        border-bottom: 1px dotted;
      }

      .esgst-auto-sync {
        display: inline-block;
        margin: -5px 5px 0;
        padding: 2px;
        width: 50px;
      }

      .esgst-ap-popout .featured__table__row__left:not(.esgst-uh-title), .esgst-mr-reply, .esgst-mr-edit, .esgst-mr-delete, .esgst-mr-undelete {
        margin: 0 10px 0 0;
      }

      .esgst-ugd-button {
        cursor: pointer;
        display: inline-block;
      }

      .esgst-cfh-popout {
        font: 700 12px "Open Sans", sans-serif;
      }

      .esgst-cfh-panel span >:first-child >* {
        margin: 0 !important;
      }

      .esgst-cfh-popout input {
        width: auto;
      }

      .esgst-namwc-highlight {
        font-weight: bold;
      }

      .esgst-iwh-icon {
        margin: 0 0 0 5px;
      }

      .esgst-ap-suspended >* {
        color: #e9202a;
      }

      .esgst-ap-popout {
        border: none !important;
        border-radius: 5px;
        box-shadow: 0 0 10px 2px hsla(0, 0%, 0%, 0.8);
        min-width: 400px;
        padding: 0 !important;
        text-shadow: none;
      }

      .ui-tooltip {
        z-index: 99999;
      }

      .esgst-ap-popout .featured__outer-wrap:not(.esgst-uh-box) {
        border-radius: 5px;
        padding: 5px;
        width: auto;
        white-space: normal;
      }

      .esgst-ap-popout .featured__inner-wrap {
        align-items: flex-start;
        padding: 0 5px 0 0;
      }

      .esgst-ap-popout .featured__heading {
        margin: 0;
      }

      .esgst-ap-popout .featured__heading__medium {
        font-size: 18px;
      }

      .esgst-ap-link {
        width: 100px;
      }

      .esgst-ap-link .global__image-outer-wrap--avatar-large {
        box-sizing: content-box !important;
        height: 64px !important;
        margin: 5px;
        width: 64px !important;
      }

      .esgst-ap-popout .global__image-outer-wrap--avatar-large:hover {
        background-color: hsla(0, 0%, 25%, 0.2) !important;
      }

      .esgst-ap-link .global__image-inner-wrap {
        background-size: cover !important;
      }

      .esgst-ap-popout .sidebar__shortcut-outer-wrap {
        margin: 10px 0;
      }

      .esgst-ap-popout .sidebar__shortcut-inner-wrap i {
        height: 18px;
        font-size: 12px;
      }

      .esgst-ap-popout .sidebar__shortcut-inner-wrap * {
        line-height: 18px;
        vertical-align: middle;
      }

      .esgst-ap-popout .sidebar__shortcut-inner-wrap img {
        height: 16px;
        vertical-align: baseline !important;
        width: 16px;
      }

      .esgst-ap-popout .featured__table {
        display: inline-block;
        width: 100%;
      }

      .esgst-ap-popout .featured__table__row {
        padding: 2px;
      }

      .esgst-ap-popout .featured__table__row:nth-child(n + 3) {
        margin-left: -95px;
      }

      .esgst-ap-popout .featured__table__row:last-of-type .featured__table__row__right * {
        font-size: 11px;
      }

      .esgst-ct-comment-button {
        cursor: pointer;
      }

      .popup__keys__list .esgst-ggl-member, .esgst-dh-highlighted, .esgst-dh-highlighted.table__row-outer-wrap {
        background-color: rgba(150, 196, 104, 0.2) !important;
        padding: 5px !important;
      }

      .esgst-gb-highlighted.ending, .esgst-error-button, .esgst-error-button >*:hover {
        background-color: rgba(236, 133, 131, 0.8) !important;
        background-image: none !important;
      }

      .esgst-gb-highlighted.started {
        background-color: rgba(150, 196, 104, 0.8) !important;
        background-image: none !important;
      }

      .esgst-gb-highlighted.ending.started {
        background-color: rgba(193, 165, 118, 0.8) !important;
        background-image: none !important;
      }

      .esgst-ct-comment-read:hover, .esgst-ct-visited:hover {
        background-color: rgba(119, 137, 154, 0.1) !important;
      }

      .esgst-gf-hide-button, .esgst-gf-unhide-button, .esgst-gb-button, .esgst-gdttt-button {
        cursor: pointer; display: inline-block;
        margin: 0 5px 0 0;
      }

      .esgst-codb-button, .esgst-dh-button, .esgst-df-button {
        display: inline-block;
        margin: 0 5px 0 0;
        padding: 0;
      }

      .page__heading .esgst-codb-button >*, .page__heading .esgst-dh-button >*, .page__heading .esgst-df-button >* {
        padding: 5px 10px;
      }

      .esgst-ust-checkbox {
        cursor: pointer;
        margin-left: -17px;
        position: absolute;
        top: calc(50% - 7px);
      }

      .esgst-pm-button {
        margin-left: -17px;
        position: absolute;
        top: calc(50% - 7px);
      }

      .esgst-dh-highlighted .esgst-pm-button {
        margin-left: -22px;
      }

      .page__heading .esgst-pm-button {
        display: inline-block;
        margin: 0 5px 0 0;
        padding: 0;
        position: static;
      }

      .page__heading .esgst-pm-button >* {
        padding: 5px 10px;
      }

      .esgst-adots .esgst-pm-button {
        margin-left: -58px;
      }

      .comment__actions .esgst-ct-comment-button {
        margin: 0 0 0 10px;
      }

      .comment__actions >:first-child + .esgst-ct-comment-button {
        margin: 0;
      }

      .esgst-ct-comment-button >:not(:last-child) {
        margin: 0 10px 0 0;
      }

      .esgst-cfh-panel {
        margin: 0 0 2px;
        position: sticky;
        text-align: left;
      }

      .esgst-cfh-panel >* {
        background-color: #fff;
        border: 1px solid #ccc;
        border-radius: 5px;
        cursor: pointer;
        display: inline-block;
        margin: 1px;
        opacity: 0.5;
        padding: 5px;
      }

      .esgst-cfh-panel >*:hover {
        opacity: 1;
      }

      .esgst-cfh-panel span >:not(:first-child), .esgst-ded-status {
        display: block;
      }

      .esgst-cfh-panel span i {
        line-height: 22px;
      }

      .esgst-cfh-panel .form__saving-button {
        display: inline-block;
        margin: 5px;
        min-width:0;
      }

      .esgst-cfh-panel table {
        display: block;
        max-height: 200px;
        max-width: 375px;
        overflow: auto;
      }

      .esgst-cfh-panel table td:first-child {
        min-width: 25px;
        text-align: center;
      }

      .esgst-cfh-panel table td:not(:first-child) {
        min-width: 75px;
        text-align: center;
      }

      .esgst-cfh-emojis {
        display: block !important;
        font-size: 18px;
        max-height: 200px;
        min-height: 30px;
        overflow: auto;
        text-align: center;
      }

      .esgst-cfh-emojis >* {
        cursor: pointer;
        display: inline-block;
        margin: 2px;
      }

      .esgst-cfh-popout {
        white-space: normal;
        width: 300px;
      }

      .esgst-mpp-popup {
        position: fixed !important;
      }

      .esgst-mpp-visible {
        padding: 0;
      }

      .esgst-mpp-hidden {
        display: none;
        max-height: 75%;
        overflow: auto;
        padding: 15px;
        position: absolute;
        width: 75%;
      }

      .esgst-ueg {
        opacity: 1 !important;
      }

      .esgst-fh {
        height: auto !important;
        position: sticky;
        top: 0;
        z-index: 999 !important;
      }

      .esgst-fs {
        overflow-y: hidden;
        position: sticky;
      }

      .esgst-fs.stuck {
        overflow-y: auto;
      }

      .esgst-fs.stuck .sidebar__mpu {
        display: none !important;
      }

      .esgst-fmph {
        background-color: var(--esgst-body-bg-color);
        margin-top: -5px;
        padding: 5px 0;
        position: sticky;
        z-index: 998;
      }

      .esgst-fmph + * {
        margin-top: -5px;
      }

      .esgst-ff {
        background-color: inherit;
        bottom: 0;
        padding: 0;
        position: sticky;
        z-index: 999;
      }

      .esgst-ff >* {
        padding: 15px 25px;
      }

      .esgst-sgac-button, .esgst-sgg-button {
        margin: 0 5px 0 0;
      }

      .esgst-ct-count {
        color: #e9202a;
        font-weight: bold;
      }

      .esgst-uh-box {
        background: linear-gradient(to bottom, #555, #222);
        border: 1px solid #888;
        margin: 5px 0 0;
        padding: 15px;
        position: absolute;
        text-align: center;
      }

      .esgst-uh-title {
        color: rgba(255, 255, 255, 0.6);
        font-weight: bold;
        margin: 0 0 15px;
      }

      .esgst-uh-list {
        color: rgba(255, 255, 255, 0.4);
      }

      .esgst-wbc-button, .esgst-namwc-button, .esgst-nrf-button {
        cursor: pointer;
        margin: 0 0 0 5px;
      }

      .esgst-luc-value {
        margin: 0 0 0 5px;
      }

      .esgst-sgpb-container {
        display: flex;
      }

      .esgst-sgpb-container >* {
        flex: 1;
      }

      .esgst-sgpb-button {
        background-image: linear-gradient(rgba(255, 255, 255, 0.8) 0%, rgba(255, 255, 255, 0.3) 100%);
        border-color: #dde2ea #cdd4df #cbd1dc #d6dbe7;
        color: #6e7585;
        text-shadow: 1px 1px 1px #fff;
        transition: opacity 0.5s;
        border-radius: 3px;
        font: 700 13px 'Open Sans', sans-serif;
        margin: 0 0 0 5px;
        padding: 7px 15px;
        display: flex;
        align-items: center;
        border-width: 1px;
        border-style: solid;
        text-decoration: none;
      }

      .esgst-sgpb-button:active {
        background-image: linear-gradient(#e1e7eb 0%, #e6ebf0 50%, #ebeff2 100%) !important;
        box-shadow: 2px 2px 5px #ccd4db inset;
        text-shadow: 1px 1px 1px rgba(255, 255, 255, 0.6);
        margin: 2px 0 0 7px !important;
        border: 0;
      }

      .esgst-sgpb-button:hover {
        background-image: linear-gradient(rgba(255, 255, 255, 1) 0%, rgba(255, 255, 255, 0.3) 100%);
      }

      .esgst-sgpb-button i {
        height: 14px;
        margin: 0 10px 0;
        width: 14px;
      }

      .esgst-sgpb-button img {
        height: 14px;
        vertical-align: baseline;
        width: 14px;
      }

      .esgst-stpb-button img {
        vertical-align: top;
      }

      .esgst-gh-highlight, .esgst-green-highlight {
        background-color: rgba(150, 196, 104, 0.2);
      }

      .esgst-pgb-button, .esgst-gf-button {
        border: 1px solid #d2d6e0;
        border-top: none;
        background-color: #e1e6ef;
        background-image: linear-gradient(rgba(255, 255, 255, 0.15) 0%, rgba(255, 255, 255, 0) 100%);color: #6b7a8c;
        cursor: pointer;
        margin-bottom: 15px;
        padding: 3px;
        text-align: center;
        border-radius: 0 0 4px 4px;
      }

      .esgst-gf-button {
        margin-bottom: 0 !important;
      }

      .esgst-pgb-button:hover, .esgst-gf-button:hover {
        background-image:linear-gradient(rgba(255, 255, 255, 0.4) 0%, rgba(255, 255, 255, 0) 100%);
      }

      .esgst-gm-giveaway {
        background-color: #fff;
        border: 1px solid;
        border-radius: 4px;
        cursor: pointer;
        display: inline-block;
        margin: 5px 2px;
        padding: 2px 5px;
      }

      .esgst-feature-description {
        background-color: #fff;
        color: #465670;
        padding: 10px;
        width: 420px;
        border-radius: 4px;
      }

      .esgst-feature-description img {
        max-width: 400px;
      }

      .esgst-gm-giveaway.error {
        background-color: rgba(236, 133, 131, 0.5);
      }

      .esgst-gm-giveaway.success {
        background-color: rgba(150, 196, 104, 0.5);
      }

      .esgst-gm-giveaway.connected {
        text-decoration: line-through;
      }

      .esgst-gts-section >*, .esgst-gm-section >* {
        margin: 5px 0;
      }

      .esgst-gm-section .esgst-button-set {
        display: inline-block;
        margin: 5px;
      }

      .sidebar .esgst-button-set >* {
        margin-bottom: 5px;
        width: 304px;
      }

      .esgst-button-set .sidebar__entry-delete, .esgst-button-set .sidebar__error {
        display: inline-block;
      }

      .esgst-button-group {
        display: block;
      }

      .esgst-button-group >* {
        display: inline-block;
      }

      .esgst-button-group >*:not(:first-child) {
        margin-left: 5px;
      }

      .esgst-ggl-panel {
        color: #6b7a8c;
        font-size: 12px;
        padding: 5px;
      }

      .esgst-ggl-panel >* {
        display: inline-block;
      }

      .esgst-ggl-panel >*:not(:last-child) {
        margin-right: 10px;
      }

      .esgst-ggl-panel a:last-child {
        border-bottom: 1px dotted;
      }

      .esgst-ggl-panel .table_image_avatar {
        cursor: pointer;
        display: inline-block;
        height: 12px;
        width: 12px;
        vertical-align: middle;
      }

      .esgst-ggl-member {
        font-weight: bold;
      }

      .esgst-ggl-heading {
        font-weight: bold;
        line-weight: 22px;
        margin: 10px;
      }

      .esgst-gcl-popout, .esgst-ggl-popout {
        padding: 0 !important;
      }

      .esgst-gcl-popout .table__row-outer-wrap, .esgst-ggl-popout .table__row-outer-wrap {
        padding: 10px 5px;
      }

      .esgst-hidden-buttons {
        padding: 2px !important;
      }

      .esgst-popout {
        background-color: #fff;
        border: 1px solid #d2d6e0;
        border-radius: 4px;
        color: #465670;
        left: 0;
        overflow: auto;
        padding: 10px;
        position: absolute;
        top: 0;
        z-index: 99999;
      }

      .esgst-aic-carousel {
        align-items: center;
        cursor: default !important;
        display: flex;
        justify-content: center;
      }

      .esgst-aic-carousel >:last-child {
        border: 5px solid #fff;
        border-radius: 5px;
        max-width: 90%;
      }

      .esgst-aic-carousel img {
        display: block;
      }

      .esgst-aic-panel {
        color: #fff;
        position: absolute;
        text-align: center;
        top: 25px;
      }

      .esgst-aic-left-button, .esgst-aic-right-button {
        cursor: pointer;
        display: inline-block;
        margin: 10px;
        text-align: center;
        width: 25px;
      }

      .esgst-aic-left-button i, .esgst-aic-right-button i {
        font-size: 25px;
      }

      .esgst-aic-source {
        font-weight: bold;
        margin-top: 10px;
        text-decoration: underline;
      }

      .esgst-popup-modal {
        background-color: rgba(60, 66, 77, 0.7);
        bottom: 0;
        cursor: pointer;
        left: 0;
        position: fixed;
        right: 0;
        top: 0;
      }

      .esgst-popup-large {
        width: 75%;
      }

      .esgst-popup {
        background-color: var(--esgst-body-bg-color);
        border-radius: 4px;
        color: #465670;
        padding: 25px;
        position: fixed;
        text-align: center;
        text-shadow: 1px 1px rgba(255,255,255,0.94);
        transition: 500ms ease;
        ${esgst.staticPopups ? `
          max-width: calc(100% - 150px);
          top: 50px;
          ${esgst.staticPopups_f ? `
            left: 0;
            margin: 0 auto;
            right: 0;
            width: ${esgst.staticPopups_width};
          ` : `
            left: 50px;
          `}
        ` : `
          max-width: calc(90% - 50px);
        `}
      }

      .esgst-popout li:before, .esgst-popup li:before {
        margin-left: 0;
        padding-right: 10px;
        position: static;
        width: auto;
        text-align: left;
      }

      .esgst-popup-description >*, .esgst-popup-scrollable >* {
        margin: 10px 0 0 !important;
      }

      .esgst-popup-actions {
        color: #4b72d4;
        margin-top: 15px;
      }

      .esgst-popup-actions >* {
        border-bottom: 1px dotted;
        box-shadow: 0 1px 0 #fff;
        cursor: pointer;
        display: inline-block;
      }

      .esgst-popup-actions >*:not(:last-child) {
        margin-right: 15px;
      }

      .esgst-popup-scrollable {
        overflow: auto;
      }

      .esgst-popup .popup__keys__list {
        max-height: none;
      }

      .esgst-heading-button {
        display: inline-block;
        cursor: pointer;
      }

      .esgst-popup-heading {
        display: flex;
        align-items: center;
        margin-bottom: 5px;
      }

      .esgst-popup-icon {
        font-size: 25px;
        margin-right: 10px;
      }

      .esgst-popup-title {
        font: 300 18px 'Open Sans', sans-serif;
      }

      .esgst-popup-title span {
        font-weight: bold;
      }

      .esgst-text-left {
        text-align: left;
      }

      .esgst-text-center {
        text-align: center;
      }

      .esgst-hidden {
        display: none !important;
      }

      .esgst-clickable {
        cursor: pointer;
      }

      .fa img {
        height: 14px;
        width: 14px;
        vertical-align: middle;
      }

      .nav__left-container .fa img {
        vertical-align: baseline;
      }

      .esgst-checkbox, .esgst-hb-update, .esgst-hb-changelog, .esgst-dh-view-button {
        cursor: pointer;
      }

      .esgst-sm-small-number {
        font-size: 12px;
        display: inline-block;
      }

      .esgst-toggle-switch-container {
        margin: 2px;
      }

      .esgst-toggle-switch-container.inline {
        display: inline-block;
      }

      .page__heading .esgst-toggle-switch-container.inline, .page_heading .esgst-toggle-switch-container.inline, .esgst-page-heading .esgst-toggle-switch-container.inline {
        height: 16px;
        margin: 0 2px;
        line-height: normal;
        vertical-align: middle;
      }

      .esgst-toggle-switch {
        position: relative;
        display: inline-block;
        width: 26px;
        height: 14px;
        vertical-align: top;
      }

      .esgst-toggle-switch input {
        display: none !important;
      }

      .esgst-toggle-switch-slider {
        border-radius: 20px;
        position: absolute;
        cursor: pointer;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: #ccc;
        -webkit-transition: .4s;
        transition: .4s;
      }

      .esgst-toggle-switch-slider:before {
        border-radius: 50%;
        position: absolute;
        content: "";
        height: 12px;
        width: 12px;
        left: 1px;
        bottom: 1px;
        background-color: white;
        -webkit-transition: .4s;
        transition: .4s;
      }

      input:checked + .esgst-toggle-switch-slider {
        background-color: #4B72D4;
      }

      input:focus + .esgst-toggle-switch-slider {
        box-shadow: 0 0 1px #4B72D4;
      }

      input:checked + .esgst-toggle-switch-slider:before {
        -webkit-transform: translateX(12px);
        -ms-transform: translateX(12px);
        transform: translateX(12px);
      }

      .esgst-adots, .esgst-rbot {
        margin-bottom: 25px;
      }

      .esgst-float-left {
        float: left;
      }

      .esgst-float-right {
        float: right;
      }

      .esgst-clear {
        clear: both;
      }

      .esgst-rbot .reply_form .btn_cancel {
        display: none;
      }

      .esgst-aas-button {
        cursor: pointer;
        display: inline-block;
      }

      .esgst-es-page-heading {
        margin-top: 25px;
      }

      .esgst-gc-border {
        display: flex;
        height: 5px;
        margin-left: 5px;
        width: ${esgst.ib ? `186px` : `174px`};
      }

      .esgst-gc-border >* {
        flex: 1;
      }

      .esgst-gc-panel {
        text-align: left;
      }

      .esgst-gc-panel a {
        text-decoration: none;
      }

      .esgst-gc-panel-inline {
        display: inline-block;
        margin: 0 0 0 5px;
      }

      .esgst-gch-highlight, .esgst-gc:not(.giveaway__column):not(.featured__column) {
        border-radius: 4px;
        display: inline-block;
        font-size: 10px;
        line-height: 10px;
        margin: 5px 0;
        padding: 2px 3px;
        text-shadow: none;
      }

      .esgst-gch-highlight {
        font-size: 14px;
        line-height: 14px;
        margin: 0 5px;
      }

      a.esgst-gc-genres {
        max-width: 150px;
        overflow: hidden;
        text-overflow: ellipsis;
        vertical-align: middle;
        white-space: nowrap;
      }

      .esgst-gf-container {
        position: sticky;
        text-align: left;
        z-index: 998;
      }

      .esgst-gf-container:not(.esgst-popup-scrollable) {
        background-color: #E8EAEF;
        border-radius: 4px;
      }

      .esgst-gf-container.esgst-popup-scrollable {
        min-width: 650px;
      }

      .esgst-gf-filters {
        display: flex;
        justify-content: space-between;
        overflow: auto;
        position: relative;
      }

      .esgst-gf-left-panel {
        flex: 1;
        max-height: 500px;
        overflow-y: auto;
      }

      .esgst-gf-right-panel .form__input-small {
        width: 100px !important;
      }

      .esgst-gf-filters >* {
        margin: 5px;
      }

      .esgst-gf-preset-panel {
        margin: 5px;
        text-align: right;
      }

      .esgst-gf-preset-panel >* {
        margin: 5px;
      }

      .esgst-gf-filter-count {
        background-color: #ddd;
        border-radius: 5px;
        font-size: 10px;
        padding: 2px;
        vertical-align: middle;
      }

      .esgst-gf-button {
        border-top: 1px;
      }

      .esgst-wbh-highlight {
        border: none !important;
        border-radius: 4px;
        padding: 2px 5px;
        text-shadow: none;
      }

      .page__heading__breadcrumbs .esgst-wbh-highlight {
        padding: 0 2px;
      }

      .esgst-sm-colors input {
        display: inline-block;
        padding: 0;
        width: 100px;
      }

      .esgst-sm-colors input[type=color] {
        width: 25px;
      }

      .esgst-sm-colors select {
        display: inline-block;
        padding: 0;
        width: 100px;
      }

      .esgst-sm-colors-default {
        line-height: normal;
        padding: 5px 15px;
      }

      .esgst-ged-icon {
        margin: 0 0 0 10px;
      }

      .esgst-pgb-container {
        border-radius: 0 !important;
        margin: 0! important;
      }

      .esgst-gf-box {
        background-color: #E8EAEF;
        border: 1px solid #d2d6e0;
        border-radius: 0 !important;
        margin: 0! important;
        padding: 0 15px;
      }

      .esgst-gr-button {
        cursor: pointer;
        display: inline-block;
      }

      .esgst-egh-icon {
        cursor: pointer;
      }

      .giveaway__row-outer-wrap .esgst-egh-button, .giveaway__row-outer-wrap .esgst-gr-button, .table__row-outer-wrap .esgst-egh-button, .table__row-outer-wrap .esgst-egh-button, .table__row-outer-wrap .esgst-gr-button {
        margin-right: 5px;
      }

      p.table__column__heading {
        display: inline-block;
      }

      .esgst-giveaway-links {
        float: left;
        margin: 2px;
      }

      .esgst-gv-box .esgst-giveaway-panel:empty {
        height: 0;
        width: 0;
      }

      .esgst-giveaway-panel:empty {
        height: 25px;
        width: 250px;
      }

      .esgst-giveaway-panel.giveaway__columns {
        float: right;
        margin: 2px;
      }

      .esgst-giveaway-panel .esgst-button-set {
        border: 0;
        padding: 0;
      }

      .esgst-giveaway-panel .esgst-button-set >* {
        line-height: inherit;
        margin:0;
      }

      .esgst-giveaway-panel >:first-child {
        margin: 0;
      }

      .esgst-giveaway-panel >*:not(:first-child) {
        margin: 0 0 0 5px;
      }

      .esgst-gv-popout .esgst-gwc, .esgst-gv-popout .esgst-gwr, .esgst-gv-popout .esgst-ttec {
        display: inline-block;
        margin: 0 !important;
        padding: 0 5px !important;
        width: 67px !important;
        vertical-align: top;
      }

      .esgst-gv-popout .esgst-gp-button {
        display: inline-block;
        margin: 0 !important;
        width: auto !important;
        vertical-align: top;
      }

      .esgst-gv-popout .esgst-gp-button >* {
        padding: 0 5px !important;
        width: 67px !important;
      }

      .esgst-giveaway-panel .form__submit-button, .esgst-giveaway-panel .form__saving-button {
        margin-bottom: 0;
        min-width: 0;
      }

      .esgst-ged-source {
        font-weight: bold;
        margin: 5px 0;
      }

      .table__column--width-small {
        width: 8%;
      }

      .sidebar .table__row-outer-wrap {
        padding: 5px 0;
      }

      .esgst-adots-tab-heading {
        background-color: #2f3540;
        border-top-left-radius: 5px;
        border-top-right-radius: 5px;
        color: #fff;
        cursor: pointer;
        display: inline-block;
        opacity: 0.5;
        padding: 5px 10px;
        text-shadow: none;
      }

      .esgst-adots-tab-heading.esgst-selected {
        opacity: 1;
      }

      .sidebar .esgst-adots {
        margin: 0;
        max-height: 300px;
        max-width: 336px;
        overflow: auto;
      }

      .sidebar .esgst-adots .esgst-dh-highlighted {
        padding: 0 !important;
        padding-bottom: 5px !important;
      }

      .sidebar .esgst-adots .table__column__heading, .esgst-adots .homepage_table_column_heading {
        display: inline-block;
        max-width: 225px;
        overflow: hidden;
        text-overflow: ellipsis;
        vertical-align: middle;
        white-space: nowrap;
      }

      .esgst-ns .esgst-adots .table__column__heading, .esgst-ns .esgst-adots .homepage_table_column_heading {
        max-width: 100px;
      }

      .sidebar .esgst-adots .table__row-outer-wrap {
        padding: 0 !important;
        padding-bottom: 5px !important;
        border: 0;
        box-shadow: none;
      }

      .sidebar .esgst-adots .table__row-inner-wrap {
        display: block;
      }

      .sidebar .esgst-adots .table__row-inner-wrap >*:not(:last-child) {
        display: inline-block;
      }

      .esgst-faded {
        opacity: 0.5;
      }

      .esgst-sm-faded >*:not(.SMFeatures), .esgst-sm-faded > .SMFeatures > .esgst-sm-colors {
        opacity: 0.5;
      }

      .esgst-green {
        color: #96c468 !important;
      }

      .esgst-grey {
        color: #77899a !important;
      }

      .esgst-orange {
        color: #c1a576 !important;
      }

      .esgst-red {
        color: #ec8583 !important;
      }

      .esgst-yellow {
        color: #fecc66 !important;
      }

      .esgst-warning {
        color: #e9202a !important;
        font-weight: bold;
      }

      .esgst-toggle-switch-container .esgst-description, .esgst-button-group .esgst-description {
        display: inline-block;
        margin: 0;
      }

      .esgst-description {
        color: #6b7a8c;
        font-size: 11px;
        font-style: italic;
        margin-top: 10px;
      }

      .esgst-progress-bar {
        height: 10px;
        overflow: hidden;
        text-align: left;
      }

      .esgst-progress-bar .ui-progressbar-value {
        background-color: #96c468;
        height: 100%;
        margin: -1px;
      }

      .esgst-ib-user {
        background-color: #fff;
        background-position: 5px 5px;
        background-size: 32px;
        border: 1px solid #d2d6e0;
        border-radius: 4px;
        height: 44px;
        padding: 5px;
        width: 44px;
      }

      .featured__outer-wrap .esgst-ib-user {
        background-color: transparent;
        border: 1px solid rgba(255, 255, 255, 0.1);
      }

      .esgst-ib-game {
        background-color: #fff;
        background-position: 5px 5px;
        border: 1px solid #d2d6e0;
        border-radius: 4px;
        padding: 5px;
      }

      .giveaway__row-outer-wrap .esgst-ib-game {
        background-size: 184px 69px;
        height: 81px;
        width: 196px;
      }

      .table__row-outer-wrap .esgst-ib-game {
        background-size: 85px 32px;
        height: 44px;
        width: 97px;
      }

      .esgst-oadd >* {
        padding-left: 0 !important;
        margin-left: 0 !important;
        border-left: none !important;
        box-shadow: none !important;
      }

      .esgst-gv-spacing {
        font-weight: bold;
        padding: 10px;
        text-align: center;
        width: 100px;
      }

      .esgst-gv-view {
        font-size: 0;
        padding: 5px 0;
        text-align: center;
      }

      .esgst-gv-view.pinned-giveaways__inner-wrap--minimized .giveaway__row-outer-wrap:nth-child(-n + 10) {
        display: inline-block;
      }

      .esgst-gv-container {
        border: 0 !important;
        box-shadow: none !important;
        display: inline-block;
        font-size: 12px;
        padding: 0;
        text-align: center;
        vertical-align: top;
        width: ${esgst.ib ? `196px` : `184px`};
      }

      .esgst-gv-box {
        display: block;
      }

      .esgst-gv-box >*:not(.giveaway__summary):not(.esgst-gv-icons) {
        margin: 0 !important;
      }

      .esgst-gv-box.is-faded:hover, .esgst-gv-box.esgst-faded:hover {
        opacity: 1;
      }

      .esgst-gv-icons {
        float: right;
        height: 18px;
        margin: -18px 0 0 !important;
      }

      .esgst-gv-icons .esgst-gc, .esgst-gv-icons .esgst-gwc, .esgst-gv-icons .esgst-gwr, .esgst-gv-icons .esgst-ttec, .esgst-gv-time, .esgst-gv-icons .esgst-ged-source {
        background-color: #fff;
        padding: 2px !important;
      }

      .esgst-gv-icons .esgst-gp-button {
        background-color: #fff;
      }

      .esgst-ged-source {
        font-weight: bold;
      }

      .esgst-gv-time i {
        font-size: 12px;
        vertical-align: baseline;
      }

      .esgst-gv-icons >* {
        line-height: normal;
        margin: 0 !important;
      }

      .esgst-gv-icons >*:not(.esgst-giveaway-column-button) {
        padding: 1px 3px;
      }

      .esgst-gv-icons .giveaway__column--contributor-level {
        padding: 2px 5px !important;
      }

      .esgst-gv-popout {
        font-size: 11px;
        max-width: ${esgst.ib ? `174px` : `162px`};
        position: absolute;
        width: ${esgst.ib ? `174px` : `162px`};
        z-index: 1;
      }

      .esgst-gv-popout .giveaway__heading {
        display: block;
        height: auto;
      }

      .esgst-gv-popout .giveaway__heading__name {
        display: inline-block;
        font-size: 12px;
        max-width: 150px;
        overflow: hidden;
        text-overflow: ellipsis;
        vertical-align: middle;
      }

      .esgst-gv-popout .giveaway__heading__thin {
        font-size: 11px;
      }

      .esgst-gv-popout .esgst-gc-panel {
        font-size: 11px;
        text-align: center;
      }

      .esgst-gv-popout .esgst-gc-panel i, .esgst-gv-popout .giveaway__links i, .esgst-gv-popout .esgst-gwc i, .esgst-gv-popout .esgst-gwr i, .esgst-gv-popout .esgst-ggl-panel, .esgst-gv-popout .esgst-ggl-panel i {
        font-size: 11px;
      }

      .esgst-gv-popout .giveaway__columns:not(.esgst-giveaway-panel):not(.esgst-gv-icons) {
        display: block;
        float: left;
        width: calc(100% - 37px);
      }

      .esgst-gv-popout .giveaway__columns:not(.esgst-giveaway-panel):not(.esgst-gv-icons) >* {
        margin: 0;
        text-align: left;
      }

      .esgst-gv-popout .esgst-giveaway-panel {
        display: block;
        font-size: 11px;
      }

      .esgst-gv-popout .esgst-giveaway-panel >* {
        margin: 0;
      }

      .esgst-gv-popout .esgst-button-set {
        width: 100%;
      }

      .esgst-gv-popout .esgst-button-set >* {
        padding: 0;
        width: 100%;
      }
      .esgst-gv-popout .giveaway__links a:last-child {
        margin: 0 !important;
      }

      .esgst-gv-popout .giveaway_image_avatar, .esgst-gv-popout .featured_giveaway_image_avatar {
        margin: 5px;
        position: absolute;
        right: 5px;
      }

      .esgst-gv-popout .esgst-giveaway-links, .esgst-gv-popout .esgst-giveaway-panel {
        float: none;
      }

      .esgst-ags-panel {
        margin: 0 0 15px 0;
        max-width: 316px;
        text-align: center;
      }

      .esgst-ags-panel >* {
        display: inline-block;
      }

      .esgst-ags-filter {
        display: block;
        margin: 5px;
      }

      .esgst-ags-filter >* {
        padding: 0 5px !important;
        width: 125px;
      }

      .esgst-ags-checkbox-filter {
        margin: 5px;
      }

      .esgst-ugs-difference, .esgst-switch-input {
        display: inline-block;
        padding: 0 !important;
        width: 50px;
      }

      .esgst-switch-input-large {
        width: 150px;
      }

      .esgst-gas-popout {
        background-color: #fff;
        border: 1px solid #d2d6e0;
        border-radius: 4px;
        color: #465670;
        padding: 10px;
      }

      .esgst-ds-popout {
        background-color: #fff;
        border: 1px solid #d2d6e0;
        border-radius: 4px;
        color: #465670;
        padding: 10px;
      }

      .esgst-cfh-sr-container {
        max-height: 234px;
        overflow-y: auto;
      }

      .esgst-cfh-sr-box {
        position: relative;
      }

      .esgst-cfh-sr-summary {
        border-radius: 5px;
        cursor: pointer;
        padding: 5px;
        width: 200px;
      }

      .esgst-cfh-sr-box:not(:first-child) {
        border-top: 1px solid #ccc;
      }

      .esgst-cfh-sr-box:last-child) {
        border-bottom: 1px solid #ccc;
      }

      .esgst-cfh-sr-summary:hover {
        background-color: #465670;
        color: #fff;
      }

      .esgst-cfh-sr-name {
        font-size: 14px;
        overflow: hidden;
        text-overflow: ellipsis;
        width: 200px;
        white-space: nowrap;
      }

      .esgst-cfh-sr-description {
        opacity: 0.75;
        overflow: hidden;
        text-overflow: ellipsis;
        width: 200px;
        white-space: nowrap;
      }

      .esgst-cfh-sr-controls {
        position: absolute;
        right: 5px;
        top: 10px;
      }

      .esgst-cfh-sr-controls >* {
        margin: 2px;
      }

      .esgst-gt-preview .esgst-gt-tags {
        display: inline-block;
      }

      .esgst-gt-preview input[type=text] {
        display: inline-block;
        width: 100px;
        height: 15px;
      }

      .esgst-gt-preview input[type=color] {
        box-sizing: unset;
        height: 13px;
        line-height: normal;
        margin: 0;
        padding: 0;
        vertical-align: top;
        width: 15px;
      }

      .esgst-gt-button {
        border: 0! important;
        cursor: pointer;
        display: inline-block;
        line-height: normal;
        text-decoration: none !important;
        transition: opacity 0.2s;
      }

      .esgst-gt-button:hover {
        opacity: 1;
      }

      .esgst-gt-button i {
        margin: 0 !important;
      }

      .giveaway__row-outer-wrap .esgst-gt-button, .table__row-outer-wrap .esgst-gt-button {
        margin-left: 5px;
      }

      .esgst-gt-tags {
        font-size: 10px;
        font-weight: bold;
      }

      .esgst-gt-tags >* {
        display: inline-block !important;
        height: auto;
        margin: 0;
        padding: 2px;
        text-shadow: none;
        width: auto;
      }

      .esgst-gt-tags >:not(:first-child) {
        margin: 0 0 0 5px;
      }

      .esgst-gv-popout .esgst-gt-tags {
        display: none;
      }

      .esgst-ut-existing-button {
        padding: 8px;
        right: 25px;
        position: absolute;
      }

      .esgst-ut-existing-tags {
        font-weight: bold;
        text-align: left;
        text-shadow: none;
      }

      .esgst-ut-preview .esgst-ut-tags {
        display: inline-block;
      }

      .esgst-ut-preview input[type=text] {
        display: inline-block;
        width: 100px;
        height: 15px;
      }

      .esgst-ut-preview input[type=color] {
        box-sizing: unset;
        height: 13px;
        line-height: normal;
        margin: 0;
        padding: 0;
        vertical-align: top;
        width: 15px;
      }

      .esgst-ut-button {
        border: 0! important;
        cursor: pointer;
        display: inline-block;
        line-height: normal;
        margin: 0 0 0 5px;
        text-decoration: none !important;
        transition: opacity 0.2s;
      }

      .esgst-ut-button:hover {
        opacity: 1;
      }

      .author_name + .esgst-ut-button {
        margin: 0 5px 0 0;
      }

      .esgst-ut-button i {
        margin: 0 !important;
      }

      .esgst-ut-tags {
        font-size: 10px;
        font-weight: bold;
      }

      .esgst-ut-tags >* {
        display: inline-block !important;
        height: auto;
        margin: 0;
        padding: 1px 2px;
        text-shadow: none;
        width: auto;
      }

      .esgst-ut-tags >:not(:first-child) {
        margin: 0 0 0 5px;
      }

      .esgst-gv-popout .esgst-ut-tags, .esgst-adots .esgst-ut-tags {
        display: none;
      }
    `;
    if (esgst.sg) {
      style += `
        .esgst-header-menu {
          box-shadow: 1px 1px 1px rgba(255, 255, 255, 0.07) inset, 1px 1px 0 rgba(255, 255, 255, 0.02) inset;
          background-image: linear-gradient(#8a92a1 0px, #757e8f 8px, #4e5666 100%);
          border-radius: 4px;
          display: flex;
          margin-right: 5px;
        }

        .esgst-header-menu-relative-dropdown {
          position: relative;
        }

        .esgst-header-menu-absolute-dropdown {
          top: 34px;
          position: absolute;
          width: 275px;
          border-radius: 4px;
          box-shadow: 0 0 15px rgba(0, 0, 0, 0.02), 2px 2px 5px rgba(0, 0, 0, 0.05), 1px 1px 2px rgba(0, 0, 0, 0.1);
          overflow: hidden;
          z-index: 1;
        }

        .esgst-header-menu-row {
          cursor: pointer;
          background-image: linear-gradient(#fff 0%, #f6f7f9 100%);
          display: flex;
          padding: 12px 15px;
          text-shadow: 1px 1px #fff;
          align-items: center;
        }

        .esgst-version-row {
          cursor: default;
        }

        .esgst-header-menu-row:not(:first-child) {
          border-top: 1px dotted #d2d6e0;
        }

        .esgst-header-menu-row:not(.esgst-version-row):hover, .esgst.header-menu-button:hover + .esgst-header-menu-button {
          border-top-color: transparent;
        }

        .esgst-header-menu-row i {
          font-size: 28px;
          margin-right: 15px;
        }

        .esgst-header-menu-row:not(.esgst-version-row):hover i:not(.esgst-chfl-edit-button):not(.esgst-chfl-remove-button) {
          color: #fff !important;
        }

        .esgst-header-menu-row:not(.esgst-version-row):hover {
          background-image: linear-gradient(#63a0f4 0%, #63a0f4 100%);
          text-shadow: none;
        }

        .esgst-header-menu-row i.blue {
          color: #9dd9e1;
        }

        .esgst-header-menu-row i.green {
          color: #96c468;
        }

        .esgst-header-menu-row i.red {
          color: #ec8583;
        }

        .esgst-header-menu-row i.grey{
          color: #77899A;
        }

        .esgst-header-menu-row i.yellow{
          color: #FECC66;
        }

        .esgst-header-menu-name {
          color: #4B72D4;
          font: bold 11px/15px Arial, sans-serif;
        }

        .esgst-header-menu-description {
          color: #6b7a8c;
          font: 11px/13px Arial, sans-serif
        }

        .esgst-header-menu-row:not(.esgst-version-row):hover .esgst-header-menu-name {
          color: #fff;
        }

        .esgst-header-menu-row:not(.esgst-version-row):hover .esgst-header-menu-description {
          color: rgba(255, 255, 255, 0.7);
        }

        .esgst-header-menu-button {
          white-space: nowrap;
          color: #21262f;
          font: bold 11px/29px Arial, sans-serif;
          padding: 0 15px;
          cursor: pointer;
          text-shadow: 1px 1px rgba(255, 255, 255, 0.08);
          border-radius: 4px 0 0 4px;
        }

        .esgst-header-menu-button.arrow {
          border-radius: 0 4px 4px 0;
          padding: 0 10px;
        }

        .esgst-header-menu-button:hover {
          background-image: linear-gradient(#9ba2b0 0px, #8c94a3 8px, #596070 100%);
        }

        .esgst-header-menu-button.selected {
          background-image: linear-gradient(#4e525f 0px, #434857 5px, #2b2e3a 100%);
          box-shadow: 3px 3px 5px rgba(0, 0, 0, 0.3) inset;
          color: #aec5f3;
          text-shadow: 1px 1px rgba(0, 0, 0, 0.2);
        }

        .esgst-header-menu.selected .esgst-header-menu-button {
          background-image: linear-gradient(#d0d5de 0px, #c9cdd7 5px, #9097a6 100%);
          color: #3c465c;
          text-shadow: 1px 1px rgba(255, 255, 255, 0.2);
        }

        .esgst-header-menu.selected .esgst-header-menu-button:hover:not(.selected) {
          background-image: linear-gradient(#f0f1f5 0px, #d1d4de 100%);
        }
      `;
    } else {
      style += `
        .esgst-header-menu {
          display: flex;
          margin: 0 5px 0 0;
          box-shadow: 0 0 15px rgba(6, 52, 84, 0.07), 2px 2px 5px rgba(6, 52, 84, 0.07), 1px 1px 2px rgba(6, 52, 84, 0.07);
        }

        .esgst-header-menu-relative-dropdown > div {
          overflow: hidden;
          border-radius: 3px;
          background-color: #fff;
          position: absolute;
          margin-top: 39px;
          box-shadow: 0 0 15px rgba(59, 74, 84, 0.07), 2px 2px 5px rgba(59, 74, 84, 0.07), 1px 1px 2px rgba(59, 74, 84, 0.07);
          z-index: 10;
          width: 190px;
        }

        .esgst-header-menu-row {
          padding: 15px 20px;
          color: #557a93;
          display: flex;
          align-items: center;
          font: 700 12px 'Open Sans', sans-serif;
          transition: background-color 0.15s;
          cursor: pointer;
        }

        .esgst-version-row {
          cursor: default;
        }

        .esgst-header-menu-row:not(:last-child) {
          border-bottom: 1px solid #e1ebf2;
        }

        .esgst-header-menu-row.disabled {
          cursor: default
        }

        .esgst-header-menu-row > * {
          transition: opacity 0.15s;
        }

        .esgst-header-menu-row i {
          margin-right: 20px;
          font-size: 24px;
          transition: color 0.15s;
        }

        .esgst-header-menu-row:hover {
          background-color: #f0f3f5;
        }

        .esgst-header-menu-relative-dropdown:hover .esgst-header-menu-row:not(:hover) > * {
          opacity: 0.5;
        }

        .esgst-header-menu-relative-dropdown:hover .esgst-header-menu-row:not(:hover) i {
          color: #bdcbd5;
        }

        .esgst-header-menu-row i.blue {
          color: #9dd9e1;
        }

        .esgst-header-menu-row i.green {
          color: #96c468;
        }

        .esgst-header-menu-row i.red {
          color: #ec8583;
        }

        .esgst-header-menu-row i.grey{
          color: #77899a;
        }

        .esgst-header-menu-row i.yellow{
          color: #FECC66;
        }

        .esgst-header-menu-row:not(.esgst-version-row) .esgst-header-menu-description {
          display: none;
        }

        .esgst-header-menu-button {
          cursor: pointer;
          border-radius: 3px;
          display: flex;
          align-items: center;
          border: 1px solid;
          font: 700 11px 'Open Sans', sans-serif;
          padding: 8px 10px;
          white-space: nowrap;
          background-image: linear-gradient(#fff 0%, #dfe5f0 50%, #a5b2cc 100%);
          border-color: #fff #adb6c7 #909bb0 #cdd3df;
          color: #354a73;
          text-shadow: 1px 1px rgba(255, 255, 255, 0.3);
          transition: opacity 0.1s;
          opacity: 0.8;
          border-radius: 3px 0 0 3px;
          border-right: 0;
        }

        .esgst-header-menu-button:hover:not(.selected) {
          opacity: 1;
        }

        .esgst-header-menu-button.selected {
          opacity: 0.6;
        }

        .esgst-header-menu-button.arrow {
          border-radius: 0 3px 3px 0;
          border-left: 0;
        }

        .esgst-header-menu-button:not(.arrow) > i {
          margin-right: 10px;
        }

        .esgst-un-button, .page_heading .esgst-heading-button {
          background-image: linear-gradient(#fff 0%, rgba(255, 255, 255, 0.4) 100%);
          border: 1px solid #d2d6e0;
          border-radius: 3px;
          color: #4b72d4;
          cursor: pointer;
          display: inline-block;
          font: 700 14px/22px "Open Sans", sans-serif;
          padding: 5px 15px;
        }
      `;
    }
    esgst.style = insertHtml(document.head, `beforeEnd`, `<style id="esgst-style">${style}</style>`);
    esgst.theme = document.getElementById(`esgst-theme`);
    esgst.customThemeElement = document.getElementById(`esgst-custom-theme`);
    setTheme();
  }

  async function setTheme() {
    if (esgst.theme) {
      esgst.theme.remove();
      esgst.theme = null;
    }
    if (esgst.customThemeElement) {
      esgst.customThemeElement.remove();
      esgst.customThemeElement = null;
    }
    let keys = Object.keys(esgst.features.themes.features);
    for (let i = 0, n = keys.length; i < n; i++) {
      let key = keys[i];
      if (key === `customTheme`) continue;
      if (esgst[key] && checkThemeTime(key)) {
        const theme = await getValue(key, ``);
        if (!theme) continue;
        const css = getThemeCss(JSON.parse(theme));
        esgst.theme = insertHtml(document.head, `beforeEnd`, `<style id="esgst-theme">${css}</style>`);
        const revisedCss = css.replace(/!important;/g, `;`).replace(/;/g, `!important;`);
        if (revisedCss !== getLocalValue(`theme`)) {
          setLocalValue(`theme`, revisedCss);
        }
        break;
      }
    }
    if (esgst.customTheme && checkThemeTime(`customTheme`)) {
      const css = JSON.parse(await getValue(`customTheme`, ``));
      esgst.customThemeElement = insertHtml(document.head, `beforeEnd`, `<style id="esgst-custom-theme">${css}</style>`);
      const revisedCss = css.replace(/!important;/g, `;`).replace(/;/g, `!important;`);
      if (revisedCss !== getLocalValue(`customTheme`)) {
        setLocalValue(`customTheme`, revisedCss);
      }
    }
  }

  function checkThemeTime(id) {
    let startParts = esgst[`${id}_startTime`].split(`:`),
      endParts = esgst[`${id}_endTime`].split(`:`),
      startDate = new Date(),
      startHours = parseInt(startParts[0]),
      startMinutes = parseInt(startParts[1]),
      endDate = new Date(),
      endHours = parseInt(endParts[0]),
      endMinutes = parseInt(endParts[1]),
      currentDate = new Date();
    startDate.setHours(startHours);
    startDate.setMinutes(startMinutes);
    startDate.setSeconds(0);
    endDate.setHours(endHours);
    endDate.setMinutes(endMinutes);
    endDate.setSeconds(0);
    currentDate.setSeconds(0);
    if (endDate < startDate) {
      if (currentDate < startDate) {
        startDate.setDate(startDate.getDate() - 1);
      } else {
        endDate.setDate(endDate.getDate() + 1);
      }
    }
    if (currentDate >= startDate && currentDate <= endDate) {
      setTimeout(() => setTheme(), endDate - currentDate);
      return true;
    }
  }

  async function request(details) {
    if (!details.headers) {
      details.headers = {};
    }
    if (!details.headers[`Content-Type`]) {
      details.headers[`Content-Type`] = `application/x-www-form-urlencoded`;
    }
    if (details.queue) {
      let deleteLock = await createLock(`requestLock`, 1000);
      let response = await continueRequest(details);
      deleteLock();
      return response;
    } else {
      return await continueRequest(details);
    }
  }

  function hideGame(button, id, name, steamId, steamType) {
    let elements, i, popup;
    popup = new Popup(`fa-eye-slash`, `Would you like to hide all giveaways for <span class="esgst-bold">${name}</span>?`, true);
    popup.description.appendChild(new ButtonSet(`green`, `grey`, `fa-check-circle`, `fa-refresh fa-spin`, `Yes`, `Please wait...`, async callback => {
      await request({data: `xsrf_token=${esgst.xsrfToken}&do=hide_giveaways_by_game_id&game_id=${id}`, method: `POST`, url: `/ajax.php`});
      await updateHiddenGames(steamId, steamType);
      elements = document.querySelectorAll(`.giveaway__row-outer-wrap[data-game-id="${id}"]`);
      for (i = elements.length - 1; i > -1; --i) {
        elements[i].remove();
      }
      button.remove();
      callback();
      popup.close();
    }).set);
    popup.actions.firstElementChild.outerHTML = `
      <a href="/account/settings/giveaways/filters">View Hidden Games</a>
    `;
    popup.open();
  }

  function unhideGame(button, id, name, steamId, steamType) {
    let popup;
    popup = new Popup(`fa-eye-slash`, `Would you like to unhide all giveaways for <span class="esgst-bold">${name}</span>?`, true);
    popup.description.appendChild(new ButtonSet(`green`, `grey`, `fa-check-circle`, `fa-refresh fa-spin`, `Yes`, `Please wait...`, async callback => {
      await request({data: `xsrf_token=${esgst.xsrfToken}&do=remove_filter&game_id=${id}`, method: `POST`, url: `/ajax.php`});
      await updateHiddenGames(steamId, steamType, true);
      button.remove();
      callback();
      popup.close();
    }).set);
    popup.actions.firstElementChild.outerHTML = `
      <a href="/account/settings/giveaways/filters">View Hidden Games</a>
    `;
    popup.open();
  }

  async function requestGroupInvite() {
    let popup = new Popup(`fa-circle-o-notch fa-spin`, `Sending request...`, true);
    popup.open();
    if (esgst.username) {
      await request({data: `username=${esgst.username}`, method: `POST`, url: `https://script.google.com/macros/s/AKfycbw0odO9iXZBJmK54M_MUQ_IEv5l4RNzj7cEx_FWCZbrtNBNmQ/exec`});
      popup.icon.className = `fa fa-check`;
      popup.title.innerHTML = `Request sent! If you have not done so already, you also need to send a request from the <a class="esgst-bold" href="http://steamcommunity.com/groups/esgst">Steam group</a> page. After that you should be accepted in 24 hours at most.`;
    } else {
      popup.icon.className = `fa-times-circle`;
      popup.title.textContent = `Something went wrong, please try again later. If it continues to happen, please report the issue.`;
    }
  }

  async function checkUpdate() {
    let version = (await request({method: `GET`,url: `https://raw.githubusercontent.com/revilheart/ESGST/master/ESGST.meta.js`})).responseText.match(/@version (.+)/);
    if (version && version[1] != esgst.version) {
      location.href = `https://raw.githubusercontent.com/revilheart/ESGST/master/ESGST.user.js`;
    } else {
        alert(`No ESGST updates found!`);
    }
  }

  function draggable_set(obj) {
    obj.context.setAttribute(`data-dragid`, obj.id);
    for (const element of obj.context.children) {
      if (element.getAttribute(`draggable`)) continue;
      element.setAttribute(`draggable`, true);
      element.addEventListener(`dragstart`, draggable_start.bind(null, obj, element));
      element.addEventListener(`dragenter`, draggable_enter.bind(null, obj, element));
      element.addEventListener(`dragend`, draggable_end.bind(null, obj));
    }
  }

  function draggable_start(obj, element, event) {
    event.dataTransfer.setData(`text/plain`, ``);
    obj.dragging = element;
    draggable_setTrash(obj);
  }

  function draggable_enter(obj, element) {
    if (obj.context !== element.parentElement) return;
    let current = obj.dragging;
    if (!current) return;
    do {
      current = current.previousElementSibling;
      if (current && current === element) {
        obj.context.insertBefore(obj.dragging, element);
        return;
      }
    } while (current);
    obj.context.insertBefore(obj.dragging, element.nextElementSibling);
  }

  async function draggable_end(obj) {
    if (obj.trash) {
      obj.trash.remove();
      obj.trash = null;
    }
    const array = [];
    for (const element of obj.context.children) {
      array.push(decodeURIComponent(element.getAttribute(`data-id`)));
    }
    setValue(obj.id, JSON.stringify(array));
  }

  function draggable_setTrash(obj) {
    obj.trash = insertHtml(obj.context, `afterEnd`, `
      <div class="esgst-draggable-trash">
        <i class="fa fa-trash"></i>
      </div>
    `);
    obj.trash.style.width = `${obj.context.offsetWidth}px`;
    obj.trash.addEventListener(`dragenter`, () => {
      if (!obj.dragging) return;
      if (!confirm(`Are you sure you want to delete this item?`)) return;

      obj.dragging.remove();
      obj.dragging = null;
      const array = [];
      for (const element of obj.context.children) {
        array.push(decodeURIComponent(element.getAttribute(`data-id`)));
      }
      setValue(obj.id, JSON.stringify(array));
    });
  }

  function setCountdown(context, totalSeconds, callback, initialDate = Date.now()) {
    const seconds = totalSeconds - Math.floor((Date.now() - initialDate) / 1000);
    const m = Math.floor(seconds / 60);
    const s = seconds % 60;
    context.textContent = `${`0${m}`.slice(-2)}:${`0${s}`.slice(-2)}`;
    if (seconds > -1) {
      setTimeout(setCountdown, 1000, context, totalSeconds, callback, initialDate);
    } else if (callback) {
      callback();
    }
  }

  function round(number, decimals = 2) {
    const multiplier = Math.pow(10, decimals);
    return Math.round(number * multiplier) / multiplier;
  }

  function getTextNodesIn(elem, opt_fnFilter) {
    var textNodes = [];
    if (elem) {
    for (var nodes = elem.childNodes, i = 0, n = nodes.length; i < n; i++) {
      var node = nodes[i], nodeType = node.nodeType;
      if (nodeType == 3) {
      if (!opt_fnFilter || opt_fnFilter(node, elem)) {
        textNodes.push(node);
      }
      }
      else if (nodeType == 1 || nodeType == 9 || nodeType == 11) {
      textNodes = textNodes.concat(getTextNodesIn(node, opt_fnFilter));
      }
    }
    }
    return textNodes;
  }

  function observeStickyChanges() {
    observeHeaders();
  }

  /**
  * Sets up an intersection observer to notify when elements with the class
  * `.sticky_sentinel--top` become visible/invisible at the top of the container.
  * @param {Element} container
  */
  function observeHeaders() {
    const observer = new IntersectionObserver(records => {
      for (const record of records) {
        const targetInfo = record.boundingClientRect;
        const stickyTarget = record.target.parentElement.querySelector(`.sticky`);
        const rootBoundsInfo = record.rootBounds;

        // Started sticking.
        if (targetInfo.bottom < rootBoundsInfo.top) {
          stickyTarget.classList.add(`stuck`);
        }

        // Stopped sticking.
        if (
          targetInfo.bottom >= rootBoundsInfo.top &&
          targetInfo.bottom < rootBoundsInfo.bottom
        ) {
          stickyTarget.classList.remove(`stuck`);
        }
      }
    }, {threshold: 0});

    // Add the top sentinels to each section and attach an observer.
    const sentinels = addSentinels(`sticky_sentinel--top`);
    sentinels.forEach(el => observer.observe(el));
  }

  function addSentinels(className) {
    return Array.from(document.querySelectorAll(`.sticky`)).map(el => {
      const sentinel = document.createElement(`div`);
      sentinel.classList.add(`sticky_sentinel`, className);
      return el.parentElement.appendChild(sentinel);
    });
  }

  function setClearButton(input) {
    const button = input.nextElementSibling;
    input.addEventListener(`input`, toggleClearButton.bind(null, button, input));
    input.addEventListener(`change`, toggleClearButton.bind(null, button, input));
    input.nextElementSibling.addEventListener(`click`, clearInput.bind(null, input));
  }

  function toggleClearButton(button, input) {
    if (input.value) {
      if (button.classList.contains(`esgst-hidden`)) {
        button.classList.remove(`esgst-hidden`);
      }
    } else if (!button.classList.contains(`esgst-hidden`)) {
      button.classList.add(`esgst-hidden`);
    }
  }

  function clearInput(input) {
    input.value = ``;
    input.dispatchEvent(new Event(`change`));
  }

  function fixEmojis(emojis) {
    const matches = emojis.split(/<\/span>/);
    if (matches.length < 2) return emojis;
    matches.pop();
    return JSON.stringify(matches.map(fixEmoji));
  }

  function fixEmoji(emoji) {
    const match = emoji.match(/title="(.+?)"/);
    emoji = emoji.replace(/<span.+?>/, ``);
    if (match) {
      return getEmojiHtml(emoji);
    }
    let fixed = ``;
    for (let i = 0, n = emoji.length; i < n; i++) {
      fixed += getEmojiHtml(emoji[i]);
    }
    return fixed;
  }

  function getEmojiHtml(emoji) {
    return `&#x${getEmojiUnicode(emoji).toString(`16`).toUpperCase()}`;
  }

  function getEmojiUnicode(emoji) {
    if (emoji.length === 1) {
      return emoji.charCodeAt(0);
    }
    const code = (emoji.charCodeAt(0) - 0xD800) * 0x400 + (emoji.charCodeAt(1) - 0xDC00) + 0x10000;
    if (code < 0) {
      return emoji.charCodeAt(0);
    }
    return code;
  }

  function triggerOnEnter(callback, event) {
    if (event.key === `Enter`) {
      event.preventDefault();
      callback();
    }
  }

  function getChildByClassName(element, className) {
    let i;
    if (!element) return;
    for (i = element.children.length - 1; i > -1 && !element.children[i].classList.contains(className); i--);
    if (i > -1) return element.children[i];
  }

  function escapeMarkdown(string) {
    return string.replace(/(\[|\]|\(|\)|\*|~|!|\.|`|-|>|#|\|)/g, `\\$1`);
  }

  function removeDuplicateNotes(notes) {
    let output = [];
    notes.split(/\n/).forEach(part => {
      if (output.indexOf(part) < 0) {
        output.push(part);
      }
      output.push(`\n`);
    });
    return output.join(``).trim().replace(/\n\n+/g, `\n\n`);
  }

  function capitalizeFirstLetter(string) {
    return `${string[0].toUpperCase()}${string.slice(1)}`;
  }

  function getTimestamp(seconds, is24Clock, isShowSeconds) {
    if (is24Clock) {
      if (isShowSeconds) {
        return getDate(`[MMM] [D], [YYYY], [H]:[HMM]:[SS]`, seconds);
      }
      return getDate(`[MMM] [D], [YYYY], [H]:[HMM]`, seconds);
    }
    if (isShowSeconds) {
      return getDate(`[MMM] [D], [YYYY], [H12]:[HMM]:[SS][XX]`, seconds);
    }
    return getDate(`[MMM] [D], [YYYY], [H12]:[HMM][XX]`, seconds);
  }

  function getDate(format, param) {
    let date = typeof param === `number` ? new Date(param) : param,
      months = [
        `January`, `February`, `March`, `April`, `May`, `June`,
        `July`, `August`, `September`, `October`, `November`, `December`
      ];
    return format
      .replace(/\[D\]/i, date.getDate())
      .replace(/\[DD\]/i, `0${date.getDate()}`.slice(-2))
      .replace(/\[M\]/i, date.getMonth() + 1)
      .replace(/\[MM\]/i, `0${date.getMonth() + 1}`.slice(-2))
      .replace(/\[MMM\]/i, months[date.getMonth()].slice(0, 3))
      .replace(/\[MMMM\]/i, months[date.getMonth()])
      .replace(/\[YYYY\]/i, date.getFullYear())
      .replace(/\[H\]/i, date.getHours())
      .replace(/\[HH\]/i, `0${date.getHours()}`.slice(-2))
      .replace(/\[H12\]/i, `${date.getHours() % 12}`.replace(/^0$/, `12`))
      .replace(/\[HH12\]/i, `0${date.getHours() % 12}`.slice(-2).replace(/^0$/, `12`))
      .replace(/\[HM\]/i, date.getMinutes())
      .replace(/\[HMM\]/i, `0${date.getMinutes()}`.slice(-2))
      .replace(/\[S\]/i, date.getSeconds())
      .replace(/\[SS\]/i, `0${date.getSeconds()}`.slice(-2))
      .replace(/\[XX\]/i, date.getHours() < 12 ? `am` : `pm`);
  }

  function getRemainingTime(time) {
    let d, dif, h, m, s, w;
    dif = time - Date.now();
    if (dif < 0) {
      dif *= -1;
    }
    w = Math.floor(dif / 604800000);
    if (w > 0) {
      return `${w}w`;
    } else {
      d = Math.floor(dif / 86400000);
      if (d > 0) {
        return `${d}d`;
      } else {
        h = Math.floor(dif / 3600000);
        if (h > 0) {
          return `${h}h`;
        } else {
          m = Math.floor(dif / 60000);
          if (m > 0) {
            return `${m}m`;
          } else {
            s = Math.floor(dif / 1000);
            return `${s}s`;
          }
        }
      }
    }
  }

  function getTimeSince(timestamp, until) {
    let n, s;
    s = Math.floor((until ? (timestamp - Date.now()) : (Date.now() - timestamp)) / 1000);
    n = Math.floor(s / 31104000);
    if (n >= 1) {
      return `${n} year${n === 1 ? `` : `s`}`;
    }
    n = Math.floor(s / 2592000);
    if (n >= 1) {
      return `${n} month${n === 1 ? `` : `s`}`;
    }
    n = Math.floor(s / 86400);
    if (n >= 1) {
      return `${n} day${n === 1 ? `` : `s`}`;
    }
    n = Math.floor(s / 3600);
    if (n >= 1) {
      return `${n} hour${n === 1 ? `` : `s`}`;
    }
    n = Math.floor(s / 60);
    if (n >= 1) {
      return `${n} minute${n === 1 ? `` : `s`}`;
    }
    n = Math.floor(s);
    return `${n} second${n === 1 ? `` : `s`}`;
  }

  function setLocalValue(key, value) {
    localStorage.setItem(`esgst_${key}`, value);
  }

  function getLocalValue(key, value = undefined) {
    return localStorage.getItem(`esgst_${key}`) || value;
  }

  function delLocalValue(key) {
    localStorage.removeItem(`esgst_${key}`);
  }

  function isSet(variable) {
    return typeof variable !== `undefined` && variable !== null;
  }

  function validateValue(value) {
    return typeof value === `undefined` || value;
  }

  function closeHeaderMenu(arrow, dropdown, menu, event) {
    if (!menu.contains(event.target) && arrow.classList.contains(`selected`)) {
      arrow.classList.remove(`selected`);
      dropdown.classList.add(`esgst-hidden`);
    }
  }

  function insertHtml(context, position, html) {
    try {
      context.insertAdjacentHTML(position, html);
    } catch (error) {
      console.log(error);
      console.log(html);
      return null;
    }
    let positions = {
      beforeBegin: `previousElementSibling`,
      afterBegin: `firstElementChild`,
      beforeEnd: `lastElementChild`,
      afterEnd: `nextElementSibling`
    };
    return context[positions[position]];
  }

  function sortArray(Array, desc) {
    if (desc) {
      return Array.sort((A, B) => {
        return B.localeCompare(A, {
          sensitivity: `base`
        });
      });
    }
    return Array.sort((A, B) => {
      return A.localeCompare(B, {
        sensitivity: `base`
      });
    });
  }

  function sortArrayByKey(array, key) {
    return array.sort((a, b) => {
      return a[key].localeCompare(b[key], {
        sensitivity: `base`
      });
    });
  }

  function sortArrayByNumberKey(array, numberKey, desc) {
    let n = desc ? -1 : 1;
    return array.sort((a, b) => {
      if (a[numberKey] < b[numberKey]) {
        return -1 * n;
      } else if (a[numberKey] > b[numberKey]) {
        return 1 * n;
      } else {
        return 0;
      }
    });
  }

  function setSiblingsOpacity(element, Opacity) {
    let Siblings, I, N;
    Siblings = element.parentElement.children;
    for (I = 0, N = Siblings.length; I < N; ++I) {
      if (Siblings[I] != element) {
        Siblings[I].style.opacity = Opacity;
      }
    }
  }

  function setHoverOpacity(element, EnterOpacity, LeaveOpacity) {
    element.addEventListener(`mouseenter`, () => {
      element.style.opacity = EnterOpacity;
    });
    element.addEventListener(`mouseleave`, () => {
      element.style.opacity = LeaveOpacity;
    });
  }

  function createUuid(c) {
    let r, v;
    r = Math.random() * 16 | 0;
    v = c === `x` ? r : (r & 0x3 | 0x8);
    return v.toString(16);
  }

  function timeout(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  function createTooltip(context, message) {
    let popout;
    popout = new Popout(`esgst-feature-description markdown`, context, 100);
    popout.popout.style.maxHeight = `300px`;
    popout.popout.style.overflow = `auto`;
    popout.popout.innerHTML = message;
  }

  function createOptions(options) {
    let context, elements, id, switches;
    context = document.createElement(`div`);
    elements = {};
    switches = {};
    options.forEach(option => {
      if (option.check) {
        id = option.id;
        elements[id] = insertHtml(context, `beforeEnd`, `
          <div></div>
        `);
        switches[id] = new ToggleSwitch(elements[id], id, false, option.description, false, false, option.tooltip, esgst[id]);
      }
    });
    options.forEach(option => {
      let enabled = esgst[option.id];
      if (switches[option.id]) {
        if (option.dependencies) {
          option.dependencies.forEach(dependency => {
            if (elements[dependency]) {
              switches[option.id].dependencies.push(elements[dependency]);
              if (!enabled) {
                elements[dependency].classList.add(`esgst-hidden`);
              }
            }
          });
        }
        if (option.exclusions) {
          option.exclusions.forEach(exclusion => {
            if (elements[exclusion]) {
              switches[option.id].exclusions.push(elements[exclusion]);
              if (enabled) {
                elements[exclusion].classList.add(`esgst-hidden`);
              }
            }
          });
        }
      }
    });
    return context;
  }

  function createResults(Context, element, Results) {
    let I, N, Key;
    for (I = 0, N = Results.length; I < N; ++I) {
      Context.insertAdjacentHTML(`beforeEnd`, `
        <div class="esgst-hidden">
          ${Results[I].Icon}
          <span class="esgst-bold">${Results[I].Description} (<span>0</span>):</span>
          <span class="esgst-popup-actions"></span>
        </div>
      `);
      Key = Results[I].Key;
      element[Key] = Context.lastElementChild;
      element[`${Key}Count`] = element[Key].firstElementChild.nextElementSibling.firstElementChild;
      element[`${Key}Users`] = element[Key].lastElementChild;
    }
  }

  function goToComment(hash, element, noPermalink) {
    if (!hash) {
      hash = location.hash;
    }
    let id = hash.replace(/#/, ``);
    if ((!id && !element) || location.pathname.match(/^\/account/)) return;
    if (id && !element) {
      element = document.getElementById(id);
    }
    if (!element) return;
    scrollTo(0, element.offsetTop);
    scrollBy(0, -esgst.commentsTop);
    if (noPermalink) return;
    let permalink = document.querySelector(`.is_permalink, .author_permalink`);
    if (permalink) {
      permalink.remove();
    }
    element = element.querySelector(`.comment__username, .author_avatar`);
    if (!element) return;
    element.insertAdjacentHTML(esgst.sg ? `beforeBegin` : `afterEnd`, `
      <i class="fa fa-share is_permalink author_permalink"></i>
    `);
  }

  function sortContent(array, mainKey, option) {
    let after, before, divisor, divisors, i, key, n, name;
    name = option.split(/_/);
    key = name[0];
    if (name[1] === `asc`) {
      before = -1;
      after = 1;
    } else {
      before = 1;
      after = -1;
    }
    array.sort((a, b) => {
      if (typeof a[key] === `string` && typeof b[key] === `string`) {
        return (a[key].toLowerCase().localeCompare(b[key].toLowerCase()) * after);
      } else {
        if (a[key] < b[key]) {
          return before;
        } else if (a[key] > b[key]) {
          return after;
        } else {
          return 0;
        }
      }
    });
    let context = null;
    if (mainKey === `popupGiveaways`) {
      context = array[0].outerWrap.closest(`.esgst-popup`).getElementsByClassName(`esgst-gv-view`)[0] || array[0].outerWrap.parentElement.parentElement;
    }
    for (i = 0, n = array.length; i < n; ++i) {
      if (!array[i].outerWrap.parentElement) continue;

      if (context) {
        context.appendChild(array[i].outerWrap.parentElement);
      } else {
        array[i].outerWrap.parentElement.appendChild(array[i].outerWrap);
      }
    }
    if (key === `sortIndex`) {
      divisors = document.getElementsByClassName(`esgst-es-page-divisor`);
      for (i = divisors.length - 1; i > -1; --i) {
        divisor = divisors[i];
        divisor.classList.remove(`esgst-hidden`);
        divisor.parentElement.insertBefore(divisor, document.getElementsByClassName(`esgst-es-page-${i + 2}`)[0]);
      }
    } else {
      divisors = document.querySelectorAll(`.esgst-es-page-divisor:not(.esgst-hidden)`);
      for (i = divisors.length - 1; i > -1; --i) {
        divisors[i].classList.add(`esgst-hidden`);
      }
    }
  }

  function rot(string, n) {
    return string.replace(/[a-zA-Z]/g, char => {
      return String.fromCharCode(((char <= `Z`) ? 90 : 122) >= ((char = char.charCodeAt(0) + n)) ? char : (char - 26));
    });
  }

  function buildGiveaway(context, url, errorMessage, blacklist) {
    let avatar, code, column, columns, comments, counts, endTime, endTimeColumn, entered, entries, giveaway, heading, headingName, i, id, icons, image, n, removeEntryButton, started, startTimeColumn, thinHeadings;
    giveaway = context.getElementsByClassName(`featured__outer-wrap--giveaway`)[0];
    if (giveaway) {
      let match = url.match(/giveaway\/(.+?)\//),
        sgTools = false;
      if (match) {
        code = match[1];
      } else {
        match = url.match(/giveaways\/(.+)/);
        if (match) {
          code = match[1];
          sgTools = true;
        }
      }
      id = giveaway.getAttribute(`data-game-id`);
      heading = giveaway.getElementsByClassName(`featured__heading`)[0];
      icons = heading.getElementsByTagName(`a`);
      for (i = 0, n = icons.length; i < n; ++i) {
        icons[i].classList.add(`giveaway__icon`);
      }
      headingName = heading.firstElementChild;
      headingName.outerHTML = `<a class="giveaway__heading__name" href="${url}">${headingName.innerHTML}</a>`;
      thinHeadings = heading.getElementsByClassName(`featured__heading__small`);
      for (i = 0, n = thinHeadings.length; i < n; ++i) {
        thinHeadings[0].outerHTML = `<span class="giveaway__heading__thin">${thinHeadings[0].innerHTML}</span>`;
      }
      columns = heading.nextElementSibling;
      endTimeColumn = columns.firstElementChild;
      endTimeColumn.classList.remove(`featured__column`);
      if (sgTools) {
        let info = games_getInfo(giveaway);
        if (info) {
          heading.insertAdjacentHTML(`beforeEnd`, `
            <a class="giveaway__icon" rel="nofollow" target="_blank" href="https://store.steampowered.com/${info.type.slice(0, -1)}/${info.id}/">
              <i class="fa fa-steam"></i>
            </a>
            <a class="giveaway__icon" href="/giveaways/search?${info.type.slice(0, -1)}=${info.id}">
              <i class="fa fa-search"></i>
            </a>
          `);
        }
        let date = new Date(`${endTimeColumn.lastElementChild.textContent}Z`).getTime();
        let ended = Date.now() > date;
        endTimeColumn.lastElementChild.outerHTML = `${ended ? `Ended ` : ``}<span data-timestamp="${date / 1e3}">${ended ? getTimeSince(date) : getTimeSince(date, true)}</span>${ended ? ` ago` : ` remaining `}`;
      }
      endTime = parseInt(endTimeColumn.lastElementChild.getAttribute(`data-timestamp`)) * 1000;
      startTimeColumn = endTimeColumn.nextElementSibling;
      startTimeColumn.classList.remove(`featured__column`, `featured__column--width-fill`);
      startTimeColumn.classList.add(`giveaway__column--width-fill`);
      if (sgTools) {
        let date = new Date(`${startTimeColumn.firstElementChild.textContent}Z`).getTime();
        startTimeColumn.firstElementChild.outerHTML = `<span data-timestamp="${date / 1e3}">${getTimeSince(date)}</span> ago `;
      }
      avatar = columns.lastElementChild;
      if (sgTools) {
        avatar.className = `giveaway_image_avatar`;
      }
      avatar.remove();
      startTimeColumn.querySelector(`[style]`).removeAttribute(`style`);
      column = startTimeColumn.nextElementSibling;
      while (column) {
        column.classList.remove(`featured__column`);
        column.className = column.className.replace(/featured/g, `giveaway`);
        column = column.nextElementSibling;
      }
      removeEntryButton = context.getElementsByClassName(`sidebar__entry-delete`)[0];
      if (removeEntryButton && !removeEntryButton.classList.contains(`is-hidden`)) {
        entered = `is-faded`;
      } else {
        entered = ``;
      }
      counts = context.getElementsByClassName(`sidebar__navigation__item__count`);
      if (counts.length > 1) {
        entries = counts[1].textContent;
        comments = counts[0].textContent;
        started = true;
      } else if (counts.length > 0) {
        entries = 0;
        comments = counts[0].textContent;
        started = false;
      } else {
        entries = 0;
        comments = 0;
      }
      image = giveaway.getElementsByClassName(`global__image-outer-wrap--game-large`)[0].firstElementChild.getAttribute(`src`);
      return {
        code: code,
        html: `
          <div>
            <div class="giveaway__row-outer-wrap" ${errorMessage ? `data-error="${errorMessage}"` : ``} ${blacklist ? `data-blacklist="true"` : ``} data-game-id="${id}">
              <div class="giveaway__row-inner-wrap ${entered}">
                <div class="giveaway__summary">
                  <h2 class="giveaway__heading">${heading.innerHTML}</h2>
                  <div class="giveaway__columns">${columns.innerHTML}</div>
                  <div class="giveaway__links">
                    <a href="${url}/entries">
                      <i class="fa fa-tag"></i>
                      <span>${entries} entries</span>
                    </a>
                    <a href="${url}/comment">
                      <i class="fa fa-comment"></i>
                      <span>${comments} comments</span>
                    </a>
                  </div>
                </div>
                ${avatar.outerHTML}
                <a class="giveaway_image_thumbnail" href="${url}" style="background-image: url(${image})"></a>
              </div>
            </div>
          </div>
        `,
        points: parseInt(heading.textContent.match(/\((\d+)P\)/)[1]),
        started: started,
        timestamp: endTime
      };
    } else {
      return null;
    }
  }

  function copyValue(icon, value) {
    let textArea = insertHtml(document.body, `beforeEnd`, `
      <textarea></textarea>
    `);
    textArea.value = value;
    textArea.select();
    document.execCommand(`copy`);
    textArea.remove();
    if (icon) {
      icon.classList.add(`esgst-green`);
      setTimeout(() => icon.classList.remove(`esgst-green`), 2000);
    }
  }

  function getParameters() {
    let parameters = {};
    location.search.replace(/^\?/, ``).split(/&/).forEach(item => {
      item = item.split(/=/);
      parameters[item[0]] = item[1];
    });
    return parameters;
  }

  function setMissingDiscussion(context) {
    if (context) {
      context.outerWrap.innerHTML = `
        <div class="table__row-outer-wrap" style="padding: 15px 0;">
          <div class="table__row-inner-wrap">
            <div>
              <a class="table_image_avatar" href="/user/${context.author}" style="background-image:${context.avatar.style.backgroundImage.replace(/"/g, `'`)};"></a>
            </div>
            <div class="table__column--width-fill">
              <h3 style="margin-bottom: 2px;">
                <a class="homepage_table_column_heading" href="${context.url}">${context.title}</a>
              </h3>
              <p>
                ${context.lastPostTime ? `
                  <a class="table__column__secondary-link" href="${context.url}">${context.comments} Comments</a> - Last post <span data-timestamp="${context.lastPostTimestamp}">${context.lastPostTime}</span> ago by <a class="table__column__secondary-link" href="/user/${context.lastPostAuthor}">${context.lastPostAuthor}</a>
                  <a class="icon-green table__last-comment-icon" href="/go/comment/${context.lastPostCode}">
                    <i class="fa fa-chevron-circle-right"></i>
                  </a>
                ` : `
                  <a class="table__column__secondary-link" href="${context.url}">${context.comments} Comments</a> - Created <span data-timestamp="${context.createdTimestamp}">${context.createdTime}</span> ago by <a class="table__column__secondary-link" href="/user/${context.author}">${context.author}</a>
                `}
              </p>
            </div>
          </div>
        </div>
      `;
      context.outerWrap = context.outerWrap.firstElementChild;
    }
  }

  function debug() {
    let popup, textArea;
    popup = new Popup(`fa-bug`, `Debug`);
    popup.description.insertAdjacentHTML(`afterBegin`, `<div class="esgst-description">Insert the Javascript code below to debug it. To open the console, use Ctrl + Shift + I.<br><br><span class="esgst-bold esgst-red">BE CAREFUL! Only do this if you know what you are doing or if you have been instructed to.<br><br>Playing with this when you do not know what you are doing could lead to serious consequences, such as having your entire data wiped out.<br><br>YOU HAVE BEEN WARNED!</span></div>`);
    textArea = insertHtml(popup.scrollable, `beforeEnd`, `<textarea class="esgst-debug"></textarea>`);
    popup.description.appendChild(new ButtonSet(`green`, ``, `fa-bug`, ``, `Debug`, ``, callback => {
      callback();
      eval(textArea.value);
    }).set);
    popup.open(() => textArea.focus());
  }

  function filterSm(event) {
    let collapse, element, expand, found, id, type, typeFound, value;
    value = event.currentTarget.value.toLowerCase().trim();
    for (type in esgst.features) {
      found = false;
      typeFound = false;
      for (id in esgst.features[type].features) {
        unfadeSmFeatures(esgst.features[type].features[id], id);
        found = filterSmFeature(esgst.features[type].features[id], id, value);
        if (found) {
          typeFound = true;
          unhideSmFeature(esgst.features[type].features[id], id);
        }
      }
      element = document.getElementById(`esgst_${type}`);
      if (element) {
        if (typeFound) {
          element.classList.remove(`esgst-hidden`);
        } else {
          element.classList.add(`esgst-hidden`);
        }
        if (value) {
          expand = element.getElementsByClassName(`fa-plus-square`)[0];
          if (expand) {
            expand.click();
          }
        } else {
          collapse = element.getElementsByClassName(`fa-minus-square`)[0];
          if (collapse) {
            collapse.click();
          }
        }
      }
    }
  }

  function unfadeSmFeatures(feature, id) {
    let element = document.getElementById(`esgst_${id}`);
    if (element) {
      element.classList.remove(`esgst-sm-faded`);
    }
    if (feature.features) {
      for (id in feature.features) {
        unfadeSmFeatures(feature.features[id], id);
      }
    }
  }

  function filterSmFeature(feature, id, value) {
    let element, found, subId;
    found = false;
    let exactFound = feature.name.toLowerCase().match(value);
    if (feature.features) {
      for (subId in feature.features) {
        let result = filterSmFeature(feature.features[subId], subId, value);
        found = found || result;
      }
      found = found || (feature.description && feature.description.toLowerCase().match(value)) || exactFound;
    } else {
      found = (feature.description && feature.description.toLowerCase().match(value)) || exactFound;
    }
    element = document.getElementById(`esgst_${id}`);
    if (element) {
      if (found) {
        element.classList.remove(`esgst-hidden`);
      } else {
        element.classList.add(`esgst-hidden`);
      }
      if (!exactFound) {
        element.classList.add(`esgst-sm-faded`);
      }
    }
    return found;
  }

  function unhideSmFeature(feature, id) {
    let element = document.getElementById(`esgst_${id}`);
    if (element) {
      element.classList.remove(`esgst-hidden`);
    }
    if (feature.features) {
      for (id in feature.features) {
        unhideSmFeature(feature.features[id], id);
      }
    }
  }

  function escapeRegExp(string){
    return string.replace(/[.*+?^${}()|[\]\\]/g, `\\$&`);
  }

  function getThemeUrl(id, url) {
    return new Promise(openThemePopup.bind(null, id, url));
  }

  function openThemePopup(id, url, resolve) {
    let obj = {
      resolve,
      url
    };
    obj.options = {
      sgv2Dark: [
        {
          default: 0,
          id: `ik-page width`,
          name: `Page width`,
          options: [
            {
              id: `ik-def page width`,
              name: `100%`
            },
            {
              id: `ik-fixed sg page width`,
              name: `Fixed (1440px)`
            }
          ]
        }
      ],
      steamGifties: [
        {
          default: 1,
          id: `ik-spoilertags`,
          name: `Remove spoiler tags`
        },
        {
          default: 1,
          id: `ik-hiddenlinks`,
          name: `Reveal hidden links`
        },
        {
          default: 0,
          id: `ik-sgppsupport`,
          name: `SG++ support`
        },
        {
          default: 0,
          id: `ik-whiteblacklist`,
          name: `Blacklist/Whitelist Indicator support`
        },
        {
          default: 0,
          id: `ik-easysteamgifts`,
          name: `Easy SteamGifts support`
        },
        {
          default: 0,
          id: `ik-visited-link`,
          name: `Highlight visited links`,
          options: [
            {
              id: `ik-1`,
              name: `Mark visited links`
            },
            {
              id: `ik-3`,
              name: `Mark visited links + threads in forum`
            },
            {
              id: `ik-2`,
              name: `No`
            }
          ]
        },
        {
          default: 0,
          id: `ik-touhou-style`,
          name: `TouHou Giveaways Helper support`
        },
        {
          default: 0,
          id: `ik-sg2os`,
          name: `SG2O support`
        },
        {
          default: 0,
          id: `ik-avatarsize`,
          name: `Avatar size`,
          options: [
            {
              id: `ik-1`,
              name: `Big (52px)`
            },
            {
              id: `ik-2`,
              name: `Normal`
            }
          ]
        },
        {
          default: 0,
          id: `ik-extendedsg`,
          name: `Extended SteamGifts support`
        },
        {
          default: 0,
          id: `ik-navbarbutton`,
          name: `Navigation bar button color`,
          options: [
            {
              id: `ik-1`,
              name: `Default`
            },
            {
              id: `ik-2`,
              name: `White`
            }
          ]
        },
        {
          default: 0,
          id: `ik-ESGST`,
          name: `ESGST support`
        },
        {
          default: 1,
          id: `ik-featurega`,
          name: `Featured giveaway`,
          options: [
            {
              id: `ik-1`,
              name: `No`
            },
            {
              id: `ik-2`,
              name: `Smaller banner`
            },
            {
              id: `ik-2`,
              name: `Hide banner`
            }
          ]
        },
        {
          default: 0,
          id: `ik-removepoll`,
          name: `Homepage poll`,
          options: [
            {
              id: `ik-1`,
              name: `Default`
            },
            {
              id: `ik-2`,
              name: `Remove poll`
            }
          ]
        }
      ],
      steamTradies: [
        {
          default: 0,
          id: `ik-color-sc`,
          name: `Color`,
          options: [
            {
              id: `ik-1`,
              name: `Dark blue`
            },
            {
              id: `ik-2`,
              name: `Black`
            }
          ]
        }
      ]
    };
    let binaryOptions = [
      {
        id: `ik-1`,
        name: `Yes`
      },
      {
        id: `ik-2`,
        name: `No`
      }
    ];
    let key =  id.replace(/Black|Blue/g, ``);
    if (!obj.options[key]) {
      resolve(url);
      return;
    }
    obj.popup = new Popup_v2({
      icon: `fa-gear`,
      title: `Select the options that you want:`,
      buttons: [
        {
          color1: `green`, color2: `grey`,
          icon1: `fa-gear`, icon2: `fa-circle-o-notch fa-spin`,
          title1: `Generate`, title2: `Generating...`,
          callback1: generateThemeUrl.bind(null, obj, key)
        }
      ],
      addScrollable: true
    });
    obj.popup.onClose = resolve.bind(null, url);
    let context = obj.popup.getScrollable(`
      <div class="esgst-sm-colors"></div>
    `).firstElementChild;
    obj.options[key].forEach(option => {
      option.select = insertHtml(context, `beforeEnd`, `
        <div>
          ${option.name} <select></select>
        </div>
      `).lastElementChild;
      (option.options || binaryOptions).forEach(subOption => {
        option.select.insertAdjacentHTML(`beforeEnd`, `
          <option value="${subOption.id}">${subOption.name}</option>
        `);
      });
      option.select.selectedIndex = option.default;
    });
    obj.popup.open();
  }

  function generateThemeUrl(obj, key) {
    obj.url += `?`;
    obj.options[key].forEach(option => {
      obj.url += `${option.id}=${option.select.value}&`;
    });
    obj.url = obj.url.slice(0, -1);
    obj.popup.onClose = null;
    obj.popup.close();
    obj.resolve(obj.url);
  }

  function createMenuSection(context, html, number, title, type) {
    let section = insertHtml(context, `beforeEnd`, `
      <div class="esgst-form-row" id="esgst_${type}">
        <div class="esgst-form-heading">
          <div class="esgst-form-heading-number">${number}.</div>
          <div class="esgst-form-heading-text">${title}</div>
        </div>
        <div class="esgst-form-row-indent">${html ? html : ``}</div>
      </div>
    `);
    if (esgst.collapseSections && !title.match(/Backup|Restore|Delete/)) {
      let button, container, isExpanded;
      button = insertHtml(section.firstElementChild, `afterBegin`, `
        <span class="esgst-clickable" style="margin-right: 5px;">
          <i class="fa fa-plus-square" title="Expand section"></i>
        </span>
      `);
      container = section.lastElementChild;
      container.classList.add(`esgst-hidden`);
      isExpanded = false;
      button.addEventListener(`click`, () => {
        if (isExpanded) {
          container.classList.add(`esgst-hidden`);
          button.innerHTML = `<i class="fa fa-plus-square" title="Expand section"></i>`;
          isExpanded = false;
        } else {
          container.classList.remove(`esgst-hidden`);
          button.innerHTML = `<i class="fa fa-minus-square" title="Collapse section"></i>`;
          isExpanded = true;
        }
      });
    }
    return section;
  }

  function createSMButtons(Heading, Items) {
    let I, N, Item, Icons, J, NumIcons;
    for (I = 0, N = Items.length; I < N; ++I) {
      Item = Items[I];
      if (Item.Check) {
        Icons = ``;
        for (J = 0, NumIcons = Item.Icons.length; J < NumIcons; ++J) {
          Icons += `<i class="fa ${Item.Icons[J]}"></i> `;
        }
        Heading.insertAdjacentHTML(`beforeEnd`, `<a class="${Item.Name}" title="${Item.Title}">${Icons}</a>`);
      }
    }
  }

  function triggerSetOnEnter(set, event) {
    if (event.key === `Enter`) {
      set.trigger();
    }
  }

  function formatTags(fullMatch, match1, offset, string) {
    return (((offset === 0) || (offset === (string.length - fullMatch.length))) ? `` : `, `);
  }

  function animateScroll(y, callback) {
    // From https://stackoverflow.com/a/26808520/8115112

    let currentTime, time;
    currentTime = 0;
    if (y > 0) {
      y -= esgst.commentsTop;
    }
    time = Math.max(0.1, Math.min(Math.abs(scrollY - y) / 2000, 0.8));

    function tick() {
      let p;
      currentTime += 1 / 60;
      p = currentTime / time;
      if (p < 1) {
        requestAnimationFrame(tick);
        scrollTo(0,  scrollY + ((y -  scrollY) * ((p /= 0.5) < 1 ? 0.5 * Math.pow(p, 5) : 0.5 * (Math.pow((p - 2), 5) + 2))));
      } else {
        scrollTo(0, y);
        if (callback) {
          callback();
        }
      }
    }

    tick();
  }

  function reverseComments(context) {
    let i, n;
    let frag = document.createDocumentFragment();
    for (i = 0, n = context.children.length; i < n; ++i) {
      frag.appendChild(context.lastElementChild);
    }
    context.appendChild(frag);
  }

  function createAlert(message) {
    let popup;
    popup = new Popup(`fa-exclamation`, message, true);
    popup.open();
  }

  function createConfirmation(message, onYes, onNo, event) {
    let callback, popup;
    callback = onNo;
    popup = new Popup(`fa-question`, message, true);
    popup.description.appendChild(new ButtonSet(`green`, ``, `fa-check`, ``, `Yes`, ``, () => {
      callback = onYes;
      popup.close();
    }).set);
    popup.description.appendChild(new ButtonSet(`red`, ``, `fa-times`, ``, `No`, ``, () => {
      callback = onNo;
      popup.close();
    }).set);
    popup.onClose = () => {
      if (callback) {
        callback(event);
      }
    };
    popup.open();
  }

  function createFadeMessage(context, message) {
    context.textContent = message;
    setTimeout(() => {
      context.textContent = ``;
    }, 10000);
  }

  function getDataMenu(option, switches, type) {
    let i, m, menu, n, options, toggleSwitch;
    menu = document.createElement(`div`);
    switches[option.key] = toggleSwitch = new ToggleSwitch(menu, `${type}_${option.key}`, false, option.name, false, false, null, esgst.settings[`${type}_${option.key}`]);
    switches[option.key].size = insertHtml(switches[option.key].name, `beforeEnd`, ` <span class="esgst-bold"></span>`);
    if (option.name === `Main`) {
      switches[option.key].name.insertAdjacentHTML(`beforeEnd`, ` <i class="fa fa-question-circle" title="Main data is the data that is needed by other sub-options. Because of that dependency, when deleting main data not all data may be deleted, but if you delete another sub-option first and then delete main data, all data that was required exclusively by that sub-option will be deleted."></i>`);
    }
    if (option.options) {
      options = insertHtml(menu, `beforeEnd`, `
        <div class="esgst-form-row-indent SMFeatures esgst-hidden"></div>
      `);
      for (i = 0, n = option.options.length; i < n; ++i) {
        m = getDataMenu(option.options[i], switches, type);
        options.appendChild(m);
        toggleSwitch.dependencies.push(m);
      }
      if (esgst.settings[`${type}_${option.key}`]) {
        options.classList.remove(`esgst-hidden`);
      }
    }
    toggleSwitch.onEnabled = () => {
      if (options) {
        options.classList.remove(`esgst-hidden`);
      }
    };
    toggleSwitch.onDisabled = () => {
      if (options) {
        options.classList.add(`esgst-hidden`);
      }
    }
    return menu;
  }

  function openSmallWindow(url) {
    open(url, `esgst`, `height=600,left=${(screen.width - 600) / 2},top=${(screen.height - 600) / 2},width=600`);
  }

  function convertBytes(bytes) {
    if (bytes < 1024) {
      return `${bytes} B`;
    } else {
      bytes /= 1024;
      if (bytes < 1024) {
        return `${Math.round(bytes * 100) / 100} KB`;
      } else {
        return `${Math.round(bytes / 1024 * 100) / 100} MB`;
      }
    }
  }

  function getThemeCss(theme) {
    let separators = theme.match(/@-moz-document(.+?){/g);
    if (!separators) {
      return theme;
    }
    let css = [];
    separators.forEach(separator => {
      let check = false;
      (separator.match(/domain\(.+?\)/g) || []).forEach(domain => {
        if (location.hostname.match(domain.match(/\("(.+?)"\)/)[1])) {
          check = true;
          return;
        }
      });
      (separator.match(/url(-prefix)?\(.+?\)/g) || []).forEach(url => {
        if (location.href.match(url.match(/\("(.+?)"\)/)[1])) {
          check = true;
          return;
        }
      });
      if (!check) return;
      let index = theme.indexOf(separator) + separator.length,
        open = 1;
      do {
        let character = theme[index];
        if (character === `{`) {
          open++;
        } else if (character === `}`) {
          open--;
        }
        css.push(character);
        index++;
      } while (open > 0);
      css.pop();
    });
    return css.join(``);
  }

  function loadChangelog(version) {
    let changelog, html, i, index, n, popup;
    changelog = [
      {
        date: `June 24, 2018`,
        version: `7.22.0`,
        changelog: `
          <ul>
            <li><a href="https://github.com/revilheart/ESGST/issues/545">#545</a> Add a feature: Have/Want List Checker</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/572">#572</a> Fix a bug that does not predict the level in Level Progress Visualizer correctly</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/690">#690</a> Fix a bug where Giveaway Group Loader fails in some pages</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/702">#702</a> Extend Attached Image Carousel to Quick Inbox View</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/722">#722</a> Improve performance when applying filter presets (removes live-search select box and invert rule)</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/732">#732</a> Bring back filter counters</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/768">#768</a> Save state of "create train" and "remove links" switches from Multiple Giveaway Creator with Giveaway Templates</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/769">#769</a> Add polyfill for IntersectionObserver</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/771">#771</a> Fix a bug that does not filter games without images after data being retrieved with Created/Entered/Won Giveaway Details</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/772">#772</a> Fix domain for SteamGifts popups on SteamTrades</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/773">#773</a> Fix Shared Group Checker for new Steam group page design</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/775">#775</a> Save game name when it doesn't have an image for future use</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/776">#776</a> Fix a bug that does not save an advanced filter preset after deleting the rules</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/777">#777</a> Fix a bug that does not filter by Achievements or Linux</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/778">#778</a> Add small manual for advanced filters</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/779">#779</a> Fix conflict with Touhou script</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/780">#780</a> Fix a bug that blinks the minimize popups panel if the popup was open when it ended</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/781">#781</a> Fix a bug that does not allow restoring .zip files in Firefox</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/782">#782</a> Fix a bug that skips the Quick Inbox View popout to the top when scrolling down</li>
          </ul>
        `
      },
      {
        date: `June 10, 2018`,
        version: `7.21.1`,
        changelog: `
          <ul>
            <li>Hotfix for v7.21.0.</li>
          </ul>
        `
      },
      {
        date: `June 10, 2018`,
        version: `7.21.0`,
        changelog: `
          <ul>
            <li><a href="https://github.com/revilheart/ESGST/issues/765">#765</a> Fix a bug that does not allow restoring .zip files</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/764">#764</a> Fix a bug that does not save filter settings if only basic filters are enabled</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/763">#763</a> Fix a bug that does not retrieve all pages correctly in Whitelist/Blacklist Checker</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/762">#762</a> Fix a bug that adds duplicate "Sticky group" buttons</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/760">#760</a> Add SteamGifts' CSS file to the repository to prevent ESGST pages from being messed up if cg updates the CSS</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/759">#759</a> Fix a bug that shows wrong list of users in Group Library/Wishlist Checker when searching by app ID</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/758">#758</a> Fix a bug that only previews comments on user input</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/757">#757</a> Fix a bug that does not load encrypted giveaways</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/756">#756</a> Open settings menu when clicking on the extension icon</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/755">#755</a> Add option to minimize non-temporary popups</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/753">#753</a> Fix a bug that adds duplicate "Skip User" buttons to Whitelist/Blacklist Checker</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/752">#752</a> Fix active discussions on narrow sidebar</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/750">#750</a> Fix a bug that positions large popouts incorrectly in screens below 1440x900</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/749">#749</a> Fix a bug that does not allow applying empty presets</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/748">#748</a> Improve the scrolling</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/747">#747</a> Fix a bug that applies discussion filter on the main page even when disabled</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/746">#746</a> Add a feature: Points Visualizer</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/745">#745</a> Fix a style issue in the filters</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/744">#744</a> Add a new game category: DLC (Base Owned)</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/743">#743</a> Bring back option to select which filters to appear</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/742">#742</a> Fix a bug that does not load Multi-Manager in the regular pages</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/711">#711</a> Fix a bug in Quick Inbox View</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/671">#671</a> Add a feature: Giveaway End Time Highlighter</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/573">#573</a> Completely revamp User Giveaway Data</li>
          </ul>
        `
      },
      {
        date: `May 28, 2018`,
        version: `7.20.5`,
        changelog: `
          <ul>
            <li>Hotfix for v7.20.4.</li>
          </ul>
        `
      },
      {
        date: `May 28, 2018`,
        version: `7.20.4`,
        changelog: `
          <ul>
            <li><a href="https://github.com/revilheart/ESGST/issues/737">#737</a> Save paused state of filters to allow them to remain paused when refreshing the page</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/736">#736</a> Fix a bug that deletes settings if saving a preset with some filters paused</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/735">#735</a> Convert old presets to the new system</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/734">#734</a> Fix a bug in Endless Scrolling</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/731">#731</a> Fix a bug that does not apply presets</li>
          </ul>
        `
      },
      {
        date: `May 27, 2018`,
        version: `7.20.3`,
        changelog: `
          <ul>
            <li><a href="https://github.com/revilheart/ESGST/issues/730">#730</a> Possible fix to massive CPU usage spikes</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/728">#728</a> Increase max-height of filters area</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/727">#727</a> Fix a bug that happens when backing up to Google Drive</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/726">#726</a> Fix a bug in the filters</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/723">#723</a> Change color of AND/OR filter buttons</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/721">#721</a> Fix a bug that happens in Giveaway Encrypter/Decrypter because of filters</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/720">#720</a> Bring back the core of the basic filters as an opt-out option</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/718">#718</a> Add button to pause filter rules/groups to advanced filters</li>
          </ul>
        `
      },
      {
        date: `May 27, 2018`,
        version: `7.20.2`,
        changelog: `
          <ul>
            <li>Hotfix for v7.20.1.</li>
          </ul>
        `
      },
      {
        date: `May 26, 2018`,
        version: `7.20.1`,
        changelog: `
          <ul>
            <li>Hotfix for v7.20.0.</li>
          </ul>
        `
      },
      {
        date: `May 26, 2018`,
        version: `7.20.0`,
        changelog: `
          <ul>
            <li><a href="https://github.com/revilheart/ESGST/issues/709">#709</a> Use jQuery QueryBuilder to configure filters</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/715">#715</a> Add a feature: Narrow Sidebar</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/708">#708</a> Fix a bug that does not load features correctly in new tabs</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/667">#667</a> Fix a bug that does not load endless features correctly in some pages</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/678">#678</a> Display ? instead of negative CV in Game Categories - Giveaway Info and get the price from the giveaway points when available</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/707">#707</a> Do not go to comment in Quick Inbox View</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/665">#665</a> Add other found replies to the comment instead of showing them in a popup in Reply From Inbox</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/703">#703</a> Improve description variables explanation in Multiple Giveaway Creator</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/706">#706</a> Fix a bug that reverses the pages of a discussion when there is a hash in the URL</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/705">#705</a> Fix a bug that does not manage items inside of Grid View popouts in Multi-Manager</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/704">#704</a> Add option to hide games to Multi-Manager</li>
          </ul>
        `
      },
      {
        date: `May 20, 2018`,
        version: `7.19.0`,
        changelog: `
          <ul>
            <li><a href="https://github.com/revilheart/ESGST/issues/701">#701</a> Remove min-height requirement from Fixed Sidebar</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/700">#700</a> Fix a bug that does not fix the sidebar after scrolling down a second time from the top</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/699">#699</a> Fix a bug that does not display the sync page</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/698">#698</a> Add option to choose the key combination to trigger the Custom Header/Footer Links editor</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/695">#695</a> Fix a bug where sorting fails after hiding a single giveaway</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/694">#694</a> Fix a style issue that does not position popouts above/below correctly</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/693">#693</a> Fix a style issue that does not position popouts correctly if the window is scrolled horizontally</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/692">#692</a> Remove min-height requirement from Fixed Main Page Heading</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/691">#691</a> Change Giveaway Popup button to red if giveaway cannot be accessed</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/689">#689</a> Add a button to clear the current query to the search field in the settings menu</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/688">#688</a> Extend giveaway features to the archive page</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/686">#686</a> Changes to how emojis are stored</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/685">#685</a> Compress data when backing up</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/684">#684</a> Add &quot;Last Bundled&quot; default link to Custom Header/Footer Links</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/683">#683</a> Allow selected emojis to be re-ordered</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/682">#682</a> Add option to retrieve game names when syncing</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/681">#681</a> Fix a bug where filtering is applied when changing any filter options despite filtering being disabled</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/680">#680</a> Add a feature: Visible Real CV</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/679">#679</a> Add &quot;Previously Won&quot; game category</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/677">#677</a> Fix a bug that does not persist some settings</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/676">#676</a> Fix a bug that auto-backups to computer on every page load</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/674">#674</a> Change how the NEW indicator works on Quick Inbox View</li>
          </ul>
        `
      },
      {
        date: `May 11, 2018`,
        version: `7.18.3`,
        changelog: `
          <ul>
            <li><a href="https://github.com/revilheart/ESGST/issues/675">#675</a> Remove Comment History from SteamTrades</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/673">#673</a> Fix a bug that happens when creating giveaways through either Giveaway Templates or Multiple Giveaway Creator</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/670">#670</a> Fix a bug that does not return Endless Scrolling to a paused state after continuously loading pages</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/667">#667</a> Fix a bug that does not load endless features correctly in some pages</li>
          </ul>
        `
      },
      {
        date: `May 07, 2018`,
        version: `7.18.2`,
        changelog: `
          <ul>
            <li><a href="https://github.com/revilheart/ESGST/issues/668">#668</a> Hotfix for v7.18.1</li>
          </ul>
        `
      },
      {
        date: `May 07, 2018`,
        version: `7.18.1`,
        changelog: `
          <ul>
            <li><a href="https://github.com/revilheart/ESGST/issues/666">#666</a> Hotfix for v7.18.0</li>
          </ul>
        `
      },
      {
        date: `May 07, 2018`,
        version: `7.18.0`,
        changelog: `
          <ul>
            <li><a href="https://github.com/revilheart/ESGST/issues/664">#664</a> Fix a bug that does not decrypt giveaways containing the word bot in their name</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/663">#663</a> Fix a bug that happens when importing giveaways with a description template for a train in Multiple Giveaway Creator</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/662">#662</a> Fixate the Comment Formatting Helper panel without limiting the height of the text area</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/661">#661</a> Fix a bug in Comment Formatting Helper that does not add a scrolling bar to the text area in the edit discussion page</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/660">#660</a> Fix a bug that removes all games when syncing if both the store and the API methods failed</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/659">#659</a> Fix a style issue that sometimes does not overlap popups/popouts correctly</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/658">#658</a> Fix a bug that does not refresh Quick Inbox View correctly</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/657">#657</a> Add infinite max filters to Giveaway/Discussion Filters</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/655">#655</a> Fix a bug that does not load endless features correctly</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/654">#654</a> Make SGTools link draggable in Giveaway Extractor</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/653">#653</a> Add missing Steam and search links to SGTools giveaways in Giveaway Extractor</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/651">#651</a> Update FontAwesome links</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/650">#650</a> Limit requests to the Steam store when syncing to 1 per second</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/647">#647</a> Changes to the structure of the code</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/645">#645</a> Add a SGTools filter to Giveaway Filters</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/644">#644</a> Fix a bug that does not delete table rows in Comment Formatting Helper</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/642">#642</a> Add option to group all keys for the same game in Multiple Giveaway Creator</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/641">#641</a> Add a new section to the settings menu: Themes</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/640">#640</a> Fix tooltip in Multiple Giveaway Creator</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/639">#639</a> Convert checkboxes from circles to squares</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/638">#638</a> Fix some bugs that happen when marking comments as unread</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/608">#608</a> Add a feature: Multi-Manager (remove Giveaway Manager and Multi-Tag)</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/332">#332</a> Fix a bug that fails to create multiple giveaways for the same game in Multiple Giveaway Creator</li>
          </ul>
        `
      },
      {
        date: `April 19, 2018`,
        version: `7.17.8`,
        changelog: `
          <ul>
            <li><a href="https://github.com/revilheart/ESGST/issues/637">#637</a> Fix a style issue in pages generated by ESGST open in a new tab</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/636">#636</a> Fix a bug that calculates the wrong chance per point if a giveaway has 0 points</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/635">#635</a> Bypass bot protections when extracting giveaways</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/634">#634</a> Fix a bug that does not switch the colors of game category icons for alt accounts when moving them</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/633">#633</a> Fix a bug that does not turn the decrypted giveaways icon to green when new giveaways are found</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/628">#628</a> Add option to only search for comments in a specific page range to Comment Searcher</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/599">#599</a> Extend Giveaways Sorter to popups</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/567">#567</a> Add description variables to Multiple Giveaway Creator</li>
          </ul>
        `
      },
      {
        date: `April 14, 2018`,
        version: `7.17.7`,
        changelog: `
          <ul>
            <li><a href="https://github.com/revilheart/ESGST/issues/632">#632</a> Add option to limit how many SGTools giveaways are opened when extracting</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/631">#631</a> Add option to allow manipulation of cookies for Firefox containers</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/630">#630</a> Add more details to error messages during alt accounts sync</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/629">#629</a> Cancel backup when canceling file name input</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/627">#627</a> Implement a method to make the process of adding new filters easier</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/626">#626</a> Fix a bug that does not sync games if the user does not have alt accounts set</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/625">#625</a> Integrate SGTools giveaways into Giveaway Extractor</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/624">#624</a> Fix a bug that opens duplicate SGTools links when extracting giveaways</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/623">#623</a> Add option to save backups without asking for a file name</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/593">#593</a> Add Groups and Creators giveaway filters and Authors discussion filter</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/592">#592</a> Fix a bug that does not load more pages in Endless Scrolling if there are deleted giveaways in the current page with the ended filter set to hide all</li>
          </ul>
        `
      },
      {
        date: `April 11, 2018`,
        version: `7.17.6`,
        changelog: `
          <ul>
            <li><a href="https://github.com/revilheart/ESGST/issues/620">#620</a> Add more reliable methods of syncing and backing up</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/619">#619</a> Fix a bug that does not add an Enter button when extracting giveaways with few points</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/618">#618</a> Add option to open SGTools links when extracting giveaways</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/617">#617</a> Fix a bug that does not sync owned games in alt accounts</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/616">#616</a> Allow users to sync their games through the Steam API alone if the store method is unavailable</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/615">#615</a> Fix a bug that does not reverse a discussion if endless scrolling is paused</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/614">#614</a> Add option to reverse comments in a discussion by indicating it through a hash in the URL</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/613">#613</a> Make blacklist checks an opt-out instead of an opt-in by default in Whitelist/Blacklist Checker</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/611">#611</a> Add option to specify non-region restricted giveaways when importing in Multiple Giveaway Creator</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/610">#610</a> Fix a bug that duplicates the permalink icon</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/609">#609</a> Fix a bug that does not retrieve game names when syncing</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/607">#607</a> Fix a bug that does not include the .zip download when notifying a new version in non-Firefox browsers</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/604">#604</a> Fix a bug that prevents the script from loading</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/603">#603</a> Fix a bug that can prevent some elements in the giveaway columns/panel from being moved</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/600">#600</a> Fix a bug that does not show SG popups found when requesting data if static popups are enabled</li>
          </ul>
        `
      },
      {
        date: `April 05, 2018`,
        version: `7.17.5`,
        changelog: `
          <ul>
            <li><a href="https://github.com/revilheart/ESGST/issues/605">#605</a> Fix a bug that does not set the correct default values for some settings</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/602">#602</a> Add option to clean duplicate data to the data cleaner menu</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/598">#598</a> Implement a method to automatically detect and highlight new features/options in the settings menu with the [NEW] tag</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/597">#597</a> Fix a bug that shows Inifity% chance per point on the entered page</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/596">#596</a> Replace the terms &quot;Import&quot; and &quot;Export&quot; with &quot;Restore&quot; and &quot;Backup&quot; and change the icons to avoid any confusion</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/584">#584</a> Fix a bug that does not reload the extension in Chrome when updating</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/555">#555</a> Add SteamGifts filters to Giveaway Filters</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/538">#538</a> Add options to allow users to specify the format of the tab indicators in Header Refresher</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/524">#524</a> Fix a but that shows the new version popup twice</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/299">#299</a> Implement a method to better handle marking discussions as visited across multiple tabs</li>
          </ul>
        `
      },
      {
        date: `March 25, 2018`,
        version: `7.17.4`,
        changelog: `
          <ul>
            <li><a href="https://github.com/revilheart/ESGST/issues/590">#590</a> Speed up retrieval of Game Categories for users that do not have ratings, removed and user-defined tags enabled</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/588">#588</a> Fix a conflict between whitelist/blacklist/rule checks and Quick Inbox View</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/587">#587</a> Prevent main page heading from being fixed if the page is too small</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/586">#586</a> Add option to filter giveaways by chance per point</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/585">#585</a> Fix a bug that duplicates user notes when importing and merging</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/582">#582</a> Fix a couple bugs that prevent Game Categories from being retrieved correctly</li>
          </ul>
        `
      },
      {
        date: `March 20, 2018`,
        version: `7.17.3`,
        changelog: `
          <ul>
            <li><a href="https://github.com/revilheart/ESGST/issues/583">#583</a> Revert #565</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/580">#580</a> Fix a bug in Tables Sorter that does not sort sent/received group columns correctly</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/579">#579</a> Rename Whitelist/Blacklist Links to Profile Links and add more options</li>
          </ul>
        `
      },
      {
        date: `March 15, 2018`,
        version: `7.17.2`,
        changelog: `
          <ul>
            <li>Split jQuery, jQuery UI and Parsedown into separate files</li>
          </ul>
        `
      },
      {
        date: `March 14, 2018`,
        version: `7.17.1`,
        changelog: `
          <ul>
            <li>Add extension to the Mozilla store</li>
          </ul>
        `
      },
      {
        date: `March 14, 2018`,
        version: `7.17.0`,
        changelog: `
          <ul>
            <li><a href="https://github.com/revilheart/ESGST/issues/562">#562</a> Add descriptions to the precise options in Giveaway Templates</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/563">#563</a> Add an option to specify the game when importing with Multiple Giveaway Creator</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/564">#564</a> Fix a bug that does not extract the giveaway from the current page</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/565">#565</a> Add minified version and set it as default</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/566">#566</a> Add option to specify separate details for each imported giveaway in Multiple Giveaway Creator</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/568">#568</a> Add an option to enable Giveaway Recreator for all created giveaways</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/570">#570</a> Fix a bug in Chrome that does not open the giveaway extractor on first click</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/571">#571</a> Include whether the giveaway is for a gift or a key in the template when using Giveaway Templates</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/574">#574</a> Add a feature: Element Filters (remove Hidden Feature Container and Hidden Pinned Giveaways)</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/575">#575</a> Move "Click here to see your review for this user" to the top of the page in Reply Box On Top on SteamTrades</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/576">#576</a> Fix a bug that does not load features correctly in discussions that contain polls</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/578">#578</a> Optimize the extension performance (Ongoing)</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/353">#353</a> Convert all callback functions into promises and use async/await to deal with them (Ongoing)</li>
          </ul>
        `
      },
      {
        date: `March 4, 2018`,
        version: `7.16.5`,
        changelog: `
          <ul>
            <li><a href="https://github.com/revilheart/ESGST/issues/353">#353</a> Convert all callback functions into promises and use async/await to deal with them (ongoing)</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/552">#552</a> Fix a bug that does not allow the Giveaway Extractor button to be moved</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/556">#556</a> Only load Attached Images Carouself for images that are actually in the page</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/558">#558</a> Fix a bug that does not extract giveaways in a new tab</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/560">#560</a> Fix a bug that does not load ESGST sometimes</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/561">#561</a> Fix a bug that happens when performing requests in the userscript version</li>
          </ul>
        `
      },
      {
        date: `March 2, 2018`,
        version: `7.16.4`,
        changelog: `
          <ul>
            <li>Hotfix for v7.16.3 (Userscript version was still not working)</li>
          </ul>
        `
      },
      {
        date: `March 2, 2018`,
        version: `7.16.3`,
        changelog: `
          <ul>
            <li>Hotfix for v7.16.2 (Userscript version was not working)</li>
          </ul>
        `
      },
      {
        date: `March 2, 2018`,
        version: `7.16.2`,
        changelog: `
          <ul>
            <li>Hotfix for v7.16.1 (Forgot to change the version)</li>
          </ul>
        `
      },
      {
        date: `March 2, 2018`,
        version: `7.16.1`,
        changelog: `
          <ul>
            <li><a href="https://github.com/revilheart/ESGST/issues/527">#527</a> Fix a bug that happens when loading highlighted discussions</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/537">#537</a> Add option to delete days from Entry Tracker history</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/539">#539</a> Fix a bug that happens when sending unsent gifts with the options to check if the winner is whitelisted/blacklisted</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/540">#540</a> Fix some bugs with the reordering of heading buttons</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/541">#541</a> Extend Inbox Winner Highlighter to Quick Inbox View</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/542">#542</a> Add options to specify image border width when highlighting a giveaway with Giveaway Winning Chance/Ratio</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/543">#543</a> Fix a bug that does not load some features correctly</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/544">#544</a> Change the order of the elements in the Giveaway Bookmarks popup</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/548">#548</a> Fix a bug that decrypts giveaway links from the Quick Inbox View popout</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/549">#549</a> Add domain instructions to adding a Steam API key</li>
            <li><a href="https://github.com/revilheart/ESGST/issues/550">#550</a> Optimize storage usage in the script version</li>
          </ul>
        `
      }
    ];
    if (version) {
      for (i = 0, n = changelog.length; i < n && changelog[i].version !== version; ++i);
      index = i < n ? i - 1 : n - 1;
    } else {
      index = 0;
    }
    html = [];
    while (index >= 0) {
      html.unshift(`
        <p class="esgst-bold">v${changelog[index].version} (${changelog[index].date})</p>
        ${changelog[index].changelog}
      `);
      --index;
    }
    popup = new Popup(`fa-file-text-o`, `Changelog`, true);
    popup.scrollable.insertAdjacentHTML(`afterBegin`, `
      <div class="esgst-text-left markdown">
        ${html.join(``)}
      </div>
    `);
    popup.open();
  }
  
  // initialize esgst
  init();
})();